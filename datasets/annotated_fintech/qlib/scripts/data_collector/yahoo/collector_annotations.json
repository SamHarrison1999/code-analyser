[
  {
    "line": 23,
    "text": "import qlib",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using __file__ can be risky if the script is frozen by a tool like PyInstaller.",
    "confidence": 1.0,
    "tokens": [
      11748,
      10662,
      8019
    ],
    "start_token": 0,
    "end_token": 3,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      11593,
      7753,
      834,
      460,
      307,
      17564,
      611,
      262,
      4226,
      318,
      12912,
      416,
      257,
      2891,
      588,
      9485,
      15798,
      263,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using __file__ can be risky if the script is frozen by a tool like PyInstaller."
  },
  {
    "line": 25,
    "text": "from qlib.tests.data import GetData",
    "annotation": "\ud83e\udde0 ML Signal: Modifying sys.path to include parent directories is a common pattern for dynamic module loading.",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      41989,
      13,
      7890,
      1330,
      3497,
      6601
    ],
    "start_token": 3,
    "end_token": 13,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3401,
      4035,
      25064,
      13,
      6978,
      284,
      2291,
      2560,
      29196,
      318,
      257,
      2219,
      3912,
      329,
      8925,
      8265,
      11046,
      13
    ],
    "label": "ml_signal",
    "reason": "Modifying sys.path to include parent directories is a common pattern for dynamic module loading."
  },
  {
    "line": 39,
    "text": "    get_in_stock_symbols,",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Hardcoded URL can be a security risk if not properly validated or sanitized.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      651,
      62,
      259,
      62,
      13578,
      62,
      1837,
      2022,
      10220,
      11
    ],
    "start_token": 13,
    "end_token": 26,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      6912,
      40976,
      10289,
      460,
      307,
      257,
      2324,
      2526,
      611,
      407,
      6105,
      31031,
      393,
      5336,
      36951,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Hardcoded URL can be a security risk if not properly validated or sanitized."
  },
  {
    "line": 39,
    "text": "    get_in_stock_symbols,",
    "annotation": "\u2705 Best Practice: Class-level constants should be documented or named descriptively.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      651,
      62,
      259,
      62,
      13578,
      62,
      1837,
      2022,
      10220,
      11
    ],
    "start_token": 26,
    "end_token": 39,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12,
      5715,
      38491,
      815,
      307,
      12395,
      393,
      3706,
      12145,
      2280,
      13
    ],
    "label": "best_practice",
    "reason": "Class-level constants should be documented or named descriptively."
  },
  {
    "line": 52,
    "text": "        self,",
    "annotation": "\u2705 Best Practice: Docstring provides clear parameter descriptions and defaults",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 39,
    "end_token": 48,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      11507,
      16969,
      290,
      26235
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear parameter descriptions and defaults"
  },
  {
    "line": 74,
    "text": "            time.sleep(delay), default 0",
    "annotation": "\u2705 Best Practice: Using super() to call the parent class's __init__ method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      13,
      42832,
      7,
      40850,
      828,
      4277,
      657
    ],
    "start_token": 48,
    "end_token": 67,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2208,
      3419,
      284,
      869,
      262,
      2560,
      1398,
      338,
      11593,
      15003,
      834,
      2446
    ],
    "label": "best_practice",
    "reason": "Using super() to call the parent class's __init__ method"
  },
  {
    "line": 87,
    "text": "            save_dir=save_dir,",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of instance variables and method calls in constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3613,
      62,
      15908,
      28,
      21928,
      62,
      15908,
      11
    ],
    "start_token": 67,
    "end_token": 86,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4554,
      9633,
      290,
      2446,
      3848,
      287,
      23772
    ],
    "label": "ml_signal",
    "reason": "Initialization of instance variables and method calls in constructor"
  },
  {
    "line": 87,
    "text": "            save_dir=save_dir,",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on interval type can indicate usage patterns for different intervals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3613,
      62,
      15908,
      28,
      21928,
      62,
      15908,
      11
    ],
    "start_token": 86,
    "end_token": 105,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      16654,
      2099,
      460,
      7603,
      8748,
      7572,
      329,
      1180,
      20016
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on interval type can indicate usage patterns for different intervals"
  },
  {
    "line": 89,
    "text": "            end=end,",
    "annotation": "\u2705 Best Practice: Use of max function to ensure start_datetime is not before a default value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      28,
      437,
      11
    ],
    "start_token": 105,
    "end_token": 120,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3509,
      2163,
      284,
      4155,
      923,
      62,
      19608,
      8079,
      318,
      407,
      878,
      257,
      4277,
      1988
    ],
    "label": "best_practice",
    "reason": "Use of max function to ensure start_datetime is not before a default value"
  },
  {
    "line": 94,
    "text": "            check_data_length=check_data_length,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without specific handling could lead to unhandled exceptions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2198,
      62,
      7890,
      62,
      13664,
      28,
      9122,
      62,
      7890,
      62,
      13664,
      11
    ],
    "start_token": 120,
    "end_token": 143,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      2176,
      9041,
      714,
      1085,
      284,
      555,
      38788,
      13269
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without specific handling could lead to unhandled exceptions"
  },
  {
    "line": 96,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Converting datetime to a specific timezone for consistency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 143,
    "end_token": 151,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      4818,
      8079,
      284,
      257,
      2176,
      640,
      11340,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Converting datetime to a specific timezone for consistency"
  },
  {
    "line": 98,
    "text": "        self.init_datetime()",
    "annotation": "\u2705 Best Practice: Converting datetime to a specific timezone for consistency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      15003,
      62,
      19608,
      8079,
      3419
    ],
    "start_token": 151,
    "end_token": 165,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      4818,
      8079,
      284,
      257,
      2176,
      640,
      11340,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Converting datetime to a specific timezone for consistency"
  },
  {
    "line": 96,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Consider specifying the expected return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 165,
    "end_token": 173,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      31577,
      262,
      2938,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Consider specifying the expected return type for better readability and maintainability"
  },
  {
    "line": 99,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone-related issues if timezone is not validated",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 173,
    "end_token": 173,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      12,
      5363,
      2428,
      611,
      640,
      11340,
      318,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone-related issues if timezone is not validated"
  },
  {
    "line": 99,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pd.Timestamp for datetime conversion",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 173,
    "end_token": 173,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      279,
      67,
      13,
      14967,
      27823,
      329,
      4818,
      8079,
      11315
    ],
    "label": "ml_signal",
    "reason": "Usage of pd.Timestamp for datetime conversion"
  },
  {
    "line": 102,
    "text": "            self.start_datetime = max(self.start_datetime, self.DEFAULT_START_DATETIME_1MIN)",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of timestamp to local timezone",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      796,
      3509,
      7,
      944,
      13,
      9688,
      62,
      19608,
      8079,
      11,
      2116,
      13,
      7206,
      38865,
      62,
      2257,
      7227,
      62,
      35,
      1404,
      2767,
      12789,
      62,
      16,
      23678,
      8
    ],
    "start_token": 173,
    "end_token": 216,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      41033,
      284,
      1957,
      640,
      11340
    ],
    "label": "ml_signal",
    "reason": "Conversion of timestamp to local timezone"
  },
  {
    "line": 105,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Consider logging the exception for better debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 216,
    "end_token": 225,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      18931,
      262,
      6631,
      329,
      1365,
      28769
    ],
    "label": "best_practice",
    "reason": "Consider logging the exception for better debugging"
  },
  {
    "line": 106,
    "text": "            raise ValueError(f\"interval error: {self.interval}\")",
    "annotation": "\u2705 Best Practice: Ensure the function returns a consistent type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      3849,
      2100,
      4049,
      25,
      1391,
      944,
      13,
      3849,
      2100,
      92,
      4943
    ],
    "start_token": 225,
    "end_token": 253,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2163,
      5860,
      257,
      6414,
      2099
    ],
    "label": "best_practice",
    "reason": "Ensure the function returns a consistent type"
  },
  {
    "line": 106,
    "text": "            raise ValueError(f\"interval error: {self.interval}\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method raises NotImplementedError, which could lead to unhandled exceptions if not properly overridden.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      3849,
      2100,
      4049,
      25,
      1391,
      944,
      13,
      3849,
      2100,
      92,
      4943
    ],
    "start_token": 253,
    "end_token": 281,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      11,
      543,
      714,
      1085,
      284,
      555,
      38788,
      13269,
      611,
      407,
      6105,
      23170,
      4651,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method raises NotImplementedError, which could lead to unhandled exceptions if not properly overridden."
  },
  {
    "line": 109,
    "text": "        self.end_datetime = self.convert_datetime(self.end_datetime, self._timezone)",
    "annotation": "\u2705 Best Practice: Use of @staticmethod decorator indicates that the method does not depend on instance-specific data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      1102,
      1851,
      62,
      19608,
      8079,
      7,
      944,
      13,
      437,
      62,
      19608,
      8079,
      11,
      2116,
      13557,
      2435,
      11340,
      8
    ],
    "start_token": 281,
    "end_token": 315,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      12708,
      24396,
      11705,
      1352,
      9217,
      326,
      262,
      2446,
      857,
      407,
      4745,
      319,
      4554,
      12,
      11423,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @staticmethod decorator indicates that the method does not depend on instance-specific data."
  },
  {
    "line": 109,
    "text": "        self.end_datetime = self.convert_datetime(self.end_datetime, self._timezone)",
    "annotation": "\ud83e\udde0 ML Signal: Use of f-string for error message formatting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      1102,
      1851,
      62,
      19608,
      8079,
      7,
      944,
      13,
      437,
      62,
      19608,
      8079,
      11,
      2116,
      13557,
      2435,
      11340,
      8
    ],
    "start_token": 315,
    "end_token": 349,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4049,
      3275,
      33313
    ],
    "label": "ml_signal",
    "reason": "Use of f-string for error message formatting"
  },
  {
    "line": 111,
    "text": "    @staticmethod",
    "annotation": "\u2705 Best Practice: Use of a function to encapsulate logging logic for reusability and clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 349,
    "end_token": 355,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2163,
      284,
      32652,
      5039,
      18931,
      9156,
      329,
      302,
      385,
      1799,
      290,
      16287
    ],
    "label": "best_practice",
    "reason": "Use of a function to encapsulate logging logic for reusability and clarity"
  },
  {
    "line": 113,
    "text": "        try:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive information in logs",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 355,
    "end_token": 364,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1321,
      287,
      17259
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive information in logs"
  },
  {
    "line": 116,
    "text": "        except ValueError as e:",
    "annotation": "\ud83e\udde0 ML Signal: Use of try-except block to handle exceptions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      11052,
      12331,
      355,
      304,
      25
    ],
    "start_token": 364,
    "end_token": 377,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1949,
      12,
      16341,
      2512,
      284,
      5412,
      13269
    ],
    "label": "ml_signal",
    "reason": "Use of try-except block to handle exceptions"
  },
  {
    "line": 118,
    "text": "        return dt",
    "annotation": "\ud83e\udde0 ML Signal: Use of external library function call",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      288,
      83
    ],
    "start_token": 377,
    "end_token": 387,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      7097,
      5888,
      2163,
      869
    ],
    "label": "ml_signal",
    "reason": "Use of external library function call"
  },
  {
    "line": 120,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: DataFrame manipulation pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 387,
    "end_token": 392,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6060,
      19778,
      17512,
      3912
    ],
    "label": "ml_signal",
    "reason": "DataFrame manipulation pattern"
  },
  {
    "line": 131,
    "text": "                logger.warning(f\"{error_msg}:{_resp}\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Generic exception handling may hide specific errors",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      90,
      18224,
      62,
      19662,
      92,
      29164,
      62,
      4363,
      92,
      4943
    ],
    "start_token": 392,
    "end_token": 423,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42044,
      6631,
      9041,
      743,
      7808,
      2176,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Generic exception handling may hide specific errors"
  },
  {
    "line": 131,
    "text": "                logger.warning(f\"{error_msg}:{_resp}\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive information in logs",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      90,
      18224,
      62,
      19662,
      92,
      29164,
      62,
      4363,
      92,
      4943
    ],
    "start_token": 423,
    "end_token": 454,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1321,
      287,
      17259
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive information in logs"
  },
  {
    "line": 135,
    "text": "            _resp = Ticker(symbol, asynchronous=False).history(interval=interval, start=start, end=end)",
    "annotation": "\u2705 Best Practice: Use of a decorator to handle retries indicates a robust design for network operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      4363,
      796,
      309,
      15799,
      7,
      1837,
      23650,
      11,
      39354,
      28,
      25101,
      737,
      23569,
      7,
      3849,
      2100,
      28,
      3849,
      2100,
      11,
      923,
      28,
      9688,
      11,
      886,
      28,
      437,
      8
    ],
    "start_token": 454,
    "end_token": 494,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      11705,
      1352,
      284,
      5412,
      1005,
      1678,
      9217,
      257,
      12373,
      1486,
      329,
      3127,
      4560
    ],
    "label": "best_practice",
    "reason": "Use of a decorator to handle retries indicates a robust design for network operations"
  },
  {
    "line": 136,
    "text": "            if isinstance(_resp, pd.DataFrame):",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      28264,
      4363,
      11,
      279,
      67,
      13,
      6601,
      19778,
      2599
    ],
    "start_token": 494,
    "end_token": 517,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 138,
    "text": "            elif isinstance(_resp, dict):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential use of uninitialized variable 'interval'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      28264,
      4363,
      11,
      8633,
      2599
    ],
    "start_token": 517,
    "end_token": 537,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      779,
      286,
      555,
      17532,
      7885,
      705,
      3849,
      2100,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential use of uninitialized variable 'interval'"
  },
  {
    "line": 145,
    "text": "                _show_logging_func()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Check for None or empty response to handle potential errors",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      12860,
      62,
      6404,
      2667,
      62,
      20786,
      3419
    ],
    "start_token": 537,
    "end_token": 560,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6822,
      329,
      6045,
      393,
      6565,
      2882,
      284,
      5412,
      2785,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Check for None or empty response to handle potential errors"
  },
  {
    "line": 152,
    "text": "    def get_data(",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on 'interval' value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      7
    ],
    "start_token": 560,
    "end_token": 568,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      705,
      3849,
      2100,
      6,
      1988
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on 'interval' value"
  },
  {
    "line": 158,
    "text": "            _remote_interval = \"1m\" if interval == self.INTERVAL_1min else interval",
    "annotation": "\u2705 Best Practice: Consider logging the exception for debugging purposes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      47960,
      62,
      3849,
      2100,
      796,
      366,
      16,
      76,
      1,
      611,
      16654,
      6624,
      2116,
      13,
      41358,
      23428,
      62,
      16,
      1084,
      2073,
      16654
    ],
    "start_token": 568,
    "end_token": 601,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      18931,
      262,
      6631,
      329,
      28769,
      4959
    ],
    "label": "best_practice",
    "reason": "Consider logging the exception for debugging purposes"
  },
  {
    "line": 162,
    "text": "                start=start_,",
    "annotation": "\ud83e\udde0 ML Signal: Looping pattern with date range",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      28,
      9688,
      62,
      11
    ],
    "start_token": 601,
    "end_token": 621,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6706,
      15816,
      3912,
      351,
      3128,
      2837
    ],
    "label": "ml_signal",
    "reason": "Looping pattern with date range"
  },
  {
    "line": 170,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider logging the exception for debugging purposes",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 621,
    "end_token": 621,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      18931,
      262,
      6631,
      329,
      28769,
      4959
    ],
    "label": "best_practice",
    "reason": "Consider logging the exception for debugging purposes"
  },
  {
    "line": 174,
    "text": "                _result = _get_simple(start_datetime, end_datetime)",
    "annotation": "\ud83e\udde0 ML Signal: Data concatenation and sorting pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      4808,
      1136,
      62,
      36439,
      7,
      9688,
      62,
      19608,
      8079,
      11,
      886,
      62,
      19608,
      8079,
      8
    ],
    "start_token": 621,
    "end_token": 654,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6060,
      1673,
      36686,
      341,
      290,
      29407,
      3912
    ],
    "label": "ml_signal",
    "reason": "Data concatenation and sorting pattern"
  },
  {
    "line": 177,
    "text": "        elif interval == self.INTERVAL_1min:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Unhandled interval values could lead to unexpected behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      16654,
      6624,
      2116,
      13,
      41358,
      23428,
      62,
      16,
      1084,
      25
    ],
    "start_token": 654,
    "end_token": 673,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      791,
      38788,
      16654,
      3815,
      714,
      1085,
      284,
      10059,
      4069
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Unhandled interval values could lead to unexpected behavior"
  },
  {
    "line": 179,
    "text": "            _start = self.start_datetime",
    "annotation": "\ud83e\udde0 ML Signal: Return pattern based on condition",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9688,
      796,
      2116,
      13,
      9688,
      62,
      19608,
      8079
    ],
    "start_token": 673,
    "end_token": 693,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8229,
      3912,
      1912,
      319,
      4006
    ],
    "label": "ml_signal",
    "reason": "Return pattern based on condition"
  },
  {
    "line": 173,
    "text": "            try:",
    "annotation": "\u2705 Best Practice: Consider using a more descriptive docstring to explain the method's purpose and behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 693,
    "end_token": 706,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      517,
      35644,
      2205,
      8841,
      284,
      4727,
      262,
      2446,
      338,
      4007,
      290,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a more descriptive docstring to explain the method's purpose and behavior."
  },
  {
    "line": 174,
    "text": "                _result = _get_simple(start_datetime, end_datetime)",
    "annotation": "\u2705 Best Practice: Use of super() is a good practice for calling methods from a parent class.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      4808,
      1136,
      62,
      36439,
      7,
      9688,
      62,
      19608,
      8079,
      11,
      886,
      62,
      19608,
      8079,
      8
    ],
    "start_token": 706,
    "end_token": 739,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      318,
      257,
      922,
      3357,
      329,
      4585,
      5050,
      422,
      257,
      2560,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Use of super() is a good practice for calling methods from a parent class."
  },
  {
    "line": 178,
    "text": "            _res = []",
    "annotation": "\u2705 Best Practice: Use of @abc.abstractmethod indicates this method must be implemented by subclasses, which is a good design practice for abstract classes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      411,
      796,
      17635
    ],
    "start_token": 739,
    "end_token": 754,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      39305,
      13,
      397,
      8709,
      24396,
      9217,
      428,
      2446,
      1276,
      307,
      9177,
      416,
      850,
      37724,
      11,
      543,
      318,
      257,
      922,
      1486,
      3357,
      329,
      12531,
      6097,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @abc.abstractmethod indicates this method must be implemented by subclasses, which is a good design practice for abstract classes."
  },
  {
    "line": 176,
    "text": "                pass",
    "annotation": "\u2705 Best Practice: Method docstring provides a brief description of the method's purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 754,
    "end_token": 770,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      2446,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Method docstring provides a brief description of the method's purpose"
  },
  {
    "line": 179,
    "text": "            _start = self.start_datetime",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that a method should be overridden",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9688,
      796,
      2116,
      13,
      9688,
      62,
      19608,
      8079
    ],
    "start_token": 770,
    "end_token": 790,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      257,
      2446,
      815,
      307,
      23170,
      4651
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that a method should be overridden"
  },
  {
    "line": 180,
    "text": "            while _start < self.end_datetime:",
    "annotation": "\u2705 Best Practice: Inheriting from ABC indicates that this class is intended to be abstract.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      4808,
      9688,
      1279,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      25
    ],
    "start_token": 790,
    "end_token": 812,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      9738,
      9217,
      326,
      428,
      1398,
      318,
      5292,
      284,
      307,
      12531,
      13
    ],
    "label": "best_practice",
    "reason": "Inheriting from ABC indicates that this class is intended to be abstract."
  },
  {
    "line": 180,
    "text": "            while _start < self.end_datetime:",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      4808,
      9688,
      1279,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      25
    ],
    "start_token": 812,
    "end_token": 834,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      290,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring and debugging"
  },
  {
    "line": 182,
    "text": "                try:",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 834,
    "end_token": 851,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      290,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring and debugging"
  },
  {
    "line": 184,
    "text": "                    _res.append(_resp)",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern for retrieving stock symbols",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      411,
      13,
      33295,
      28264,
      4363,
      8
    ],
    "start_token": 851,
    "end_token": 877,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      329,
      50122,
      4283,
      14354
    ],
    "label": "ml_signal",
    "reason": "Function call pattern for retrieving stock symbols"
  },
  {
    "line": 186,
    "text": "                    pass",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 877,
    "end_token": 897,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      290,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring and debugging"
  },
  {
    "line": 188,
    "text": "            if _res:",
    "annotation": "\ud83e\udde0 ML Signal: Return statement pattern for function output",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      411,
      25
    ],
    "start_token": 897,
    "end_token": 912,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8229,
      2643,
      3912,
      329,
      2163,
      5072
    ],
    "label": "ml_signal",
    "reason": "Return statement pattern for function output"
  },
  {
    "line": 186,
    "text": "                    pass",
    "annotation": "\ud83e\udde0 ML Signal: Function that processes and normalizes input data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 912,
    "end_token": 932,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      326,
      7767,
      290,
      3487,
      4340,
      5128,
      1366
    ],
    "label": "ml_signal",
    "reason": "Function that processes and normalizes input data"
  },
  {
    "line": 188,
    "text": "            if _res:",
    "annotation": "\u2705 Best Practice: Use of f-string for readability and performance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      411,
      25
    ],
    "start_token": 932,
    "end_token": 947,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      1100,
      1799,
      290,
      2854
    ],
    "label": "best_practice",
    "reason": "Use of f-string for readability and performance"
  },
  {
    "line": 190,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Consider using a constant or configuration for timezone values to improve maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 947,
    "end_token": 956,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      6937,
      393,
      8398,
      329,
      640,
      11340,
      3815,
      284,
      2987,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a constant or configuration for timezone values to improve maintainability."
  },
  {
    "line": 197,
    "text": "        self.download_index_data()",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a dictionary of index names and codes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      15002,
      62,
      9630,
      62,
      7890,
      3419
    ],
    "start_token": 956,
    "end_token": 971,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      22155,
      286,
      6376,
      3891,
      290,
      12416
    ],
    "label": "ml_signal",
    "reason": "Iterating over a dictionary of index names and codes"
  },
  {
    "line": 199,
    "text": "    @abc.abstractmethod",
    "annotation": "\ud83e\udde0 ML Signal: Logging information about the index being processed",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      39305,
      13,
      397,
      8709,
      24396
    ],
    "start_token": 971,
    "end_token": 980,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      1321,
      546,
      262,
      6376,
      852,
      13686
    ],
    "label": "ml_signal",
    "reason": "Logging information about the index being processed"
  },
  {
    "line": 200,
    "text": "    def download_index_data(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): No timeout specified for requests.get, which can lead to hanging connections",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4321,
      62,
      9630,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 980,
    "end_token": 992,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      1400,
      26827,
      7368,
      329,
      7007,
      13,
      1136,
      11,
      543,
      460,
      1085,
      284,
      10938,
      8787
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "No timeout specified for requests.get, which can lead to hanging connections"
  },
  {
    "line": 212,
    "text": "    def normalize_symbol(self, symbol):",
    "annotation": "\ud83e\udde0 ML Signal: Logging warning when an exception occurs",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      1837,
      23650,
      7,
      944,
      11,
      6194,
      2599
    ],
    "start_token": 992,
    "end_token": 1006,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      6509,
      618,
      281,
      6631,
      8833
    ],
    "label": "ml_signal",
    "reason": "Logging warning when an exception occurs"
  },
  {
    "line": 215,
    "text": "        return symbol",
    "annotation": "\u2705 Best Practice: Explicitly setting DataFrame column names for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6194
    ],
    "start_token": 1006,
    "end_token": 1015,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      6060,
      19778,
      5721,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly setting DataFrame column names for clarity"
  },
  {
    "line": 217,
    "text": "    @property",
    "annotation": "\u2705 Best Practice: Converting date strings to datetime objects for better manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1015,
    "end_token": 1020,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      3128,
      13042,
      284,
      4818,
      8079,
      5563,
      329,
      1365,
      17512
    ],
    "label": "best_practice",
    "reason": "Converting date strings to datetime objects for better manipulation"
  },
  {
    "line": 219,
    "text": "        return \"Asia/Shanghai\"",
    "annotation": "\u2705 Best Practice: Using astype with errors=\"ignore\" to safely convert data types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      38555,
      14,
      2484,
      272,
      20380,
      1
    ],
    "start_token": 1020,
    "end_token": 1035,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      6468,
      2981,
      351,
      8563,
      2625,
      46430,
      1,
      284,
      11512,
      10385,
      1366,
      3858
    ],
    "label": "best_practice",
    "reason": "Using astype with errors=\"ignore\" to safely convert data types"
  },
  {
    "line": 224,
    "text": "        # TODO: from MSN",
    "annotation": "\u2705 Best Practice: Checking if a file exists before reading it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      422,
      6579,
      45
    ],
    "start_token": 1035,
    "end_token": 1049,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      611,
      257,
      2393,
      7160,
      878,
      3555,
      340
    ],
    "label": "best_practice",
    "reason": "Checking if a file exists before reading it"
  },
  {
    "line": 227,
    "text": "        _end = self.end_datetime.strftime(_format)",
    "annotation": "\u2705 Best Practice: Using pd.concat to append new data to existing DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      437,
      796,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      28264,
      18982,
      8
    ],
    "start_token": 1049,
    "end_token": 1071,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      1102,
      9246,
      284,
      24443,
      649,
      1366,
      284,
      4683,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Using pd.concat to append new data to existing DataFrame"
  },
  {
    "line": 229,
    "text": "            logger.info(f\"get bench data: {_index_name}({_index_code})......\")",
    "annotation": "\u2705 Best Practice: Saving DataFrame to CSV without the index for cleaner output",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7,
      69,
      1,
      1136,
      7624,
      1366,
      25,
      1391,
      62,
      9630,
      62,
      3672,
      92,
      15090,
      62,
      9630,
      62,
      8189,
      30072,
      16317,
      4943
    ],
    "start_token": 1071,
    "end_token": 1106,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      34689,
      6060,
      19778,
      284,
      44189,
      1231,
      262,
      6376,
      329,
      21723,
      5072
    ],
    "label": "best_practice",
    "reason": "Saving DataFrame to CSV without the index for cleaner output"
  },
  {
    "line": 231,
    "text": "                df = pd.DataFrame(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Fixed sleep duration can lead to inefficient waiting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7
    ],
    "start_token": 1106,
    "end_token": 1129,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      10832,
      3993,
      9478,
      460,
      1085,
      284,
      30904,
      4953
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Fixed sleep duration can lead to inefficient waiting"
  },
  {
    "line": 222,
    "text": "class YahooCollectorCN1d(YahooCollectorCN):",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [
      4871,
      16551,
      31337,
      273,
      44175,
      16,
      67,
      7,
      56,
      12992,
      31337,
      273,
      44175,
      2599
    ],
    "start_token": 1129,
    "end_token": 1143,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring explaining its purpose and usage"
  },
  {
    "line": 223,
    "text": "    def download_index_data(self):",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its functionality",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4321,
      62,
      9630,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 1143,
    "end_token": 1155,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      11244
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its functionality"
  },
  {
    "line": 225,
    "text": "        _format = \"%Y%m%d\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of inheritance and method overriding",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      18982,
      796,
      36521,
      56,
      4,
      76,
      4,
      67,
      1
    ],
    "start_token": 1155,
    "end_token": 1172,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      24155,
      290,
      2446,
      44987
    ],
    "label": "ml_signal",
    "reason": "Use of inheritance and method overriding"
  },
  {
    "line": 227,
    "text": "        _end = self.end_datetime.strftime(_format)",
    "annotation": "\u2705 Best Practice: Returning a modified list of symbols",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      437,
      796,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      28264,
      18982,
      8
    ],
    "start_token": 1172,
    "end_token": 1194,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      9518,
      1351,
      286,
      14354
    ],
    "label": "best_practice",
    "reason": "Returning a modified list of symbols"
  },
  {
    "line": 226,
    "text": "        _begin = self.start_datetime.strftime(_format)",
    "annotation": "\u2705 Best Practice: Define a method to download index data, but currently it's a placeholder with no implementation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      27471,
      796,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      28264,
      18982,
      8
    ],
    "start_token": 1194,
    "end_token": 1216,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      2446,
      284,
      4321,
      6376,
      1366,
      11,
      475,
      3058,
      340,
      338,
      257,
      46076,
      351,
      645,
      7822,
      13
    ],
    "label": "best_practice",
    "reason": "Define a method to download index data, but currently it's a placeholder with no implementation."
  },
  {
    "line": 229,
    "text": "            logger.info(f\"get bench data: {_index_name}({_index_code})......\")",
    "annotation": "\u2705 Best Practice: Inheriting from ABC indicates this class is intended to be abstract",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7,
      69,
      1,
      1136,
      7624,
      1366,
      25,
      1391,
      62,
      9630,
      62,
      3672,
      92,
      15090,
      62,
      9630,
      62,
      8189,
      30072,
      16317,
      4943
    ],
    "start_token": 1216,
    "end_token": 1251,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      9738,
      9217,
      428,
      1398,
      318,
      5292,
      284,
      307,
      12531
    ],
    "label": "best_practice",
    "reason": "Inheriting from ABC indicates this class is intended to be abstract"
  },
  {
    "line": 230,
    "text": "            try:",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 1251,
    "end_token": 1264,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      290,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring and debugging"
  },
  {
    "line": 231,
    "text": "                df = pd.DataFrame(",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7
    ],
    "start_token": 1264,
    "end_token": 1287,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Function call pattern for data retrieval"
  },
  {
    "line": 238,
    "text": "                )",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1287,
    "end_token": 1303,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      290,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring and debugging"
  },
  {
    "line": 240,
    "text": "                logger.warning(f\"get {_index_name} error: {e}\")",
    "annotation": "\u2705 Best Practice: Explicitly returning a value from a function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      1136,
      1391,
      62,
      9630,
      62,
      3672,
      92,
      4049,
      25,
      1391,
      68,
      92,
      4943
    ],
    "start_token": 1303,
    "end_token": 1337,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      8024,
      257,
      1988,
      422,
      257,
      2163
    ],
    "label": "best_practice",
    "reason": "Explicitly returning a value from a function"
  },
  {
    "line": 238,
    "text": "                )",
    "annotation": "\u2705 Best Practice: Define a method with a clear purpose, even if not yet implemented",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1337,
    "end_token": 1353,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      2446,
      351,
      257,
      1598,
      4007,
      11,
      772,
      611,
      407,
      1865,
      9177
    ],
    "label": "best_practice",
    "reason": "Define a method with a clear purpose, even if not yet implemented"
  },
  {
    "line": 240,
    "text": "                logger.warning(f\"get {_index_name} error: {e}\")",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      1136,
      1391,
      62,
      9630,
      62,
      3672,
      92,
      4049,
      25,
      1391,
      68,
      92,
      4943
    ],
    "start_token": 1353,
    "end_token": 1387,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose and parameters"
  },
  {
    "line": 241,
    "text": "                continue",
    "annotation": "\ud83e\udde0 ML Signal: Usage of helper function to transform data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2555
    ],
    "start_token": 1387,
    "end_token": 1403,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      31904,
      2163,
      284,
      6121,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of helper function to transform data"
  },
  {
    "line": 243,
    "text": "            df[\"date\"] = pd.to_datetime(df[\"date\"])",
    "annotation": "\u2705 Best Practice: Consider using a constant or configuration for timezone values to improve maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      4475,
      8973,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      14692,
      4475,
      8973,
      8
    ],
    "start_token": 1403,
    "end_token": 1432,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      6937,
      393,
      8398,
      329,
      640,
      11340,
      3815,
      284,
      2987,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a constant or configuration for timezone values to improve maintainability."
  },
  {
    "line": 245,
    "text": "            df[\"adjclose\"] = df[\"close\"]",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality from a parent class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      41255,
      19836,
      8973,
      796,
      47764,
      14692,
      19836,
      8973
    ],
    "start_token": 1432,
    "end_token": 1453,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      422,
      257,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality from a parent class"
  },
  {
    "line": 247,
    "text": "            _path = self.save_dir.joinpath(f\"sh{_index_code}.csv\")",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality of YahooCollectorUS",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      6978,
      796,
      2116,
      13,
      21928,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      1477,
      90,
      62,
      9630,
      62,
      8189,
      27422,
      40664,
      4943
    ],
    "start_token": 1453,
    "end_token": 1487,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      286,
      16551,
      31337,
      273,
      2937
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality of YahooCollectorUS"
  },
  {
    "line": 249,
    "text": "                _old_df = pd.read_csv(_path)",
    "annotation": "\u2705 Best Practice: Inheriting from both YahooCollector and ABC indicates use of abstract base classes for interface enforcement.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      727,
      62,
      7568,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      28264,
      6978,
      8
    ],
    "start_token": 1487,
    "end_token": 1516,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      1111,
      16551,
      31337,
      273,
      290,
      9738,
      9217,
      779,
      286,
      12531,
      2779,
      6097,
      329,
      7071,
      5394,
      13
    ],
    "label": "best_practice",
    "reason": "Inheriting from both YahooCollector and ABC indicates use of abstract base classes for interface enforcement."
  },
  {
    "line": 250,
    "text": "                df = pd.concat([_old_df, df], sort=False)",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      1102,
      9246,
      26933,
      62,
      727,
      62,
      7568,
      11,
      47764,
      4357,
      3297,
      28,
      25101,
      8
    ],
    "start_token": 1516,
    "end_token": 1550,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 252,
    "text": "            time.sleep(5)",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      13,
      42832,
      7,
      20,
      8
    ],
    "start_token": 1550,
    "end_token": 1567,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 254,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern for retrieving stock symbols",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1567,
    "end_token": 1567,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      329,
      50122,
      4283,
      14354
    ],
    "label": "ml_signal",
    "reason": "Function call pattern for retrieving stock symbols"
  },
  {
    "line": 256,
    "text": "    def get_instrument_list(self):",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      259,
      43872,
      62,
      4868,
      7,
      944,
      2599
    ],
    "start_token": 1567,
    "end_token": 1580,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 258,
    "text": "        return symbols + [\"000300.ss\", \"000905.ss\", \"000903.ss\"]",
    "annotation": "\u2705 Best Practice: Explicitly returning the result of a function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      14354,
      1343,
      14631,
      830,
      6200,
      13,
      824,
      1600,
      366,
      830,
      44928,
      13,
      824,
      1600,
      366,
      830,
      24,
      3070,
      13,
      824,
      8973
    ],
    "start_token": 1580,
    "end_token": 1609,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      8024,
      262,
      1255,
      286,
      257,
      2163
    ],
    "label": "best_practice",
    "reason": "Explicitly returning the result of a function"
  },
  {
    "line": 255,
    "text": "class YahooCollectorCN1min(YahooCollectorCN):",
    "annotation": "\u2705 Best Practice: Define a method to download index data, even if not yet implemented",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      31337,
      273,
      44175,
      16,
      1084,
      7,
      56,
      12992,
      31337,
      273,
      44175,
      2599
    ],
    "start_token": 1609,
    "end_token": 1623,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      2446,
      284,
      4321,
      6376,
      1366,
      11,
      772,
      611,
      407,
      1865,
      9177
    ],
    "label": "best_practice",
    "reason": "Define a method to download index data, even if not yet implemented"
  },
  {
    "line": 257,
    "text": "        symbols = super(YahooCollectorCN1min, self).get_instrument_list()",
    "annotation": "\u2705 Best Practice: Use 'pass' to indicate an intentional no-operation placeholder",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14354,
      796,
      2208,
      7,
      56,
      12992,
      31337,
      273,
      44175,
      16,
      1084,
      11,
      2116,
      737,
      1136,
      62,
      259,
      43872,
      62,
      4868,
      3419
    ],
    "start_token": 1623,
    "end_token": 1651,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      6603,
      6,
      284,
      7603,
      281,
      21391,
      645,
      12,
      27184,
      46076
    ],
    "label": "best_practice",
    "reason": "Use 'pass' to indicate an intentional no-operation placeholder"
  },
  {
    "line": 257,
    "text": "        symbols = super(YahooCollectorCN1min, self).get_instrument_list()",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14354,
      796,
      2208,
      7,
      56,
      12992,
      31337,
      273,
      44175,
      16,
      1084,
      11,
      2116,
      737,
      1136,
      62,
      259,
      43872,
      62,
      4868,
      3419
    ],
    "start_token": 1651,
    "end_token": 1679,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose and parameters"
  },
  {
    "line": 258,
    "text": "        return symbols + [\"000300.ss\", \"000905.ss\", \"000903.ss\"]",
    "annotation": "\ud83e\udde0 ML Signal: Usage of helper function to transform data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      14354,
      1343,
      14631,
      830,
      6200,
      13,
      824,
      1600,
      366,
      830,
      44928,
      13,
      824,
      1600,
      366,
      830,
      24,
      3070,
      13,
      824,
      8973
    ],
    "start_token": 1679,
    "end_token": 1708,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      31904,
      2163,
      284,
      6121,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of helper function to transform data"
  },
  {
    "line": 260,
    "text": "    def download_index_data(self):",
    "annotation": "\u2705 Best Practice: Consider using a constant or configuration for timezone values to improve maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4321,
      62,
      9630,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 1708,
    "end_token": 1720,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      6937,
      393,
      8398,
      329,
      640,
      11340,
      3815,
      284,
      2987,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a constant or configuration for timezone values to improve maintainability."
  },
  {
    "line": 262,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality of YahooCollectorIN",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1720,
    "end_token": 1720,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      286,
      16551,
      31337,
      273,
      1268
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality of YahooCollectorIN"
  },
  {
    "line": 264,
    "text": "class YahooCollectorUS(YahooCollector, ABC):",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality from YahooCollectorIN",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      31337,
      273,
      2937,
      7,
      56,
      12992,
      31337,
      273,
      11,
      9738,
      2599
    ],
    "start_token": 1720,
    "end_token": 1733,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      422,
      16551,
      31337,
      273,
      1268
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality from YahooCollectorIN"
  },
  {
    "line": 266,
    "text": "        logger.info(\"get US stock symbols......\")",
    "annotation": "\u2705 Best Practice: Use of 'pass' to indicate intentional empty class definition",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      1136,
      1294,
      4283,
      14354,
      16317,
      4943
    ],
    "start_token": 1733,
    "end_token": 1750,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      6603,
      6,
      284,
      7603,
      21391,
      6565,
      1398,
      6770
    ],
    "label": "best_practice",
    "reason": "Use of 'pass' to indicate intentional empty class definition"
  },
  {
    "line": 266,
    "text": "        logger.info(\"get US stock symbols......\")",
    "annotation": "\u2705 Best Practice: Inheriting from both YahooCollector and ABC suggests this class is meant to be abstract.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      1136,
      1294,
      4283,
      14354,
      16317,
      4943
    ],
    "start_token": 1750,
    "end_token": 1767,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      1111,
      16551,
      31337,
      273,
      290,
      9738,
      5644,
      428,
      1398,
      318,
      4001,
      284,
      307,
      12531,
      13
    ],
    "label": "best_practice",
    "reason": "Inheriting from both YahooCollector and ABC suggests this class is meant to be abstract."
  },
  {
    "line": 268,
    "text": "            \"^GSPC\",",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the method's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      61,
      38,
      4303,
      34,
      1600
    ],
    "start_token": 1767,
    "end_token": 1784,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2446,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the method's purpose and usage."
  },
  {
    "line": 282,
    "text": "    def _timezone(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method raises NotImplementedError, indicating it's intended to be overridden.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      2435,
      11340,
      7,
      944,
      2599
    ],
    "start_token": 1784,
    "end_token": 1794,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      11,
      12739,
      340,
      338,
      5292,
      284,
      307,
      23170,
      4651,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method raises NotImplementedError, indicating it's intended to be overridden."
  },
  {
    "line": 283,
    "text": "        return \"America/New_York\"",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for tracking function execution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      18165,
      14,
      3791,
      62,
      49278,
      1
    ],
    "start_token": 1794,
    "end_token": 1809,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9646,
      2163,
      9706
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for tracking function execution"
  },
  {
    "line": 284,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1809,
    "end_token": 1809,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Function call pattern for data retrieval"
  },
  {
    "line": 289,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for tracking function execution",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1809,
    "end_token": 1809,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9646,
      2163,
      9706
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for tracking function execution"
  },
  {
    "line": 291,
    "text": "    pass",
    "annotation": "\u2705 Best Practice: Explicitly returning the result of the function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1208
    ],
    "start_token": 1809,
    "end_token": 1813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      8024,
      262,
      1255,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Explicitly returning the result of the function"
  },
  {
    "line": 289,
    "text": "",
    "annotation": "\u2705 Best Practice: Define a method to download index data, but currently it's a placeholder with no implementation.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1813,
    "end_token": 1813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      2446,
      284,
      4321,
      6376,
      1366,
      11,
      475,
      3058,
      340,
      338,
      257,
      46076,
      351,
      645,
      7822,
      13
    ],
    "label": "best_practice",
    "reason": "Define a method to download index data, but currently it's a placeholder with no implementation."
  },
  {
    "line": 292,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1813,
    "end_token": 1813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters."
  },
  {
    "line": 294,
    "text": "class YahooCollectorIN(YahooCollector, ABC):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of string manipulation methods like upper() can indicate data normalization patterns.",
    "confidence": 0.5,
    "tokens": [
      4871,
      16551,
      31337,
      273,
      1268,
      7,
      56,
      12992,
      31337,
      273,
      11,
      9738,
      2599
    ],
    "start_token": 1813,
    "end_token": 1826,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4731,
      17512,
      5050,
      588,
      6727,
      3419,
      460,
      7603,
      1366,
      3487,
      1634,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of string manipulation methods like upper() can indicate data normalization patterns."
  },
  {
    "line": 296,
    "text": "        logger.info(\"get INDIA stock symbols......\")",
    "annotation": "\u2705 Best Practice: Using @property decorator is a good practice for creating read-only attributes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      1136,
      24413,
      3539,
      4283,
      14354,
      16317,
      4943
    ],
    "start_token": 1826,
    "end_token": 1844,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2488,
      26745,
      11705,
      1352,
      318,
      257,
      922,
      3357,
      329,
      4441,
      1100,
      12,
      8807,
      12608,
      13
    ],
    "label": "best_practice",
    "reason": "Using @property decorator is a good practice for creating read-only attributes."
  },
  {
    "line": 294,
    "text": "class YahooCollectorIN(YahooCollector, ABC):",
    "annotation": "\u2705 Best Practice: Consider using a constant or configuration for timezone values to improve maintainability.",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      31337,
      273,
      1268,
      7,
      56,
      12992,
      31337,
      273,
      11,
      9738,
      2599
    ],
    "start_token": 1844,
    "end_token": 1857,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      6937,
      393,
      8398,
      329,
      640,
      11340,
      3815,
      284,
      2987,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a constant or configuration for timezone values to improve maintainability."
  },
  {
    "line": 296,
    "text": "        logger.info(\"get INDIA stock symbols......\")",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      1136,
      24413,
      3539,
      4283,
      14354,
      16317,
      4943
    ],
    "start_token": 1857,
    "end_token": 1875,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage."
  },
  {
    "line": 298,
    "text": "        logger.info(f\"get {len(symbols)} symbols.\")",
    "annotation": "\u2705 Best Practice: Class variables should be documented to explain their purpose.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7,
      69,
      1,
      1136,
      1391,
      11925,
      7,
      1837,
      2022,
      10220,
      38165,
      14354,
      19570
    ],
    "start_token": 1875,
    "end_token": 1898,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      9633,
      815,
      307,
      12395,
      284,
      4727,
      511,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Class variables should be documented to explain their purpose."
  },
  {
    "line": 298,
    "text": "        logger.info(f\"get {len(symbols)} symbols.\")",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7,
      69,
      1,
      1136,
      1391,
      11925,
      7,
      1837,
      2022,
      10220,
      38165,
      14354,
      19570
    ],
    "start_token": 1898,
    "end_token": 1921,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage."
  },
  {
    "line": 300,
    "text": "",
    "annotation": "\u2705 Best Practice: Class variables should be documented to explain their purpose.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1921,
    "end_token": 1921,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      9633,
      815,
      307,
      12395,
      284,
      4727,
      511,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Class variables should be documented to explain their purpose."
  },
  {
    "line": 302,
    "text": "        pass",
    "annotation": "\ud83e\udde0 ML Signal: Use of class-level constants for configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 1921,
    "end_token": 1929,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1398,
      12,
      5715,
      38491,
      329,
      8398
    ],
    "label": "ml_signal",
    "reason": "Use of class-level constants for configuration"
  },
  {
    "line": 304,
    "text": "    def normalize_symbol(self, symbol):",
    "annotation": "\ud83e\udde0 ML Signal: Use of static method for utility function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      1837,
      23650,
      7,
      944,
      11,
      6194,
      2599
    ],
    "start_token": 1929,
    "end_token": 1943,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      9037,
      2446,
      329,
      10361,
      2163
    ],
    "label": "ml_signal",
    "reason": "Use of static method for utility function"
  },
  {
    "line": 305,
    "text": "        return code_to_fname(symbol).upper()",
    "annotation": "\u2705 Best Practice: Use of .copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2438,
      62,
      1462,
      62,
      69,
      3672,
      7,
      1837,
      23650,
      737,
      45828,
      3419
    ],
    "start_token": 1943,
    "end_token": 1963,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use of .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 307,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Filling missing values with forward fill method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1963,
    "end_token": 1968,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      376,
      4509,
      4814,
      3815,
      351,
      2651,
      6070,
      2446
    ],
    "label": "ml_signal",
    "reason": "Filling missing values with forward fill method"
  },
  {
    "line": 309,
    "text": "        return \"Asia/Kolkata\"",
    "annotation": "\ud83e\udde0 ML Signal: Shifting series to calculate change",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      38555,
      14,
      42,
      13597,
      1045,
      1
    ],
    "start_token": 1968,
    "end_token": 1983,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      911,
      13309,
      2168,
      284,
      15284,
      1487
    ],
    "label": "ml_signal",
    "reason": "Shifting series to calculate change"
  },
  {
    "line": 311,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential IndexError if DataFrame is empty",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1983,
    "end_token": 1983,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      12901,
      12331,
      611,
      6060,
      19778,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential IndexError if DataFrame is empty"
  },
  {
    "line": 313,
    "text": "    pass",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of iloc can lead to IndexError if DataFrame is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1208
    ],
    "start_token": 1983,
    "end_token": 1987,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      4229,
      420,
      460,
      1085,
      284,
      12901,
      12331,
      611,
      6060,
      19778,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of iloc can lead to IndexError if DataFrame is empty"
  },
  {
    "line": 313,
    "text": "    pass",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of percentage change",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1208
    ],
    "start_token": 1987,
    "end_token": 1991,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      5873,
      1487
    ],
    "label": "ml_signal",
    "reason": "Calculation of percentage change"
  },
  {
    "line": 313,
    "text": "    pass",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1208
    ],
    "start_token": 1991,
    "end_token": 1995,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the function parameters and return type for better readability and maintainability."
  },
  {
    "line": 321,
    "text": "    def retry(cls):  # pylint: disable=E0213",
    "annotation": "\u2705 Best Practice: Early return for empty DataFrame improves code readability and efficiency.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1005,
      563,
      7,
      565,
      82,
      2599,
      220,
      1303,
      279,
      2645,
      600,
      25,
      15560,
      28,
      36,
      2999,
      1485
    ],
    "start_token": 1995,
    "end_token": 2016,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12556,
      1441,
      329,
      6565,
      6060,
      19778,
      19575,
      2438,
      1100,
      1799,
      290,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Early return for empty DataFrame improves code readability and efficiency."
  },
  {
    "line": 324,
    "text": "        Yahoo Finance unfortunately does not keep track of some",
    "annotation": "\ud83e\udde0 ML Signal: Extracting the symbol from the DataFrame could be a feature for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16551,
      15007,
      12716,
      857,
      407,
      1394,
      2610,
      286,
      617
    ],
    "start_token": 2016,
    "end_token": 2032,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      262,
      6194,
      422,
      262,
      6060,
      19778,
      714,
      307,
      257,
      3895,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Extracting the symbol from the DataFrame could be a feature for ML models."
  },
  {
    "line": 326,
    "text": "",
    "annotation": "\u2705 Best Practice: Using deepcopy to avoid modifying the original COLUMNS list.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2032,
    "end_token": 2032,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2769,
      30073,
      284,
      3368,
      30620,
      262,
      2656,
      20444,
      5883,
      8035,
      1351,
      13
    ],
    "label": "best_practice",
    "reason": "Using deepcopy to avoid modifying the original COLUMNS list."
  },
  {
    "line": 328,
    "text": "        set to 5 will keep trying to get the stock data up to 5 times,",
    "annotation": "\u2705 Best Practice: Copying the DataFrame to avoid modifying the original data.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      900,
      284,
      642,
      481,
      1394,
      2111,
      284,
      651,
      262,
      4283,
      1366,
      510,
      284,
      642,
      1661,
      11
    ],
    "start_token": 2032,
    "end_token": 2055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6955,
      1112,
      262,
      6060,
      19778,
      284,
      3368,
      30620,
      262,
      2656,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Copying the DataFrame to avoid modifying the original data."
  },
  {
    "line": 330,
    "text": "",
    "annotation": "\u2705 Best Practice: Setting the index for better DataFrame operations.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2055,
    "end_token": 2055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      6376,
      329,
      1365,
      6060,
      19778,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Setting the index for better DataFrame operations."
  },
  {
    "line": 330,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensuring the index is in datetime format for time series operations.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2055,
    "end_token": 2055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      870,
      262,
      6376,
      318,
      287,
      4818,
      8079,
      5794,
      329,
      640,
      2168,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Ensuring the index is in datetime format for time series operations."
  },
  {
    "line": 330,
    "text": "",
    "annotation": "\u2705 Best Practice: Removing timezone information for consistency.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2055,
    "end_token": 2055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3982,
      5165,
      640,
      11340,
      1321,
      329,
      15794,
      13
    ],
    "label": "best_practice",
    "reason": "Removing timezone information for consistency."
  },
  {
    "line": 338,
    "text": "        raise NotImplementedError",
    "annotation": "\u2705 Best Practice: Removing duplicate indices to ensure data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331
    ],
    "start_token": 2055,
    "end_token": 2068,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3982,
      5165,
      23418,
      36525,
      284,
      4155,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Removing duplicate indices to ensure data integrity."
  },
  {
    "line": 339,
    "text": "",
    "annotation": "\u2705 Best Practice: Reindexing to align with a given calendar list.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2068,
    "end_token": 2068,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      9630,
      278,
      284,
      10548,
      351,
      257,
      1813,
      11845,
      1351,
      13
    ],
    "label": "best_practice",
    "reason": "Reindexing to align with a given calendar list."
  },
  {
    "line": 348,
    "text": "    def download_index_data(self):",
    "annotation": "\u2705 Best Practice: Sorting the index to maintain chronological order.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4321,
      62,
      9630,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 2068,
    "end_token": 2080,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      262,
      6376,
      284,
      5529,
      45946,
      1502,
      13
    ],
    "label": "best_practice",
    "reason": "Sorting the index to maintain chronological order."
  },
  {
    "line": 350,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for division by zero or NaN values in volume, ensure proper handling.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2080,
    "end_token": 2080,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      7297,
      416,
      6632,
      393,
      11013,
      45,
      3815,
      287,
      6115,
      11,
      4155,
      1774,
      9041,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for division by zero or NaN values in volume, ensure proper handling."
  },
  {
    "line": 352,
    "text": "        return code_to_fname(symbol).upper()",
    "annotation": "\ud83e\udde0 ML Signal: Calculating change could be a feature for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2438,
      62,
      1462,
      62,
      69,
      3672,
      7,
      1837,
      23650,
      737,
      45828,
      3419
    ],
    "start_token": 2080,
    "end_token": 2100,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27131,
      803,
      1487,
      714,
      307,
      257,
      3895,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Calculating change could be a feature for ML models."
  },
  {
    "line": 356,
    "text": "        return \"Brazil/East\"",
    "annotation": "\ud83e\udde0 ML Signal: Repeated calculation of change could indicate a pattern for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      39190,
      14,
      25234,
      1
    ],
    "start_token": 2100,
    "end_token": 2113,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30558,
      515,
      17952,
      286,
      1487,
      714,
      7603,
      257,
      3912,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Repeated calculation of change could indicate a pattern for ML models."
  },
  {
    "line": 362,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that division by 100 does not lead to unintended data corruption.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2113,
    "end_token": 2113,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      7297,
      416,
      1802,
      857,
      407,
      1085,
      284,
      30261,
      1366,
      9253,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that division by 100 does not lead to unintended data corruption."
  },
  {
    "line": 366,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for logging sensitive information, ensure proper logging practices.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2113,
    "end_token": 2113,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      18931,
      8564,
      1321,
      11,
      4155,
      1774,
      18931,
      6593,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for logging sensitive information, ensure proper logging practices."
  },
  {
    "line": 371,
    "text": "    @staticmethod",
    "annotation": "\ud83e\udde0 ML Signal: Final change calculation could be a feature for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 2113,
    "end_token": 2119,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8125,
      1487,
      17952,
      714,
      307,
      257,
      3895,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Final change calculation could be a feature for ML models."
  },
  {
    "line": 374,
    "text": "        _tmp_series = df[\"close\"].fillna(method=\"ffill\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that setting NaN values does not lead to data loss.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      22065,
      62,
      25076,
      796,
      47764,
      14692,
      19836,
      1,
      4083,
      20797,
      2616,
      7,
      24396,
      2625,
      487,
      359,
      4943
    ],
    "start_token": 2119,
    "end_token": 2144,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      4634,
      11013,
      45,
      3815,
      857,
      407,
      1085,
      284,
      1366,
      2994,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that setting NaN values does not lead to data loss."
  },
  {
    "line": 376,
    "text": "        if last_close is not None:",
    "annotation": "\u2705 Best Practice: Ensuring the symbol field is consistently set.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      938,
      62,
      19836,
      318,
      407,
      6045,
      25
    ],
    "start_token": 2144,
    "end_token": 2159,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      870,
      262,
      6194,
      2214,
      318,
      9835,
      900,
      13
    ],
    "label": "best_practice",
    "reason": "Ensuring the symbol field is consistently set."
  },
  {
    "line": 378,
    "text": "        change_series = _tmp_series / _tmp_shift_series - 1",
    "annotation": "\u2705 Best Practice: Naming the index for clarity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1487,
      62,
      25076,
      796,
      4808,
      22065,
      62,
      25076,
      1220,
      4808,
      22065,
      62,
      30846,
      62,
      25076,
      532,
      352
    ],
    "start_token": 2159,
    "end_token": 2183,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      399,
      3723,
      262,
      6376,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Naming the index for clarity."
  },
  {
    "line": 380,
    "text": "",
    "annotation": "\u2705 Best Practice: Resetting the index to return a DataFrame with a default integer index.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2183,
    "end_token": 2183,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      889,
      262,
      6376,
      284,
      1441,
      257,
      6060,
      19778,
      351,
      257,
      4277,
      18253,
      6376,
      13
    ],
    "label": "best_practice",
    "reason": "Resetting the index to return a DataFrame with a default integer index."
  },
  {
    "line": 362,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method signature with type hints indicating input and output types",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2183,
    "end_token": 2183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      351,
      2099,
      20269,
      12739,
      5128,
      290,
      5072,
      3858
    ],
    "label": "ml_signal",
    "reason": "Method signature with type hints indicating input and output types"
  },
  {
    "line": 364,
    "text": "    retry = 2",
    "annotation": "\ud83e\udde0 ML Signal: Chaining method calls for data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1005,
      563,
      796,
      362
    ],
    "start_token": 2183,
    "end_token": 2190,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      609,
      1397,
      2446,
      3848,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Chaining method calls for data transformation"
  },
  {
    "line": 366,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Returning a DataFrame after processing",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2190,
    "end_token": 2190,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      6060,
      19778,
      706,
      7587
    ],
    "label": "ml_signal",
    "reason": "Returning a DataFrame after processing"
  },
  {
    "line": 369,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u2705 Best Practice: Use of abstract method to enforce implementation in subclasses",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 2190,
    "end_token": 2208,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      12531,
      2446,
      284,
      4605,
      7822,
      287,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Use of abstract method to enforce implementation in subclasses"
  },
  {
    "line": 366,
    "text": "",
    "annotation": "\u2705 Best Practice: Method docstring is present, providing a brief description of the method.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2208,
    "end_token": 2208,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      2205,
      8841,
      318,
      1944,
      11,
      4955,
      257,
      4506,
      6764,
      286,
      262,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Method docstring is present, providing a brief description of the method."
  },
  {
    "line": 369,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method is not implemented, which could lead to runtime errors if called.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 2208,
    "end_token": 2226,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      318,
      407,
      9177,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      1444,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method is not implemented, which could lead to runtime errors if called."
  },
  {
    "line": 369,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u2705 Best Practice: Class name should follow CamelCase naming convention",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 2226,
    "end_token": 2244,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      1438,
      815,
      1061,
      43281,
      20448,
      19264,
      9831
    ],
    "label": "best_practice",
    "reason": "Class name should follow CamelCase naming convention"
  },
  {
    "line": 371,
    "text": "    @staticmethod",
    "annotation": "\u2705 Best Practice: Constants should be in uppercase to distinguish them from variables",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 2244,
    "end_token": 2250,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      287,
      334,
      39921,
      589,
      284,
      15714,
      606,
      422,
      9633
    ],
    "label": "best_practice",
    "reason": "Constants should be in uppercase to distinguish them from variables"
  },
  {
    "line": 372,
    "text": "    def calc_change(df: pd.DataFrame, last_close: float) -> pd.Series:",
    "annotation": "\u2705 Best Practice: Check for empty DataFrame to avoid unnecessary processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      42302,
      62,
      3803,
      7,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11,
      938,
      62,
      19836,
      25,
      12178,
      8,
      4613,
      279,
      67,
      13,
      27996,
      25
    ],
    "start_token": 2250,
    "end_token": 2278,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      6060,
      19778,
      284,
      3368,
      13114,
      7587
    ],
    "label": "best_practice",
    "reason": "Check for empty DataFrame to avoid unnecessary processing"
  },
  {
    "line": 375,
    "text": "        _tmp_shift_series = _tmp_series.shift(1)",
    "annotation": "\u2705 Best Practice: Use copy to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      22065,
      62,
      30846,
      62,
      25076,
      796,
      4808,
      22065,
      62,
      25076,
      13,
      30846,
      7,
      16,
      8
    ],
    "start_token": 2278,
    "end_token": 2301,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      4866,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use copy to avoid modifying the original DataFrame"
  },
  {
    "line": 377,
    "text": "            _tmp_shift_series.iloc[0] = float(last_close)",
    "annotation": "\u2705 Best Practice: Set index for easier time-series manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      22065,
      62,
      30846,
      62,
      25076,
      13,
      346,
      420,
      58,
      15,
      60,
      796,
      12178,
      7,
      12957,
      62,
      19836,
      8
    ],
    "start_token": 2301,
    "end_token": 2331,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5345,
      6376,
      329,
      4577,
      640,
      12,
      25076,
      17512
    ],
    "label": "best_practice",
    "reason": "Set index for easier time-series manipulation"
  },
  {
    "line": 380,
    "text": "",
    "annotation": "\u2705 Best Practice: Calculate adjustment factor for price adjustments",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2331,
    "end_token": 2331,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      378,
      15068,
      5766,
      329,
      2756,
      16895
    ],
    "label": "best_practice",
    "reason": "Calculate adjustment factor for price adjustments"
  },
  {
    "line": 382,
    "text": "    def normalize_yahoo(",
    "annotation": "\u2705 Best Practice: Forward fill to handle missing values in adjustment factor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      40774,
      7
    ],
    "start_token": 2331,
    "end_token": 2340,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      19530,
      6070,
      284,
      5412,
      4814,
      3815,
      287,
      15068,
      5766
    ],
    "label": "best_practice",
    "reason": "Forward fill to handle missing values in adjustment factor"
  },
  {
    "line": 385,
    "text": "        date_field_name: str = \"date\",",
    "annotation": "\u2705 Best Practice: Default factor to 1 when 'adjclose' is not present",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600
    ],
    "start_token": 2340,
    "end_token": 2358,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      5766,
      284,
      352,
      618,
      705,
      41255,
      19836,
      6,
      318,
      407,
      1944
    ],
    "label": "best_practice",
    "reason": "Default factor to 1 when 'adjclose' is not present"
  },
  {
    "line": 388,
    "text": "    ):",
    "annotation": "\u2705 Best Practice: Check if column exists before processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 2358,
    "end_token": 2362,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      5721,
      7160,
      878,
      7587
    ],
    "label": "best_practice",
    "reason": "Check if column exists before processing"
  },
  {
    "line": 392,
    "text": "        columns = copy.deepcopy(YahooNormalize.COLUMNS)",
    "annotation": "\u2705 Best Practice: Adjust volume by dividing with factor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      796,
      4866,
      13,
      22089,
      30073,
      7,
      56,
      12992,
      26447,
      1096,
      13,
      25154,
      5883,
      8035,
      8
    ],
    "start_token": 2362,
    "end_token": 2385,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20292,
      6115,
      416,
      27241,
      351,
      5766
    ],
    "label": "best_practice",
    "reason": "Adjust volume by dividing with factor"
  },
  {
    "line": 395,
    "text": "        df.index = pd.to_datetime(df.index)",
    "annotation": "\u2705 Best Practice: Adjust price-related columns by multiplying with factor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 2385,
    "end_token": 2408,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20292,
      2756,
      12,
      5363,
      15180,
      416,
      48816,
      351,
      5766
    ],
    "label": "best_practice",
    "reason": "Adjust price-related columns by multiplying with factor"
  },
  {
    "line": 395,
    "text": "        df.index = pd.to_datetime(df.index)",
    "annotation": "\u2705 Best Practice: Ensure index name is set correctly for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 2408,
    "end_token": 2431,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      6376,
      1438,
      318,
      900,
      9380,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Ensure index name is set correctly for clarity"
  },
  {
    "line": 400,
    "text": "                pd.DataFrame(index=calendar_list)",
    "annotation": "\u2705 Best Practice: Reset index to return DataFrame to original structure",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      7,
      9630,
      28,
      9948,
      9239,
      62,
      4868,
      8
    ],
    "start_token": 2431,
    "end_token": 2459,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      6376,
      284,
      1441,
      6060,
      19778,
      284,
      2656,
      4645
    ],
    "label": "best_practice",
    "reason": "Reset index to return DataFrame to original structure"
  },
  {
    "line": 391,
    "text": "        symbol = df.loc[df[symbol_field_name].first_valid_index(), symbol_field_name]",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      22784,
      6194,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 2459,
    "end_token": 2493,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 393,
    "text": "        df = df.copy()",
    "annotation": "\ud83e\udde0 ML Signal: Use of inheritance and method overriding, which is a common pattern in object-oriented programming.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      30073,
      3419
    ],
    "start_token": 2493,
    "end_token": 2506,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      24155,
      290,
      2446,
      44987,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      2134,
      12,
      17107,
      8300,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of inheritance and method overriding, which is a common pattern in object-oriented programming."
  },
  {
    "line": 395,
    "text": "        df.index = pd.to_datetime(df.index)",
    "annotation": "\ud83e\udde0 ML Signal: Chaining method calls on a DataFrame, indicating a data transformation process.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 2506,
    "end_token": 2529,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      609,
      1397,
      2446,
      3848,
      319,
      257,
      6060,
      19778,
      11,
      12739,
      257,
      1366,
      13389,
      1429,
      13
    ],
    "label": "ml_signal",
    "reason": "Chaining method calls on a DataFrame, indicating a data transformation process."
  },
  {
    "line": 395,
    "text": "        df.index = pd.to_datetime(df.index)",
    "annotation": "\u2705 Best Practice: Explicit return of the DataFrame makes the function's behavior clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 2529,
    "end_token": 2552,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      1441,
      286,
      262,
      6060,
      19778,
      1838,
      262,
      2163,
      338,
      4069,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Explicit return of the DataFrame makes the function's behavior clear."
  },
  {
    "line": 395,
    "text": "        df.index = pd.to_datetime(df.index)",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the method's purpose and usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      796,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 2552,
    "end_token": 2575,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2446,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the method's purpose and usage."
  },
  {
    "line": 401,
    "text": "                .loc[",
    "annotation": "\u2705 Best Practice: Using .loc with first_valid_index() ensures that the DataFrame is sliced correctly from the first valid 'close' value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      17946,
      58
    ],
    "start_token": 2575,
    "end_token": 2593,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      764,
      17946,
      351,
      717,
      62,
      12102,
      62,
      9630,
      3419,
      19047,
      326,
      262,
      6060,
      19778,
      318,
      26790,
      9380,
      422,
      262,
      717,
      4938,
      705,
      19836,
      6,
      1988,
      13
    ],
    "label": "best_practice",
    "reason": "Using .loc with first_valid_index() ensures that the DataFrame is sliced correctly from the first valid 'close' value."
  },
  {
    "line": 403,
    "text": "                    + pd.Timedelta(hours=23, minutes=59)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'close' column always has at least one valid entry; potential IndexError if DataFrame is empty or all NaN.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1343,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      24425,
      28,
      1954,
      11,
      2431,
      28,
      3270,
      8
    ],
    "start_token": 2593,
    "end_token": 2628,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      19836,
      6,
      5721,
      1464,
      468,
      379,
      1551,
      530,
      4938,
      5726,
      26,
      2785,
      12901,
      12331,
      611,
      6060,
      19778,
      318,
      6565,
      393,
      477,
      11013,
      45,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'close' column always has at least one valid entry; potential IndexError if DataFrame is empty or all NaN."
  },
  {
    "line": 405,
    "text": "                .index",
    "annotation": "\ud83e\udde0 ML Signal: Returns the first non-zero 'close' value, which could be a feature in financial models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 2628,
    "end_token": 2645,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      16409,
      262,
      717,
      1729,
      12,
      22570,
      705,
      19836,
      6,
      1988,
      11,
      543,
      714,
      307,
      257,
      3895,
      287,
      3176,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Returns the first non-zero 'close' value, which could be a feature in financial models."
  },
  {
    "line": 405,
    "text": "                .index",
    "annotation": "\u2705 Best Practice: Check for empty DataFrame to avoid unnecessary processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 2645,
    "end_token": 2662,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      6060,
      19778,
      284,
      3368,
      13114,
      7587
    ],
    "label": "best_practice",
    "reason": "Check for empty DataFrame to avoid unnecessary processing"
  },
  {
    "line": 408,
    "text": "        df.loc[(df[\"volume\"] <= 0) | np.isnan(df[\"volume\"]), list(set(df.columns) - {symbol_field_name})] = np.nan",
    "annotation": "\u2705 Best Practice: Use copy to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      17946,
      58,
      7,
      7568,
      14692,
      29048,
      8973,
      19841,
      657,
      8,
      930,
      45941,
      13,
      271,
      12647,
      7,
      7568,
      14692,
      29048,
      8973,
      828,
      1351,
      7,
      2617,
      7,
      7568,
      13,
      28665,
      82,
      8,
      532,
      1391,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      92,
      15437,
      796,
      45941,
      13,
      12647
    ],
    "start_token": 2662,
    "end_token": 2715,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      4866,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use copy to avoid modifying the original DataFrame"
  },
  {
    "line": 410,
    "text": "        change_series = YahooNormalize.calc_change(df, last_close)",
    "annotation": "\u2705 Best Practice: Sort DataFrame to ensure operations are performed in the correct order",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1487,
      62,
      25076,
      796,
      16551,
      26447,
      1096,
      13,
      9948,
      66,
      62,
      3803,
      7,
      7568,
      11,
      938,
      62,
      19836,
      8
    ],
    "start_token": 2715,
    "end_token": 2741,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      33947,
      6060,
      19778,
      284,
      4155,
      4560,
      389,
      6157,
      287,
      262,
      3376,
      1502
    ],
    "label": "best_practice",
    "reason": "Sort DataFrame to ensure operations are performed in the correct order"
  },
  {
    "line": 412,
    "text": "        # WARNING: If it is normal for a `symbol(exchange)` to differ by a factor of *89* to *111* for consecutive trading days,",
    "annotation": "\u2705 Best Practice: Set index for easier data manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      39410,
      25,
      1002,
      340,
      318,
      3487,
      329,
      257,
      4600,
      1837,
      23650,
      7,
      1069,
      3803,
      8,
      63,
      284,
      13238,
      416,
      257,
      5766,
      286,
      1635,
      4531,
      9,
      284,
      1635,
      16243,
      9,
      329,
      12785,
      7313,
      1528,
      11
    ],
    "start_token": 2741,
    "end_token": 2783,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5345,
      6376,
      329,
      4577,
      1366,
      17512
    ],
    "label": "best_practice",
    "reason": "Set index for easier data manipulation"
  },
  {
    "line": 414,
    "text": "        _count = 0",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a helper function to retrieve specific data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9127,
      796,
      657
    ],
    "start_token": 2783,
    "end_token": 2794,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      31904,
      2163,
      284,
      19818,
      2176,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of a helper function to retrieve specific data"
  },
  {
    "line": 417,
    "text": "            change_series = YahooNormalize.calc_change(df, last_close)",
    "annotation": "\u2705 Best Practice: Use of continue to skip unnecessary iterations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1487,
      62,
      25076,
      796,
      16551,
      26447,
      1096,
      13,
      9948,
      66,
      62,
      3803,
      7,
      7568,
      11,
      938,
      62,
      19836,
      8
    ],
    "start_token": 2794,
    "end_token": 2824,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2555,
      284,
      14267,
      13114,
      34820
    ],
    "label": "best_practice",
    "reason": "Use of continue to skip unnecessary iterations"
  },
  {
    "line": 420,
    "text": "                break",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for integer overflow if volume and _close are large",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2270
    ],
    "start_token": 2824,
    "end_token": 2840,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      18253,
      30343,
      611,
      6115,
      290,
      4808,
      19836,
      389,
      1588
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for integer overflow if volume and _close are large"
  },
  {
    "line": 423,
    "text": "            _count += 1",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Division by zero risk if _close is zero",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9127,
      15853,
      352
    ],
    "start_token": 2840,
    "end_token": 2855,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7458,
      416,
      6632,
      2526,
      611,
      4808,
      19836,
      318,
      6632
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Division by zero risk if _close is zero"
  },
  {
    "line": 423,
    "text": "            _count += 1",
    "annotation": "\u2705 Best Practice: Reset index to maintain original DataFrame structure",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9127,
      15853,
      352
    ],
    "start_token": 2855,
    "end_token": 2870,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      6376,
      284,
      5529,
      2656,
      6060,
      19778,
      4645
    ],
    "label": "best_practice",
    "reason": "Reset index to maintain original DataFrame structure"
  },
  {
    "line": 419,
    "text": "            if not _mask.any():",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from a base class, indicating a pattern of extending functionality",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      4808,
      27932,
      13,
      1092,
      33529
    ],
    "start_token": 2870,
    "end_token": 2888,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      257,
      2779,
      1398,
      11,
      12739,
      257,
      3912,
      286,
      16610,
      11244
    ],
    "label": "ml_signal",
    "reason": "Inheritance from a base class, indicating a pattern of extending functionality"
  },
  {
    "line": 423,
    "text": "            _count += 1",
    "annotation": "\u2705 Best Practice: Docstring provides clear parameter descriptions and default values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9127,
      15853,
      352
    ],
    "start_token": 2888,
    "end_token": 2903,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      11507,
      16969,
      290,
      4277,
      3815
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear parameter descriptions and default values"
  },
  {
    "line": 434,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass constructor",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2903,
    "end_token": 2903,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      23772
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass constructor"
  },
  {
    "line": 436,
    "text": "        df.index.names = [date_field_name]",
    "annotation": "\ud83e\udde0 ML Signal: Usage of financial data column names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      13,
      14933,
      796,
      685,
      4475,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 2903,
    "end_token": 2923,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      3176,
      1366,
      5721,
      3891
    ],
    "label": "ml_signal",
    "reason": "Usage of financial data column names"
  },
  {
    "line": 438,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Loading data from a specified directory",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2923,
    "end_token": 2923,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      12320,
      1366,
      422,
      257,
      7368,
      8619
    ],
    "label": "ml_signal",
    "reason": "Loading data from a specified directory"
  },
  {
    "line": 436,
    "text": "        df.index.names = [date_field_name]",
    "annotation": "\u2705 Best Practice: Type hinting for function parameters improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      9630,
      13,
      14933,
      796,
      685,
      4475,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 2923,
    "end_token": 2943,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for function parameters improves code readability and maintainability"
  },
  {
    "line": 438,
    "text": "",
    "annotation": "\u2705 Best Practice: Converting path to string and resolving it ensures consistent path format",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2943,
    "end_token": 2943,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      3108,
      284,
      4731,
      290,
      31038,
      340,
      19047,
      6414,
      3108,
      5794
    ],
    "label": "best_practice",
    "reason": "Converting path to string and resolving it ensures consistent path format"
  },
  {
    "line": 440,
    "text": "        # normalize",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Initialization with external data directory could lead to data integrity issues if not validated",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      3487,
      1096
    ],
    "start_token": 2943,
    "end_token": 2953,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      20768,
      1634,
      351,
      7097,
      1366,
      8619,
      714,
      1085,
      284,
      1366,
      11540,
      2428,
      611,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Initialization with external data directory could lead to data integrity issues if not validated"
  },
  {
    "line": 442,
    "text": "        # adjusted price",
    "annotation": "\ud83e\udde0 ML Signal: Usage of D.features suggests data extraction for ML model training or analysis",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      12328,
      2756
    ],
    "start_token": 2953,
    "end_token": 2963,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      360,
      13,
      40890,
      5644,
      1366,
      22236,
      329,
      10373,
      2746,
      3047,
      393,
      3781
    ],
    "label": "ml_signal",
    "reason": "Usage of D.features suggests data extraction for ML model training or analysis"
  },
  {
    "line": 444,
    "text": "        return df",
    "annotation": "\u2705 Best Practice: Explicitly setting DataFrame columns improves code clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 2963,
    "end_token": 2972,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      6060,
      19778,
      15180,
      19575,
      2438,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly setting DataFrame columns improves code clarity"
  },
  {
    "line": 443,
    "text": "        df = self.adjusted_price(df)",
    "annotation": "\ud83e\udde0 ML Signal: Use of inheritance and method overriding",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      2116,
      13,
      29117,
      62,
      20888,
      7,
      7568,
      8
    ],
    "start_token": 2972,
    "end_token": 2989,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      24155,
      290,
      2446,
      44987
    ],
    "label": "ml_signal",
    "reason": "Use of inheritance and method overriding"
  },
  {
    "line": 445,
    "text": "",
    "annotation": "\u2705 Best Practice: Setting index for DataFrame for efficient data manipulation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2989,
    "end_token": 2989,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      6376,
      329,
      6060,
      19778,
      329,
      6942,
      1366,
      17512
    ],
    "label": "best_practice",
    "reason": "Setting index for DataFrame for efficient data manipulation"
  },
  {
    "line": 447,
    "text": "    def adjusted_price(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing DataFrame columns using dynamic field names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      12328,
      62,
      20888,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 2989,
    "end_token": 3014,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      6060,
      19778,
      15180,
      1262,
      8925,
      2214,
      3891
    ],
    "label": "ml_signal",
    "reason": "Accessing DataFrame columns using dynamic field names"
  },
  {
    "line": 449,
    "text": "        raise NotImplementedError(\"rewrite adjusted_price\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of unique values from DataFrame for conditional logic",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7203,
      1809,
      6525,
      12328,
      62,
      20888,
      4943
    ],
    "start_token": 3014,
    "end_token": 3034,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3748,
      3815,
      422,
      6060,
      19778,
      329,
      26340,
      9156
    ],
    "label": "ml_signal",
    "reason": "Use of unique values from DataFrame for conditional logic"
  },
  {
    "line": 452,
    "text": "class YahooNormalize1d(YahooNormalize, ABC):",
    "annotation": "\u2705 Best Practice: Resetting index before returning DataFrame",
    "confidence": 0.5,
    "tokens": [
      4871,
      16551,
      26447,
      1096,
      16,
      67,
      7,
      56,
      12992,
      26447,
      1096,
      11,
      9738,
      2599
    ],
    "start_token": 3034,
    "end_token": 3048,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      889,
      6376,
      878,
      8024,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Resetting index before returning DataFrame"
  },
  {
    "line": 454,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional data selection based on symbol name",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3048,
    "end_token": 3048,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      1366,
      6356,
      1912,
      319,
      6194,
      1438
    ],
    "label": "ml_signal",
    "reason": "Conditional data selection based on symbol name"
  },
  {
    "line": 456,
    "text": "        if df.empty:",
    "annotation": "\ud83e\udde0 ML Signal: Use of DataFrame indexing to find latest date",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 3048,
    "end_token": 3060,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6060,
      19778,
      6376,
      278,
      284,
      1064,
      3452,
      3128
    ],
    "label": "ml_signal",
    "reason": "Use of DataFrame indexing to find latest date"
  },
  {
    "line": 458,
    "text": "        df = df.copy()",
    "annotation": "\ud83e\udde0 ML Signal: Slicing DataFrame based on date",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      30073,
      3419
    ],
    "start_token": 3060,
    "end_token": 3073,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      677,
      278,
      6060,
      19778,
      1912,
      319,
      3128
    ],
    "label": "ml_signal",
    "reason": "Slicing DataFrame based on date"
  },
  {
    "line": 460,
    "text": "        if \"adjclose\" in df:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing first row of DataFrame for comparison",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      366,
      41255,
      19836,
      1,
      287,
      47764,
      25
    ],
    "start_token": 3073,
    "end_token": 3088,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      717,
      5752,
      286,
      6060,
      19778,
      329,
      7208
    ],
    "label": "ml_signal",
    "reason": "Accessing first row of DataFrame for comparison"
  },
  {
    "line": 462,
    "text": "            df[\"factor\"] = df[\"factor\"].fillna(method=\"ffill\")",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific row in DataFrame for comparison",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      31412,
      8973,
      796,
      47764,
      14692,
      31412,
      1,
      4083,
      20797,
      2616,
      7,
      24396,
      2625,
      487,
      359,
      4943
    ],
    "start_token": 3088,
    "end_token": 3117,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      5752,
      287,
      6060,
      19778,
      329,
      7208
    ],
    "label": "ml_signal",
    "reason": "Accessing specific row in DataFrame for comparison"
  },
  {
    "line": 466,
    "text": "            if _col not in df.columns:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if new_latest_data[col] is zero",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      4033,
      407,
      287,
      47764,
      13,
      28665,
      82,
      25
    ],
    "start_token": 3117,
    "end_token": 3138,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      649,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      60,
      318,
      6632
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if new_latest_data[col] is zero"
  },
  {
    "line": 469,
    "text": "                df[_col] = df[_col] / df[\"factor\"]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if new_latest_data[col] is zero",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      29795,
      4033,
      60,
      796,
      47764,
      29795,
      4033,
      60,
      1220,
      47764,
      14692,
      31412,
      8973
    ],
    "start_token": 3138,
    "end_token": 3167,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      649,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      60,
      318,
      6632
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if new_latest_data[col] is zero"
  },
  {
    "line": 469,
    "text": "                df[_col] = df[_col] / df[\"factor\"]",
    "annotation": "\u2705 Best Practice: Dropping the first row and resetting index before returning DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      29795,
      4033,
      60,
      796,
      47764,
      29795,
      4033,
      60,
      1220,
      47764,
      14692,
      31412,
      8973
    ],
    "start_token": 3167,
    "end_token": 3196,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      262,
      717,
      5752,
      290,
      13259,
      889,
      6376,
      878,
      8024,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Dropping the first row and resetting index before returning DataFrame"
  },
  {
    "line": 462,
    "text": "            df[\"factor\"] = df[\"factor\"].fillna(method=\"ffill\")",
    "annotation": "\u2705 Best Practice: Constants should be defined at the class level for clarity and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      31412,
      8973,
      796,
      47764,
      14692,
      31412,
      1,
      4083,
      20797,
      2616,
      7,
      24396,
      2625,
      487,
      359,
      4943
    ],
    "start_token": 3196,
    "end_token": 3225,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      5447,
      379,
      262,
      1398,
      1241,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Constants should be defined at the class level for clarity and maintainability"
  },
  {
    "line": 464,
    "text": "            df[\"factor\"] = 1",
    "annotation": "\u2705 Best Practice: Constants should be defined at the class level for clarity and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      31412,
      8973,
      796,
      352
    ],
    "start_token": 3225,
    "end_token": 3242,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      5447,
      379,
      262,
      1398,
      1241,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Constants should be defined at the class level for clarity and maintainability"
  },
  {
    "line": 466,
    "text": "            if _col not in df.columns:",
    "annotation": "\u2705 Best Practice: Constants should be defined at the class level for clarity and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      4033,
      407,
      287,
      47764,
      13,
      28665,
      82,
      25
    ],
    "start_token": 3242,
    "end_token": 3263,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      5447,
      379,
      262,
      1398,
      1241,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Constants should be defined at the class level for clarity and maintainability"
  },
  {
    "line": 469,
    "text": "                df[_col] = df[_col] / df[\"factor\"]",
    "annotation": "\u2705 Best Practice: Constants should be defined at the class level for clarity and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      29795,
      4033,
      60,
      796,
      47764,
      29795,
      4033,
      60,
      1220,
      47764,
      14692,
      31412,
      8973
    ],
    "start_token": 3263,
    "end_token": 3292,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      5447,
      379,
      262,
      1398,
      1241,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Constants should be defined at the class level for clarity and maintainability"
  },
  {
    "line": 469,
    "text": "                df[_col] = df[_col] / df[\"factor\"]",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      29795,
      4033,
      60,
      796,
      47764,
      29795,
      4033,
      60,
      1220,
      47764,
      14692,
      31412,
      8973
    ],
    "start_token": 3292,
    "end_token": 3321,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability."
  },
  {
    "line": 480,
    "text": "    def _get_first_close(self, df: pd.DataFrame) -> float:",
    "annotation": "\u2705 Best Practice: Calling the superclass's __init__ method ensures proper initialization of the base class.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      11085,
      62,
      19836,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      12178,
      25
    ],
    "start_token": 3321,
    "end_token": 3345,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      32677,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      286,
      262,
      2779,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Calling the superclass's __init__ method ensures proper initialization of the base class."
  },
  {
    "line": 482,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of qlib with a specific data directory could indicate a pattern for data loading.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3345,
    "end_token": 3345,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      10662,
      8019,
      351,
      257,
      2176,
      1366,
      8619,
      714,
      7603,
      257,
      3912,
      329,
      1366,
      11046,
      13
    ],
    "label": "ml_signal",
    "reason": "Initialization of qlib with a specific data directory could indicate a pattern for data loading."
  },
  {
    "line": 483,
    "text": "        Notes",
    "annotation": "\ud83e\udde0 ML Signal: Loading features from a data source is a common pattern in data processing pipelines.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11822
    ],
    "start_token": 3345,
    "end_token": 3353,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      12320,
      3033,
      422,
      257,
      1366,
      2723,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      31108,
      13
    ],
    "label": "ml_signal",
    "reason": "Loading features from a data source is a common pattern in data processing pipelines."
  },
  {
    "line": 483,
    "text": "        Notes",
    "annotation": "\u2705 Best Practice: Explicitly specify the return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11822
    ],
    "start_token": 3353,
    "end_token": 3361,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      11986,
      262,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly specify the return type for better readability and maintainability."
  },
  {
    "line": 485,
    "text": "            For incremental updates(append) to Yahoo 1D data, user need to use a close that is not 0 on the first trading day of the existing data",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a method to convert a calendar to a list, indicating a pattern of data transformation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1114,
      29497,
      5992,
      7,
      33295,
      8,
      284,
      16551,
      352,
      35,
      1366,
      11,
      2836,
      761,
      284,
      779,
      257,
      1969,
      326,
      318,
      407,
      657,
      319,
      262,
      717,
      7313,
      1110,
      286,
      262,
      4683,
      1366
    ],
    "start_token": 3361,
    "end_token": 3403,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2446,
      284,
      10385,
      257,
      11845,
      284,
      257,
      1351,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      13389,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a method to convert a calendar to a list, indicating a pattern of data transformation."
  },
  {
    "line": 487,
    "text": "        df = df.loc[df[\"close\"].first_valid_index() :]",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, improving code readability and encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      14692,
      19836,
      1,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      3419,
      1058,
      60
    ],
    "start_token": 3403,
    "end_token": 3429,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      10068,
      2438,
      1100,
      1799,
      290,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, improving code readability and encapsulation."
  },
  {
    "line": 486,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of getattr to check for cached attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 3429,
    "end_token": 3437,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      651,
      35226,
      284,
      2198,
      329,
      39986,
      11688
    ],
    "label": "ml_signal",
    "reason": "Use of getattr to check for cached attribute"
  },
  {
    "line": 489,
    "text": "        return _close",
    "annotation": "\ud83e\udde0 ML Signal: Lazy initialization pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      19836
    ],
    "start_token": 3437,
    "end_token": 3447,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      406,
      12582,
      37588,
      3912
    ],
    "label": "ml_signal",
    "reason": "Lazy initialization pattern"
  },
  {
    "line": 491,
    "text": "    def _manual_adj_data(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Use of setattr to cache computed value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      805,
      723,
      62,
      41255,
      62,
      7890,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 3447,
    "end_token": 3476,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      900,
      35226,
      284,
      12940,
      29231,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of setattr to cache computed value"
  },
  {
    "line": 491,
    "text": "    def _manual_adj_data(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Method signature and parameter types can be used to infer function usage patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      805,
      723,
      62,
      41255,
      62,
      7890,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 3476,
    "end_token": 3505,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      290,
      11507,
      3858,
      460,
      307,
      973,
      284,
      13249,
      2163,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method signature and parameter types can be used to infer function usage patterns"
  },
  {
    "line": 492,
    "text": "        \"\"\"manual adjust data: All fields (except change) are standardized according to the close of the first day\"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Function call with specific parameters can indicate common usage patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      805,
      723,
      4532,
      1366,
      25,
      1439,
      7032,
      357,
      16341,
      1487,
      8,
      389,
      25713,
      1864,
      284,
      262,
      1969,
      286,
      262,
      717,
      1110,
      37811
    ],
    "start_token": 3505,
    "end_token": 3535,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      2176,
      10007,
      460,
      7603,
      2219,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function call with specific parameters can indicate common usage patterns"
  },
  {
    "line": 494,
    "text": "            return df",
    "annotation": "\u2705 Best Practice: Use of descriptive parameter names improves code readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 3535,
    "end_token": 3548,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      11507,
      3891,
      19575,
      2438,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of descriptive parameter names improves code readability"
  },
  {
    "line": 496,
    "text": "        df.sort_values(self._date_field_name, inplace=True)",
    "annotation": "\ud83e\udde0 ML Signal: Method signature with type hints can be used to infer data processing patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      30619,
      62,
      27160,
      7,
      944,
      13557,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 3548,
    "end_token": 3574,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      351,
      2099,
      20269,
      460,
      307,
      973,
      284,
      13249,
      1366,
      7587,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method signature with type hints can be used to infer data processing patterns"
  },
  {
    "line": 505,
    "text": "            else:",
    "annotation": "\u2705 Best Practice: Returning the DataFrame directly after processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 3574,
    "end_token": 3587,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      262,
      6060,
      19778,
      3264,
      706,
      7587
    ],
    "label": "best_practice",
    "reason": "Returning the DataFrame directly after processing"
  },
  {
    "line": 508,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of abstract method to enforce implementation in subclasses",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3587,
    "end_token": 3587,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      12531,
      2446,
      284,
      4605,
      7822,
      287,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Use of abstract method to enforce implementation in subclasses"
  },
  {
    "line": 508,
    "text": "",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that a method should be overridden.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3587,
    "end_token": 3587,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      257,
      2446,
      815,
      307,
      23170,
      4651,
      13
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that a method should be overridden."
  },
  {
    "line": 510,
    "text": "class YahooNormalize1dExtend(YahooNormalize1d):",
    "annotation": "\u2705 Best Practice: Using abc.abstractmethod enforces that subclasses must implement this method.",
    "confidence": 0.5,
    "tokens": [
      4871,
      16551,
      26447,
      1096,
      16,
      67,
      11627,
      437,
      7,
      56,
      12992,
      26447,
      1096,
      16,
      67,
      2599
    ],
    "start_token": 3587,
    "end_token": 3603,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      450,
      66,
      13,
      397,
      8709,
      24396,
      551,
      27087,
      326,
      850,
      37724,
      1276,
      3494,
      428,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Using abc.abstractmethod enforces that subclasses must implement this method."
  },
  {
    "line": 510,
    "text": "class YahooNormalize1dExtend(YahooNormalize1d):",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      26447,
      1096,
      16,
      67,
      11627,
      437,
      7,
      56,
      12992,
      26447,
      1096,
      16,
      67,
      2599
    ],
    "start_token": 3603,
    "end_token": 3619,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 512,
    "text": "        self, old_qlib_data_dir: [str, Path], date_field_name: str = \"date\", symbol_field_name: str = \"symbol\", **kwargs",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that a method should be overridden",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      1468,
      62,
      80,
      8019,
      62,
      7890,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      1837,
      23650,
      1600,
      12429,
      46265,
      22046
    ],
    "start_token": 3619,
    "end_token": 3668,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      257,
      2446,
      815,
      307,
      23170,
      4651
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that a method should be overridden"
  },
  {
    "line": 513,
    "text": "    ):",
    "annotation": "\ud83e\udde0 ML Signal: Method with a specific return type hint indicating expected output",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 3668,
    "end_token": 3672,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      351,
      257,
      2176,
      1441,
      2099,
      9254,
      12739,
      2938,
      5072
    ],
    "label": "ml_signal",
    "reason": "Method with a specific return type hint indicating expected output"
  },
  {
    "line": 515,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Calls a function with a specific string argument, indicating a pattern of usage",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3672,
    "end_token": 3672,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27592,
      257,
      2163,
      351,
      257,
      2176,
      4731,
      4578,
      11,
      12739,
      257,
      3912,
      286,
      8748
    ],
    "label": "ml_signal",
    "reason": "Calls a function with a specific string argument, indicating a pattern of usage"
  },
  {
    "line": 515,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality from multiple parent classes",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3672,
    "end_token": 3672,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      422,
      3294,
      2560,
      6097
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality from multiple parent classes"
  },
  {
    "line": 517,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality from multiple parent classes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 3672,
    "end_token": 3681,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      422,
      3294,
      2560,
      6097
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality from multiple parent classes"
  },
  {
    "line": 519,
    "text": "            the qlib data to be updated for yahoo, usually from: https://github.com/microsoft/qlib/tree/main/scripts#download-cn-data",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      10662,
      8019,
      1366,
      284,
      307,
      6153,
      329,
      331,
      12992,
      11,
      3221,
      422,
      25,
      3740,
      1378,
      12567,
      13,
      785,
      14,
      40485,
      14,
      80,
      8019,
      14,
      21048,
      14,
      12417,
      14,
      46521,
      2,
      15002,
      12,
      31522,
      12,
      7890
    ],
    "start_token": 3681,
    "end_token": 3728,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage"
  },
  {
    "line": 521,
    "text": "            date field name, default is date",
    "annotation": "\u2705 Best Practice: Constants should be in uppercase to distinguish them from regular variables",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      2214,
      1438,
      11,
      4277,
      318,
      3128
    ],
    "start_token": 3728,
    "end_token": 3746,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      287,
      334,
      39921,
      589,
      284,
      15714,
      606,
      422,
      3218,
      9633
    ],
    "label": "best_practice",
    "reason": "Constants should be in uppercase to distinguish them from regular variables"
  },
  {
    "line": 521,
    "text": "            date field name, default is date",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      2214,
      1438,
      11,
      4277,
      318,
      3128
    ],
    "start_token": 3746,
    "end_token": 3764,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 523,
    "text": "            symbol field name, default is symbol",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without context can make debugging difficult",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      2214,
      1438,
      11,
      4277,
      318,
      6194
    ],
    "start_token": 3764,
    "end_token": 3782,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      4732,
      460,
      787,
      28769,
      2408
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without context can make debugging difficult"
  },
  {
    "line": 523,
    "text": "            symbol field name, default is symbol",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a private method, indicating encapsulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      2214,
      1438,
      11,
      4277,
      318,
      6194
    ],
    "start_token": 3782,
    "end_token": 3800,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      2839,
      2446,
      11,
      12739,
      32652,
      1741
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a private method, indicating encapsulation"
  },
  {
    "line": 525,
    "text": "        super(YahooNormalize1dExtend, self).__init__(date_field_name, symbol_field_name)",
    "annotation": "\ud83e\udde0 ML Signal: Calls an external function, indicating a dependency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      56,
      12992,
      26447,
      1096,
      16,
      67,
      11627,
      437,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      6194,
      62,
      3245,
      62,
      3672,
      8
    ],
    "start_token": 3800,
    "end_token": 3836,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27592,
      281,
      7097,
      2163,
      11,
      12739,
      257,
      20203
    ],
    "label": "ml_signal",
    "reason": "Calls an external function, indicating a dependency"
  },
  {
    "line": 525,
    "text": "        super(YahooNormalize1dExtend, self).__init__(date_field_name, symbol_field_name)",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and parameters of the function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      56,
      12992,
      26447,
      1096,
      16,
      67,
      11627,
      437,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      6194,
      62,
      3245,
      62,
      3672,
      8
    ],
    "start_token": 3836,
    "end_token": 3872,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      10007,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and parameters of the function"
  },
  {
    "line": 527,
    "text": "        self.old_qlib_data = self._get_old_data(old_qlib_data_dir)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a helper function to transform data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      727,
      62,
      80,
      8019,
      62,
      7890,
      796,
      2116,
      13557,
      1136,
      62,
      727,
      62,
      7890,
      7,
      727,
      62,
      80,
      8019,
      62,
      7890,
      62,
      15908,
      8
    ],
    "start_token": 3872,
    "end_token": 3905,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      31904,
      2163,
      284,
      6121,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of a helper function to transform data"
  },
  {
    "line": 528,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring should be added to describe the purpose and usage of the class",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3905,
    "end_token": 3905,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      815,
      307,
      2087,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      1398
    ],
    "label": "best_practice",
    "reason": "Class docstring should be added to describe the purpose and usage of the class"
  },
  {
    "line": 528,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3905,
    "end_token": 3905,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 530,
    "text": "        qlib_data_dir = str(Path(qlib_data_dir).expanduser().resolve())",
    "annotation": "\ud83e\udde0 ML Signal: Function calls with specific string arguments can indicate usage patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      15908,
      796,
      965,
      7,
      15235,
      7,
      80,
      8019,
      62,
      7890,
      62,
      15908,
      737,
      11201,
      392,
      7220,
      22446,
      411,
      6442,
      28955
    ],
    "start_token": 3905,
    "end_token": 3937,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      351,
      2176,
      4731,
      7159,
      460,
      7603,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function calls with specific string arguments can indicate usage patterns"
  },
  {
    "line": 530,
    "text": "        qlib_data_dir = str(Path(qlib_data_dir).expanduser().resolve())",
    "annotation": "\u2705 Best Practice: Use of multiple inheritance can lead to complex class hierarchies; ensure that the parent classes are compatible and necessary.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      15908,
      796,
      965,
      7,
      15235,
      7,
      80,
      8019,
      62,
      7890,
      62,
      15908,
      737,
      11201,
      392,
      7220,
      22446,
      411,
      6442,
      28955
    ],
    "start_token": 3937,
    "end_token": 3969,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3294,
      24155,
      460,
      1085,
      284,
      3716,
      1398,
      28398,
      444,
      26,
      4155,
      326,
      262,
      2560,
      6097,
      389,
      11670,
      290,
      3306,
      13
    ],
    "label": "best_practice",
    "reason": "Use of multiple inheritance can lead to complex class hierarchies; ensure that the parent classes are compatible and necessary."
  },
  {
    "line": 532,
    "text": "        df = D.features(D.instruments(\"all\"), [\"$\" + col for col in self.column_list])",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      360,
      13,
      40890,
      7,
      35,
      13,
      259,
      2536,
      2886,
      7203,
      439,
      12340,
      14631,
      3,
      1,
      1343,
      951,
      329,
      951,
      287,
      2116,
      13,
      28665,
      62,
      4868,
      12962
    ],
    "start_token": 3969,
    "end_token": 4004,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage"
  },
  {
    "line": 534,
    "text": "        return df",
    "annotation": "\ud83e\udde0 ML Signal: Class attribute that might be used to configure behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 4004,
    "end_token": 4013,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      11688,
      326,
      1244,
      307,
      973,
      284,
      17425,
      4069
    ],
    "label": "ml_signal",
    "reason": "Class attribute that might be used to configure behavior"
  },
  {
    "line": 534,
    "text": "        return df",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 4013,
    "end_token": 4022,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function"
  },
  {
    "line": 536,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without context can make debugging difficult",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 4022,
    "end_token": 4046,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      4732,
      460,
      787,
      28769,
      2408
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without context can make debugging difficult"
  },
  {
    "line": 536,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a pattern of retrieving calendar data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 4046,
    "end_token": 4070,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      3912,
      286,
      50122,
      11845,
      1366
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a pattern of retrieving calendar data"
  },
  {
    "line": 538,
    "text": "        df.set_index(self._date_field_name, inplace=True)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a specific calendar identifier \"IN_ALL\"",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      2617,
      62,
      9630,
      7,
      944,
      13557,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 4070,
    "end_token": 4096,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2176,
      11845,
      27421,
      366,
      1268,
      62,
      7036,
      1
    ],
    "label": "ml_signal",
    "reason": "Usage of a specific calendar identifier \"IN_ALL\""
  },
  {
    "line": 538,
    "text": "        df.set_index(self._date_field_name, inplace=True)",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and parameters of the function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      2617,
      62,
      9630,
      7,
      944,
      13557,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 4096,
    "end_token": 4122,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      10007,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and parameters of the function"
  },
  {
    "line": 540,
    "text": "        old_symbol_list = self.old_qlib_data.index.get_level_values(\"instrument\").unique().to_list()",
    "annotation": "\ud83e\udde0 ML Signal: Function calls can indicate common usage patterns and dependencies",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1468,
      62,
      1837,
      23650,
      62,
      4868,
      796,
      2116,
      13,
      727,
      62,
      80,
      8019,
      62,
      7890,
      13,
      9630,
      13,
      1136,
      62,
      5715,
      62,
      27160,
      7203,
      259,
      43872,
      11074,
      34642,
      22446,
      1462,
      62,
      4868,
      3419
    ],
    "start_token": 4122,
    "end_token": 4162,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      460,
      7603,
      2219,
      8748,
      7572,
      290,
      20086
    ],
    "label": "ml_signal",
    "reason": "Function calls can indicate common usage patterns and dependencies"
  },
  {
    "line": 541,
    "text": "        if str(symbol_name).upper() not in old_symbol_list:",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      965,
      7,
      1837,
      23650,
      62,
      3672,
      737,
      45828,
      3419,
      407,
      287,
      1468,
      62,
      1837,
      23650,
      62,
      4868,
      25
    ],
    "start_token": 4162,
    "end_token": 4188,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 543,
    "text": "        old_df = self.old_qlib_data.loc[str(symbol_name).upper()]",
    "annotation": "\ud83e\udde0 ML Signal: Function calls with specific string arguments can indicate usage patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1468,
      62,
      7568,
      796,
      2116,
      13,
      727,
      62,
      80,
      8019,
      62,
      7890,
      13,
      17946,
      58,
      2536,
      7,
      1837,
      23650,
      62,
      3672,
      737,
      45828,
      3419,
      60
    ],
    "start_token": 4188,
    "end_token": 4220,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      351,
      2176,
      4731,
      7159,
      460,
      7603,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function calls with specific string arguments can indicate usage patterns"
  },
  {
    "line": 543,
    "text": "        old_df = self.old_qlib_data.loc[str(symbol_name).upper()]",
    "annotation": "\u2705 Best Practice: Use of multiple inheritance to combine functionality from YahooNormalizeCN and YahooNormalize1d",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1468,
      62,
      7568,
      796,
      2116,
      13,
      727,
      62,
      80,
      8019,
      62,
      7890,
      13,
      17946,
      58,
      2536,
      7,
      1837,
      23650,
      62,
      3672,
      737,
      45828,
      3419,
      60
    ],
    "start_token": 4220,
    "end_token": 4252,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3294,
      24155,
      284,
      12082,
      11244,
      422,
      16551,
      26447,
      1096,
      44175,
      290,
      16551,
      26447,
      1096,
      16,
      67
    ],
    "label": "best_practice",
    "reason": "Use of multiple inheritance to combine functionality from YahooNormalizeCN and YahooNormalize1d"
  },
  {
    "line": 545,
    "text": "        df = df.loc[latest_date:]",
    "annotation": "\u2705 Best Practice: Use of class inheritance to extend functionality from multiple parent classes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      17946,
      58,
      42861,
      62,
      4475,
      47715
    ],
    "start_token": 4252,
    "end_token": 4269,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      24155,
      284,
      9117,
      11244,
      422,
      3294,
      2560,
      6097
    ],
    "label": "best_practice",
    "reason": "Use of class inheritance to extend functionality from multiple parent classes"
  },
  {
    "line": 547,
    "text": "        old_latest_data = old_df.loc[latest_date]",
    "annotation": "\u2705 Best Practice: Class definition should follow the naming conventions, using CamelCase.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1468,
      62,
      42861,
      62,
      7890,
      796,
      1468,
      62,
      7568,
      13,
      17946,
      58,
      42861,
      62,
      4475,
      60
    ],
    "start_token": 4269,
    "end_token": 4292,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      262,
      19264,
      21396,
      11,
      1262,
      43281,
      20448,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should follow the naming conventions, using CamelCase."
  },
  {
    "line": 549,
    "text": "            if col == \"volume\":",
    "annotation": "\ud83e\udde0 ML Signal: Constants like AM_RANGE and PM_RANGE can be used to identify trading session times.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      951,
      6624,
      366,
      29048,
      1298
    ],
    "start_token": 4292,
    "end_token": 4309,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      588,
      3001,
      62,
      49,
      27746,
      290,
      3122,
      62,
      49,
      27746,
      460,
      307,
      973,
      284,
      5911,
      7313,
      6246,
      1661,
      13
    ],
    "label": "ml_signal",
    "reason": "Constants like AM_RANGE and PM_RANGE can be used to identify trading session times."
  },
  {
    "line": 551,
    "text": "            else:",
    "annotation": "\ud83e\udde0 ML Signal: Constants like AM_RANGE and PM_RANGE can be used to identify trading session times.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 4309,
    "end_token": 4322,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      588,
      3001,
      62,
      49,
      27746,
      290,
      3122,
      62,
      49,
      27746,
      460,
      307,
      973,
      284,
      5911,
      7313,
      6246,
      1661,
      13
    ],
    "label": "ml_signal",
    "reason": "Constants like AM_RANGE and PM_RANGE can be used to identify trading session times."
  },
  {
    "line": 550,
    "text": "                df[col] = df[col] / (new_latest_data[col] / old_latest_data[col])",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      4033,
      60,
      796,
      47764,
      58,
      4033,
      60,
      1220,
      357,
      3605,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      60,
      1220,
      1468,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      12962
    ],
    "start_token": 4322,
    "end_token": 4365,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 552,
    "text": "                df[col] = df[col] * (old_latest_data[col] / new_latest_data[col])",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining and function calls can indicate common usage patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      4033,
      60,
      796,
      47764,
      58,
      4033,
      60,
      1635,
      357,
      727,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      60,
      1220,
      649,
      62,
      42861,
      62,
      7890,
      58,
      4033,
      12962
    ],
    "start_token": 4365,
    "end_token": 4408,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      290,
      2163,
      3848,
      460,
      7603,
      2219,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method chaining and function calls can indicate common usage patterns"
  },
  {
    "line": 553,
    "text": "        return df.drop(df.index[0]).reset_index()",
    "annotation": "\ud83e\udde0 ML Signal: Checks if a string contains a specific character",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764,
      13,
      14781,
      7,
      7568,
      13,
      9630,
      58,
      15,
      35944,
      42503,
      62,
      9630,
      3419
    ],
    "start_token": 4408,
    "end_token": 4430,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      611,
      257,
      4731,
      4909,
      257,
      2176,
      2095
    ],
    "label": "ml_signal",
    "reason": "Checks if a string contains a specific character"
  },
  {
    "line": 555,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Extracts a substring from a string",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 4430,
    "end_token": 4430,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      82,
      257,
      3293,
      1806,
      422,
      257,
      4731
    ],
    "label": "ml_signal",
    "reason": "Extracts a substring from a string"
  },
  {
    "line": 557,
    "text": "    \"\"\"Normalised to 1min using local 1d data\"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Conditional assignment based on string properties",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227,
      26447,
      1417,
      284,
      352,
      1084,
      1262,
      1957,
      352,
      67,
      1366,
      37811
    ],
    "start_token": 4430,
    "end_token": 4445,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      16237,
      1912,
      319,
      4731,
      6608
    ],
    "label": "ml_signal",
    "reason": "Conditional assignment based on string properties"
  },
  {
    "line": 559,
    "text": "    AM_RANGE = None  # type: tuple  # eg: (\"09:30:00\", \"11:29:00\")",
    "annotation": "\ud83e\udde0 ML Signal: String concatenation and slicing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3001,
      62,
      49,
      27746,
      796,
      6045,
      220,
      1303,
      2099,
      25,
      46545,
      220,
      1303,
      29206,
      25,
      5855,
      2931,
      25,
      1270,
      25,
      405,
      1600,
      366,
      1157,
      25,
      1959,
      25,
      405,
      4943
    ],
    "start_token": 4445,
    "end_token": 4477,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      10903,
      1673,
      36686,
      341,
      290,
      49289
    ],
    "label": "ml_signal",
    "reason": "String concatenation and slicing"
  },
  {
    "line": 561,
    "text": "",
    "annotation": "\u2705 Best Practice: Returns a value from a function",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 4477,
    "end_token": 4477,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      16409,
      257,
      1988,
      422,
      257,
      2163
    ],
    "label": "best_practice",
    "reason": "Returns a value from a function"
  },
  {
    "line": 558,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 4477,
    "end_token": 4477,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 560,
    "text": "    PM_RANGE = None  # type: tuple  # eg: (\"13:00:00\", \"14:59:00\")",
    "annotation": "\ud83e\udde0 ML Signal: Function calls with string literals can indicate feature usage patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      3122,
      62,
      49,
      27746,
      796,
      6045,
      220,
      1303,
      2099,
      25,
      46545,
      220,
      1303,
      29206,
      25,
      5855,
      1485,
      25,
      405,
      25,
      405,
      1600,
      366,
      1415,
      25,
      3270,
      25,
      405,
      4943
    ],
    "start_token": 4477,
    "end_token": 4509,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      351,
      4731,
      4187,
      874,
      460,
      7603,
      3895,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function calls with string literals can indicate feature usage patterns"
  },
  {
    "line": 561,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method definition with a specific return type hint",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 4509,
    "end_token": 4509,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      6770,
      351,
      257,
      2176,
      1441,
      2099,
      9254
    ],
    "label": "ml_signal",
    "reason": "Method definition with a specific return type hint"
  },
  {
    "line": 563,
    "text": "    CONSISTENT_1d = True",
    "annotation": "\ud83e\udde0 ML Signal: Function call with a hardcoded string argument",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      39537,
      8808,
      3525,
      62,
      16,
      67,
      796,
      6407
    ],
    "start_token": 4509,
    "end_token": 4520,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      257,
      1327,
      40976,
      4731,
      4578
    ],
    "label": "ml_signal",
    "reason": "Function call with a hardcoded string argument"
  },
  {
    "line": 563,
    "text": "    CONSISTENT_1d = True",
    "annotation": "\u2705 Best Practice: Use of multiple inheritance to combine functionality from YahooNormalizeBR and YahooNormalize1d",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      39537,
      8808,
      3525,
      62,
      16,
      67,
      796,
      6407
    ],
    "start_token": 4520,
    "end_token": 4531,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3294,
      24155,
      284,
      12082,
      11244,
      422,
      16551,
      26447,
      1096,
      11473,
      290,
      16551,
      26447,
      1096,
      16,
      67
    ],
    "label": "best_practice",
    "reason": "Use of multiple inheritance to combine functionality from YahooNormalizeBR and YahooNormalize1d"
  },
  {
    "line": 566,
    "text": "    def __init__(",
    "annotation": "\u2705 Best Practice: Class attribute CALC_PAUSED_NUM is defined, indicating a shared state or configuration for instances.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 4531,
    "end_token": 4539,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      11688,
      33290,
      34,
      62,
      4537,
      2937,
      1961,
      62,
      41359,
      318,
      5447,
      11,
      12739,
      257,
      4888,
      1181,
      393,
      8398,
      329,
      10245,
      13
    ],
    "label": "best_practice",
    "reason": "Class attribute CALC_PAUSED_NUM is defined, indicating a shared state or configuration for instances."
  },
  {
    "line": 567,
    "text": "        self, qlib_data_1d_dir: [str, Path], date_field_name: str = \"date\", symbol_field_name: str = \"symbol\", **kwargs",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the method's purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      1837,
      23650,
      1600,
      12429,
      46265,
      22046
    ],
    "start_token": 4539,
    "end_token": 4589,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the method's purpose and parameters"
  },
  {
    "line": 569,
    "text": "        \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without context may make debugging difficult",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 4589,
    "end_token": 4597,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      4732,
      743,
      787,
      28769,
      2408
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without context may make debugging difficult"
  },
  {
    "line": 569,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a private method, indicating encapsulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 4597,
    "end_token": 4605,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      2839,
      2446,
      11,
      12739,
      32652,
      1741
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a private method, indicating encapsulation"
  },
  {
    "line": 571,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Calls an external function, indicating a dependency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 4605,
    "end_token": 4613,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27592,
      281,
      7097,
      2163,
      11,
      12739,
      257,
      20203
    ],
    "label": "ml_signal",
    "reason": "Calls an external function, indicating a dependency"
  },
  {
    "line": 571,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 4613,
    "end_token": 4621,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 573,
    "text": "        qlib_data_1d_dir: str, Path",
    "annotation": "\ud83e\udde0 ML Signal: Function calls with specific naming patterns can indicate domain-specific operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      965,
      11,
      10644
    ],
    "start_token": 4621,
    "end_token": 4641,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      351,
      2176,
      19264,
      7572,
      460,
      7603,
      7386,
      12,
      11423,
      4560
    ],
    "label": "ml_signal",
    "reason": "Function calls with specific naming patterns can indicate domain-specific operations"
  },
  {
    "line": 573,
    "text": "        qlib_data_1d_dir: str, Path",
    "annotation": "\u2705 Best Practice: Inheriting from a base class promotes code reuse and organization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      965,
      11,
      10644
    ],
    "start_token": 4641,
    "end_token": 4661,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      257,
      2779,
      1398,
      21068,
      2438,
      32349,
      290,
      4009
    ],
    "label": "best_practice",
    "reason": "Inheriting from a base class promotes code reuse and organization"
  },
  {
    "line": 575,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 4661,
    "end_token": 4675,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 575,
    "text": "        date_field_name: str",
    "annotation": "\ud83e\udde0 ML Signal: Constructor parameters can indicate configuration patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 4675,
    "end_token": 4689,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28407,
      273,
      10007,
      460,
      7603,
      8398,
      7572
    ],
    "label": "ml_signal",
    "reason": "Constructor parameters can indicate configuration patterns"
  },
  {
    "line": 592,
    "text": "            setattr(self, \"_calendar_list_1d\", calendar_list_1d)",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass constructor for proper initialization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      900,
      35226,
      7,
      944,
      11,
      45434,
      9948,
      9239,
      62,
      4868,
      62,
      16,
      67,
      1600,
      11845,
      62,
      4868,
      62,
      16,
      67,
      8
    ],
    "start_token": 4689,
    "end_token": 4721,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      23772,
      329,
      1774,
      37588
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass constructor for proper initialization"
  },
  {
    "line": 593,
    "text": "        return calendar_list_1d",
    "annotation": "\ud83e\udde0 ML Signal: Storing configuration values in instance variables",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      11845,
      62,
      4868,
      62,
      16,
      67
    ],
    "start_token": 4721,
    "end_token": 4735,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      8398,
      3815,
      287,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Storing configuration values in instance variables"
  },
  {
    "line": 593,
    "text": "        return calendar_list_1d",
    "annotation": "\ud83e\udde0 ML Signal: Method constructs a class name dynamically based on region and interval.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      11845,
      62,
      4868,
      62,
      16,
      67
    ],
    "start_token": 4735,
    "end_token": 4749,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      34175,
      257,
      1398,
      1438,
      32366,
      1912,
      319,
      3814,
      290,
      16654,
      13
    ],
    "label": "ml_signal",
    "reason": "Method constructs a class name dynamically based on region and interval."
  },
  {
    "line": 596,
    "text": "        return generate_minutes_calendar_from_daily(",
    "annotation": "\u2705 Best Practice: Use of @property decorator for defining a read-only attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      7716,
      62,
      1084,
      1769,
      62,
      9948,
      9239,
      62,
      6738,
      62,
      29468,
      7
    ],
    "start_token": 4749,
    "end_token": 4769,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      16215,
      257,
      1100,
      12,
      8807,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for defining a read-only attribute."
  },
  {
    "line": 595,
    "text": "    def generate_1min_from_daily(self, calendars: Iterable) -> pd.Index:",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its action",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      7716,
      62,
      16,
      1084,
      62,
      6738,
      62,
      29468,
      7,
      944,
      11,
      50215,
      25,
      40806,
      540,
      8,
      4613,
      279,
      67,
      13,
      15732,
      25
    ],
    "start_token": 4769,
    "end_token": 4795,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      2223
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its action"
  },
  {
    "line": 596,
    "text": "        return generate_minutes_calendar_from_daily(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of f-string for string formatting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      7716,
      62,
      1084,
      1769,
      62,
      9948,
      9239,
      62,
      6738,
      62,
      29468,
      7
    ],
    "start_token": 4795,
    "end_token": 4815,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "ml_signal",
    "reason": "Usage of f-string for string formatting"
  },
  {
    "line": 598,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Specify the return type as a Union of Path and str for clarity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 4815,
    "end_token": 4823,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      1958,
      262,
      1441,
      2099,
      355,
      257,
      4479,
      286,
      10644,
      290,
      965,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Specify the return type as a Union of Path and str for clarity."
  },
  {
    "line": 600,
    "text": "    def adjusted_price(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning a global variable directly can lead to unintended side effects if the variable is mutable.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      12328,
      62,
      20888,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 4823,
    "end_token": 4848,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      257,
      3298,
      7885,
      3264,
      460,
      1085,
      284,
      30261,
      1735,
      3048,
      611,
      262,
      7885,
      318,
      4517,
      540,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning a global variable directly can lead to unintended side effects if the variable is mutable."
  },
  {
    "line": 635,
    "text": "class YahooNormalizeUS1min(YahooNormalizeUS, YahooNormalize1min):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone issues with datetime.now() if not handled properly",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      26447,
      1096,
      2937,
      16,
      1084,
      7,
      56,
      12992,
      26447,
      1096,
      2937,
      11,
      16551,
      26447,
      1096,
      16,
      1084,
      2599
    ],
    "start_token": 4848,
    "end_token": 4868,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      2428,
      351,
      4818,
      8079,
      13,
      2197,
      3419,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone issues with datetime.now() if not handled properly"
  },
  {
    "line": 637,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message may expose sensitive information if not handled properly",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 4868,
    "end_token": 4868,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      743,
      15651,
      8564,
      1321,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message may expose sensitive information if not handled properly"
  },
  {
    "line": 638,
    "text": "    def _get_calendar_list(self) -> Iterable[pd.Timestamp]:",
    "annotation": "\u2705 Best Practice: Use of super() to call a method from the parent class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      9948,
      9239,
      62,
      4868,
      7,
      944,
      8,
      4613,
      40806,
      540,
      58,
      30094,
      13,
      14967,
      27823,
      5974
    ],
    "start_token": 4868,
    "end_token": 4891,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      257,
      2446,
      422,
      262,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of super() to call a method from the parent class"
  },
  {
    "line": 667,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential NoneType dereference if qlib_data_1d_dir is None",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 4891,
    "end_token": 4891,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      6045,
      6030,
      390,
      35790,
      611,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      318,
      6045
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential NoneType dereference if qlib_data_1d_dir is None"
  },
  {
    "line": 668,
    "text": "    def symbol_to_yahoo(self, symbol):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message could expose internal logic or paths",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      6194,
      62,
      1462,
      62,
      40774,
      7,
      944,
      11,
      6194,
      2599
    ],
    "start_token": 4891,
    "end_token": 4905,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      714,
      15651,
      5387,
      9156,
      393,
      13532
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message could expose internal logic or paths"
  },
  {
    "line": 674,
    "text": "        # TODO: from MSN",
    "annotation": "\u2705 Best Practice: Use of super() to call parent class method ensures maintainability and proper inheritance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      422,
      6579,
      45
    ],
    "start_token": 4905,
    "end_token": 4919,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      2560,
      1398,
      2446,
      19047,
      5529,
      1799,
      290,
      1774,
      24155
    ],
    "label": "best_practice",
    "reason": "Use of super() to call parent class method ensures maintainability and proper inheritance"
  },
  {
    "line": 677,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides detailed information about the function's purpose, parameters, and usage.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 4919,
    "end_token": 4919,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      6496,
      1321,
      546,
      262,
      2163,
      338,
      4007,
      11,
      10007,
      11,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides detailed information about the function's purpose, parameters, and usage."
  },
  {
    "line": 699,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic attribute access using getattr, indicating potential use of reflection or dynamic class loading.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 4919,
    "end_token": 4919,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      11688,
      1895,
      1262,
      651,
      35226,
      11,
      12739,
      2785,
      779,
      286,
      14580,
      393,
      8925,
      1398,
      11046,
      13
    ],
    "label": "ml_signal",
    "reason": "Dynamic attribute access using getattr, indicating potential use of reflection or dynamic class loading."
  },
  {
    "line": 699,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Instantiation of a class with multiple parameters, indicating a complex object creation pattern.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 4919,
    "end_token": 4919,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24470,
      3920,
      286,
      257,
      1398,
      351,
      3294,
      10007,
      11,
      12739,
      257,
      3716,
      2134,
      6282,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Instantiation of a class with multiple parameters, indicating a complex object creation pattern."
  },
  {
    "line": 709,
    "text": "class YahooNormalizeBR1d(YahooNormalizeBR, YahooNormalize1d):",
    "annotation": "\ud83e\udde0 ML Signal: Method call on an object, indicating a potential action or process being executed.",
    "confidence": 1.0,
    "tokens": [
      4871,
      16551,
      26447,
      1096,
      11473,
      16,
      67,
      7,
      56,
      12992,
      26447,
      1096,
      11473,
      11,
      16551,
      26447,
      1096,
      16,
      67,
      2599
    ],
    "start_token": 4919,
    "end_token": 4939,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      319,
      281,
      2134,
      11,
      12739,
      257,
      2785,
      2223,
      393,
      1429,
      852,
      10945,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call on an object, indicating a potential action or process being executed."
  },
  {
    "line": 741,
    "text": "        region: str",
    "annotation": "\u2705 Best Practice: Use of datetime and pd.Timestamp for date manipulation is clear and effective.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3814,
      25,
      965
    ],
    "start_token": 4939,
    "end_token": 4949,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4818,
      8079,
      290,
      279,
      67,
      13,
      14967,
      27823,
      329,
      3128,
      17512,
      318,
      1598,
      290,
      4050,
      13
    ],
    "label": "best_practice",
    "reason": "Use of datetime and pd.Timestamp for date manipulation is clear and effective."
  },
  {
    "line": 743,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of pd.Timedelta for date arithmetic is clear and effective.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 4949,
    "end_token": 4957,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      14967,
      276,
      12514,
      329,
      3128,
      34768,
      318,
      1598,
      290,
      4050,
      13
    ],
    "label": "best_practice",
    "reason": "Use of pd.Timedelta for date arithmetic is clear and effective."
  },
  {
    "line": 743,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Method call with parameters could indicate a pattern for data downloading.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 4957,
    "end_token": 4965,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      10007,
      714,
      7603,
      257,
      3912,
      329,
      1366,
      22023,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call with parameters could indicate a pattern for data downloading."
  },
  {
    "line": 751,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Date formatting pattern could be useful for ML models to understand date handling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 4965,
    "end_token": 4970,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7536,
      33313,
      3912,
      714,
      307,
      4465,
      329,
      10373,
      4981,
      284,
      1833,
      3128,
      9041,
      13
    ],
    "label": "ml_signal",
    "reason": "Date formatting pattern could be useful for ML models to understand date handling."
  },
  {
    "line": 779,
    "text": "            end datetime, default ``pd.Timestamp(datetime.datetime.now() + pd.Timedelta(days=1))``; open interval(excluding end)",
    "annotation": "\u2705 Best Practice: Use of logging for warnings instead of print statements",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      4818,
      8079,
      11,
      4277,
      7559,
      30094,
      13,
      14967,
      27823,
      7,
      19608,
      8079,
      13,
      19608,
      8079,
      13,
      2197,
      3419,
      1343,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      12545,
      28,
      16,
      4008,
      15506,
      26,
      1280,
      16654,
      7,
      42218,
      886,
      8
    ],
    "start_token": 4970,
    "end_token": 5020,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      329,
      14601,
      2427,
      286,
      3601,
      6299
    ],
    "label": "best_practice",
    "reason": "Use of logging for warnings instead of print statements"
  },
  {
    "line": 782,
    "text": "        limit_nums: int",
    "annotation": "\u2705 Best Practice: Use of Path to handle file paths",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4179,
      62,
      77,
      5700,
      25,
      493
    ],
    "start_token": 5020,
    "end_token": 5033,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10644,
      284,
      5412,
      2393,
      13532
    ],
    "label": "best_practice",
    "reason": "Use of Path to handle file paths"
  },
  {
    "line": 783,
    "text": "            using for debug, by default None",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential directory traversal if qlib_data_1d_dir is user-controlled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1262,
      329,
      14257,
      11,
      416,
      4277,
      6045
    ],
    "start_token": 5033,
    "end_token": 5051,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      8619,
      33038,
      282,
      611,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      318,
      2836,
      12,
      14401
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential directory traversal if qlib_data_1d_dir is user-controlled"
  },
  {
    "line": 786,
    "text": "        -----",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking existence before fetching data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37404
    ],
    "start_token": 5051,
    "end_token": 5059,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      6224,
      878,
      21207,
      278,
      1366
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking existence before fetching data"
  },
  {
    "line": 790,
    "text": "                cn 1min, a week: 4 * 60 * 5",
    "annotation": "\u2705 Best Practice: Use of Path to handle file paths",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      269,
      77,
      352,
      1084,
      11,
      257,
      1285,
      25,
      604,
      1635,
      3126,
      1635,
      642
    ],
    "start_token": 5059,
    "end_token": 5087,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10644,
      284,
      5412,
      2393,
      13532
    ],
    "label": "best_practice",
    "reason": "Use of Path to handle file paths"
  },
  {
    "line": 791,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of calculating previous trading day",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 5087,
    "end_token": 5087,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      26019,
      2180,
      7313,
      1110
    ],
    "label": "ml_signal",
    "reason": "Pattern of calculating previous trading day"
  },
  {
    "line": 796,
    "text": "            # get 1m data",
    "annotation": "\ud83e\udde0 ML Signal: Default end_date calculation based on trading_date",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      651,
      352,
      76,
      1366
    ],
    "start_token": 5087,
    "end_token": 5103,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15161,
      886,
      62,
      4475,
      17952,
      1912,
      319,
      7313,
      62,
      4475
    ],
    "label": "ml_signal",
    "reason": "Default end_date calculation based on trading_date"
  },
  {
    "line": 797,
    "text": "            $ python collector.py download_data --source_dir ~/.qlib/stock_data/source --region CN --start 2020-11-01 --end 2020-11-10 --delay 0.1 --interval 1m",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of downloading data with delay and date range",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      720,
      21015,
      22967,
      13,
      9078,
      4321,
      62,
      7890,
      1377,
      10459,
      62,
      15908,
      39763,
      80,
      8019,
      14,
      13578,
      62,
      7890,
      14,
      10459,
      1377,
      36996,
      31171,
      1377,
      9688,
      12131,
      12,
      1157,
      12,
      486,
      1377,
      437,
      12131,
      12,
      1157,
      12,
      940,
      1377,
      40850,
      657,
      13,
      16,
      1377,
      3849,
      2100,
      352,
      76
    ],
    "start_token": 5103,
    "end_token": 5162,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      22023,
      1366,
      351,
      5711,
      290,
      3128,
      2837
    ],
    "label": "ml_signal",
    "reason": "Pattern of downloading data with delay and date range"
  },
  {
    "line": 797,
    "text": "            $ python collector.py download_data --source_dir ~/.qlib/stock_data/source --region CN --start 2020-11-01 --end 2020-11-10 --delay 0.1 --interval 1m",
    "annotation": "\u2705 Best Practice: Dynamic calculation of max_workers based on CPU count",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      720,
      21015,
      22967,
      13,
      9078,
      4321,
      62,
      7890,
      1377,
      10459,
      62,
      15908,
      39763,
      80,
      8019,
      14,
      13578,
      62,
      7890,
      14,
      10459,
      1377,
      36996,
      31171,
      1377,
      9688,
      12131,
      12,
      1157,
      12,
      486,
      1377,
      437,
      12131,
      12,
      1157,
      12,
      940,
      1377,
      40850,
      657,
      13,
      16,
      1377,
      3849,
      2100,
      352,
      76
    ],
    "start_token": 5162,
    "end_token": 5221,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      26977,
      17952,
      286,
      3509,
      62,
      22896,
      1912,
      319,
      9135,
      954
    ],
    "label": "best_practice",
    "reason": "Dynamic calculation of max_workers based on CPU count"
  },
  {
    "line": 806,
    "text": "        date_field_name: str = \"date\",",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600
    ],
    "start_token": 5221,
    "end_token": 5239,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names"
  },
  {
    "line": 814,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of handling different regions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 5239,
    "end_token": 5248,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      9041,
      1180,
      7652
    ],
    "label": "ml_signal",
    "reason": "Pattern of handling different regions"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Use of logging for warnings instead of print statements",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5248,
    "end_token": 5262,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      329,
      14601,
      2427,
      286,
      3601,
      6299
    ],
    "label": "best_practice",
    "reason": "Use of logging for warnings instead of print statements"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of selecting index list based on region",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5262,
    "end_token": 5276,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      17246,
      6376,
      1351,
      1912,
      319,
      3814
    ],
    "label": "ml_signal",
    "reason": "Pattern of selecting index list based on region"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Dynamic import using importlib",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5276,
    "end_token": 5290,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      26977,
      1330,
      1262,
      1330,
      8019
    ],
    "label": "best_practice",
    "reason": "Dynamic import using importlib"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of fetching instruments for each index",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5290,
    "end_token": 5304,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      21207,
      278,
      12834,
      329,
      1123,
      6376
    ],
    "label": "ml_signal",
    "reason": "Pattern of fetching instruments for each index"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Use of __name__ guard for script execution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5304,
    "end_token": 5318,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      3672,
      834,
      4860,
      329,
      4226,
      9706
    ],
    "label": "best_practice",
    "reason": "Use of __name__ guard for script execution"
  },
  {
    "line": 815,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Use of fire for command-line interface",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 5318,
    "end_token": 5332,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2046,
      329,
      3141,
      12,
      1370,
      7071
    ],
    "label": "best_practice",
    "reason": "Use of fire for command-line interface"
  }
]