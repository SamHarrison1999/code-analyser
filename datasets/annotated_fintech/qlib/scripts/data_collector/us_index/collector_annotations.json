[
  {
    "line": 13,
    "text": "import pandas as pd",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying sys.path can lead to import conflicts or security issues if not handled carefully.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 0,
    "end_token": 6,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      25064,
      13,
      6978,
      460,
      1085,
      284,
      1330,
      12333,
      393,
      2324,
      2428,
      611,
      407,
      12118,
      7773,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying sys.path can lead to import conflicts or security issues if not handled carefully."
  },
  {
    "line": 18,
    "text": "CUR_DIR = Path(__file__).resolve().parent",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Hardcoded URLs can lead to security risks if the URL changes or is compromised.",
    "confidence": 0.5,
    "tokens": [
      34,
      4261,
      62,
      34720,
      796,
      10644,
      7,
      834,
      7753,
      834,
      737,
      411,
      6442,
      22446,
      8000
    ],
    "start_token": 6,
    "end_token": 21,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6912,
      40976,
      32336,
      460,
      1085,
      284,
      2324,
      7476,
      611,
      262,
      10289,
      2458,
      393,
      318,
      19066,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Hardcoded URLs can lead to security risks if the URL changes or is compromised."
  },
  {
    "line": 18,
    "text": "CUR_DIR = Path(__file__).resolve().parent",
    "annotation": "\ud83e\udde0 ML Signal: Dictionary mapping for index names to URLs, useful for pattern recognition in ML models.",
    "confidence": 0.5,
    "tokens": [
      34,
      4261,
      62,
      34720,
      796,
      10644,
      7,
      834,
      7753,
      834,
      737,
      411,
      6442,
      22446,
      8000
    ],
    "start_token": 21,
    "end_token": 36,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28261,
      16855,
      329,
      6376,
      3891,
      284,
      32336,
      11,
      4465,
      329,
      3912,
      9465,
      287,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Dictionary mapping for index names to URLs, useful for pattern recognition in ML models."
  },
  {
    "line": 24,
    "text": "",
    "annotation": "\u2705 Best Practice: Class names should follow the CapWords convention for readability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 36,
    "end_token": 36,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      3891,
      815,
      1061,
      262,
      4476,
      37117,
      9831,
      329,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class names should follow the CapWords convention for readability."
  },
  {
    "line": 26,
    "text": "WIKI_URL = \"https://en.wikipedia.org/wiki\"",
    "annotation": "\u2705 Best Practice: Class variables should be documented or initialized with meaningful default values.",
    "confidence": 1.0,
    "tokens": [
      54,
      18694,
      40,
      62,
      21886,
      796,
      366,
      5450,
      1378,
      268,
      13,
      31266,
      13,
      2398,
      14,
      15466,
      1
    ],
    "start_token": 36,
    "end_token": 53,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      9633,
      815,
      307,
      12395,
      393,
      23224,
      351,
      11570,
      4277,
      3815,
      13
    ],
    "label": "best_practice",
    "reason": "Class variables should be documented or initialized with meaningful default values."
  },
  {
    "line": 34,
    "text": "",
    "annotation": "\u2705 Best Practice: Call to super() ensures proper initialization of the base class",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 53,
    "end_token": 53,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      3419,
      19047,
      1774,
      37588,
      286,
      262,
      2779,
      1398
    ],
    "label": "best_practice",
    "reason": "Call to super() ensures proper initialization of the base class"
  },
  {
    "line": 37,
    "text": "    # NOTE: The US stock code contains \"PRN\", and the directory cannot be created on Windows system, use the \"_\" prefix",
    "annotation": "\ud83e\udde0 ML Signal: Use of f-string for URL construction",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      24550,
      25,
      383,
      1294,
      4283,
      2438,
      4909,
      366,
      4805,
      45,
      1600,
      290,
      262,
      8619,
      2314,
      307,
      2727,
      319,
      3964,
      1080,
      11,
      779,
      262,
      45434,
      1,
      21231
    ],
    "start_token": 53,
    "end_token": 83,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      10289,
      5103
    ],
    "label": "ml_signal",
    "reason": "Use of f-string for URL construction"
  },
  {
    "line": 41,
    "text": "    def __init__(",
    "annotation": "\u2705 Best Practice: Use of @property decorator for defining a read-only attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 83,
    "end_token": 91,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      16215,
      257,
      1100,
      12,
      8807,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for defining a read-only attribute"
  },
  {
    "line": 41,
    "text": "    def __init__(",
    "annotation": "\u2705 Best Practice: Include type hints for return values to improve code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 91,
    "end_token": 99,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      1441,
      3815,
      284,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for return values to improve code readability and maintainability"
  },
  {
    "line": 48,
    "text": "    ):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if not properly handled",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 99,
    "end_token": 103,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      6105,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if not properly handled"
  },
  {
    "line": 49,
    "text": "        super(WIKIIndex, self).__init__(",
    "annotation": "\u2705 Best Practice: Use of @abc.abstractmethod to enforce implementation in subclasses",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      54,
      18694,
      3978,
      358,
      1069,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7
    ],
    "start_token": 103,
    "end_token": 124,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      39305,
      13,
      397,
      8709,
      24396,
      284,
      4605,
      7822,
      287,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Use of @abc.abstractmethod to enforce implementation in subclasses"
  },
  {
    "line": 49,
    "text": "        super(WIKIIndex, self).__init__(",
    "annotation": "\u2705 Best Practice: Docstring provides a clear description of the method's purpose and return type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      54,
      18694,
      3978,
      358,
      1069,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7
    ],
    "start_token": 124,
    "end_token": 145,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      2446,
      338,
      4007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear description of the method's purpose and return type"
  },
  {
    "line": 62,
    "text": "        \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method is not implemented, which could lead to runtime errors if called",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 145,
    "end_token": 153,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      318,
      407,
      9177,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      1444
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method is not implemented, which could lead to runtime errors if called"
  },
  {
    "line": 71,
    "text": "            pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Check if 'self.freq' is defined and used correctly",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 153,
    "end_token": 170,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      944,
      13,
      19503,
      80,
      6,
      318,
      5447,
      290,
      973,
      9380
    ],
    "label": "best_practice",
    "reason": "Check if 'self.freq' is defined and used correctly"
  },
  {
    "line": 72,
    "text": "                symbol      date        type",
    "annotation": "\u2705 Best Practice: Use of lambda for concise function definition",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      220,
      220,
      220,
      220,
      220,
      3128,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2099
    ],
    "start_token": 170,
    "end_token": 200,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      37456,
      329,
      35327,
      2163,
      6770
    ],
    "label": "best_practice",
    "reason": "Use of lambda for concise function definition"
  },
  {
    "line": 75,
    "text": "            dtypes:",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas apply with lambda for DataFrame column transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      19199,
      25
    ],
    "start_token": 200,
    "end_token": 214,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      4174,
      351,
      37456,
      329,
      6060,
      19778,
      5721,
      13389
    ],
    "label": "ml_signal",
    "reason": "Use of pandas apply with lambda for DataFrame column transformation"
  },
  {
    "line": 83,
    "text": "        \"\"\"formatting the datetime in an instrument",
    "annotation": "\u2705 Best Practice: Use of getattr to check for attribute existence is a good practice for optional caching",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      18982,
      889,
      262,
      4818,
      8079,
      287,
      281,
      8875
    ],
    "start_token": 214,
    "end_token": 230,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      35226,
      284,
      2198,
      329,
      11688,
      6224,
      318,
      257,
      922,
      3357,
      329,
      11902,
      40918
    ],
    "label": "best_practice",
    "reason": "Use of getattr to check for attribute existence is a good practice for optional caching"
  },
  {
    "line": 86,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda function for filtering",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 230,
    "end_token": 239,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      2163,
      329,
      25431
    ],
    "label": "ml_signal",
    "reason": "Use of lambda function for filtering"
  },
  {
    "line": 88,
    "text": "            inst_df.columns = [self.SYMBOL_FIELD_NAME, self.START_DATE_FIELD, self.END_DATE_FIELD]",
    "annotation": "\u2705 Best Practice: Use of setattr to cache the result for future calls",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      916,
      62,
      7568,
      13,
      28665,
      82,
      796,
      685,
      944,
      13,
      23060,
      10744,
      3535,
      62,
      44603,
      62,
      20608,
      11,
      2116,
      13,
      2257,
      7227,
      62,
      35,
      6158,
      62,
      44603,
      11,
      2116,
      13,
      10619,
      62,
      35,
      6158,
      62,
      44603,
      60
    ],
    "start_token": 239,
    "end_token": 287,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      900,
      35226,
      284,
      12940,
      262,
      1255,
      329,
      2003,
      3848
    ],
    "label": "best_practice",
    "reason": "Use of setattr to cache the result for future calls"
  },
  {
    "line": 88,
    "text": "            inst_df.columns = [self.SYMBOL_FIELD_NAME, self.START_DATE_FIELD, self.END_DATE_FIELD]",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the method's purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      916,
      62,
      7568,
      13,
      28665,
      82,
      796,
      685,
      944,
      13,
      23060,
      10744,
      3535,
      62,
      44603,
      62,
      20608,
      11,
      2116,
      13,
      2257,
      7227,
      62,
      35,
      6158,
      62,
      44603,
      11,
      2116,
      13,
      10619,
      62,
      35,
      6158,
      62,
      44603,
      60
    ],
    "start_token": 287,
    "end_token": 335,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the method's purpose and parameters"
  },
  {
    "line": 90,
    "text": "        Returns",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Using 'timeout=None' can lead to hanging requests; consider setting a timeout value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16409
    ],
    "start_token": 335,
    "end_token": 343,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8554,
      705,
      48678,
      28,
      14202,
      6,
      460,
      1085,
      284,
      10938,
      7007,
      26,
      2074,
      4634,
      257,
      26827,
      1988
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Using 'timeout=None' can lead to hanging requests; consider setting a timeout value"
  },
  {
    "line": 92,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Checking for HTTP status code to handle errors",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 343,
    "end_token": 343,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      329,
      14626,
      3722,
      2438,
      284,
      5412,
      8563
    ],
    "label": "ml_signal",
    "reason": "Checking for HTTP status code to handle errors"
  },
  {
    "line": 94,
    "text": "        if self.freq != \"day\":",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic exception without logging the error details",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      19503,
      80,
      14512,
      366,
      820,
      1298
    ],
    "start_token": 343,
    "end_token": 359,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      6631,
      1231,
      18931,
      262,
      4049,
      3307
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic exception without logging the error details"
  },
  {
    "line": 96,
    "text": "                lambda x: (pd.Timestamp(x) + pd.Timedelta(hours=23, minutes=59)).strftime(\"%Y-%m-%d %H:%M:%S\")",
    "annotation": "\ud83e\udde0 ML Signal: Returning the response object from an HTTP request",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37456,
      2124,
      25,
      357,
      30094,
      13,
      14967,
      27823,
      7,
      87,
      8,
      1343,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      24425,
      28,
      1954,
      11,
      2431,
      28,
      3270,
      29720,
      2536,
      31387,
      7203,
      4,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      4064,
      39,
      25,
      4,
      44,
      25,
      4,
      50,
      4943
    ],
    "start_token": 359,
    "end_token": 421,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      262,
      2882,
      2134,
      422,
      281,
      14626,
      2581
    ],
    "label": "ml_signal",
    "reason": "Returning the response object from an HTTP request"
  },
  {
    "line": 94,
    "text": "        if self.freq != \"day\":",
    "annotation": "\u2705 Best Practice: Use of .copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      19503,
      80,
      14512,
      366,
      820,
      1298
    ],
    "start_token": 421,
    "end_token": 437,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use of .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 96,
    "text": "                lambda x: (pd.Timestamp(x) + pd.Timedelta(hours=23, minutes=59)).strftime(\"%Y-%m-%d %H:%M:%S\")",
    "annotation": "\ud83e\udde0 ML Signal: Stripping whitespace from string fields is a common data cleaning step",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37456,
      2124,
      25,
      357,
      30094,
      13,
      14967,
      27823,
      7,
      87,
      8,
      1343,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      24425,
      28,
      1954,
      11,
      2431,
      28,
      3270,
      29720,
      2536,
      31387,
      7203,
      4,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      4064,
      39,
      25,
      4,
      44,
      25,
      4,
      50,
      4943
    ],
    "start_token": 437,
    "end_token": 499,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26137,
      2105,
      13216,
      10223,
      422,
      4731,
      7032,
      318,
      257,
      2219,
      1366,
      12724,
      2239
    ],
    "label": "ml_signal",
    "reason": "Stripping whitespace from string fields is a common data cleaning step"
  },
  {
    "line": 98,
    "text": "        return inst_df",
    "annotation": "\ud83e\udde0 ML Signal: Setting default values for date fields is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      916,
      62,
      7568
    ],
    "start_token": 499,
    "end_token": 510,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      4277,
      3815,
      329,
      3128,
      7032,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Setting default values for date fields is a common pattern"
  },
  {
    "line": 100,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Setting default values for date fields is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 510,
    "end_token": 515,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      4277,
      3815,
      329,
      3128,
      7032,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Setting default values for date fields is a common pattern"
  },
  {
    "line": 102,
    "text": "        \"\"\"get history trading date",
    "annotation": "\u2705 Best Practice: Use of .loc for selecting specific columns improves readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      1136,
      2106,
      7313,
      3128
    ],
    "start_token": 515,
    "end_token": 527,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      764,
      17946,
      329,
      17246,
      2176,
      15180,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of .loc for selecting specific columns improves readability"
  },
  {
    "line": 100,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 527,
    "end_token": 532,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 102,
    "text": "        \"\"\"get history trading date",
    "annotation": "\ud83e\udde0 ML Signal: Usage of retry pattern for network requests",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      1136,
      2106,
      7313,
      3128
    ],
    "start_token": 532,
    "end_token": 544,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      1005,
      563,
      3912,
      329,
      3127,
      7007
    ],
    "label": "ml_signal",
    "reason": "Usage of retry pattern for network requests"
  },
  {
    "line": 104,
    "text": "        Returns",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large data processing in memory",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16409
    ],
    "start_token": 544,
    "end_token": 552,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      1366,
      7587,
      287,
      4088
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large data processing in memory"
  },
  {
    "line": 107,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Check for None and empty DataFrame before processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 552,
    "end_token": 560,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6045,
      290,
      6565,
      6060,
      19778,
      878,
      7587
    ],
    "label": "best_practice",
    "reason": "Check for None and empty DataFrame before processing"
  },
  {
    "line": 110,
    "text": "            _calendar_list = list(filter(lambda x: x >= self.bench_start_date, get_calendar_list(\"US_ALL\")))",
    "annotation": "\u2705 Best Practice: Consistent column naming for DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9948,
      9239,
      62,
      4868,
      796,
      1351,
      7,
      24455,
      7,
      50033,
      2124,
      25,
      2124,
      18189,
      2116,
      13,
      26968,
      62,
      9688,
      62,
      4475,
      11,
      651,
      62,
      9948,
      9239,
      62,
      4868,
      7203,
      2937,
      62,
      7036,
      1,
      22305
    ],
    "start_token": 560,
    "end_token": 606,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3515,
      7609,
      5721,
      19264,
      329,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Consistent column naming for DataFrame"
  },
  {
    "line": 112,
    "text": "        return _calendar_list",
    "annotation": "\ud83e\udde0 ML Signal: Usage of default settings for data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      9948,
      9239,
      62,
      4868
    ],
    "start_token": 606,
    "end_token": 619,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4277,
      6460,
      329,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Usage of default settings for data processing"
  },
  {
    "line": 113,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 619,
    "end_token": 619,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 116,
    "text": "        if resp.status_code != 200:",
    "annotation": "\u2705 Best Practice: Return early to avoid unnecessary processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1217,
      13,
      13376,
      62,
      8189,
      14512,
      939,
      25
    ],
    "start_token": 619,
    "end_token": 635,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1903,
      284,
      3368,
      13114,
      7587
    ],
    "label": "best_practice",
    "reason": "Return early to avoid unnecessary processing"
  },
  {
    "line": 110,
    "text": "            _calendar_list = list(filter(lambda x: x >= self.bench_start_date, get_calendar_list(\"US_ALL\")))",
    "annotation": "\u2705 Best Practice: Method signature includes type hints for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9948,
      9239,
      62,
      4868,
      796,
      1351,
      7,
      24455,
      7,
      50033,
      2124,
      25,
      2124,
      18189,
      2116,
      13,
      26968,
      62,
      9688,
      62,
      4475,
      11,
      651,
      62,
      9948,
      9239,
      62,
      4868,
      7203,
      2937,
      62,
      7036,
      1,
      22305
    ],
    "start_token": 635,
    "end_token": 681,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      9877,
      3407,
      2099,
      20269,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Method signature includes type hints for better readability and maintainability"
  },
  {
    "line": 112,
    "text": "        return _calendar_list",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method raises NotImplementedError, which could lead to runtime errors if not properly implemented",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      9948,
      9239,
      62,
      4868
    ],
    "start_token": 681,
    "end_token": 694,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      6105,
      9177
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method raises NotImplementedError, which could lead to runtime errors if not properly implemented"
  },
  {
    "line": 112,
    "text": "        return _calendar_list",
    "annotation": "\u2705 Best Practice: Class definition should follow PEP 8 naming conventions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      9948,
      9239,
      62,
      4868
    ],
    "start_token": 694,
    "end_token": 707,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      350,
      8905,
      807,
      19264,
      21396
    ],
    "label": "best_practice",
    "reason": "Class definition should follow PEP 8 naming conventions"
  },
  {
    "line": 113,
    "text": "",
    "annotation": "\u2705 Best Practice: Constants should be in uppercase and follow naming conventions",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 707,
    "end_token": 707,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      287,
      334,
      39921,
      589,
      290,
      1061,
      19264,
      21396
    ],
    "label": "best_practice",
    "reason": "Constants should be in uppercase and follow naming conventions"
  },
  {
    "line": 118,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Hardcoded URL can lead to security risks if not validated or sanitized",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 707,
    "end_token": 707,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6912,
      40976,
      10289,
      460,
      1085,
      284,
      2324,
      7476,
      611,
      407,
      31031,
      393,
      5336,
      36951
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Hardcoded URL can lead to security risks if not validated or sanitized"
  },
  {
    "line": 119,
    "text": "        return resp",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a URL pattern for accessing external resources",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1217
    ],
    "start_token": 707,
    "end_token": 716,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      10289,
      3912,
      329,
      22534,
      7097,
      4133
    ],
    "label": "ml_signal",
    "reason": "Usage of a URL pattern for accessing external resources"
  },
  {
    "line": 121,
    "text": "    def set_default_date_range(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Constants should be in uppercase and follow naming conventions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      900,
      62,
      12286,
      62,
      4475,
      62,
      9521,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 716,
    "end_token": 745,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      287,
      334,
      39921,
      589,
      290,
      1061,
      19264,
      21396
    ],
    "label": "best_practice",
    "reason": "Constants should be in uppercase and follow naming conventions"
  },
  {
    "line": 122,
    "text": "        _df = df.copy()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a constant to define the number of workers for parallel processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      796,
      47764,
      13,
      30073,
      3419
    ],
    "start_token": 745,
    "end_token": 759,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      6937,
      284,
      8160,
      262,
      1271,
      286,
      3259,
      329,
      10730,
      7587
    ],
    "label": "ml_signal",
    "reason": "Usage of a constant to define the number of workers for parallel processing"
  },
  {
    "line": 118,
    "text": "",
    "annotation": "\u2705 Best Practice: Check for DataFrame length to ensure it has enough data to process",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 759,
    "end_token": 759,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6060,
      19778,
      4129,
      284,
      4155,
      340,
      468,
      1576,
      1366,
      284,
      1429
    ],
    "label": "best_practice",
    "reason": "Check for DataFrame length to ensure it has enough data to process"
  },
  {
    "line": 119,
    "text": "        return resp",
    "annotation": "\u2705 Best Practice: Use .copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1217
    ],
    "start_token": 759,
    "end_token": 768,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 122,
    "text": "        _df = df.copy()",
    "annotation": "\u2705 Best Practice: Use of pd.Timestamp for date handling ensures consistency and compatibility with pandas operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      796,
      47764,
      13,
      30073,
      3419
    ],
    "start_token": 768,
    "end_token": 782,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      14967,
      27823,
      329,
      3128,
      9041,
      19047,
      15794,
      290,
      17764,
      351,
      19798,
      292,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Use of pd.Timestamp for date handling ensures consistency and compatibility with pandas operations."
  },
  {
    "line": 125,
    "text": "        _df[self.END_DATE_FIELD] = self.DEFAULT_END_DATE",
    "annotation": "\u2705 Best Practice: Converting trade_date to a string format for consistent usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      58,
      944,
      13,
      10619,
      62,
      35,
      6158,
      62,
      44603,
      60,
      796,
      2116,
      13,
      7206,
      38865,
      62,
      10619,
      62,
      35,
      6158
    ],
    "start_token": 782,
    "end_token": 811,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      3292,
      62,
      4475,
      284,
      257,
      4731,
      5794,
      329,
      6414,
      8748
    ],
    "label": "best_practice",
    "reason": "Converting trade_date to a string format for consistent usage"
  },
  {
    "line": 127,
    "text": "",
    "annotation": "\u2705 Best Practice: Using pathlib for file path operations",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 811,
    "end_token": 811,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      3108,
      8019,
      329,
      2393,
      3108,
      4560
    ],
    "label": "best_practice",
    "reason": "Using pathlib for file path operations"
  },
  {
    "line": 128,
    "text": "    def get_new_companies(self):",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic for cache usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      3605,
      62,
      34390,
      444,
      7,
      944,
      2599
    ],
    "start_token": 811,
    "end_token": 824,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      329,
      12940,
      8748
    ],
    "label": "ml_signal",
    "reason": "Conditional logic for cache usage"
  },
  {
    "line": 131,
    "text": "        df_list = pd.read_html(_data.text)",
    "annotation": "\ud83e\udde0 ML Signal: Reading from cache",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      62,
      4868,
      796,
      279,
      67,
      13,
      961,
      62,
      6494,
      28264,
      7890,
      13,
      5239,
      8
    ],
    "start_token": 824,
    "end_token": 846,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      422,
      12940
    ],
    "label": "ml_signal",
    "reason": "Reading from cache"
  },
  {
    "line": 134,
    "text": "            if (_df is not None) and (not _df.empty):",
    "annotation": "\ud83e\udde0 ML Signal: Constructing URL for API request",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      44104,
      7568,
      318,
      407,
      6045,
      8,
      290,
      357,
      1662,
      4808,
      7568,
      13,
      28920,
      2599
    ],
    "start_token": 846,
    "end_token": 872,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28407,
      278,
      10289,
      329,
      7824,
      2581
    ],
    "label": "ml_signal",
    "reason": "Constructing URL for API request"
  },
  {
    "line": 136,
    "text": "                _df = self.set_default_date_range(_df)",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): No timeout specified for requests.post, which can lead to hanging connections",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      796,
      2116,
      13,
      2617,
      62,
      12286,
      62,
      4475,
      62,
      9521,
      28264,
      7568,
      8
    ],
    "start_token": 872,
    "end_token": 902,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      1400,
      26827,
      7368,
      329,
      7007,
      13,
      7353,
      11,
      543,
      460,
      1085,
      284,
      10938,
      8787
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "No timeout specified for requests.post, which can lead to hanging connections"
  },
  {
    "line": 138,
    "text": "                return _df",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Basic error handling for HTTP response",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      7568
    ],
    "start_token": 902,
    "end_token": 920,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      14392,
      4049,
      9041,
      329,
      14626,
      2882
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Basic error handling for HTTP response"
  },
  {
    "line": 141,
    "text": "        raise NotImplementedError(\"rewrite filter_df\")",
    "annotation": "\ud83e\udde0 ML Signal: Processing JSON response into DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7203,
      1809,
      6525,
      8106,
      62,
      7568,
      4943
    ],
    "start_token": 920,
    "end_token": 940,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28403,
      19449,
      2882,
      656,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Processing JSON response into DataFrame"
  },
  {
    "line": 143,
    "text": "",
    "annotation": "\u2705 Best Practice: Adding a new column to DataFrame",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 940,
    "end_token": 940,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18247,
      257,
      649,
      5721,
      284,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Adding a new column to DataFrame"
  },
  {
    "line": 145,
    "text": "    HISTORY_COMPANIES_URL = (",
    "annotation": "\u2705 Best Practice: Renaming DataFrame columns for consistency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      367,
      42480,
      62,
      9858,
      47,
      1565,
      11015,
      62,
      21886,
      796,
      357
    ],
    "start_token": 940,
    "end_token": 954,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7152,
      3723,
      6060,
      19778,
      15180,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Renaming DataFrame columns for consistency"
  },
  {
    "line": 146,
    "text": "        \"https://indexes.nasdaqomx.com/Index/WeightingData?id=NDX&tradeDate={trade_date}T00%3A00%3A00.000&timeOfDay=SOD\"",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic for saving to cache",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      5450,
      1378,
      9630,
      274,
      13,
      24716,
      48539,
      296,
      87,
      13,
      785,
      14,
      15732,
      14,
      25844,
      278,
      6601,
      30,
      312,
      28,
      8575,
      55,
      5,
      25351,
      10430,
      34758,
      25351,
      62,
      4475,
      92,
      51,
      405,
      4,
      18,
      32,
      405,
      4,
      18,
      32,
      405,
      13,
      830,
      5,
      2435,
      5189,
      12393,
      28,
      50,
      3727,
      1
    ],
    "start_token": 954,
    "end_token": 1012,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      329,
      8914,
      284,
      12940
    ],
    "label": "ml_signal",
    "reason": "Conditional logic for saving to cache"
  },
  {
    "line": 149,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Writing to cache",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1012,
    "end_token": 1012,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      284,
      12940
    ],
    "label": "ml_signal",
    "reason": "Writing to cache"
  },
  {
    "line": 150,
    "text": "    def filter_df(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Returning DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      8106,
      62,
      7568,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1012,
    "end_token": 1037,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Returning DataFrame"
  },
  {
    "line": 144,
    "text": "class NASDAQ100Index(WIKIIndex):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of tqdm for progress tracking",
    "confidence": 0.5,
    "tokens": [
      4871,
      7210,
      46640,
      3064,
      15732,
      7,
      54,
      18694,
      3978,
      358,
      1069,
      2599
    ],
    "start_token": 1037,
    "end_token": 1049,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      256,
      80,
      36020,
      329,
      4371,
      9646
    ],
    "label": "ml_signal",
    "reason": "Usage of tqdm for progress tracking"
  },
  {
    "line": 146,
    "text": "        \"https://indexes.nasdaqomx.com/Index/WeightingData?id=NDX&tradeDate={trade_date}T00%3A00%3A00.000&timeOfDay=SOD\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of ThreadPoolExecutor for concurrent execution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      5450,
      1378,
      9630,
      274,
      13,
      24716,
      48539,
      296,
      87,
      13,
      785,
      14,
      15732,
      14,
      25844,
      278,
      6601,
      30,
      312,
      28,
      8575,
      55,
      5,
      25351,
      10430,
      34758,
      25351,
      62,
      4475,
      92,
      51,
      405,
      4,
      18,
      32,
      405,
      4,
      18,
      32,
      405,
      13,
      830,
      5,
      2435,
      5189,
      12393,
      28,
      50,
      3727,
      1
    ],
    "start_token": 1049,
    "end_token": 1107,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      14122,
      27201,
      23002,
      38409,
      329,
      24580,
      9706
    ],
    "label": "ml_signal",
    "reason": "Usage of ThreadPoolExecutor for concurrent execution"
  },
  {
    "line": 146,
    "text": "        \"https://indexes.nasdaqomx.com/Index/WeightingData?id=NDX&tradeDate={trade_date}T00%3A00%3A00.000&timeOfDay=SOD\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for race conditions or thread safety issues",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      5450,
      1378,
      9630,
      274,
      13,
      24716,
      48539,
      296,
      87,
      13,
      785,
      14,
      15732,
      14,
      25844,
      278,
      6601,
      30,
      312,
      28,
      8575,
      55,
      5,
      25351,
      10430,
      34758,
      25351,
      62,
      4475,
      92,
      51,
      405,
      4,
      18,
      32,
      405,
      4,
      18,
      32,
      405,
      13,
      830,
      5,
      2435,
      5189,
      12393,
      28,
      50,
      3727,
      1
    ],
    "start_token": 1107,
    "end_token": 1165,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      3234,
      3403,
      393,
      4704,
      3747,
      2428
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for race conditions or thread safety issues"
  },
  {
    "line": 161,
    "text": "        cache_path = self.cache_dir.joinpath(f\"{trade_date}_history_companies.pkl\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for ValueError if all_history is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12940,
      62,
      6978,
      796,
      2116,
      13,
      23870,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      25351,
      62,
      4475,
      92,
      62,
      23569,
      62,
      34390,
      444,
      13,
      79,
      41582,
      4943
    ],
    "start_token": 1165,
    "end_token": 1201,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11052,
      12331,
      611,
      477,
      62,
      23569,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for ValueError if all_history is empty"
  },
  {
    "line": 159,
    "text": "    def _request_history_companies(self, trade_date: pd.Timestamp, use_cache: bool = True) -> pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Method chaining improves readability by reducing the need for intermediate variables.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      25927,
      62,
      23569,
      62,
      34390,
      444,
      7,
      944,
      11,
      3292,
      62,
      4475,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11,
      779,
      62,
      23870,
      25,
      20512,
      796,
      6407,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1201,
    "end_token": 1240,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      442,
      1397,
      19575,
      1100,
      1799,
      416,
      8868,
      262,
      761,
      329,
      19898,
      9633,
      13
    ],
    "label": "best_practice",
    "reason": "Method chaining improves readability by reducing the need for intermediate variables."
  },
  {
    "line": 161,
    "text": "        cache_path = self.cache_dir.joinpath(f\"{trade_date}_history_companies.pkl\")",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self indicates this is a method within a class, which is common in object-oriented programming.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12940,
      62,
      6978,
      796,
      2116,
      13,
      23870,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      25351,
      62,
      4475,
      92,
      62,
      23569,
      62,
      34390,
      444,
      13,
      79,
      41582,
      4943
    ],
    "start_token": 1240,
    "end_token": 1276,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      9217,
      428,
      318,
      257,
      2446,
      1626,
      257,
      1398,
      11,
      543,
      318,
      2219,
      287,
      2134,
      12,
      17107,
      8300,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of self indicates this is a method within a class, which is common in object-oriented programming."
  },
  {
    "line": 161,
    "text": "        cache_path = self.cache_dir.joinpath(f\"{trade_date}_history_companies.pkl\")",
    "annotation": "\u2705 Best Practice: Use of @property decorator for getter method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12940,
      62,
      6978,
      796,
      2116,
      13,
      23870,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      25351,
      62,
      4475,
      92,
      62,
      23569,
      62,
      34390,
      444,
      13,
      79,
      41582,
      4943
    ],
    "start_token": 1276,
    "end_token": 1312,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      651,
      353,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for getter method"
  },
  {
    "line": 163,
    "text": "            df = pd.read_pickle(cache_path)",
    "annotation": "\u2705 Best Practice: Use of type hint for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      27729,
      293,
      7,
      23870,
      62,
      6978,
      8
    ],
    "start_token": 1312,
    "end_token": 1337,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hint for return type improves code readability and maintainability"
  },
  {
    "line": 165,
    "text": "            url = self.HISTORY_COMPANIES_URL.format(trade_date=trade_date)",
    "annotation": "\ud83e\udde0 ML Signal: Consistent use of fixed start date could indicate a pattern in data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      19016,
      796,
      2116,
      13,
      39,
      42480,
      62,
      9858,
      47,
      1565,
      11015,
      62,
      21886,
      13,
      18982,
      7,
      25351,
      62,
      4475,
      28,
      25351,
      62,
      4475,
      8
    ],
    "start_token": 1337,
    "end_token": 1372,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3515,
      7609,
      779,
      286,
      5969,
      923,
      3128,
      714,
      7603,
      257,
      3912,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Consistent use of fixed start date could indicate a pattern in data processing"
  },
  {
    "line": 165,
    "text": "            url = self.HISTORY_COMPANIES_URL.format(trade_date=trade_date)",
    "annotation": "\u2705 Best Practice: Define the function with a clear purpose and return type for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      19016,
      796,
      2116,
      13,
      39,
      42480,
      62,
      9858,
      47,
      1565,
      11015,
      62,
      21886,
      13,
      18982,
      7,
      25351,
      62,
      4475,
      28,
      25351,
      62,
      4475,
      8
    ],
    "start_token": 1372,
    "end_token": 1407,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      262,
      2163,
      351,
      257,
      1598,
      4007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Define the function with a clear purpose and return type for better readability and maintainability."
  },
  {
    "line": 167,
    "text": "            if resp.status_code != 200:",
    "annotation": "\u2705 Best Practice: Use 'pass' to indicate an unimplemented function, making it clear that the function is intentionally left blank.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1217,
      13,
      13376,
      62,
      8189,
      14512,
      939,
      25
    ],
    "start_token": 1407,
    "end_token": 1427,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      6603,
      6,
      284,
      7603,
      281,
      28418,
      1154,
      12061,
      2163,
      11,
      1642,
      340,
      1598,
      326,
      262,
      2163,
      318,
      16464,
      1364,
      9178,
      13
    ],
    "label": "best_practice",
    "reason": "Use 'pass' to indicate an unimplemented function, making it clear that the function is intentionally left blank."
  },
  {
    "line": 168,
    "text": "                raise ValueError(f\"request error: {url}\")",
    "annotation": "\u2705 Best Practice: Check if \"Symbol\" is in columns to avoid KeyError",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      25927,
      4049,
      25,
      1391,
      6371,
      92,
      4943
    ],
    "start_token": 1427,
    "end_token": 1455,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      366,
      13940,
      23650,
      1,
      318,
      287,
      15180,
      284,
      3368,
      7383,
      12331
    ],
    "label": "best_practice",
    "reason": "Check if \"Symbol\" is in columns to avoid KeyError"
  },
  {
    "line": 170,
    "text": "            df[self.DATE_FIELD_NAME] = trade_date",
    "annotation": "\u2705 Best Practice: Use .copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      944,
      13,
      35,
      6158,
      62,
      44603,
      62,
      20608,
      60,
      796,
      3292,
      62,
      4475
    ],
    "start_token": 1455,
    "end_token": 1481,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 172,
    "text": "            if not df.empty:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of lambda function for string manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1481,
    "end_token": 1498,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      37456,
      2163,
      329,
      4731,
      17512
    ],
    "label": "ml_signal",
    "reason": "Usage of lambda function for string manipulation"
  },
  {
    "line": 172,
    "text": "            if not df.empty:",
    "annotation": "\u2705 Best Practice: Method name should reflect its purpose; consider renaming if it doesn't parse instruments.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1498,
    "end_token": 1515,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      4079,
      663,
      4007,
      26,
      2074,
      8851,
      3723,
      611,
      340,
      1595,
      470,
      21136,
      12834,
      13
    ],
    "label": "best_practice",
    "reason": "Method name should reflect its purpose; consider renaming if it doesn't parse instruments."
  },
  {
    "line": 174,
    "text": "        return df",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging warning messages can expose sensitive information if not handled properly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 1515,
    "end_token": 1524,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6509,
      6218,
      460,
      15651,
      8564,
      1321,
      611,
      407,
      12118,
      6105,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging warning messages can expose sensitive information if not handled properly."
  },
  {
    "line": 175,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Constant URL for data source, useful for web scraping pattern detection",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1524,
    "end_token": 1524,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20217,
      10289,
      329,
      1366,
      2723,
      11,
      4465,
      329,
      3992,
      46743,
      3912,
      13326
    ],
    "label": "ml_signal",
    "reason": "Constant URL for data source, useful for web scraping pattern detection"
  },
  {
    "line": 177,
    "text": "        logger.info(f\"start get history companies......\")",
    "annotation": "\u2705 Best Practice: Type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7,
      69,
      1,
      9688,
      651,
      2106,
      2706,
      16317,
      4943
    ],
    "start_token": 1524,
    "end_token": 1543,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 179,
    "text": "        error_list = []",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded date values can indicate fixed starting points or baselines in data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4049,
      62,
      4868,
      796,
      17635
    ],
    "start_token": 1543,
    "end_token": 1555,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      3128,
      3815,
      460,
      7603,
      5969,
      3599,
      2173,
      393,
      1615,
      20655,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Hardcoded date values can indicate fixed starting points or baselines in data processing"
  },
  {
    "line": 180,
    "text": "        with tqdm(total=len(self.calendar_list)) as p_bar:",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      256,
      80,
      36020,
      7,
      23350,
      28,
      11925,
      7,
      944,
      13,
      9948,
      9239,
      62,
      4868,
      4008,
      355,
      279,
      62,
      5657,
      25
    ],
    "start_token": 1555,
    "end_token": 1583,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 182,
    "text": "                for _trading_date, _df in zip(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): External data source without validation or sanitization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      4808,
      2213,
      4980,
      62,
      4475,
      11,
      4808,
      7568,
      287,
      19974,
      7
    ],
    "start_token": 1583,
    "end_token": 1610,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      34579,
      1366,
      2723,
      1231,
      21201,
      393,
      5336,
      270,
      1634
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "External data source without validation or sanitization"
  },
  {
    "line": 185,
    "text": "                    if _df.empty:",
    "annotation": "\u2705 Best Practice: Explicitly setting DataFrame column names for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      7568,
      13,
      28920,
      25
    ],
    "start_token": 1610,
    "end_token": 1635,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      6060,
      19778,
      5721,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly setting DataFrame column names for clarity"
  },
  {
    "line": 187,
    "text": "                    else:",
    "annotation": "\u2705 Best Practice: Converting date strings to datetime objects for consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1635,
    "end_token": 1656,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      3128,
      13042,
      284,
      4818,
      8079,
      5563,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Converting date strings to datetime objects for consistency"
  },
  {
    "line": 192,
    "text": "            logger.warning(f\"get error: {error_list}\")",
    "annotation": "\u2705 Best Practice: Adding a new column to indicate the type of change",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      1136,
      4049,
      25,
      1391,
      18224,
      62,
      4868,
      92,
      4943
    ],
    "start_token": 1656,
    "end_token": 1682,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18247,
      257,
      649,
      5721,
      284,
      7603,
      262,
      2099,
      286,
      1487
    ],
    "label": "best_practice",
    "reason": "Adding a new column to indicate the type of change"
  },
  {
    "line": 196,
    "text": "",
    "annotation": "\u2705 Best Practice: Dropping rows with NaN values in specific columns",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1682,
    "end_token": 1682,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      15274,
      351,
      11013,
      45,
      3815,
      287,
      2176,
      15180
    ],
    "label": "best_practice",
    "reason": "Dropping rows with NaN values in specific columns"
  },
  {
    "line": 199,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on type of change",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1682,
    "end_token": 1682,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      2099,
      286,
      1487
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on type of change"
  },
  {
    "line": 207,
    "text": "        pass",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 1682,
    "end_token": 1690,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 209,
    "text": "    def filter_df(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Using pd.concat to combine DataFrames",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      8106,
      62,
      7568,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1690,
    "end_token": 1715,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      1102,
      9246,
      284,
      12082,
      6060,
      35439
    ],
    "label": "best_practice",
    "reason": "Using pd.concat to combine DataFrames"
  },
  {
    "line": 203,
    "text": "    def bench_start_date(self) -> pd.Timestamp:",
    "annotation": "\ud83e\udde0 ML Signal: Checks for the presence of a specific column in a DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      7624,
      62,
      9688,
      62,
      4475,
      7,
      944,
      8,
      4613,
      279,
      67,
      13,
      14967,
      27823,
      25
    ],
    "start_token": 1715,
    "end_token": 1734,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      329,
      262,
      4931,
      286,
      257,
      2176,
      5721,
      287,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Checks for the presence of a specific column in a DataFrame"
  },
  {
    "line": 205,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of .copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1734,
    "end_token": 1734,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use of .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 207,
    "text": "        pass",
    "annotation": "\u2705 Best Practice: Use of @property decorator for getter method to provide a read-only attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 1734,
    "end_token": 1742,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      651,
      353,
      2446,
      284,
      2148,
      257,
      1100,
      12,
      8807,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for getter method to provide a read-only attribute"
  },
  {
    "line": 207,
    "text": "        pass",
    "annotation": "\u2705 Best Practice: Use of type hint for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 1742,
    "end_token": 1750,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hint for return type improves code readability and maintainability"
  },
  {
    "line": 209,
    "text": "    def filter_df(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded date values can indicate fixed starting points or baselines in data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      8106,
      62,
      7568,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1750,
    "end_token": 1775,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      3128,
      3815,
      460,
      7603,
      5969,
      3599,
      2173,
      393,
      1615,
      20655,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Hardcoded date values can indicate fixed starting points or baselines in data processing"
  },
  {
    "line": 209,
    "text": "    def filter_df(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Method signature with return type hint indicating expected output type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      8106,
      62,
      7568,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1775,
    "end_token": 1800,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      351,
      1441,
      2099,
      9254,
      12739,
      2938,
      5072,
      2099
    ],
    "label": "ml_signal",
    "reason": "Method signature with return type hint indicating expected output type"
  },
  {
    "line": 211,
    "text": "            _df = df.loc[:, [\"Symbol\"]].copy()",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      796,
      47764,
      13,
      17946,
      58,
      45299,
      14631,
      13940,
      23650,
      8973,
      4083,
      30073,
      3419
    ],
    "start_token": 1800,
    "end_token": 1826,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 213,
    "text": "            return _df",
    "annotation": "\u2705 Best Practice: Checking if a column exists before accessing it prevents runtime errors",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      7568
    ],
    "start_token": 1826,
    "end_token": 1840,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      611,
      257,
      5721,
      7160,
      878,
      22534,
      340,
      15174,
      19124,
      8563
    ],
    "label": "best_practice",
    "reason": "Checking if a column exists before accessing it prevents runtime errors"
  },
  {
    "line": 215,
    "text": "    def parse_instruments(self):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of DataFrame column filtering pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      21136,
      62,
      259,
      2536,
      2886,
      7,
      944,
      2599
    ],
    "start_token": 1840,
    "end_token": 1852,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      6060,
      19778,
      5721,
      25431,
      3912
    ],
    "label": "ml_signal",
    "reason": "Usage of DataFrame column filtering pattern"
  },
  {
    "line": 216,
    "text": "        logger.warning(f\"No suitable data source has been found!\")",
    "annotation": "\u2705 Best Practice: Using .copy() to avoid SettingWithCopyWarning and ensure a new DataFrame is returned",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      2949,
      11080,
      1366,
      2723,
      468,
      587,
      1043,
      2474,
      8
    ],
    "start_token": 1852,
    "end_token": 1874,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      764,
      30073,
      3419,
      284,
      3368,
      25700,
      3152,
      29881,
      20361,
      290,
      4155,
      257,
      649,
      6060,
      19778,
      318,
      4504
    ],
    "label": "best_practice",
    "reason": "Using .copy() to avoid SettingWithCopyWarning and ensure a new DataFrame is returned"
  },
  {
    "line": 215,
    "text": "    def parse_instruments(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging warning messages without context can lead to confusion during debugging.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      21136,
      62,
      259,
      2536,
      2886,
      7,
      944,
      2599
    ],
    "start_token": 1874,
    "end_token": 1886,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6509,
      6218,
      1231,
      4732,
      460,
      1085,
      284,
      10802,
      1141,
      28769,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging warning messages without context can lead to confusion during debugging."
  },
  {
    "line": 217,
    "text": "",
    "annotation": "\u2705 Best Practice: Use the standard Python idiom for checking if a script is run as the main program.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1886,
    "end_token": 1886,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      262,
      3210,
      11361,
      4686,
      29005,
      329,
      10627,
      611,
      257,
      4226,
      318,
      1057,
      355,
      262,
      1388,
      1430,
      13
    ],
    "label": "best_practice",
    "reason": "Use the standard Python idiom for checking if a script is run as the main program."
  },
  {
    "line": 217,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of the 'fire' library indicates a command-line interface pattern.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1886,
    "end_token": 1886,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      262,
      705,
      6495,
      6,
      5888,
      9217,
      257,
      3141,
      12,
      1370,
      7071,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of the 'fire' library indicates a command-line interface pattern."
  },
  {
    "line": 217,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using 'fire.Fire' can execute arbitrary code if user input is not properly sanitized.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1886,
    "end_token": 1886,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      705,
      6495,
      13,
      13543,
      6,
      460,
      12260,
      14977,
      2438,
      611,
      2836,
      5128,
      318,
      407,
      6105,
      5336,
      36951,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using 'fire.Fire' can execute arbitrary code if user input is not properly sanitized."
  },
  {
    "line": 217,
    "text": "",
    "annotation": "\u2705 Best Practice: Use 'partial' from 'functools' to fix certain arguments of a function, improving code readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1886,
    "end_token": 1886,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      47172,
      6,
      422,
      705,
      12543,
      310,
      10141,
      6,
      284,
      4259,
      1728,
      7159,
      286,
      257,
      2163,
      11,
      10068,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use 'partial' from 'functools' to fix certain arguments of a function, improving code readability."
  }
]