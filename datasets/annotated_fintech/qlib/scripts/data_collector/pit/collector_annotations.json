[
  {
    "line": 11,
    "text": "import pandas as pd",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying sys.path can lead to import conflicts or security issues if not handled carefully.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 0,
    "end_token": 6,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      25064,
      13,
      6978,
      460,
      1085,
      284,
      1330,
      12333,
      393,
      2324,
      2428,
      611,
      407,
      12118,
      7773,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying sys.path can lead to import conflicts or security issues if not handled carefully."
  },
  {
    "line": 14,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Importing utility functions indicates a pattern of code reuse and modular design.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 6,
    "end_token": 6,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17267,
      278,
      10361,
      5499,
      9217,
      257,
      3912,
      286,
      2438,
      32349,
      290,
      26507,
      1486,
      13
    ],
    "label": "ml_signal",
    "reason": "Importing utility functions indicates a pattern of code reuse and modular design."
  },
  {
    "line": 14,
    "text": "",
    "annotation": "\u2705 Best Practice: Constants are defined at the class level for easy configuration and readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 6,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      389,
      5447,
      379,
      262,
      1398,
      1241,
      329,
      2562,
      8398,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Constants are defined at the class level for easy configuration and readability."
  },
  {
    "line": 16,
    "text": "sys.path.append(str(BASE_DIR.parent.parent))",
    "annotation": "\u2705 Best Practice: Default start datetime constants are defined for both quarterly and annual intervals.",
    "confidence": 0.5,
    "tokens": [
      17597,
      13,
      6978,
      13,
      33295,
      7,
      2536,
      7,
      33,
      11159,
      62,
      34720,
      13,
      8000,
      13,
      8000,
      4008
    ],
    "start_token": 6,
    "end_token": 23,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      923,
      4818,
      8079,
      38491,
      389,
      5447,
      329,
      1111,
      27868,
      290,
      5079,
      20016,
      13
    ],
    "label": "best_practice",
    "reason": "Default start datetime constants are defined for both quarterly and annual intervals."
  },
  {
    "line": 19,
    "text": "from data_collector.utils import get_hs_stock_symbols, get_calendar_list",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using current datetime can lead to non-deterministic behavior in tests or logs.",
    "confidence": 1.0,
    "tokens": [
      6738,
      1366,
      62,
      33327,
      273,
      13,
      26791,
      1330,
      651,
      62,
      11994,
      62,
      13578,
      62,
      1837,
      2022,
      10220,
      11,
      651,
      62,
      9948,
      9239,
      62,
      4868
    ],
    "start_token": 23,
    "end_token": 47,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1459,
      4818,
      8079,
      460,
      1085,
      284,
      1729,
      12,
      67,
      2357,
      49228,
      4069,
      287,
      5254,
      393,
      17259,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using current datetime can lead to non-deterministic behavior in tests or logs."
  },
  {
    "line": 21,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using current datetime can lead to non-deterministic behavior in tests or logs.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 47,
    "end_token": 47,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1459,
      4818,
      8079,
      460,
      1085,
      284,
      1729,
      12,
      67,
      2357,
      49228,
      4069,
      287,
      5254,
      393,
      17259,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using current datetime can lead to non-deterministic behavior in tests or logs."
  },
  {
    "line": 21,
    "text": "",
    "annotation": "\u2705 Best Practice: Constants for interval types improve code readability and reduce the risk of typos.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 47,
    "end_token": 47,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      329,
      16654,
      3858,
      2987,
      2438,
      1100,
      1799,
      290,
      4646,
      262,
      2526,
      286,
      1259,
      1930,
      13
    ],
    "label": "best_practice",
    "reason": "Constants for interval types improve code readability and reduce the risk of typos."
  },
  {
    "line": 34,
    "text": "        start: Optional[str] = None,",
    "annotation": "\u2705 Best Practice: Docstring provides clear parameter descriptions and default values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      25,
      32233,
      58,
      2536,
      60,
      796,
      6045,
      11
    ],
    "start_token": 47,
    "end_token": 63,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      11507,
      16969,
      290,
      4277,
      3815
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear parameter descriptions and default values"
  },
  {
    "line": 59,
    "text": "        end: str",
    "annotation": "\ud83e\udde0 ML Signal: Usage of regex for filtering symbols",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      25,
      965
    ],
    "start_token": 63,
    "end_token": 73,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      40364,
      329,
      25431,
      14354
    ],
    "label": "ml_signal",
    "reason": "Usage of regex for filtering symbols"
  },
  {
    "line": 59,
    "text": "        end: str",
    "annotation": "\u2705 Best Practice: Use of super() to initialize parent class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      25,
      965
    ],
    "start_token": 73,
    "end_token": 83,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      41216,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of super() to initialize parent class"
  },
  {
    "line": 71,
    "text": "            start=start,",
    "annotation": "\u2705 Best Practice: Logging the start of a function can help in tracing and debugging.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      28,
      9688,
      11
    ],
    "start_token": 83,
    "end_token": 98,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      262,
      923,
      286,
      257,
      2163,
      460,
      1037,
      287,
      35328,
      290,
      28769,
      13
    ],
    "label": "best_practice",
    "reason": "Logging the start of a function can help in tracing and debugging."
  },
  {
    "line": 73,
    "text": "            interval=interval,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a function to retrieve stock symbols indicates a pattern of data retrieval.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      28,
      3849,
      2100,
      11
    ],
    "start_token": 98,
    "end_token": 114,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2163,
      284,
      19818,
      4283,
      14354,
      9217,
      257,
      3912,
      286,
      1366,
      45069,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a function to retrieve stock symbols indicates a pattern of data retrieval."
  },
  {
    "line": 75,
    "text": "            max_collector_count=max_collector_count,",
    "annotation": "\u2705 Best Practice: Checking for None before using a variable is a good practice to avoid errors.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      33327,
      273,
      62,
      9127,
      28,
      9806,
      62,
      33327,
      273,
      62,
      9127,
      11
    ],
    "start_token": 114,
    "end_token": 139,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      329,
      6045,
      878,
      1262,
      257,
      7885,
      318,
      257,
      922,
      3357,
      284,
      3368,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Checking for None before using a variable is a good practice to avoid errors."
  },
  {
    "line": 77,
    "text": "            check_data_length=check_data_length,",
    "annotation": "\u2705 Best Practice: Compiling regex outside of loops for efficiency.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2198,
      62,
      7890,
      62,
      13664,
      28,
      9122,
      62,
      7890,
      62,
      13664,
      11
    ],
    "start_token": 139,
    "end_token": 162,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3082,
      4386,
      40364,
      2354,
      286,
      23607,
      329,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Compiling regex outside of loops for efficiency."
  },
  {
    "line": 79,
    "text": "        )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for ReDoS if the regex is user-controlled and complex.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 162,
    "end_token": 170,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      797,
      46498,
      611,
      262,
      40364,
      318,
      2836,
      12,
      14401,
      290,
      3716,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for ReDoS if the regex is user-controlled and complex."
  },
  {
    "line": 81,
    "text": "    def get_instrument_list(self) -> List[str]:",
    "annotation": "\u2705 Best Practice: Logging the number of items processed can help in monitoring and debugging.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      259,
      43872,
      62,
      4868,
      7,
      944,
      8,
      4613,
      7343,
      58,
      2536,
      5974
    ],
    "start_token": 170,
    "end_token": 188,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      262,
      1271,
      286,
      3709,
      13686,
      460,
      1037,
      287,
      9904,
      290,
      28769,
      13
    ],
    "label": "best_practice",
    "reason": "Logging the number of items processed can help in monitoring and debugging."
  },
  {
    "line": 83,
    "text": "        symbols = get_hs_stock_symbols()",
    "annotation": "\ud83e\udde0 ML Signal: Returning a list of symbols is a common pattern in financial data processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14354,
      796,
      651,
      62,
      11994,
      62,
      13578,
      62,
      1837,
      2022,
      10220,
      3419
    ],
    "start_token": 188,
    "end_token": 207,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      1351,
      286,
      14354,
      318,
      257,
      2219,
      3912,
      287,
      3176,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Returning a list of symbols is a common pattern in financial data processing."
  },
  {
    "line": 79,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Method for normalizing stock symbols, useful for financial data processing models",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 207,
    "end_token": 215,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      3487,
      2890,
      4283,
      14354,
      11,
      4465,
      329,
      3176,
      1366,
      7587,
      4981
    ],
    "label": "ml_signal",
    "reason": "Method for normalizing stock symbols, useful for financial data processing models"
  },
  {
    "line": 81,
    "text": "    def get_instrument_list(self) -> List[str]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes input symbol always contains a '.', potential for ValueError",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      259,
      43872,
      62,
      4868,
      7,
      944,
      8,
      4613,
      7343,
      58,
      2536,
      5974
    ],
    "start_token": 215,
    "end_token": 233,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      5128,
      6194,
      1464,
      4909,
      257,
      705,
      2637,
      11,
      2785,
      329,
      11052,
      12331
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes input symbol always contains a '.', potential for ValueError"
  },
  {
    "line": 83,
    "text": "        symbols = get_hs_stock_symbols()",
    "annotation": "\u2705 Best Practice: Use of ternary operator for concise conditional assignment",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14354,
      796,
      651,
      62,
      11994,
      62,
      13578,
      62,
      1837,
      2022,
      10220,
      3419
    ],
    "start_token": 233,
    "end_token": 252,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1059,
      77,
      560,
      10088,
      329,
      35327,
      26340,
      16237
    ],
    "label": "best_practice",
    "reason": "Use of ternary operator for concise conditional assignment"
  },
  {
    "line": 84,
    "text": "        if self.symbol_regex is not None:",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      1837,
      23650,
      62,
      260,
      25636,
      318,
      407,
      6045,
      25
    ],
    "start_token": 252,
    "end_token": 271,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting"
  },
  {
    "line": 89,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of @staticmethod for methods that do not access instance data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 271,
    "end_token": 271,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      12708,
      24396,
      329,
      5050,
      326,
      466,
      407,
      1895,
      4554,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of @staticmethod for methods that do not access instance data"
  },
  {
    "line": 89,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external API call pattern",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 271,
    "end_token": 271,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      7824,
      869,
      3912
    ],
    "label": "ml_signal",
    "reason": "Usage of external API call pattern"
  },
  {
    "line": 92,
    "text": "        exchange = \"sh\" if exchange == \"ss\" else \"sz\"",
    "annotation": "\ud83e\udde0 ML Signal: Loop pattern for data retrieval",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5163,
      796,
      366,
      1477,
      1,
      611,
      5163,
      6624,
      366,
      824,
      1,
      2073,
      366,
      82,
      89,
      1
    ],
    "start_token": 271,
    "end_token": 294,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26304,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Loop pattern for data retrieval"
  },
  {
    "line": 94,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Appending data to a list",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 294,
    "end_token": 294,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      1366,
      284,
      257,
      1351
    ],
    "label": "ml_signal",
    "reason": "Appending data to a list"
  },
  {
    "line": 95,
    "text": "    @staticmethod",
    "annotation": "\ud83e\udde0 ML Signal: DataFrame creation from list",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 294,
    "end_token": 300,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6060,
      19778,
      6282,
      422,
      1351
    ],
    "label": "ml_signal",
    "reason": "DataFrame creation from list"
  },
  {
    "line": 99,
    "text": "            \"performanceExpStatDate\": \"period\",",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if keys are missing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      26585,
      16870,
      17126,
      10430,
      1298,
      366,
      41007,
      1600
    ],
    "start_token": 300,
    "end_token": 320,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      8251,
      389,
      4814
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if keys are missing"
  },
  {
    "line": 102,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Exception handling pattern",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 320,
    "end_token": 320,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35528,
      9041,
      3912
    ],
    "label": "ml_signal",
    "reason": "Exception handling pattern"
  },
  {
    "line": 104,
    "text": "        report_list = []",
    "annotation": "\u2705 Best Practice: Use of rename with inplace for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      989,
      62,
      4868,
      796,
      17635
    ],
    "start_token": 320,
    "end_token": 332,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      36265,
      351,
      287,
      5372,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Use of rename with inplace for clarity"
  },
  {
    "line": 106,
    "text": "            report_list.append(resp.get_row_data())",
    "annotation": "\ud83e\udde0 ML Signal: Adding a constant column to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      989,
      62,
      4868,
      13,
      33295,
      7,
      4363,
      13,
      1136,
      62,
      808,
      62,
      7890,
      28955
    ],
    "start_token": 332,
    "end_token": 357,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      6937,
      5721,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding a constant column to DataFrame"
  },
  {
    "line": 108,
    "text": "        try:",
    "annotation": "\u2705 Best Practice: Use of pd.to_numeric for safe conversion",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 357,
    "end_token": 366,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      1462,
      62,
      77,
      39223,
      329,
      3338,
      11315
    ],
    "label": "best_practice",
    "reason": "Use of pd.to_numeric for safe conversion"
  },
  {
    "line": 110,
    "text": "        except KeyError:",
    "annotation": "\ud83e\udde0 ML Signal: Applying a lambda function to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      7383,
      12331,
      25
    ],
    "start_token": 366,
    "end_token": 377,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      37456,
      2163,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Applying a lambda function to a DataFrame column"
  },
  {
    "line": 105,
    "text": "        while (resp.error_code == \"0\") and resp.next():",
    "annotation": "\u2705 Best Practice: Use a dictionary for column mapping to improve readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      357,
      4363,
      13,
      18224,
      62,
      8189,
      6624,
      366,
      15,
      4943,
      290,
      1217,
      13,
      19545,
      33529
    ],
    "start_token": 377,
    "end_token": 400,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      257,
      22155,
      329,
      5721,
      16855,
      284,
      2987,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use a dictionary for column mapping to improve readability and maintainability."
  },
  {
    "line": 107,
    "text": "        report_df = pd.DataFrame(report_list, columns=resp.fields)",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific API function with hardcoded parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      989,
      62,
      7568,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      13116,
      62,
      4868,
      11,
      15180,
      28,
      4363,
      13,
      25747,
      8
    ],
    "start_token": 400,
    "end_token": 427,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      7824,
      2163,
      351,
      1327,
      40976,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a specific API function with hardcoded parameters."
  },
  {
    "line": 109,
    "text": "            report_df = report_df[list(column_mapping.keys())]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of incorrect date format causing ValueError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      989,
      62,
      7568,
      796,
      989,
      62,
      7568,
      58,
      4868,
      7,
      28665,
      62,
      76,
      5912,
      13,
      13083,
      3419,
      15437
    ],
    "start_token": 427,
    "end_token": 456,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      11491,
      3128,
      5794,
      6666,
      11052,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of incorrect date format causing ValueError."
  },
  {
    "line": 111,
    "text": "            return pd.DataFrame()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of incorrect date format causing ValueError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      13,
      6601,
      19778,
      3419
    ],
    "start_token": 456,
    "end_token": 474,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      11491,
      3128,
      5794,
      6666,
      11052,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of incorrect date format causing ValueError."
  },
  {
    "line": 113,
    "text": "        report_df[\"field\"] = \"roeWa\"",
    "annotation": "\u2705 Best Practice: Use list comprehension for concise and efficient list creation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      989,
      62,
      7568,
      14692,
      3245,
      8973,
      796,
      366,
      20646,
      33484,
      1
    ],
    "start_token": 474,
    "end_token": 492,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1351,
      35915,
      329,
      35327,
      290,
      6942,
      1351,
      6282,
      13
    ],
    "label": "best_practice",
    "reason": "Use list comprehension for concise and efficient list creation."
  },
  {
    "line": 117,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific API function with dynamic parameters.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 492,
    "end_token": 492,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      7824,
      2163,
      351,
      8925,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a specific API function with dynamic parameters."
  },
  {
    "line": 122,
    "text": "        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of accessing an index that may not exist.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      4475,
      796,
      4818,
      8079,
      13,
      2536,
      457,
      524,
      7,
      9688,
      62,
      4475,
      11,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      4943
    ],
    "start_token": 492,
    "end_token": 523,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      22534,
      281,
      6376,
      326,
      743,
      407,
      2152,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of accessing an index that may not exist."
  },
  {
    "line": 127,
    "text": "            resp = bs.query_profit_data(code=code, year=year, quarter=quarter)",
    "annotation": "\u2705 Best Practice: Use pandas DataFrame for structured data handling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1217,
      796,
      275,
      82,
      13,
      22766,
      62,
      9183,
      62,
      7890,
      7,
      8189,
      28,
      8189,
      11,
      614,
      28,
      1941,
      11,
      3860,
      28,
      24385,
      8
    ],
    "start_token": 523,
    "end_token": 557,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      19798,
      292,
      6060,
      19778,
      329,
      20793,
      1366,
      9041,
      13
    ],
    "label": "best_practice",
    "reason": "Use pandas DataFrame for structured data handling."
  },
  {
    "line": 130,
    "text": "                    continue",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if keys are not present in DataFrame columns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2555
    ],
    "start_token": 557,
    "end_token": 577,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      8251,
      389,
      407,
      1944,
      287,
      6060,
      19778,
      15180,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if keys are not present in DataFrame columns."
  },
  {
    "line": 136,
    "text": "        try:",
    "annotation": "\u2705 Best Practice: Use rename with inplace=True for efficient DataFrame column renaming.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 577,
    "end_token": 586,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      36265,
      351,
      287,
      5372,
      28,
      17821,
      329,
      6942,
      6060,
      19778,
      5721,
      8851,
      3723,
      13
    ],
    "label": "best_practice",
    "reason": "Use rename with inplace=True for efficient DataFrame column renaming."
  },
  {
    "line": 137,
    "text": "            profit_df = profit_df[list(column_mapping.keys())]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of conversion errors if 'value' column contains non-numeric data.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7630,
      62,
      7568,
      796,
      7630,
      62,
      7568,
      58,
      4868,
      7,
      28665,
      62,
      76,
      5912,
      13,
      13083,
      3419,
      15437
    ],
    "start_token": 586,
    "end_token": 615,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      11315,
      8563,
      611,
      705,
      8367,
      6,
      5721,
      4909,
      1729,
      12,
      77,
      39223,
      1366,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of conversion errors if 'value' column contains non-numeric data."
  },
  {
    "line": 131,
    "text": "                row_data = resp.get_row_data()",
    "annotation": "\ud83e\udde0 ML Signal: Use of a dictionary for column mapping",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5752,
      62,
      7890,
      796,
      1217,
      13,
      1136,
      62,
      808,
      62,
      7890,
      3419
    ],
    "start_token": 615,
    "end_token": 642,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      22155,
      329,
      5721,
      16855
    ],
    "label": "ml_signal",
    "reason": "Use of a dictionary for column mapping"
  },
  {
    "line": 137,
    "text": "            profit_df = profit_df[list(column_mapping.keys())]",
    "annotation": "\ud83e\udde0 ML Signal: Use of external API call",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7630,
      62,
      7568,
      796,
      7630,
      62,
      7568,
      58,
      4868,
      7,
      28665,
      62,
      76,
      5912,
      13,
      13083,
      3419,
      15437
    ],
    "start_token": 642,
    "end_token": 671,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      7097,
      7824,
      869
    ],
    "label": "ml_signal",
    "reason": "Use of external API call"
  },
  {
    "line": 140,
    "text": "        profit_df.rename(columns=column_mapping, inplace=True)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential infinite loop if resp.next() always returns True",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7630,
      62,
      7568,
      13,
      918,
      480,
      7,
      28665,
      82,
      28,
      28665,
      62,
      76,
      5912,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 671,
    "end_token": 698,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      15541,
      9052,
      611,
      1217,
      13,
      19545,
      3419,
      1464,
      5860,
      6407
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential infinite loop if resp.next() always returns True"
  },
  {
    "line": 142,
    "text": "        profit_df[\"value\"] = pd.to_numeric(profit_df[\"value\"], errors=\"ignore\")",
    "annotation": "\ud83e\udde0 ML Signal: Appending data to a list",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7630,
      62,
      7568,
      14692,
      8367,
      8973,
      796,
      279,
      67,
      13,
      1462,
      62,
      77,
      39223,
      7,
      9183,
      62,
      7568,
      14692,
      8367,
      33116,
      8563,
      2625,
      46430,
      4943
    ],
    "start_token": 698,
    "end_token": 730,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      1366,
      284,
      257,
      1351
    ],
    "label": "ml_signal",
    "reason": "Appending data to a list"
  },
  {
    "line": 143,
    "text": "        return profit_df",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of list to DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      7630,
      62,
      7568
    ],
    "start_token": 730,
    "end_token": 741,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      1351,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Conversion of list to DataFrame"
  },
  {
    "line": 146,
    "text": "    def get_forecast_report_df(code: str, start_date: str, end_date: str) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Use of list for numeric fields",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      754,
      2701,
      62,
      13116,
      62,
      7568,
      7,
      8189,
      25,
      965,
      11,
      923,
      62,
      4475,
      25,
      965,
      11,
      886,
      62,
      4475,
      25,
      965,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 741,
    "end_token": 777,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1351,
      329,
      35575,
      7032
    ],
    "label": "ml_signal",
    "reason": "Use of list for numeric fields"
  },
  {
    "line": 149,
    "text": "            \"profitForcastExpStatDate\": \"period\",",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential data type conversion issue",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      9183,
      1890,
      2701,
      16870,
      17126,
      10430,
      1298,
      366,
      41007,
      1600
    ],
    "start_token": 777,
    "end_token": 799,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1366,
      2099,
      11315,
      2071
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential data type conversion issue"
  },
  {
    "line": 152,
    "text": "        resp = bs.query_forecast_report(code=code, start_date=start_date, end_date=end_date)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning empty DataFrame on exception",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1217,
      796,
      275,
      82,
      13,
      22766,
      62,
      754,
      2701,
      62,
      13116,
      7,
      8189,
      28,
      8189,
      11,
      923,
      62,
      4475,
      28,
      9688,
      62,
      4475,
      11,
      886,
      62,
      4475,
      28,
      437,
      62,
      4475,
      8
    ],
    "start_token": 799,
    "end_token": 838,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      6565,
      6060,
      19778,
      319,
      6631
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning empty DataFrame on exception"
  },
  {
    "line": 154,
    "text": "        while (resp.error_code == \"0\") and resp.next():",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of new column based on existing data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      357,
      4363,
      13,
      18224,
      62,
      8189,
      6624,
      366,
      15,
      4943,
      290,
      1217,
      13,
      19545,
      33529
    ],
    "start_token": 838,
    "end_token": 861,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      649,
      5721,
      1912,
      319,
      4683,
      1366
    ],
    "label": "ml_signal",
    "reason": "Calculation of new column based on existing data"
  },
  {
    "line": 156,
    "text": "        forecast_df = pd.DataFrame(forecast_list, columns=resp.fields)",
    "annotation": "\ud83e\udde0 ML Signal: Reordering DataFrame columns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      7568,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      754,
      2701,
      62,
      4868,
      11,
      15180,
      28,
      4363,
      13,
      25747,
      8
    ],
    "start_token": 861,
    "end_token": 889,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      797,
      34555,
      6060,
      19778,
      15180
    ],
    "label": "ml_signal",
    "reason": "Reordering DataFrame columns"
  },
  {
    "line": 158,
    "text": "        try:",
    "annotation": "\ud83e\udde0 ML Signal: Renaming DataFrame columns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 889,
    "end_token": 898,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7152,
      3723,
      6060,
      19778,
      15180
    ],
    "label": "ml_signal",
    "reason": "Renaming DataFrame columns"
  },
  {
    "line": 160,
    "text": "        except KeyError:",
    "annotation": "\ud83e\udde0 ML Signal: Adding a constant column to DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      7383,
      12331,
      25
    ],
    "start_token": 898,
    "end_token": 909,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      6937,
      5721,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding a constant column to DataFrame"
  },
  {
    "line": 162,
    "text": "        forecast_df[\"value\"] = (forecast_df[\"profitForcastChgPctUp\"] + forecast_df[\"profitForcastChgPctDwn\"]) / 200",
    "annotation": "\ud83e\udde0 ML Signal: Returning a DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      7568,
      14692,
      8367,
      8973,
      796,
      357,
      754,
      2701,
      62,
      7568,
      14692,
      9183,
      1890,
      2701,
      1925,
      70,
      47,
      310,
      4933,
      8973,
      1343,
      11092,
      62,
      7568,
      14692,
      9183,
      1890,
      2701,
      1925,
      70,
      47,
      310,
      35,
      675,
      8973,
      8,
      1220,
      939
    ],
    "start_token": 909,
    "end_token": 956,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Returning a DataFrame"
  },
  {
    "line": 164,
    "text": "        forecast_df.rename(columns=column_mapping, inplace=True)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Misuse of @staticmethod decorator without a class context",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      7568,
      13,
      918,
      480,
      7,
      28665,
      82,
      28,
      28665,
      62,
      76,
      5912,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 956,
    "end_token": 983,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      14136,
      1904,
      286,
      2488,
      12708,
      24396,
      11705,
      1352,
      1231,
      257,
      1398,
      4732
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Misuse of @staticmethod decorator without a class context"
  },
  {
    "line": 152,
    "text": "        resp = bs.query_forecast_report(code=code, start_date=start_date, end_date=end_date)",
    "annotation": "\u2705 Best Practice: Type hints for function parameters and return type improve code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1217,
      796,
      275,
      82,
      13,
      22766,
      62,
      754,
      2701,
      62,
      13116,
      7,
      8189,
      28,
      8189,
      11,
      923,
      62,
      4475,
      28,
      9688,
      62,
      4475,
      11,
      886,
      62,
      4475,
      28,
      437,
      62,
      4475,
      8
    ],
    "start_token": 983,
    "end_token": 1022,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hints for function parameters and return type improve code readability and maintainability."
  },
  {
    "line": 155,
    "text": "            forecast_list.append(resp.get_row_data())",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded values like \"sh.600519\" can indicate specific usage patterns or preferences.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      4868,
      13,
      33295,
      7,
      4363,
      13,
      1136,
      62,
      808,
      62,
      7890,
      28955
    ],
    "start_token": 1022,
    "end_token": 1047,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      3815,
      588,
      366,
      1477,
      13,
      8054,
      47785,
      1,
      460,
      7603,
      2176,
      8748,
      7572,
      393,
      15387,
      13
    ],
    "label": "ml_signal",
    "reason": "Hardcoded values like \"sh.600519\" can indicate specific usage patterns or preferences."
  },
  {
    "line": 157,
    "text": "        numeric_fields = [\"profitForcastChgPctUp\", \"profitForcastChgPctDwn\"]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Parsing strings to dates without validation can lead to unexpected errors if the format is incorrect.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      35575,
      62,
      25747,
      796,
      14631,
      9183,
      1890,
      2701,
      1925,
      70,
      47,
      310,
      4933,
      1600,
      366,
      9183,
      1890,
      2701,
      1925,
      70,
      47,
      310,
      35,
      675,
      8973
    ],
    "start_token": 1047,
    "end_token": 1079,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      23042,
      278,
      13042,
      284,
      9667,
      1231,
      21201,
      460,
      1085,
      284,
      10059,
      8563,
      611,
      262,
      5794,
      318,
      11491,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Parsing strings to dates without validation can lead to unexpected errors if the format is incorrect."
  },
  {
    "line": 159,
    "text": "            forecast_df[numeric_fields] = forecast_df[numeric_fields].apply(pd.to_numeric, errors=\"ignore\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Parsing strings to dates without validation can lead to unexpected errors if the format is incorrect.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      7568,
      58,
      77,
      39223,
      62,
      25747,
      60,
      796,
      11092,
      62,
      7568,
      58,
      77,
      39223,
      62,
      25747,
      4083,
      39014,
      7,
      30094,
      13,
      1462,
      62,
      77,
      39223,
      11,
      8563,
      2625,
      46430,
      4943
    ],
    "start_token": 1079,
    "end_token": 1122,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      23042,
      278,
      13042,
      284,
      9667,
      1231,
      21201,
      460,
      1085,
      284,
      10059,
      8563,
      611,
      262,
      5794,
      318,
      11491,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Parsing strings to dates without validation can lead to unexpected errors if the format is incorrect."
  },
  {
    "line": 161,
    "text": "            return pd.DataFrame()",
    "annotation": "\u2705 Best Practice: List comprehensions are a concise way to create lists and improve readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      13,
      6601,
      19778,
      3419
    ],
    "start_token": 1122,
    "end_token": 1140,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7343,
      8569,
      507,
      389,
      257,
      35327,
      835,
      284,
      2251,
      8341,
      290,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "List comprehensions are a concise way to create lists and improve readability."
  },
  {
    "line": 165,
    "text": "        forecast_df[\"field\"] = \"YOYNI\"",
    "annotation": "\ud83e\udde0 ML Signal: The use of external API calls can indicate integration patterns and dependencies.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      7568,
      14692,
      3245,
      8973,
      796,
      366,
      56,
      21414,
      22125,
      1
    ],
    "start_token": 1140,
    "end_token": 1159,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      779,
      286,
      7097,
      7824,
      3848,
      460,
      7603,
      11812,
      7572,
      290,
      20086,
      13
    ],
    "label": "ml_signal",
    "reason": "The use of external API calls can indicate integration patterns and dependencies."
  },
  {
    "line": 167,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential infinite loop if `resp.next()` always returns True and `resp.error_code` is \"0\".",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1159,
    "end_token": 1159,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      15541,
      9052,
      611,
      4600,
      4363,
      13,
      19545,
      3419,
      63,
      1464,
      5860,
      6407,
      290,
      4600,
      4363,
      13,
      18224,
      62,
      8189,
      63,
      318,
      366,
      15,
      1911
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential infinite loop if `resp.next()` always returns True and `resp.error_code` is \"0\"."
  },
  {
    "line": 172,
    "text": "        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")",
    "annotation": "\u2705 Best Practice: Using pd.Timestamp for date comparison ensures compatibility with pandas operations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      4475,
      796,
      4818,
      8079,
      13,
      2536,
      457,
      524,
      7,
      9688,
      62,
      4475,
      11,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      4943
    ],
    "start_token": 1159,
    "end_token": 1190,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      14967,
      27823,
      329,
      3128,
      7208,
      19047,
      17764,
      351,
      19798,
      292,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Using pd.Timestamp for date comparison ensures compatibility with pandas operations."
  },
  {
    "line": 176,
    "text": "        for year, quarter in args:",
    "annotation": "\u2705 Best Practice: Using pandas DataFrame for structured data manipulation is efficient and readable.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      614,
      11,
      3860,
      287,
      26498,
      25
    ],
    "start_token": 1190,
    "end_token": 1204,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      19798,
      292,
      6060,
      19778,
      329,
      20793,
      1366,
      17512,
      318,
      6942,
      290,
      31744,
      13
    ],
    "label": "best_practice",
    "reason": "Using pandas DataFrame for structured data manipulation is efficient and readable."
  },
  {
    "line": 177,
    "text": "            resp = bs.query_growth_data(code=code, year=year, quarter=quarter)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Accessing DataFrame columns without checking existence can raise KeyError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1217,
      796,
      275,
      82,
      13,
      22766,
      62,
      27922,
      62,
      7890,
      7,
      8189,
      28,
      8189,
      11,
      614,
      28,
      1941,
      11,
      3860,
      28,
      24385,
      8
    ],
    "start_token": 1204,
    "end_token": 1238,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8798,
      278,
      6060,
      19778,
      15180,
      1231,
      10627,
      6224,
      460,
      5298,
      7383,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Accessing DataFrame columns without checking existence can raise KeyError."
  },
  {
    "line": 184,
    "text": "                    growth_list.append(row_data)",
    "annotation": "\u2705 Best Practice: Using rename with inplace=True avoids unnecessary DataFrame copies.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      4868,
      13,
      33295,
      7,
      808,
      62,
      7890,
      8
    ],
    "start_token": 1238,
    "end_token": 1267,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      36265,
      351,
      287,
      5372,
      28,
      17821,
      30940,
      13114,
      6060,
      19778,
      9088,
      13
    ],
    "label": "best_practice",
    "reason": "Using rename with inplace=True avoids unnecessary DataFrame copies."
  },
  {
    "line": 185,
    "text": "        growth_df = pd.DataFrame(growth_list, columns=fields)",
    "annotation": "\ud83e\udde0 ML Signal: Adding constant fields like \"field\" can indicate data labeling or categorization patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      7568,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      27922,
      62,
      4868,
      11,
      15180,
      28,
      25747,
      8
    ],
    "start_token": 1267,
    "end_token": 1292,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      6937,
      7032,
      588,
      366,
      3245,
      1,
      460,
      7603,
      1366,
      27393,
      393,
      17851,
      1634,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Adding constant fields like \"field\" can indicate data labeling or categorization patterns."
  },
  {
    "line": 187,
    "text": "            growth_df = growth_df[list(column_mapping.keys())]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Converting to numeric with errors=\"ignore\" can silently fail and lead to data inconsistencies.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      7568,
      796,
      3349,
      62,
      7568,
      58,
      4868,
      7,
      28665,
      62,
      76,
      5912,
      13,
      13083,
      3419,
      15437
    ],
    "start_token": 1292,
    "end_token": 1321,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      35602,
      889,
      284,
      35575,
      351,
      8563,
      2625,
      46430,
      1,
      460,
      24595,
      2038,
      290,
      1085,
      284,
      1366,
      40467,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Converting to numeric with errors=\"ignore\" can silently fail and lead to data inconsistencies."
  },
  {
    "line": 184,
    "text": "                    growth_list.append(row_data)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for ValueError if 'interval' is not as expected",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      4868,
      13,
      33295,
      7,
      808,
      62,
      7890,
      8
    ],
    "start_token": 1321,
    "end_token": 1350,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11052,
      12331,
      611,
      705,
      3849,
      2100,
      6,
      318,
      407,
      355,
      2938
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for ValueError if 'interval' is not as expected"
  },
  {
    "line": 187,
    "text": "            growth_df = growth_df[list(column_mapping.keys())]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'symbol' is always in the correct format with a '.'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      7568,
      796,
      3349,
      62,
      7568,
      58,
      4868,
      7,
      28665,
      62,
      76,
      5912,
      13,
      13083,
      3419,
      15437
    ],
    "start_token": 1350,
    "end_token": 1379,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      1837,
      23650,
      6,
      318,
      1464,
      287,
      262,
      3376,
      5794,
      351,
      257,
      705,
      2637
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'symbol' is always in the correct format with a '.'"
  },
  {
    "line": 189,
    "text": "            return pd.DataFrame()",
    "annotation": "\u2705 Best Practice: Use of ternary operator for concise conditional assignment",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      13,
      6601,
      19778,
      3419
    ],
    "start_token": 1379,
    "end_token": 1397,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1059,
      77,
      560,
      10088,
      329,
      35327,
      26340,
      16237
    ],
    "label": "best_practice",
    "reason": "Use of ternary operator for concise conditional assignment"
  },
  {
    "line": 191,
    "text": "        growth_df[\"field\"] = \"YOYNI\"",
    "annotation": "\ud83e\udde0 ML Signal: String formatting pattern for constructing 'code'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3349,
      62,
      7568,
      14692,
      3245,
      8973,
      796,
      366,
      56,
      21414,
      22125,
      1
    ],
    "start_token": 1397,
    "end_token": 1416,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      10903,
      33313,
      3912,
      329,
      30580,
      705,
      8189,
      6
    ],
    "label": "ml_signal",
    "reason": "String formatting pattern for constructing 'code'"
  },
  {
    "line": 193,
    "text": "        return growth_df",
    "annotation": "\ud83e\udde0 ML Signal: Usage of strftime for date formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3349,
      62,
      7568
    ],
    "start_token": 1416,
    "end_token": 1427,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      965,
      31387,
      329,
      3128,
      33313
    ],
    "label": "ml_signal",
    "reason": "Usage of strftime for date formatting"
  },
  {
    "line": 195,
    "text": "    def get_data(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of strftime for date formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      7
    ],
    "start_token": 1427,
    "end_token": 1435,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      965,
      31387,
      329,
      3128,
      33313
    ],
    "label": "ml_signal",
    "reason": "Usage of strftime for date formatting"
  },
  {
    "line": 195,
    "text": "    def get_data(",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      7
    ],
    "start_token": 1435,
    "end_token": 1443,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for data retrieval"
  },
  {
    "line": 199,
    "text": "        start_datetime: pd.Timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11
    ],
    "start_token": 1443,
    "end_token": 1461,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for data retrieval"
  },
  {
    "line": 201,
    "text": "    ) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1461,
    "end_token": 1472,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for data retrieval"
  },
  {
    "line": 203,
    "text": "            raise ValueError(f\"cannot support {interval}\")",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for data retrieval",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      66,
      34574,
      1104,
      1391,
      3849,
      2100,
      92,
      4943
    ],
    "start_token": 1472,
    "end_token": 1497,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      1366,
      45069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for data retrieval"
  },
  {
    "line": 205,
    "text": "        exchange = \"sh\" if exchange == \"ss\" else \"sz\"",
    "annotation": "\u2705 Best Practice: Use of pd.concat for combining DataFrames",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5163,
      796,
      366,
      1477,
      1,
      611,
      5163,
      6624,
      366,
      824,
      1,
      2073,
      366,
      82,
      89,
      1
    ],
    "start_token": 1497,
    "end_token": 1520,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      1102,
      9246,
      329,
      19771,
      6060,
      35439
    ],
    "label": "best_practice",
    "reason": "Use of pd.concat for combining DataFrames"
  },
  {
    "line": 202,
    "text": "        if interval != self.INTERVAL_QUARTERLY:",
    "annotation": "\u2705 Best Practice: Use of default parameter values improves function usability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      16654,
      14512,
      2116,
      13,
      41358,
      23428,
      62,
      10917,
      1503,
      5781,
      11319,
      25
    ],
    "start_token": 1520,
    "end_token": 1540,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      19575,
      2163,
      42863,
      13
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values improves function usability."
  },
  {
    "line": 203,
    "text": "            raise ValueError(f\"cannot support {interval}\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameter values can indicate common usage patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      66,
      34574,
      1104,
      1391,
      3849,
      2100,
      92,
      4943
    ],
    "start_token": 1540,
    "end_token": 1565,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      460,
      7603,
      2219,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of default parameter values can indicate common usage patterns."
  },
  {
    "line": 205,
    "text": "        exchange = \"sh\" if exchange == \"ss\" else \"sz\"",
    "annotation": "\u2705 Best Practice: Using super() to call the parent class constructor ensures proper initialization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5163,
      796,
      366,
      1477,
      1,
      611,
      5163,
      6624,
      366,
      824,
      1,
      2073,
      366,
      82,
      89,
      1
    ],
    "start_token": 1565,
    "end_token": 1588,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2208,
      3419,
      284,
      869,
      262,
      2560,
      1398,
      23772,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Using super() to call the parent class constructor ensures proper initialization."
  },
  {
    "line": 205,
    "text": "        exchange = \"sh\" if exchange == \"ss\" else \"sz\"",
    "annotation": "\ud83e\udde0 ML Signal: Storing method parameters as instance variables is a common pattern.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5163,
      796,
      366,
      1477,
      1,
      611,
      5163,
      6624,
      366,
      824,
      1,
      2073,
      366,
      82,
      89,
      1
    ],
    "start_token": 1588,
    "end_token": 1611,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      2446,
      10007,
      355,
      4554,
      9633,
      318,
      257,
      2219,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing method parameters as instance variables is a common pattern."
  },
  {
    "line": 204,
    "text": "        symbol, exchange = symbol.split(\".\")",
    "annotation": "\u2705 Best Practice: Include type hints for method parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      11,
      5163,
      796,
      6194,
      13,
      35312,
      7203,
      19570
    ],
    "start_token": 1611,
    "end_token": 1627,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2446,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for method parameters and return type for better readability and maintainability"
  },
  {
    "line": 205,
    "text": "        exchange = \"sh\" if exchange == \"ss\" else \"sz\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of lambda functions for data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5163,
      796,
      366,
      1477,
      1,
      611,
      5163,
      6624,
      366,
      824,
      1,
      2073,
      366,
      82,
      89,
      1
    ],
    "start_token": 1627,
    "end_token": 1650,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      37456,
      5499,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Usage of lambda functions for data transformation"
  },
  {
    "line": 210,
    "text": "        performance_express_report_df = self.get_performance_express_report_df(code, start_date, end_date)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on class attribute for date offset calculation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2854,
      62,
      42712,
      62,
      13116,
      62,
      7568,
      796,
      2116,
      13,
      1136,
      62,
      26585,
      62,
      42712,
      62,
      13116,
      62,
      7568,
      7,
      8189,
      11,
      923,
      62,
      4475,
      11,
      886,
      62,
      4475,
      8
    ],
    "start_token": 1650,
    "end_token": 1687,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      1398,
      11688,
      329,
      3128,
      11677,
      17952
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on class attribute for date offset calculation"
  },
  {
    "line": 212,
    "text": "        forecast_report_df = self.get_forecast_report_df(code, start_date, end_date)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if 'date' column contains non-date strings that cannot be converted",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11092,
      62,
      13116,
      62,
      7568,
      796,
      2116,
      13,
      1136,
      62,
      754,
      2701,
      62,
      13116,
      62,
      7568,
      7,
      8189,
      11,
      923,
      62,
      4475,
      11,
      886,
      62,
      4475,
      8
    ],
    "start_token": 1687,
    "end_token": 1721,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      705,
      4475,
      6,
      5721,
      4909,
      1729,
      12,
      4475,
      13042,
      326,
      2314,
      307,
      11513
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if 'date' column contains non-date strings that cannot be converted"
  },
  {
    "line": 215,
    "text": "        df = pd.concat(",
    "annotation": "\u2705 Best Practice: Convert 'period' column to datetime for consistent date operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      1102,
      9246,
      7
    ],
    "start_token": 1721,
    "end_token": 1736,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      705,
      41007,
      6,
      5721,
      284,
      4818,
      8079,
      329,
      6414,
      3128,
      4560
    ],
    "label": "best_practice",
    "reason": "Convert 'period' column to datetime for consistent date operations"
  },
  {
    "line": 217,
    "text": "            axis=0,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of lambda functions for conditional data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16488,
      28,
      15,
      11
    ],
    "start_token": 1736,
    "end_token": 1751,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      37456,
      5499,
      329,
      26340,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Usage of lambda functions for conditional data transformation"
  },
  {
    "line": 218,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on class attribute for period transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1751,
    "end_token": 1759,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      1398,
      11688,
      329,
      2278,
      13389
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on class attribute for period transformation"
  },
  {
    "line": 221,
    "text": "",
    "annotation": "\u2705 Best Practice: Return the modified DataFrame for method chaining and functional programming style",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1759,
    "end_token": 1759,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      262,
      9518,
      6060,
      19778,
      329,
      2446,
      442,
      1397,
      290,
      10345,
      8300,
      3918
    ],
    "label": "best_practice",
    "reason": "Return the modified DataFrame for method chaining and functional programming style"
  },
  {
    "line": 216,
    "text": "            [performance_express_report_df, profit_df, forecast_report_df, growth_df],",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      685,
      26585,
      62,
      42712,
      62,
      13116,
      62,
      7568,
      11,
      7630,
      62,
      7568,
      11,
      11092,
      62,
      13116,
      62,
      7568,
      11,
      3349,
      62,
      7568,
      4357
    ],
    "start_token": 1759,
    "end_token": 1793,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 218,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Function calls another function, indicating a potential pattern of delegation or abstraction",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1793,
    "end_token": 1801,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      1194,
      2163,
      11,
      12739,
      257,
      2785,
      3912,
      286,
      22635,
      393,
      34651
    ],
    "label": "ml_signal",
    "reason": "Function calls another function, indicating a potential pattern of delegation or abstraction"
  },
  {
    "line": 218,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1801,
    "end_token": 1809,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 221,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1809,
    "end_token": 1809,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 224,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 1809,
    "end_token": 1828,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 227,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1828,
    "end_token": 1852,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1852,
    "end_token": 1866,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1866,
    "end_token": 1880,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1880,
    "end_token": 1894,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1894,
    "end_token": 1908,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1908,
    "end_token": 1922,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1922,
    "end_token": 1936,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of @property decorator to define a method as a property, promoting encapsulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1936,
    "end_token": 1950,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      11560,
      32652,
      1741,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator to define a method as a property, promoting encapsulation."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Use of a property to access a private attribute.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1950,
    "end_token": 1964,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      284,
      1895,
      257,
      2839,
      11688,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a property to access a private attribute."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a state change, useful for behavior modeling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1964,
    "end_token": 1978,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      1181,
      1487,
      11,
      4465,
      329,
      4069,
      21128,
      13
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a state change, useful for behavior modeling."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Method to change the state of the object.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1978,
    "end_token": 1992,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      1487,
      262,
      1181,
      286,
      262,
      2134,
      13
    ],
    "label": "best_practice",
    "reason": "Method to change the state of the object."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: State change to 'running' can be used to track object lifecycle.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 1992,
    "end_token": 2006,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1812,
      1487,
      284,
      705,
      20270,
      6,
      460,
      307,
      973,
      284,
      2610,
      2134,
      3868,
      47510,
      13
    ],
    "label": "ml_signal",
    "reason": "State change to 'running' can be used to track object lifecycle."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a state change, useful for behavior modeling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2006,
    "end_token": 2020,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      1181,
      1487,
      11,
      4465,
      329,
      4069,
      21128,
      13
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a state change, useful for behavior modeling."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Method to change the state of the object.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2020,
    "end_token": 2034,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      1487,
      262,
      1181,
      286,
      262,
      2134,
      13
    ],
    "label": "best_practice",
    "reason": "Method to change the state of the object."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: State change to 'completed' can be used to track object lifecycle.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2034,
    "end_token": 2048,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1812,
      1487,
      284,
      705,
      785,
      16838,
      6,
      460,
      307,
      973,
      284,
      2610,
      2134,
      3868,
      47510,
      13
    ],
    "label": "ml_signal",
    "reason": "State change to 'completed' can be used to track object lifecycle."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests a state change, useful for behavior modeling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2048,
    "end_token": 2062,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      257,
      1181,
      1487,
      11,
      4465,
      329,
      4069,
      21128,
      13
    ],
    "label": "ml_signal",
    "reason": "Method name suggests a state change, useful for behavior modeling."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u2705 Best Practice: Method to change the state of the object.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2062,
    "end_token": 2076,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      1487,
      262,
      1181,
      286,
      262,
      2134,
      13
    ],
    "label": "best_practice",
    "reason": "Method to change the state of the object."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: State change to 'failed' can be used to track object lifecycle.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2076,
    "end_token": 2090,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1812,
      1487,
      284,
      705,
      47904,
      6,
      460,
      307,
      973,
      284,
      2610,
      2134,
      3868,
      47510,
      13
    ],
    "label": "ml_signal",
    "reason": "State change to 'failed' can be used to track object lifecycle."
  },
  {
    "line": 221,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method returning a class name as a string",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2090,
    "end_token": 2090,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8024,
      257,
      1398,
      1438,
      355,
      257,
      4731
    ],
    "label": "ml_signal",
    "reason": "Method returning a class name as a string"
  },
  {
    "line": 224,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Use of @property decorator for getter method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 2090,
    "end_token": 2109,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      651,
      353,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for getter method"
  },
  {
    "line": 224,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 2109,
    "end_token": 2128,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting"
  },
  {
    "line": 227,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u2705 Best Practice: Consider using Tuple[Path, str] for type hinting instead of a list for multiple return types.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 2128,
    "end_token": 2152,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      309,
      29291,
      58,
      15235,
      11,
      965,
      60,
      329,
      2099,
      9254,
      278,
      2427,
      286,
      257,
      1351,
      329,
      3294,
      1441,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using Tuple[Path, str] for type hinting instead of a list for multiple return types."
  },
  {
    "line": 230,
    "text": "                pd.to_datetime(x) + pd.DateOffset(days=(45 if self.interval == PitCollector.INTERVAL_QUARTERLY else 90))",
    "annotation": "\ud83e\udde0 ML Signal: Entry point for script execution, common pattern for command-line tools.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      1462,
      62,
      19608,
      8079,
      7,
      87,
      8,
      1343,
      279,
      67,
      13,
      10430,
      34519,
      7,
      12545,
      16193,
      2231,
      611,
      2116,
      13,
      3849,
      2100,
      6624,
      16889,
      31337,
      273,
      13,
      41358,
      23428,
      62,
      10917,
      1503,
      5781,
      11319,
      2073,
      4101,
      4008
    ],
    "start_token": 2152,
    "end_token": 2207,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21617,
      966,
      329,
      4226,
      9706,
      11,
      2219,
      3912,
      329,
      3141,
      12,
      1370,
      4899,
      13
    ],
    "label": "ml_signal",
    "reason": "Entry point for script execution, common pattern for command-line tools."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Ensure that bs.login() handles authentication securely.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2207,
    "end_token": 2221,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      48987,
      326,
      275,
      82,
      13,
      38235,
      3419,
      17105,
      18239,
      30835,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Ensure that bs.login() handles authentication securely."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a login function, indicating authentication process.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2221,
    "end_token": 2235,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      17594,
      2163,
      11,
      12739,
      18239,
      1429,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a login function, indicating authentication process."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of the fire library to create a command-line interface.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2235,
    "end_token": 2249,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      262,
      2046,
      5888,
      284,
      2251,
      257,
      3141,
      12,
      1370,
      7071,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of the fire library to create a command-line interface."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Ensure that bs.logout() properly terminates the session and clears sensitive data.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2249,
    "end_token": 2263,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      48987,
      326,
      275,
      82,
      13,
      6404,
      448,
      3419,
      6105,
      5651,
      689,
      262,
      6246,
      290,
      37526,
      8564,
      1366,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Ensure that bs.logout() properly terminates the session and clears sensitive data."
  },
  {
    "line": 231,
    "text": "            ).date()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a logout function, indicating session management.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6739,
      4475,
      3419
    ],
    "start_token": 2263,
    "end_token": 2277,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2604,
      448,
      2163,
      11,
      12739,
      6246,
      4542,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a logout function, indicating session management."
  }
]