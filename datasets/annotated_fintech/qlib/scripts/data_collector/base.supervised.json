[
  {
    "line": 9,
    "text": "from pathlib import Path",
    "annotation": "\u2705 Best Practice: tqdm is a popular library for progress bars, indicating long-running operations.",
    "confidence": 0.5,
    "tokens": [
      6738,
      3108,
      8019,
      1330,
      10644
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      256,
      80,
      36020,
      318,
      257,
      2968,
      5888,
      329,
      4371,
      9210,
      11,
      12739,
      890,
      12,
      20270,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "tqdm is a popular library for progress bars, indicating long-running operations."
  },
  {
    "line": 11,
    "text": "from concurrent.futures import ProcessPoolExecutor",
    "annotation": "\u2705 Best Practice: loguru is a modern logging library, suggesting structured logging practices.",
    "confidence": 0.5,
    "tokens": [
      6738,
      24580,
      13,
      69,
      315,
      942,
      1330,
      10854,
      27201,
      23002,
      38409
    ],
    "start_token": 5,
    "end_token": 16,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2604,
      14717,
      318,
      257,
      3660,
      18931,
      5888,
      11,
      9524,
      20793,
      18931,
      6593,
      13
    ],
    "label": "best_practice",
    "reason": "loguru is a modern logging library, suggesting structured logging practices."
  },
  {
    "line": 13,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: joblib is often used for parallel processing, indicating performance optimization.",
    "confidence": 0.5,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 16,
    "end_token": 22,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      1693,
      8019,
      318,
      1690,
      973,
      329,
      10730,
      7587,
      11,
      12739,
      2854,
      23989,
      13
    ],
    "label": "best_practice",
    "reason": "joblib is often used for parallel processing, indicating performance optimization."
  },
  {
    "line": 15,
    "text": "from loguru import logger",
    "annotation": "\ud83e\udde0 ML Signal: qlib is a library for quantitative research, indicating a financial or ML application.",
    "confidence": 0.5,
    "tokens": [
      6738,
      2604,
      14717,
      1330,
      49706
    ],
    "start_token": 22,
    "end_token": 27,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      10662,
      8019,
      318,
      257,
      5888,
      329,
      26610,
      2267,
      11,
      12739,
      257,
      3176,
      393,
      10373,
      3586,
      13
    ],
    "label": "ml_signal",
    "reason": "qlib is a library for quantitative research, indicating a financial or ML application."
  },
  {
    "line": 13,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Use of class constants for configuration values improves readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 27,
    "end_token": 33,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      38491,
      329,
      8398,
      3815,
      19575,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of class constants for configuration values improves readability and maintainability."
  },
  {
    "line": 15,
    "text": "from loguru import logger",
    "annotation": "\u2705 Best Practice: Constants for flags improve code readability and reduce the risk of typos.",
    "confidence": 1.0,
    "tokens": [
      6738,
      2604,
      14717,
      1330,
      49706
    ],
    "start_token": 33,
    "end_token": 38,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      329,
      9701,
      2987,
      2438,
      1100,
      1799,
      290,
      4646,
      262,
      2526,
      286,
      1259,
      1930,
      13
    ],
    "label": "best_practice",
    "reason": "Constants for flags improve code readability and reduce the risk of typos."
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\u2705 Best Practice: Default timestamps are set using pandas, which is appropriate for handling date and time.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 38,
    "end_token": 38,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      4628,
      395,
      9430,
      389,
      900,
      1262,
      19798,
      292,
      11,
      543,
      318,
      5035,
      329,
      9041,
      3128,
      290,
      640,
      13
    ],
    "label": "best_practice",
    "reason": "Default timestamps are set using pandas, which is appropriate for handling date and time."
  },
  {
    "line": 20,
    "text": "class BaseCollector(abc.ABC):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using current datetime can lead to non-deterministic behavior in tests or logs.",
    "confidence": 1.0,
    "tokens": [
      4871,
      7308,
      31337,
      273,
      7,
      39305,
      13,
      24694,
      2599
    ],
    "start_token": 38,
    "end_token": 47,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1459,
      4818,
      8079,
      460,
      1085,
      284,
      1729,
      12,
      67,
      2357,
      49228,
      4069,
      287,
      5254,
      393,
      17259,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using current datetime can lead to non-deterministic behavior in tests or logs."
  },
  {
    "line": 22,
    "text": "    NORMAL_FLAG = \"NORMAL\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using current datetime can lead to non-deterministic behavior in tests or logs.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      25273,
      42126,
      62,
      38948,
      796,
      366,
      35510,
      42126,
      1
    ],
    "start_token": 47,
    "end_token": 59,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1459,
      4818,
      8079,
      460,
      1085,
      284,
      1729,
      12,
      67,
      2357,
      49228,
      4069,
      287,
      5254,
      393,
      17259,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using current datetime can lead to non-deterministic behavior in tests or logs."
  },
  {
    "line": 22,
    "text": "    NORMAL_FLAG = \"NORMAL\"",
    "annotation": "\u2705 Best Practice: Reusing constants avoids duplication and potential inconsistencies.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      25273,
      42126,
      62,
      38948,
      796,
      366,
      35510,
      42126,
      1
    ],
    "start_token": 59,
    "end_token": 71,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      3500,
      38491,
      30940,
      50124,
      290,
      2785,
      40467,
      13
    ],
    "label": "best_practice",
    "reason": "Reusing constants avoids duplication and potential inconsistencies."
  },
  {
    "line": 22,
    "text": "    NORMAL_FLAG = \"NORMAL\"",
    "annotation": "\u2705 Best Practice: Constants for intervals improve code readability and reduce the risk of typos.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      25273,
      42126,
      62,
      38948,
      796,
      366,
      35510,
      42126,
      1
    ],
    "start_token": 71,
    "end_token": 83,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      329,
      20016,
      2987,
      2438,
      1100,
      1799,
      290,
      4646,
      262,
      2526,
      286,
      1259,
      1930,
      13
    ],
    "label": "best_practice",
    "reason": "Constants for intervals improve code readability and reduce the risk of typos."
  },
  {
    "line": 56,
    "text": "        interval: str",
    "annotation": "\u2705 Best Practice: Use of Path object for file system paths improves code portability and readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      25,
      965
    ],
    "start_token": 83,
    "end_token": 93,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10644,
      2134,
      329,
      2393,
      1080,
      13532,
      19575,
      2438,
      2493,
      1799,
      290,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of Path object for file system paths improves code portability and readability"
  },
  {
    "line": 58,
    "text": "        start: str",
    "annotation": "\u2705 Best Practice: Creating directories with parents=True ensures that all necessary parent directories are created",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      25,
      965
    ],
    "start_token": 93,
    "end_token": 103,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30481,
      29196,
      351,
      3397,
      28,
      17821,
      19047,
      326,
      477,
      3306,
      2560,
      29196,
      389,
      2727
    ],
    "label": "best_practice",
    "reason": "Creating directories with parents=True ensures that all necessary parent directories are created"
  },
  {
    "line": 65,
    "text": "            using for debug, by default None",
    "annotation": "\u2705 Best Practice: Using max() to ensure check_data_length is non-negative improves robustness",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1262,
      329,
      14257,
      11,
      416,
      4277,
      6045
    ],
    "start_token": 103,
    "end_token": 121,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      3509,
      3419,
      284,
      4155,
      2198,
      62,
      7890,
      62,
      13664,
      318,
      1729,
      12,
      31591,
      19575,
      12373,
      1108
    ],
    "label": "best_practice",
    "reason": "Using max() to ensure check_data_length is non-negative improves robustness"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Sorting and deduplication of instrument list indicates data normalization",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 121,
    "end_token": 121,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      24707,
      290,
      4648,
      84,
      489,
      3299,
      286,
      8875,
      1351,
      9217,
      1366,
      3487,
      1634
    ],
    "label": "ml_signal",
    "reason": "Sorting and deduplication of instrument list indicates data normalization"
  },
  {
    "line": 73,
    "text": "        self.mini_symbol_map = {}",
    "annotation": "\ud83e\udde0 ML Signal: Slicing lists based on a parameter indicates dynamic data handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      45313,
      62,
      1837,
      23650,
      62,
      8899,
      796,
      23884
    ],
    "start_token": 121,
    "end_token": 138,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      677,
      278,
      8341,
      1912,
      319,
      257,
      11507,
      9217,
      8925,
      1366,
      9041
    ],
    "label": "ml_signal",
    "reason": "Slicing lists based on a parameter indicates dynamic data handling"
  },
  {
    "line": 76,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Catching broad exceptions can hide unexpected errors",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 138,
    "end_token": 138,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      327,
      19775,
      3154,
      13269,
      460,
      7808,
      10059,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Catching broad exceptions can hide unexpected errors"
  },
  {
    "line": 72,
    "text": "        self.max_collector_count = max_collector_count",
    "annotation": "\u2705 Best Practice: Type hint for start_datetime should use Union for better clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9806,
      62,
      33327,
      273,
      62,
      9127,
      796,
      3509,
      62,
      33327,
      273,
      62,
      9127
    ],
    "start_token": 138,
    "end_token": 160,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      329,
      923,
      62,
      19608,
      8079,
      815,
      779,
      4479,
      329,
      1365,
      16287
    ],
    "label": "best_practice",
    "reason": "Type hint for start_datetime should use Union for better clarity"
  },
  {
    "line": 73,
    "text": "        self.mini_symbol_map = {}",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pd.Timestamp to convert string to timestamp",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      45313,
      62,
      1837,
      23650,
      62,
      8899,
      796,
      23884
    ],
    "start_token": 160,
    "end_token": 177,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      279,
      67,
      13,
      14967,
      27823,
      284,
      10385,
      4731,
      284,
      41033
    ],
    "label": "ml_signal",
    "reason": "Usage of pd.Timestamp to convert string to timestamp"
  },
  {
    "line": 73,
    "text": "        self.mini_symbol_map = {}",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if start_datetime is not a valid date string",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      45313,
      62,
      1837,
      23650,
      62,
      8899,
      796,
      23884
    ],
    "start_token": 177,
    "end_token": 194,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      923,
      62,
      19608,
      8079,
      318,
      407,
      257,
      4938,
      3128,
      4731
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if start_datetime is not a valid date string"
  },
  {
    "line": 79,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic attribute access pattern using getattr",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 194,
    "end_token": 194,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      11688,
      1895,
      3912,
      1262,
      651,
      35226
    ],
    "label": "ml_signal",
    "reason": "Dynamic attribute access pattern using getattr"
  },
  {
    "line": 78,
    "text": "        self.end_datetime = self.normalize_end_datetime(end)",
    "annotation": "\u2705 Best Practice: Type hinting with a list should use List from typing module",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      11265,
      1096,
      62,
      437,
      62,
      19608,
      8079,
      7,
      437,
      8
    ],
    "start_token": 194,
    "end_token": 220,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      351,
      257,
      1351,
      815,
      779,
      7343,
      422,
      19720,
      8265
    ],
    "label": "best_practice",
    "reason": "Type hinting with a list should use List from typing module"
  },
  {
    "line": 79,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of pd.Timestamp for datetime normalization",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 220,
    "end_token": 220,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      279,
      67,
      13,
      14967,
      27823,
      329,
      4818,
      8079,
      3487,
      1634
    ],
    "label": "ml_signal",
    "reason": "Use of pd.Timestamp for datetime normalization"
  },
  {
    "line": 85,
    "text": "            except Exception as e:",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic attribute access pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      35528,
      355,
      304,
      25
    ],
    "start_token": 220,
    "end_token": 236,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      11688,
      1895,
      3912
    ],
    "label": "ml_signal",
    "reason": "Dynamic attribute access pattern"
  },
  {
    "line": 86,
    "text": "                logger.warning(f\"Cannot use limit_nums={limit_nums}, the parameter will be ignored\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of abstract method indicating a design pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      34,
      34574,
      779,
      4179,
      62,
      77,
      5700,
      34758,
      32374,
      62,
      77,
      5700,
      5512,
      262,
      11507,
      481,
      307,
      9514,
      4943
    ],
    "start_token": 236,
    "end_token": 276,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      12531,
      2446,
      12739,
      257,
      1486,
      3912
    ],
    "label": "ml_signal",
    "reason": "Use of abstract method indicating a design pattern"
  },
  {
    "line": 86,
    "text": "                logger.warning(f\"Cannot use limit_nums={limit_nums}, the parameter will be ignored\")",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that this method should be overridden.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      34,
      34574,
      779,
      4179,
      62,
      77,
      5700,
      34758,
      32374,
      62,
      77,
      5700,
      5512,
      262,
      11507,
      481,
      307,
      9514,
      4943
    ],
    "start_token": 276,
    "end_token": 316,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      428,
      2446,
      815,
      307,
      23170,
      4651,
      13
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that this method should be overridden."
  },
  {
    "line": 89,
    "text": "        return (",
    "annotation": "\u2705 Best Practice: Using @abc.abstractmethod enforces that subclasses must implement this method.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      357
    ],
    "start_token": 316,
    "end_token": 325,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2488,
      39305,
      13,
      397,
      8709,
      24396,
      551,
      27087,
      326,
      850,
      37724,
      1276,
      3494,
      428,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Using @abc.abstractmethod enforces that subclasses must implement this method."
  },
  {
    "line": 90,
    "text": "            pd.Timestamp(str(start_datetime))",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that this method should be overridden.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      14967,
      27823,
      7,
      2536,
      7,
      9688,
      62,
      19608,
      8079,
      4008
    ],
    "start_token": 325,
    "end_token": 349,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      428,
      2446,
      815,
      307,
      23170,
      4651,
      13
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that this method should be overridden."
  },
  {
    "line": 92,
    "text": "            else getattr(self, f\"DEFAULT_START_DATETIME_{self.interval.upper()}\")",
    "annotation": "\u2705 Best Practice: Using abc.abstractmethod enforces that subclasses must implement this method.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      651,
      35226,
      7,
      944,
      11,
      277,
      1,
      7206,
      38865,
      62,
      2257,
      7227,
      62,
      35,
      1404,
      2767,
      12789,
      23330,
      944,
      13,
      3849,
      2100,
      13,
      45828,
      3419,
      92,
      4943
    ],
    "start_token": 349,
    "end_token": 388,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      450,
      66,
      13,
      397,
      8709,
      24396,
      551,
      27087,
      326,
      850,
      37724,
      1276,
      3494,
      428,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Using abc.abstractmethod enforces that subclasses must implement this method."
  },
  {
    "line": 95,
    "text": "    def normalize_end_datetime(self, end_datetime: [str, pd.Timestamp] = None):",
    "annotation": "\u2705 Best Practice: Docstring provides clear documentation of parameters and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      437,
      62,
      19608,
      8079,
      7,
      944,
      11,
      886,
      62,
      19608,
      8079,
      25,
      685,
      2536,
      11,
      279,
      67,
      13,
      14967,
      27823,
      60,
      796,
      6045,
      2599
    ],
    "start_token": 388,
    "end_token": 419,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      10314,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear documentation of parameters and return type"
  },
  {
    "line": 108,
    "text": "        \"\"\"normalize symbol\"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      11265,
      1096,
      6194,
      37811
    ],
    "start_token": 419,
    "end_token": 431,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation"
  },
  {
    "line": 108,
    "text": "        \"\"\"normalize symbol\"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using time.sleep can lead to performance issues if not managed properly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      11265,
      1096,
      6194,
      37811
    ],
    "start_token": 431,
    "end_token": 443,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      640,
      13,
      42832,
      460,
      1085,
      284,
      2854,
      2428,
      611,
      407,
      5257,
      6105,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using time.sleep can lead to performance issues if not managed properly."
  },
  {
    "line": 109,
    "text": "        raise NotImplementedError(\"rewrite normalize_symbol\")",
    "annotation": "\u2705 Best Practice: Ensure that self.delay is validated to prevent excessively long sleep times.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7203,
      1809,
      6525,
      3487,
      1096,
      62,
      1837,
      23650,
      4943
    ],
    "start_token": 443,
    "end_token": 465,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      2116,
      13,
      40850,
      318,
      31031,
      284,
      2948,
      40437,
      890,
      3993,
      1661,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that self.delay is validated to prevent excessively long sleep times."
  },
  {
    "line": 111,
    "text": "    @abc.abstractmethod",
    "annotation": "\u2705 Best Practice: Docstring provides parameter information, enhancing code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      39305,
      13,
      397,
      8709,
      24396
    ],
    "start_token": 465,
    "end_token": 474,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      11507,
      1321,
      11,
      27496,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Docstring provides parameter information, enhancing code readability and maintainability"
  },
  {
    "line": 117,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Method calls like self.sleep() can indicate timing or delay patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 474,
    "end_token": 482,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      3848,
      588,
      2116,
      13,
      42832,
      3419,
      460,
      7603,
      10576,
      393,
      5711,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method calls like self.sleep() can indicate timing or delay patterns"
  },
  {
    "line": 119,
    "text": "        symbol: str",
    "annotation": "\ud83e\udde0 ML Signal: Collecting data with self.get_data() can indicate data retrieval patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      25,
      965
    ],
    "start_token": 482,
    "end_token": 492,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9745,
      278,
      1366,
      351,
      2116,
      13,
      1136,
      62,
      7890,
      3419,
      460,
      7603,
      1366,
      45069,
      7572
    ],
    "label": "ml_signal",
    "reason": "Collecting data with self.get_data() can indicate data retrieval patterns"
  },
  {
    "line": 122,
    "text": "        start_datetime: pd.Timestamp",
    "annotation": "\ud83e\udde0 ML Signal: Conditional checks on data length can indicate data validation or filtering patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 492,
    "end_token": 509,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      8794,
      319,
      1366,
      4129,
      460,
      7603,
      1366,
      21201,
      393,
      25431,
      7572
    ],
    "label": "ml_signal",
    "reason": "Conditional checks on data length can indicate data validation or filtering patterns"
  },
  {
    "line": 124,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Caching data with self.cache_small_data() can indicate data storage or optimization patterns",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 509,
    "end_token": 509,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      8103,
      1366,
      351,
      2116,
      13,
      23870,
      62,
      17470,
      62,
      7890,
      3419,
      460,
      7603,
      1366,
      6143,
      393,
      23989,
      7572
    ],
    "label": "ml_signal",
    "reason": "Caching data with self.cache_small_data() can indicate data storage or optimization patterns"
  },
  {
    "line": 125,
    "text": "        Returns",
    "annotation": "\ud83e\udde0 ML Signal: Using flags like self.NORMAL_FLAG can indicate status or state management patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16409
    ],
    "start_token": 509,
    "end_token": 517,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      9701,
      588,
      2116,
      13,
      35510,
      42126,
      62,
      38948,
      460,
      7603,
      3722,
      393,
      1181,
      4542,
      7572
    ],
    "label": "ml_signal",
    "reason": "Using flags like self.NORMAL_FLAG can indicate status or state management patterns"
  },
  {
    "line": 125,
    "text": "        Returns",
    "annotation": "\ud83e\udde0 ML Signal: Saving data with self.save_instrument() can indicate data persistence patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16409
    ],
    "start_token": 517,
    "end_token": 525,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      34689,
      1366,
      351,
      2116,
      13,
      21928,
      62,
      259,
      43872,
      3419,
      460,
      7603,
      1366,
      30802,
      7572
    ],
    "label": "ml_signal",
    "reason": "Saving data with self.save_instrument() can indicate data persistence patterns"
  },
  {
    "line": 133,
    "text": "        time.sleep(self.delay)",
    "annotation": "\ud83e\udde0 ML Signal: Returning result values can indicate outcome or status reporting patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      13,
      42832,
      7,
      944,
      13,
      40850,
      8
    ],
    "start_token": 525,
    "end_token": 540,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      1255,
      3815,
      460,
      7603,
      8055,
      393,
      3722,
      6447,
      7572
    ],
    "label": "ml_signal",
    "reason": "Returning result values can indicate outcome or status reporting patterns"
  },
  {
    "line": 133,
    "text": "        time.sleep(self.delay)",
    "annotation": "\u2705 Best Practice: Check for None or empty DataFrame to avoid unnecessary processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      13,
      42832,
      7,
      944,
      13,
      40850,
      8
    ],
    "start_token": 540,
    "end_token": 555,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6045,
      393,
      6565,
      6060,
      19778,
      284,
      3368,
      13114,
      7587
    ],
    "label": "best_practice",
    "reason": "Check for None or empty DataFrame to avoid unnecessary processing"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Normalizing input data is a common preprocessing step",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 555,
    "end_token": 555,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      14435,
      2890,
      5128,
      1366,
      318,
      257,
      2219,
      662,
      36948,
      2239
    ],
    "label": "ml_signal",
    "reason": "Normalizing input data is a common preprocessing step"
  },
  {
    "line": 139,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Converting code to filename is a common pattern for file operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 555,
    "end_token": 564,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      2438,
      284,
      29472,
      318,
      257,
      2219,
      3912,
      329,
      2393,
      4560
    ],
    "label": "ml_signal",
    "reason": "Converting code to filename is a common pattern for file operations"
  },
  {
    "line": 141,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Using pathlib for file paths is a modern Python practice",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 564,
    "end_token": 564,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      3108,
      8019,
      329,
      2393,
      13532,
      318,
      257,
      3660,
      11361,
      3357
    ],
    "label": "ml_signal",
    "reason": "Using pathlib for file paths is a modern Python practice"
  },
  {
    "line": 143,
    "text": "        self.sleep()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Overwriting the \"symbol\" column without checking its existence",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      42832,
      3419
    ],
    "start_token": 564,
    "end_token": 575,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3827,
      16502,
      262,
      366,
      1837,
      23650,
      1,
      5721,
      1231,
      10627,
      663,
      6224
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Overwriting the \"symbol\" column without checking its existence"
  },
  {
    "line": 145,
    "text": "        _result = self.NORMAL_FLAG",
    "annotation": "\u2705 Best Practice: Check if file exists before reading to avoid FileNotFoundError",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      2116,
      13,
      35510,
      42126,
      62,
      38948
    ],
    "start_token": 575,
    "end_token": 591,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      2393,
      7160,
      878,
      3555,
      284,
      3368,
      9220,
      3673,
      21077,
      12331
    ],
    "label": "best_practice",
    "reason": "Check if file exists before reading to avoid FileNotFoundError"
  },
  {
    "line": 147,
    "text": "            _result = self.cache_small_data(symbol, df)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): No error handling for file read operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      2116,
      13,
      23870,
      62,
      17470,
      62,
      7890,
      7,
      1837,
      23650,
      11,
      47764,
      8
    ],
    "start_token": 591,
    "end_token": 618,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1400,
      4049,
      9041,
      329,
      2393,
      1100,
      4560
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "No error handling for file read operations"
  },
  {
    "line": 149,
    "text": "            self.save_instrument(symbol, df)",
    "annotation": "\ud83e\udde0 ML Signal: Concatenating DataFrames is a common data manipulation operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      21928,
      62,
      259,
      43872,
      7,
      1837,
      23650,
      11,
      47764,
      8
    ],
    "start_token": 618,
    "end_token": 641,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1482,
      9246,
      268,
      803,
      6060,
      35439,
      318,
      257,
      2219,
      1366,
      17512,
      4905
    ],
    "label": "ml_signal",
    "reason": "Concatenating DataFrames is a common data manipulation operation"
  },
  {
    "line": 151,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): No error handling for file write operations",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 641,
    "end_token": 641,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1400,
      4049,
      9041,
      329,
      2393,
      3551,
      4560
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "No error handling for file write operations"
  },
  {
    "line": 145,
    "text": "        _result = self.NORMAL_FLAG",
    "annotation": "\ud83e\udde0 ML Signal: Function checks the length of data and caches it based on a condition",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      2116,
      13,
      35510,
      42126,
      62,
      38948
    ],
    "start_token": 641,
    "end_token": 657,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      8794,
      262,
      4129,
      286,
      1366,
      290,
      50177,
      340,
      1912,
      319,
      257,
      4006
    ],
    "label": "ml_signal",
    "reason": "Function checks the length of data and caches it based on a condition"
  },
  {
    "line": 147,
    "text": "            _result = self.cache_small_data(symbol, df)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential logging of sensitive information",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      2116,
      13,
      23870,
      62,
      17470,
      62,
      7890,
      7,
      1837,
      23650,
      11,
      47764,
      8
    ],
    "start_token": 657,
    "end_token": 684,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      18931,
      286,
      8564,
      1321
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential logging of sensitive information"
  },
  {
    "line": 149,
    "text": "            self.save_instrument(symbol, df)",
    "annotation": "\u2705 Best Practice: Use setdefault to initialize a list if the key is not present",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      21928,
      62,
      259,
      43872,
      7,
      1837,
      23650,
      11,
      47764,
      8
    ],
    "start_token": 684,
    "end_token": 707,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      900,
      12286,
      284,
      41216,
      257,
      1351,
      611,
      262,
      1994,
      318,
      407,
      1944
    ],
    "label": "best_practice",
    "reason": "Use setdefault to initialize a list if the key is not present"
  },
  {
    "line": 151,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Appends a copy of the dataframe to a list in a dictionary",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 707,
    "end_token": 707,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      2412,
      257,
      4866,
      286,
      262,
      1366,
      14535,
      284,
      257,
      1351,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Appends a copy of the dataframe to a list in a dictionary"
  },
  {
    "line": 155,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Removes symbol from cache if it exists",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 707,
    "end_token": 715,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3982,
      5241,
      6194,
      422,
      12940,
      611,
      340,
      7160
    ],
    "label": "ml_signal",
    "reason": "Removes symbol from cache if it exists"
  },
  {
    "line": 156,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Use of parallel processing with joblib for performance optimization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 715,
    "end_token": 724,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      10730,
      7587,
      351,
      1693,
      8019,
      329,
      2854,
      23989
    ],
    "label": "ml_signal",
    "reason": "Use of parallel processing with joblib for performance optimization"
  },
  {
    "line": 159,
    "text": "        df : pd.DataFrame",
    "annotation": "\ud83e\udde0 ML Signal: Use of delayed function for lazy evaluation in parallel processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      1058,
      279,
      67,
      13,
      6601,
      19778
    ],
    "start_token": 724,
    "end_token": 738,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      11038,
      2163,
      329,
      16931,
      12660,
      287,
      10730,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of delayed function for lazy evaluation in parallel processing"
  },
  {
    "line": 164,
    "text": "            return",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of print statement for logging, consider using a logging framework",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 738,
    "end_token": 750,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      3601,
      2643,
      329,
      18931,
      11,
      2074,
      1262,
      257,
      18931,
      9355
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of print statement for logging, consider using a logging framework"
  },
  {
    "line": 166,
    "text": "        symbol = self.normalize_symbol(symbol)",
    "annotation": "\u2705 Best Practice: Use of logging framework for better control over log levels and outputs",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      2116,
      13,
      11265,
      1096,
      62,
      1837,
      23650,
      7,
      1837,
      23650,
      8
    ],
    "start_token": 750,
    "end_token": 770,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      9355,
      329,
      1365,
      1630,
      625,
      2604,
      2974,
      290,
      23862
    ],
    "label": "best_practice",
    "reason": "Use of logging framework for better control over log levels and outputs"
  },
  {
    "line": 168,
    "text": "        instrument_path = self.save_dir.joinpath(f\"{symbol}.csv\")",
    "annotation": "\u2705 Best Practice: Use of logging framework for better control over log levels and outputs",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8875,
      62,
      6978,
      796,
      2116,
      13,
      21928,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      1837,
      23650,
      27422,
      40664,
      4943
    ],
    "start_token": 770,
    "end_token": 798,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      9355,
      329,
      1365,
      1630,
      625,
      2604,
      2974,
      290,
      23862
    ],
    "label": "best_practice",
    "reason": "Use of logging framework for better control over log levels and outputs"
  },
  {
    "line": 171,
    "text": "            _old_df = pd.read_csv(instrument_path)",
    "annotation": "\u2705 Best Practice: Use of set to remove duplicates before sorting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      727,
      62,
      7568,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      259,
      43872,
      62,
      6978,
      8
    ],
    "start_token": 798,
    "end_token": 826,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      900,
      284,
      4781,
      14184,
      16856,
      878,
      29407
    ],
    "label": "best_practice",
    "reason": "Use of set to remove duplicates before sorting"
  },
  {
    "line": 169,
    "text": "        df[\"symbol\"] = symbol",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      1837,
      23650,
      8973,
      796,
      6194
    ],
    "start_token": 826,
    "end_token": 840,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 175,
    "text": "    def cache_small_data(self, symbol, df):",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      12940,
      62,
      17470,
      62,
      7890,
      7,
      944,
      11,
      6194,
      11,
      47764,
      2599
    ],
    "start_token": 840,
    "end_token": 856,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 178,
    "text": "            _temp = self.mini_symbol_map.setdefault(symbol, [])",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      29510,
      796,
      2116,
      13,
      45313,
      62,
      1837,
      23650,
      62,
      8899,
      13,
      2617,
      12286,
      7,
      1837,
      23650,
      11,
      685,
      12962
    ],
    "start_token": 856,
    "end_token": 887,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 181,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potentially large data concatenation without memory management",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 887,
    "end_token": 896,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6902,
      3746,
      1588,
      1366,
      1673,
      36686,
      341,
      1231,
      4088,
      4542
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potentially large data concatenation without memory management"
  },
  {
    "line": 184,
    "text": "            return self.NORMAL_FLAG",
    "annotation": "\u2705 Best Practice: Use drop_duplicates to ensure data integrity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      35510,
      42126,
      62,
      38948
    ],
    "start_token": 896,
    "end_token": 914,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      4268,
      62,
      646,
      489,
      16856,
      284,
      4155,
      1366,
      11540
    ],
    "label": "best_practice",
    "reason": "Use drop_duplicates to ensure data integrity"
  },
  {
    "line": 186,
    "text": "    def _collector(self, instrument_list):",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      33327,
      273,
      7,
      944,
      11,
      8875,
      62,
      4868,
      2599
    ],
    "start_token": 914,
    "end_token": 928,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 186,
    "text": "    def _collector(self, instrument_list):",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for monitoring or debugging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      33327,
      273,
      7,
      944,
      11,
      8875,
      62,
      4868,
      2599
    ],
    "start_token": 928,
    "end_token": 942,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9904,
      393,
      28769
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for monitoring or debugging"
  },
  {
    "line": 184,
    "text": "            return self.NORMAL_FLAG",
    "annotation": "\u2705 Best Practice: Inheriting from abc.ABC to define an abstract base class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      35510,
      42126,
      62,
      38948
    ],
    "start_token": 942,
    "end_token": 960,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      450,
      66,
      13,
      24694,
      284,
      8160,
      281,
      12531,
      2779,
      1398
    ],
    "label": "best_practice",
    "reason": "Inheriting from abc.ABC to define an abstract base class"
  },
  {
    "line": 186,
    "text": "    def _collector(self, instrument_list):",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      33327,
      273,
      7,
      944,
      11,
      8875,
      62,
      4868,
      2599
    ],
    "start_token": 960,
    "end_token": 974,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 197,
    "text": "        error_symbol.extend(self.mini_symbol_map.keys())",
    "annotation": "\u2705 Best Practice: Storing additional keyword arguments for future extensibility",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4049,
      62,
      1837,
      23650,
      13,
      2302,
      437,
      7,
      944,
      13,
      45313,
      62,
      1837,
      23650,
      62,
      8899,
      13,
      13083,
      28955
    ],
    "start_token": 974,
    "end_token": 1000,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      520,
      3255,
      3224,
      21179,
      7159,
      329,
      2003,
      1070,
      641,
      2247
    ],
    "label": "best_practice",
    "reason": "Storing additional keyword arguments for future extensibility"
  },
  {
    "line": 199,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of internal state with method call",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1000,
    "end_token": 1000,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      5387,
      1181,
      351,
      2446,
      869
    ],
    "label": "ml_signal",
    "reason": "Initialization of internal state with method call"
  },
  {
    "line": 199,
    "text": "",
    "annotation": "\u2705 Best Practice: Define a method signature with type hints for better readability and maintainability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1000,
    "end_token": 1000,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      2446,
      9877,
      351,
      2099,
      20269,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Define a method signature with type hints for better readability and maintainability"
  },
  {
    "line": 200,
    "text": "    def collector_data(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising NotImplementedError without a message can be less informative for debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      22967,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 1000,
    "end_token": 1010,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      257,
      3275,
      460,
      307,
      1342,
      30304,
      329,
      28769
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising NotImplementedError without a message can be less informative for debugging"
  },
  {
    "line": 203,
    "text": "        instrument_list = self.instrument_list",
    "annotation": "\u2705 Best Practice: Use of abstractmethod decorator to enforce implementation in subclasses",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8875,
      62,
      4868,
      796,
      2116,
      13,
      259,
      43872,
      62,
      4868
    ],
    "start_token": 1010,
    "end_token": 1027,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      12531,
      24396,
      11705,
      1352,
      284,
      4605,
      7822,
      287,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Use of abstractmethod decorator to enforce implementation in subclasses"
  },
  {
    "line": 202,
    "text": "        logger.info(\"start collector data......\")",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      9688,
      22967,
      1366,
      16317,
      4943
    ],
    "start_token": 1027,
    "end_token": 1043,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 205,
    "text": "            if not instrument_list:",
    "annotation": "\u2705 Best Practice: Use of docstring to describe the function's purpose",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      8875,
      62,
      4868,
      25
    ],
    "start_token": 1043,
    "end_token": 1060,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Use of docstring to describe the function's purpose"
  },
  {
    "line": 234,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential directory traversal if source_dir or target_dir is user-controlled",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1060,
    "end_token": 1060,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      8619,
      33038,
      282,
      611,
      2723,
      62,
      15908,
      393,
      2496,
      62,
      15908,
      318,
      2836,
      12,
      14401
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential directory traversal if source_dir or target_dir is user-controlled"
  },
  {
    "line": 236,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential directory traversal if source_dir or target_dir is user-controlled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1060,
    "end_token": 1084,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      8619,
      33038,
      282,
      611,
      2723,
      62,
      15908,
      393,
      2496,
      62,
      15908,
      318,
      2836,
      12,
      14401
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential directory traversal if source_dir or target_dir is user-controlled"
  },
  {
    "line": 238,
    "text": "        raise NotImplementedError(\"\")",
    "annotation": "\u2705 Best Practice: Ensure target directory exists, preventing runtime errors",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7203,
      4943
    ],
    "start_token": 1084,
    "end_token": 1099,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      2496,
      8619,
      7160,
      11,
      12174,
      19124,
      8563
    ],
    "label": "best_practice",
    "reason": "Ensure target directory exists, preventing runtime errors"
  },
  {
    "line": 244,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a class instance with dynamic parameters",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1099,
    "end_token": 1099,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      1398,
      4554,
      351,
      8925,
      10007
    ],
    "label": "ml_signal",
    "reason": "Usage of a class instance with dynamic parameters"
  },
  {
    "line": 245,
    "text": "",
    "annotation": "\u2705 Best Practice: Convert file_path to Path object to ensure consistent path handling",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1099,
    "end_token": 1099,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      2393,
      62,
      6978,
      284,
      10644,
      2134,
      284,
      4155,
      6414,
      3108,
      9041
    ],
    "label": "best_practice",
    "reason": "Convert file_path to Path object to ensure consistent path handling"
  },
  {
    "line": 247,
    "text": "    def __init__(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of internal pandas API, which may indicate advanced data manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 1099,
    "end_token": 1107,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      5387,
      19798,
      292,
      7824,
      11,
      543,
      743,
      7603,
      6190,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Usage of internal pandas API, which may indicate advanced data manipulation"
  },
  {
    "line": 249,
    "text": "        source_dir: [str, Path],",
    "annotation": "\u2705 Best Practice: Copying default_na to avoid modifying the original list",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2723,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357
    ],
    "start_token": 1107,
    "end_token": 1123,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6955,
      1112,
      4277,
      62,
      2616,
      284,
      3368,
      30620,
      262,
      2656,
      1351
    ],
    "label": "best_practice",
    "reason": "Copying default_na to avoid modifying the original list"
  },
  {
    "line": 250,
    "text": "        target_dir: [str, Path],",
    "annotation": "\u2705 Best Practice: Removing \"NA\" from symbol_na to customize NA handling",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2496,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357
    ],
    "start_token": 1123,
    "end_token": 1139,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3982,
      5165,
      366,
      4535,
      1,
      422,
      6194,
      62,
      2616,
      284,
      24184,
      11746,
      9041
    ],
    "label": "best_practice",
    "reason": "Removing \"NA\" from symbol_na to customize NA handling"
  },
  {
    "line": 250,
    "text": "        target_dir: [str, Path],",
    "annotation": "\ud83e\udde0 ML Signal: Reading only the header of the CSV to get column names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2496,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357
    ],
    "start_token": 1139,
    "end_token": 1155,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      691,
      262,
      13639,
      286,
      262,
      44189,
      284,
      651,
      5721,
      3891
    ],
    "label": "ml_signal",
    "reason": "Reading only the header of the CSV to get column names"
  },
  {
    "line": 256,
    "text": "    ):",
    "annotation": "\ud83e\udde0 ML Signal: Conditional NA value handling based on column names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 1155,
    "end_token": 1159,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      11746,
      1988,
      9041,
      1912,
      319,
      5721,
      3891
    ],
    "label": "ml_signal",
    "reason": "Conditional NA value handling based on column names"
  },
  {
    "line": 262,
    "text": "            The directory where the raw data collected from the Internet is saved",
    "annotation": "\ud83e\udde0 ML Signal: Normalizing data using a custom normalization object",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      8619,
      810,
      262,
      8246,
      1366,
      7723,
      422,
      262,
      4455,
      318,
      7448
    ],
    "start_token": 1159,
    "end_token": 1182,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      14435,
      2890,
      1366,
      1262,
      257,
      2183,
      3487,
      1634,
      2134
    ],
    "label": "ml_signal",
    "reason": "Normalizing data using a custom normalization object"
  },
  {
    "line": 264,
    "text": "            Directory for normalize data",
    "annotation": "\u2705 Best Practice: Check if DataFrame is not None and not empty before processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      27387,
      329,
      3487,
      1096,
      1366
    ],
    "start_token": 1182,
    "end_token": 1198,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      6060,
      19778,
      318,
      407,
      6045,
      290,
      407,
      6565,
      878,
      7587
    ],
    "label": "best_practice",
    "reason": "Check if DataFrame is not None and not empty before processing"
  },
  {
    "line": 266,
    "text": "            normalize class",
    "annotation": "\u2705 Best Practice: Check if _end_date is not None before applying date filter",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3487,
      1096,
      1398
    ],
    "start_token": 1198,
    "end_token": 1212,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      4808,
      437,
      62,
      4475,
      318,
      407,
      6045,
      878,
      11524,
      3128,
      8106
    ],
    "label": "best_practice",
    "reason": "Check if _end_date is not None before applying date filter"
  },
  {
    "line": 268,
    "text": "            Concurrent number, default is 16",
    "annotation": "\ud83e\udde0 ML Signal: Filtering DataFrame based on date field",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      13223,
      6657,
      1271,
      11,
      4277,
      318,
      1467
    ],
    "start_token": 1212,
    "end_token": 1230,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      6060,
      19778,
      1912,
      319,
      3128,
      2214
    ],
    "label": "ml_signal",
    "reason": "Filtering DataFrame based on date field"
  },
  {
    "line": 271,
    "text": "        symbol_field_name: str",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if _target_dir is not validated or sanitized",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 1230,
    "end_token": 1244,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4808,
      16793,
      62,
      15908,
      318,
      407,
      31031,
      393,
      5336,
      36951
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if _target_dir is not validated or sanitized"
  },
  {
    "line": 263,
    "text": "        target_dir: str or Path",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2496,
      62,
      15908,
      25,
      965,
      393,
      10644
    ],
    "start_token": 1244,
    "end_token": 1258,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern"
  },
  {
    "line": 265,
    "text": "        normalize_class: Type[YahooNormalize]",
    "annotation": "\u2705 Best Practice: Use of ProcessPoolExecutor for parallel processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3487,
      1096,
      62,
      4871,
      25,
      5994,
      58,
      56,
      12992,
      26447,
      1096,
      60
    ],
    "start_token": 1258,
    "end_token": 1277,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      7587
    ],
    "label": "best_practice",
    "reason": "Use of ProcessPoolExecutor for parallel processing"
  },
  {
    "line": 267,
    "text": "        max_workers: int",
    "annotation": "\ud83e\udde0 ML Signal: Use of glob to list files",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      22896,
      25,
      493
    ],
    "start_token": 1277,
    "end_token": 1289,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      15095,
      284,
      1351,
      3696
    ],
    "label": "ml_signal",
    "reason": "Use of glob to list files"
  },
  {
    "line": 269,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Use of tqdm for progress tracking",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 1289,
    "end_token": 1303,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      256,
      80,
      36020,
      329,
      4371,
      9646
    ],
    "label": "best_practice",
    "reason": "Use of tqdm for progress tracking"
  },
  {
    "line": 271,
    "text": "        symbol_field_name: str",
    "annotation": "\u2705 Best Practice: Updating progress bar within loop",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 1303,
    "end_token": 1317,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3205,
      38734,
      4371,
      2318,
      1626,
      9052
    ],
    "label": "best_practice",
    "reason": "Updating progress bar within loop"
  },
  {
    "line": 269,
    "text": "        date_field_name: str",
    "annotation": "\u2705 Best Practice: Inheriting from abc.ABC to define an abstract base class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 1317,
    "end_token": 1331,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      450,
      66,
      13,
      24694,
      284,
      8160,
      281,
      12531,
      2779,
      1398
    ],
    "label": "best_practice",
    "reason": "Inheriting from abc.ABC to define an abstract base class"
  },
  {
    "line": 286,
    "text": "        )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Directory creation without proper permissions handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1331,
    "end_token": 1339,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      27387,
      6282,
      1231,
      1774,
      21627,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Directory creation without proper permissions handling"
  },
  {
    "line": 291,
    "text": "        # some symbol_field values such as TRUE, NA are decoded as True(bool), NaN(np.float) by pandas default csv parsing.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Directory creation without proper permissions handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      617,
      6194,
      62,
      3245,
      3815,
      884,
      355,
      26751,
      11,
      11746,
      389,
      875,
      9043,
      355,
      6407,
      7,
      30388,
      828,
      11013,
      45,
      7,
      37659,
      13,
      22468,
      8,
      416,
      19798,
      292,
      4277,
      269,
      21370,
      32096,
      13
    ],
    "start_token": 1339,
    "end_token": 1380,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      27387,
      6282,
      1231,
      1774,
      21627,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Directory creation without proper permissions handling"
  },
  {
    "line": 293,
    "text": "        default_na = pd._libs.parsers.STR_NA_VALUES  # pylint: disable=I1101",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Dynamic import can lead to code execution vulnerabilities",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4277,
      62,
      2616,
      796,
      279,
      67,
      13557,
      8019,
      82,
      13,
      79,
      945,
      364,
      13,
      18601,
      62,
      4535,
      62,
      23428,
      35409,
      220,
      1303,
      279,
      2645,
      600,
      25,
      15560,
      28,
      40,
      1157,
      486
    ],
    "start_token": 1380,
    "end_token": 1418,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      26977,
      1330,
      460,
      1085,
      284,
      2438,
      9706,
      23805
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Dynamic import can lead to code execution vulnerabilities"
  },
  {
    "line": 296,
    "text": "        columns = pd.read_csv(file_path, nrows=0).columns",
    "annotation": "\ud83e\udde0 ML Signal: Usage of max_workers parameter for concurrency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      7753,
      62,
      6978,
      11,
      299,
      8516,
      28,
      15,
      737,
      28665,
      82
    ],
    "start_token": 1418,
    "end_token": 1445,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      3509,
      62,
      22896,
      11507,
      329,
      1673,
      13382
    ],
    "label": "ml_signal",
    "reason": "Usage of max_workers parameter for concurrency"
  },
  {
    "line": 297,
    "text": "        df = pd.read_csv(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of interval parameter for scheduling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7
    ],
    "start_token": 1445,
    "end_token": 1461,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      16654,
      11507,
      329,
      26925
    ],
    "label": "ml_signal",
    "reason": "Usage of interval parameter for scheduling"
  },
  {
    "line": 297,
    "text": "        df = pd.read_csv(",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a common pattern for abstract methods",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7
    ],
    "start_token": 1461,
    "end_token": 1477,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      2219,
      3912,
      329,
      12531,
      5050
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a common pattern for abstract methods"
  },
  {
    "line": 300,
    "text": "            keep_default_na=False,",
    "annotation": "\u2705 Best Practice: Using @property decorator for abstract methods is a good practice for defining abstract properties",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1394,
      62,
      12286,
      62,
      2616,
      28,
      25101,
      11
    ],
    "start_token": 1477,
    "end_token": 1496,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2488,
      26745,
      11705,
      1352,
      329,
      12531,
      5050,
      318,
      257,
      922,
      3357,
      329,
      16215,
      12531,
      6608
    ],
    "label": "best_practice",
    "reason": "Using @property decorator for abstract methods is a good practice for defining abstract properties"
  },
  {
    "line": 301,
    "text": "            na_values={col: symbol_na if col == self._symbol_field_name else default_na for col in columns},",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError in abstract methods is a common pattern to enforce implementation in subclasses.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12385,
      62,
      27160,
      34758,
      4033,
      25,
      6194,
      62,
      2616,
      611,
      951,
      6624,
      2116,
      13557,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      2073,
      4277,
      62,
      2616,
      329,
      951,
      287,
      15180,
      5512
    ],
    "start_token": 1496,
    "end_token": 1536,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      287,
      12531,
      5050,
      318,
      257,
      2219,
      3912,
      284,
      4605,
      7822,
      287,
      850,
      37724,
      13
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError in abstract methods is a common pattern to enforce implementation in subclasses."
  },
  {
    "line": 304,
    "text": "        # NOTE: It has been reported that there may be some problems here, and the specific issues will be dealt with when they are identified.",
    "annotation": "\u2705 Best Practice: Using @property decorator for abstract methods is a good practice to enforce property implementation in subclasses.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      632,
      468,
      587,
      2098,
      326,
      612,
      743,
      307,
      617,
      2761,
      994,
      11,
      290,
      262,
      2176,
      2428,
      481,
      307,
      11829,
      351,
      618,
      484,
      389,
      5174,
      13
    ],
    "start_token": 1536,
    "end_token": 1571,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2488,
      26745,
      11705,
      1352,
      329,
      12531,
      5050,
      318,
      257,
      922,
      3357,
      284,
      4605,
      3119,
      7822,
      287,
      850,
      37724,
      13
    ],
    "label": "best_practice",
    "reason": "Using @property decorator for abstract methods is a good practice to enforce property implementation in subclasses."
  },
  {
    "line": 304,
    "text": "        # NOTE: It has been reported that there may be some problems here, and the specific issues will be dealt with when they are identified.",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      632,
      468,
      587,
      2098,
      326,
      612,
      743,
      307,
      617,
      2761,
      994,
      11,
      290,
      262,
      2176,
      2428,
      481,
      307,
      11829,
      351,
      618,
      484,
      389,
      5174,
      13
    ],
    "start_token": 1571,
    "end_token": 1606,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 306,
    "text": "        if df is not None and not df.empty:",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that a method should be overridden",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      318,
      407,
      6045,
      290,
      407,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1606,
    "end_token": 1624,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      257,
      2446,
      815,
      307,
      23170,
      4651
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that a method should be overridden"
  },
  {
    "line": 336,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of getattr allows for dynamic attribute access, which is flexible for different modules.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1624,
    "end_token": 1632,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      35226,
      3578,
      329,
      8925,
      11688,
      1895,
      11,
      543,
      318,
      12846,
      329,
      1180,
      13103,
      13
    ],
    "label": "best_practice",
    "reason": "Use of getattr allows for dynamic attribute access, which is flexible for different modules."
  },
  {
    "line": 337,
    "text": "        if source_dir is None:",
    "annotation": "\ud83e\udde0 ML Signal: The parameters passed to the class could be used to understand data collection patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2723,
      62,
      15908,
      318,
      6045,
      25
    ],
    "start_token": 1632,
    "end_token": 1646,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      10007,
      3804,
      284,
      262,
      1398,
      714,
      307,
      973,
      284,
      1833,
      1366,
      4947,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "The parameters passed to the class could be used to understand data collection patterns."
  },
  {
    "line": 337,
    "text": "        if source_dir is None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if self.source_dir or other parameters are user-controlled and not validated.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2723,
      62,
      15908,
      318,
      6045,
      25
    ],
    "start_token": 1646,
    "end_token": 1660,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      2116,
      13,
      10459,
      62,
      15908,
      393,
      584,
      10007,
      389,
      2836,
      12,
      14401,
      290,
      407,
      31031,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if self.source_dir or other parameters are user-controlled and not validated."
  },
  {
    "line": 350,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1660,
    "end_token": 1660,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 362,
    "text": "    @abc.abstractmethod",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic class retrieval using getattr, indicating potential use of different normalization strategies",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      39305,
      13,
      397,
      8709,
      24396
    ],
    "start_token": 1660,
    "end_token": 1669,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      1398,
      45069,
      1262,
      651,
      35226,
      11,
      12739,
      2785,
      779,
      286,
      1180,
      3487,
      1634,
      10064
    ],
    "label": "ml_signal",
    "reason": "Dynamic class retrieval using getattr, indicating potential use of different normalization strategies"
  },
  {
    "line": 362,
    "text": "    @abc.abstractmethod",
    "annotation": "\ud83e\udde0 ML Signal: Instantiation of a Normalize object with various parameters, indicating a pattern of data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      39305,
      13,
      397,
      8709,
      24396
    ],
    "start_token": 1669,
    "end_token": 1678,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24470,
      3920,
      286,
      257,
      14435,
      1096,
      2134,
      351,
      2972,
      10007,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Instantiation of a Normalize object with various parameters, indicating a pattern of data processing"
  },
  {
    "line": 371,
    "text": "        end=None,",
    "annotation": "\ud83e\udde0 ML Signal: Method call on an object, indicating a pattern of executing a normalization process",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      28,
      14202,
      11
    ],
    "start_token": 1678,
    "end_token": 1689,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      319,
      281,
      2134,
      11,
      12739,
      257,
      3912,
      286,
      23710,
      257,
      3487,
      1634,
      1429
    ],
    "label": "ml_signal",
    "reason": "Method call on an object, indicating a pattern of executing a normalization process"
  }
]