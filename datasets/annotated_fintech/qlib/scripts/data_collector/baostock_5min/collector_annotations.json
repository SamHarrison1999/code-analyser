[
  {
    "line": 14,
    "text": "from typing import Iterable, List",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying sys.path can lead to import conflicts or security issues if not handled carefully.",
    "confidence": 1.0,
    "tokens": [
      6738,
      19720,
      1330,
      40806,
      540,
      11,
      7343
    ],
    "start_token": 0,
    "end_token": 7,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      25064,
      13,
      6978,
      460,
      1085,
      284,
      1330,
      12333,
      393,
      2324,
      2428,
      611,
      407,
      12118,
      7773,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying sys.path can lead to import conflicts or security issues if not handled carefully."
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from a base class indicates a design pattern for code reuse and extension",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 7,
    "end_token": 7,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      257,
      2779,
      1398,
      9217,
      257,
      1486,
      3912,
      329,
      2438,
      32349,
      290,
      7552
    ],
    "label": "ml_signal",
    "reason": "Inheritance from a base class indicates a design pattern for code reuse and extension"
  },
  {
    "line": 30,
    "text": "        start=None,",
    "annotation": "\u2705 Best Practice: Use of docstring to describe parameters and their default values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      28,
      14202,
      11
    ],
    "start_token": 7,
    "end_token": 18,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2205,
      8841,
      284,
      6901,
      10007,
      290,
      511,
      4277,
      3815
    ],
    "label": "best_practice",
    "reason": "Use of docstring to describe parameters and their default values"
  },
  {
    "line": 53,
    "text": "        start: str",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if bs.login() fails or raises an exception",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      25,
      965
    ],
    "start_token": 18,
    "end_token": 28,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      275,
      82,
      13,
      38235,
      3419,
      10143,
      393,
      12073,
      281,
      6631
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if bs.login() fails or raises an exception"
  },
  {
    "line": 53,
    "text": "        start: str",
    "annotation": "\u2705 Best Practice: Proper use of super() to initialize the parent class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      25,
      965
    ],
    "start_token": 28,
    "end_token": 38,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      45989,
      779,
      286,
      2208,
      3419,
      284,
      41216,
      262,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Proper use of super() to initialize the parent class"
  },
  {
    "line": 69,
    "text": "            max_collector_count=max_collector_count,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the 'bs.query_trade_dates' function handles input validation and sanitization to prevent potential injection attacks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      33327,
      273,
      62,
      9127,
      28,
      9806,
      62,
      33327,
      273,
      62,
      9127,
      11
    ],
    "start_token": 38,
    "end_token": 63,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      705,
      1443,
      13,
      22766,
      62,
      25351,
      62,
      19581,
      6,
      2163,
      17105,
      5128,
      21201,
      290,
      5336,
      270,
      1634,
      284,
      2948,
      2785,
      16954,
      3434,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the 'bs.query_trade_dates' function handles input validation and sanitization to prevent potential injection attacks."
  },
  {
    "line": 72,
    "text": "            limit_nums=limit_nums,",
    "annotation": "\u2705 Best Practice: Use 'and' instead of '&' for logical operations to improve readability and avoid confusion with bitwise operations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4179,
      62,
      77,
      5700,
      28,
      32374,
      62,
      77,
      5700,
      11
    ],
    "start_token": 63,
    "end_token": 84,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      392,
      6,
      2427,
      286,
      705,
      5,
      6,
      329,
      12219,
      4560,
      284,
      2987,
      1100,
      1799,
      290,
      3368,
      10802,
      351,
      1643,
      3083,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Use 'and' instead of '&' for logical operations to improve readability and avoid confusion with bitwise operations."
  },
  {
    "line": 74,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Appending data to a list in a loop is a common pattern that can be used to identify data collection or aggregation behavior.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 84,
    "end_token": 84,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      1366,
      284,
      257,
      1351,
      287,
      257,
      9052,
      318,
      257,
      2219,
      3912,
      326,
      460,
      307,
      973,
      284,
      5911,
      1366,
      4947,
      393,
      46500,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Appending data to a list in a loop is a common pattern that can be used to identify data collection or aggregation behavior."
  },
  {
    "line": 76,
    "text": "        _format = \"%Y-%m-%d\"",
    "annotation": "\ud83e\udde0 ML Signal: Creating a DataFrame from a list of data is a common pattern in data processing tasks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      18982,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 84,
    "end_token": 103,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      6060,
      19778,
      422,
      257,
      1351,
      286,
      1366,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Creating a DataFrame from a list of data is a common pattern in data processing tasks."
  },
  {
    "line": 78,
    "text": "        end = self.end_datetime.strftime(_format)",
    "annotation": "\ud83e\udde0 ML Signal: Filtering a DataFrame based on a condition is a common data manipulation pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      796,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      28264,
      18982,
      8
    ],
    "start_token": 103,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      257,
      6060,
      19778,
      1912,
      319,
      257,
      4006,
      318,
      257,
      2219,
      1366,
      17512,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Filtering a DataFrame based on a condition is a common data manipulation pattern."
  },
  {
    "line": 80,
    "text": "        calendar_list = []",
    "annotation": "\ud83e\udde0 ML Signal: Returning specific columns or values from a DataFrame is a common pattern in data extraction tasks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11845,
      62,
      4868,
      796,
      17635
    ],
    "start_token": 124,
    "end_token": 136,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      2176,
      15180,
      393,
      3815,
      422,
      257,
      6060,
      19778,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      22236,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Returning specific columns or values from a DataFrame is a common pattern in data extraction tasks."
  },
  {
    "line": 84,
    "text": "        trade_calendar_df = calendar_df[~calendar_df[\"is_trading_day\"].isin([\"0\"])]",
    "annotation": "\u2705 Best Practice: Use the @staticmethod decorator to indicate that the method does not modify the class or instance state.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9948,
      9239,
      62,
      7568,
      796,
      11845,
      62,
      7568,
      58,
      93,
      9948,
      9239,
      62,
      7568,
      14692,
      271,
      62,
      2213,
      4980,
      62,
      820,
      1,
      4083,
      45763,
      7,
      14692,
      15,
      8973,
      15437
    ],
    "start_token": 136,
    "end_token": 174,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      262,
      2488,
      12708,
      24396,
      11705,
      1352,
      284,
      7603,
      326,
      262,
      2446,
      857,
      407,
      13096,
      262,
      1398,
      393,
      4554,
      1181,
      13
    ],
    "label": "best_practice",
    "reason": "Use the @staticmethod decorator to indicate that the method does not modify the class or instance state."
  },
  {
    "line": 77,
    "text": "        start = self.start_datetime.strftime(_format)",
    "annotation": "\ud83e\udde0 ML Signal: Function processes input based on specific string values, useful for learning conditional logic",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      796,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      28264,
      18982,
      8
    ],
    "start_token": 174,
    "end_token": 195,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      7767,
      5128,
      1912,
      319,
      2176,
      4731,
      3815,
      11,
      4465,
      329,
      4673,
      26340,
      9156
    ],
    "label": "ml_signal",
    "reason": "Function processes input based on specific string values, useful for learning conditional logic"
  },
  {
    "line": 79,
    "text": "        rs = bs.query_trade_dates(start_date=start, end_date=end)",
    "annotation": "\ud83e\udde0 ML Signal: Returns a dictionary based on input, useful for learning data transformation patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      44608,
      796,
      275,
      82,
      13,
      22766,
      62,
      25351,
      62,
      19581,
      7,
      9688,
      62,
      4475,
      28,
      9688,
      11,
      886,
      62,
      4475,
      28,
      437,
      8
    ],
    "start_token": 195,
    "end_token": 225,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      16409,
      257,
      22155,
      1912,
      319,
      5128,
      11,
      4465,
      329,
      4673,
      1366,
      13389,
      7572
    ],
    "label": "ml_signal",
    "reason": "Returns a dictionary based on input, useful for learning data transformation patterns"
  },
  {
    "line": 81,
    "text": "        while (rs.error_code == \"0\") & rs.next():",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      357,
      3808,
      13,
      18224,
      62,
      8189,
      6624,
      366,
      15,
      4943,
      1222,
      44608,
      13,
      19545,
      33529
    ],
    "start_token": 225,
    "end_token": 248,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability"
  },
  {
    "line": 84,
    "text": "        trade_calendar_df = calendar_df[~calendar_df[\"is_trading_day\"].isin([\"0\"])]",
    "annotation": "\ud83e\udde0 ML Signal: Returns a dictionary based on input, useful for learning data transformation patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9948,
      9239,
      62,
      7568,
      796,
      11845,
      62,
      7568,
      58,
      93,
      9948,
      9239,
      62,
      7568,
      14692,
      271,
      62,
      2213,
      4980,
      62,
      820,
      1,
      4083,
      45763,
      7,
      14692,
      15,
      8973,
      15437
    ],
    "start_token": 248,
    "end_token": 286,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      16409,
      257,
      22155,
      1912,
      319,
      5128,
      11,
      4465,
      329,
      4673,
      1366,
      13389,
      7572
    ],
    "label": "ml_signal",
    "reason": "Returns a dictionary based on input, useful for learning data transformation patterns"
  },
  {
    "line": 84,
    "text": "        trade_calendar_df = calendar_df[~calendar_df[\"is_trading_day\"].isin([\"0\"])]",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a method to fetch data from a remote source",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9948,
      9239,
      62,
      7568,
      796,
      11845,
      62,
      7568,
      58,
      93,
      9948,
      9239,
      62,
      7568,
      14692,
      271,
      62,
      2213,
      4980,
      62,
      820,
      1,
      4083,
      45763,
      7,
      14692,
      15,
      8973,
      15437
    ],
    "start_token": 286,
    "end_token": 324,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2446,
      284,
      21207,
      1366,
      422,
      257,
      6569,
      2723
    ],
    "label": "ml_signal",
    "reason": "Usage of a method to fetch data from a remote source"
  },
  {
    "line": 88,
    "text": "    def process_interval(interval: str):",
    "annotation": "\u2705 Best Practice: Explicitly setting DataFrame column names for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      1429,
      62,
      3849,
      2100,
      7,
      3849,
      2100,
      25,
      965,
      2599
    ],
    "start_token": 324,
    "end_token": 338,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      6060,
      19778,
      5721,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly setting DataFrame column names for clarity"
  },
  {
    "line": 90,
    "text": "            return {\"interval\": \"d\", \"fields\": \"date,code,open,high,low,close,volume,amount,adjustflag\"}",
    "annotation": "\u2705 Best Practice: Converting string to datetime for proper time handling",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      19779,
      3849,
      2100,
      1298,
      366,
      67,
      1600,
      366,
      25747,
      1298,
      366,
      4475,
      11,
      8189,
      11,
      9654,
      11,
      8929,
      11,
      9319,
      11,
      19836,
      11,
      29048,
      11,
      17287,
      11,
      23032,
      32109,
      20662
    ],
    "start_token": 338,
    "end_token": 380,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      4731,
      284,
      4818,
      8079,
      329,
      1774,
      640,
      9041
    ],
    "label": "best_practice",
    "reason": "Converting string to datetime for proper time handling"
  },
  {
    "line": 92,
    "text": "            return {\"interval\": \"5\", \"fields\": \"date,time,code,open,high,low,close,volume,amount,adjustflag\"}",
    "annotation": "\u2705 Best Practice: Formatting datetime for consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      19779,
      3849,
      2100,
      1298,
      366,
      20,
      1600,
      366,
      25747,
      1298,
      366,
      4475,
      11,
      2435,
      11,
      8189,
      11,
      9654,
      11,
      8929,
      11,
      9319,
      11,
      19836,
      11,
      29048,
      11,
      17287,
      11,
      23032,
      32109,
      20662
    ],
    "start_token": 380,
    "end_token": 424,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18980,
      889,
      4818,
      8079,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Formatting datetime for consistency"
  },
  {
    "line": 93,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone issues when subtracting fixed time deltas",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 424,
    "end_token": 424,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      2428,
      618,
      34128,
      278,
      5969,
      640,
      1619,
      83,
      292
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone issues when subtracting fixed time deltas"
  },
  {
    "line": 95,
    "text": "        self, symbol: str, interval: str, start_datetime: pd.Timestamp, end_datetime: pd.Timestamp",
    "annotation": "\u2705 Best Practice: Dropping unnecessary columns to save memory",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      6194,
      25,
      965,
      11,
      16654,
      25,
      965,
      11,
      923,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11,
      886,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 424,
    "end_token": 462,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      13114,
      15180,
      284,
      3613,
      4088
    ],
    "label": "best_practice",
    "reason": "Dropping unnecessary columns to save memory"
  },
  {
    "line": 98,
    "text": "            symbol=symbol, interval=interval, start_datetime=start_datetime, end_datetime=end_datetime",
    "annotation": "\u2705 Best Practice: Normalizing symbol format for consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      28,
      1837,
      23650,
      11,
      16654,
      28,
      3849,
      2100,
      11,
      923,
      62,
      19608,
      8079,
      28,
      9688,
      62,
      19608,
      8079,
      11,
      886,
      62,
      19608,
      8079,
      28,
      437,
      62,
      19608,
      8079
    ],
    "start_token": 462,
    "end_token": 502,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14435,
      2890,
      6194,
      5794,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Normalizing symbol format for consistency"
  },
  {
    "line": 98,
    "text": "            symbol=symbol, interval=interval, start_datetime=start_datetime, end_datetime=end_datetime",
    "annotation": "\u2705 Best Practice: Initialize the DataFrame to ensure it is always defined, even if the query fails.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      28,
      1837,
      23650,
      11,
      16654,
      28,
      3849,
      2100,
      11,
      923,
      62,
      19608,
      8079,
      28,
      9688,
      62,
      19608,
      8079,
      11,
      886,
      62,
      19608,
      8079,
      28,
      437,
      62,
      19608,
      8079
    ],
    "start_token": 502,
    "end_token": 542,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      262,
      6060,
      19778,
      284,
      4155,
      340,
      318,
      1464,
      5447,
      11,
      772,
      611,
      262,
      12405,
      10143,
      13
    ],
    "label": "best_practice",
    "reason": "Initialize the DataFrame to ensure it is always defined, even if the query fails."
  },
  {
    "line": 99,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external API to fetch data, which can be a pattern for data retrieval tasks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 542,
    "end_token": 550,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      7824,
      284,
      21207,
      1366,
      11,
      543,
      460,
      307,
      257,
      3912,
      329,
      1366,
      45069,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of external API to fetch data, which can be a pattern for data retrieval tasks."
  },
  {
    "line": 99,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic field selection based on interval, indicating a pattern of flexible data requests.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 550,
    "end_token": 558,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      2214,
      6356,
      1912,
      319,
      16654,
      11,
      12739,
      257,
      3912,
      286,
      12846,
      1366,
      7007,
      13
    ],
    "label": "ml_signal",
    "reason": "Dynamic field selection based on interval, indicating a pattern of flexible data requests."
  },
  {
    "line": 107,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicit conversion of datetime to string for API compatibility.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 558,
    "end_token": 558,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      11315,
      286,
      4818,
      8079,
      284,
      4731,
      329,
      7824,
      17764,
      13
    ],
    "label": "best_practice",
    "reason": "Explicit conversion of datetime to string for API compatibility."
  },
  {
    "line": 107,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicit conversion of datetime to string for API compatibility.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 558,
    "end_token": 558,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      11315,
      286,
      4818,
      8079,
      284,
      4731,
      329,
      7824,
      17764,
      13
    ],
    "label": "best_practice",
    "reason": "Explicit conversion of datetime to string for API compatibility."
  },
  {
    "line": 109,
    "text": "    def get_data_from_remote(",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic interval processing, indicating a pattern of flexible data requests.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      62,
      6738,
      62,
      47960,
      7
    ],
    "start_token": 558,
    "end_token": 570,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      16654,
      7587,
      11,
      12739,
      257,
      3912,
      286,
      12846,
      1366,
      7007,
      13
    ],
    "label": "ml_signal",
    "reason": "Dynamic interval processing, indicating a pattern of flexible data requests."
  },
  {
    "line": 113,
    "text": "        rs = bs.query_history_k_data_plus(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): No error handling for API call failures other than checking error_code.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      44608,
      796,
      275,
      82,
      13,
      22766,
      62,
      23569,
      62,
      74,
      62,
      7890,
      62,
      9541,
      7
    ],
    "start_token": 570,
    "end_token": 592,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1400,
      4049,
      9041,
      329,
      7824,
      869,
      15536,
      584,
      621,
      10627,
      4049,
      62,
      8189,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "No error handling for API call failures other than checking error_code."
  },
  {
    "line": 117,
    "text": "            end_date=str(end_datetime.strftime(\"%Y-%m-%d\")),",
    "annotation": "\u2705 Best Practice: Construct DataFrame with specified columns for clarity and structure.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      4475,
      28,
      2536,
      7,
      437,
      62,
      19608,
      8079,
      13,
      2536,
      31387,
      7203,
      4,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      4943,
      828
    ],
    "start_token": 592,
    "end_token": 627,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      28407,
      6060,
      19778,
      351,
      7368,
      15180,
      329,
      16287,
      290,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Construct DataFrame with specified columns for clarity and structure."
  },
  {
    "line": 119,
    "text": "            adjustflag=\"3\",",
    "annotation": "\u2705 Best Practice: Return a DataFrame, ensuring consistent return type.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4532,
      32109,
      2625,
      18,
      1600
    ],
    "start_token": 627,
    "end_token": 643,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      257,
      6060,
      19778,
      11,
      13359,
      6414,
      1441,
      2099,
      13
    ],
    "label": "best_practice",
    "reason": "Return a DataFrame, ensuring consistent return type."
  },
  {
    "line": 115,
    "text": "            BaostockCollectorHS3005min.process_interval(interval=interval)[\"fields\"],",
    "annotation": "\ud83e\udde0 ML Signal: Usage of tqdm for progress tracking indicates a pattern of processing large datasets",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8999,
      455,
      735,
      31337,
      273,
      7998,
      6200,
      20,
      1084,
      13,
      14681,
      62,
      3849,
      2100,
      7,
      3849,
      2100,
      28,
      3849,
      2100,
      8,
      14692,
      25747,
      33116
    ],
    "start_token": 643,
    "end_token": 678,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      256,
      80,
      36020,
      329,
      4371,
      9646,
      9217,
      257,
      3912,
      286,
      7587,
      1588,
      40522
    ],
    "label": "ml_signal",
    "reason": "Usage of tqdm for progress tracking indicates a pattern of processing large datasets"
  },
  {
    "line": 118,
    "text": "            frequency=BaostockCollectorHS3005min.process_interval(interval=interval)[\"interval\"],",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large data retrieval without error handling for network issues",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8373,
      28,
      34458,
      455,
      735,
      31337,
      273,
      7998,
      6200,
      20,
      1084,
      13,
      14681,
      62,
      3849,
      2100,
      7,
      3849,
      2100,
      28,
      3849,
      2100,
      8,
      14692,
      3849,
      2100,
      33116
    ],
    "start_token": 678,
    "end_token": 716,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      1366,
      45069,
      1231,
      4049,
      9041,
      329,
      3127,
      2428
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large data retrieval without error handling for network issues"
  },
  {
    "line": 120,
    "text": "        )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Loop may become infinite if error_code is never \"0\"",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 716,
    "end_token": 724,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      26304,
      743,
      1716,
      15541,
      611,
      4049,
      62,
      8189,
      318,
      1239,
      366,
      15,
      1
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Loop may become infinite if error_code is never \"0\""
  },
  {
    "line": 122,
    "text": "            data_list = rs.data",
    "annotation": "\ud83e\udde0 ML Signal: Appending data to a list in a loop is a common pattern for data collection",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      4868,
      796,
      44608,
      13,
      7890
    ],
    "start_token": 724,
    "end_token": 742,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      1366,
      284,
      257,
      1351,
      287,
      257,
      9052,
      318,
      257,
      2219,
      3912,
      329,
      1366,
      4947
    ],
    "label": "ml_signal",
    "reason": "Appending data to a list in a loop is a common pattern for data collection"
  },
  {
    "line": 124,
    "text": "            df = pd.DataFrame(data_list, columns=columns)",
    "annotation": "\ud83e\udde0 ML Signal: Progress bar update in a loop indicates iterative processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      7890,
      62,
      4868,
      11,
      15180,
      28,
      28665,
      82,
      8
    ],
    "start_token": 742,
    "end_token": 770,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18387,
      2318,
      4296,
      287,
      257,
      9052,
      9217,
      11629,
      876,
      7587
    ],
    "label": "ml_signal",
    "reason": "Progress bar update in a loop indicates iterative processing"
  },
  {
    "line": 126,
    "text": "",
    "annotation": "\u2705 Best Practice: Using a set comprehension to remove duplicates before sorting",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 770,
    "end_token": 770,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      900,
      35915,
      284,
      4781,
      14184,
      16856,
      878,
      29407
    ],
    "label": "best_practice",
    "reason": "Using a set comprehension to remove duplicates before sorting"
  },
  {
    "line": 122,
    "text": "            data_list = rs.data",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its functionality",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      4868,
      796,
      44608,
      13,
      7890
    ],
    "start_token": 770,
    "end_token": 788,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      11244
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its functionality"
  },
  {
    "line": 124,
    "text": "            df = pd.DataFrame(data_list, columns=columns)",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for tracking execution flow",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      7890,
      62,
      4868,
      11,
      15180,
      28,
      28665,
      82,
      8
    ],
    "start_token": 788,
    "end_token": 816,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9646,
      9706,
      5202
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for tracking execution flow"
  },
  {
    "line": 126,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for retrieving data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 816,
    "end_token": 816,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      50122,
      1366
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for retrieving data"
  },
  {
    "line": 128,
    "text": "        hs300_stocks = []",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern for tracking execution flow",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      289,
      82,
      6200,
      62,
      29522,
      796,
      17635
    ],
    "start_token": 816,
    "end_token": 830,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      329,
      9646,
      9706,
      5202
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern for tracking execution flow"
  },
  {
    "line": 130,
    "text": "        with tqdm(total=len(trade_calendar)) as p_bar:",
    "annotation": "\ud83e\udde0 ML Signal: Return statement pattern for method output",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      256,
      80,
      36020,
      7,
      23350,
      28,
      11925,
      7,
      25351,
      62,
      9948,
      9239,
      4008,
      355,
      279,
      62,
      5657,
      25
    ],
    "start_token": 830,
    "end_token": 856,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8229,
      2643,
      3912,
      329,
      2446,
      5072
    ],
    "label": "ml_signal",
    "reason": "Return statement pattern for method output"
  },
  {
    "line": 127,
    "text": "    def get_hs300_symbols(self) -> List[str]:",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      11994,
      6200,
      62,
      1837,
      2022,
      10220,
      7,
      944,
      8,
      4613,
      7343,
      58,
      2536,
      5974
    ],
    "start_token": 856,
    "end_token": 876,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 129,
    "text": "        trade_calendar = self.get_trade_calendar()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of string manipulation methods to normalize input",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9948,
      9239,
      796,
      2116,
      13,
      1136,
      62,
      25351,
      62,
      9948,
      9239,
      3419
    ],
    "start_token": 876,
    "end_token": 897,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4731,
      17512,
      5050,
      284,
      3487,
      1096,
      5128
    ],
    "label": "ml_signal",
    "reason": "Usage of string manipulation methods to normalize input"
  },
  {
    "line": 130,
    "text": "        with tqdm(total=len(trade_calendar)) as p_bar:",
    "annotation": "\u2705 Best Practice: Ensure input is a string before processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      256,
      80,
      36020,
      7,
      23350,
      28,
      11925,
      7,
      25351,
      62,
      9948,
      9239,
      4008,
      355,
      279,
      62,
      5657,
      25
    ],
    "start_token": 897,
    "end_token": 923,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      5128,
      318,
      257,
      4731,
      878,
      7587
    ],
    "label": "best_practice",
    "reason": "Ensure input is a string before processing"
  },
  {
    "line": 129,
    "text": "        trade_calendar = self.get_trade_calendar()",
    "annotation": "\ud83e\udde0 ML Signal: Class definition with specific naming pattern, useful for classifying or identifying domain-specific classes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9948,
      9239,
      796,
      2116,
      13,
      1136,
      62,
      25351,
      62,
      9948,
      9239,
      3419
    ],
    "start_token": 923,
    "end_token": 944,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      6770,
      351,
      2176,
      19264,
      3912,
      11,
      4465,
      329,
      1398,
      4035,
      393,
      13720,
      7386,
      12,
      11423,
      6097
    ],
    "label": "ml_signal",
    "reason": "Class definition with specific naming pattern, useful for classifying or identifying domain-specific classes"
  },
  {
    "line": 131,
    "text": "            for date in trade_calendar:",
    "annotation": "\ud83e\udde0 ML Signal: Use of class-level constants, indicating a pattern of configuration or fixed parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      3128,
      287,
      3292,
      62,
      9948,
      9239,
      25
    ],
    "start_token": 944,
    "end_token": 963,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1398,
      12,
      5715,
      38491,
      11,
      12739,
      257,
      3912,
      286,
      8398,
      393,
      5969,
      10007
    ],
    "label": "ml_signal",
    "reason": "Use of class-level constants, indicating a pattern of configuration or fixed parameters"
  },
  {
    "line": 133,
    "text": "                while rs.error_code == \"0\" and rs.next():",
    "annotation": "\ud83e\udde0 ML Signal: Time range constants, indicating a pattern of time-based data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      44608,
      13,
      18224,
      62,
      8189,
      6624,
      366,
      15,
      1,
      290,
      44608,
      13,
      19545,
      33529
    ],
    "start_token": 963,
    "end_token": 993,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3862,
      2837,
      38491,
      11,
      12739,
      257,
      3912,
      286,
      640,
      12,
      3106,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Time range constants, indicating a pattern of time-based data processing"
  },
  {
    "line": 136,
    "text": "        return sorted({e[1] for e in hs300_stocks})",
    "annotation": "\ud83e\udde0 ML Signal: Time range constants, indicating a pattern of time-based data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      23243,
      15090,
      68,
      58,
      16,
      60,
      329,
      304,
      287,
      289,
      82,
      6200,
      62,
      29522,
      30072
    ],
    "start_token": 993,
    "end_token": 1016,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3862,
      2837,
      38491,
      11,
      12739,
      257,
      3912,
      286,
      640,
      12,
      3106,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Time range constants, indicating a pattern of time-based data processing"
  },
  {
    "line": 136,
    "text": "        return sorted({e[1] for e in hs300_stocks})",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      23243,
      15090,
      68,
      58,
      16,
      60,
      329,
      304,
      287,
      289,
      82,
      6200,
      62,
      29522,
      30072
    ],
    "start_token": 1016,
    "end_token": 1039,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability."
  },
  {
    "line": 148,
    "text": "class BaostockNormalizeHS3005min(BaseNormalize):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Ensure that the login credentials are securely managed and not hardcoded.",
    "confidence": 0.5,
    "tokens": [
      4871,
      8999,
      455,
      735,
      26447,
      1096,
      7998,
      6200,
      20,
      1084,
      7,
      14881,
      26447,
      1096,
      2599
    ],
    "start_token": 1039,
    "end_token": 1054,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      48987,
      326,
      262,
      17594,
      18031,
      389,
      30835,
      5257,
      290,
      407,
      1327,
      40976,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Ensure that the login credentials are securely managed and not hardcoded."
  },
  {
    "line": 149,
    "text": "    COLUMNS = [\"open\", \"close\", \"high\", \"low\", \"volume\"]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Validate the input path to prevent potential path traversal issues.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      20444,
      5883,
      8035,
      796,
      14631,
      9654,
      1600,
      366,
      19836,
      1600,
      366,
      8929,
      1600,
      366,
      9319,
      1600,
      366,
      29048,
      8973
    ],
    "start_token": 1054,
    "end_token": 1076,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3254,
      20540,
      262,
      5128,
      3108,
      284,
      2948,
      2785,
      3108,
      33038,
      282,
      2428,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Validate the input path to prevent potential path traversal issues."
  },
  {
    "line": 152,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Collecting features from all instruments could be used to train models on financial data.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1076,
    "end_token": 1076,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9745,
      278,
      3033,
      422,
      477,
      12834,
      714,
      307,
      973,
      284,
      4512,
      4981,
      319,
      3176,
      1366,
      13
    ],
    "label": "ml_signal",
    "reason": "Collecting features from all instruments could be used to train models on financial data."
  },
  {
    "line": 154,
    "text": "        self, qlib_data_1d_dir: [str, Path], date_field_name: str = \"date\", symbol_field_name: str = \"symbol\", **kwargs",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      1837,
      23650,
      1600,
      12429,
      46265,
      22046
    ],
    "start_token": 1076,
    "end_token": 1126,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization."
  },
  {
    "line": 152,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of .copy() to avoid modifying the original DataFrame",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1126,
    "end_token": 1126,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      764,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use of .copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 154,
    "text": "        self, qlib_data_1d_dir: [str, Path], date_field_name: str = \"date\", symbol_field_name: str = \"symbol\", **kwargs",
    "annotation": "\ud83e\udde0 ML Signal: Filling missing values with forward fill indicates time series data handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      685,
      2536,
      11,
      10644,
      4357,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      4475,
      1600,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      1837,
      23650,
      1600,
      12429,
      46265,
      22046
    ],
    "start_token": 1126,
    "end_token": 1176,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      376,
      4509,
      4814,
      3815,
      351,
      2651,
      6070,
      9217,
      640,
      2168,
      1366,
      9041
    ],
    "label": "ml_signal",
    "reason": "Filling missing values with forward fill indicates time series data handling"
  },
  {
    "line": 156,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of .shift() suggests calculation of changes over time",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1176,
    "end_token": 1184,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      764,
      30846,
      3419,
      5644,
      17952,
      286,
      2458,
      625,
      640
    ],
    "label": "ml_signal",
    "reason": "Use of .shift() suggests calculation of changes over time"
  },
  {
    "line": 158,
    "text": "        Parameters",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential IndexError if df is empty and last_close is not None",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 1184,
    "end_token": 1192,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      12901,
      12331,
      611,
      47764,
      318,
      6565,
      290,
      938,
      62,
      19836,
      318,
      407,
      6045
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential IndexError if df is empty and last_close is not None"
  },
  {
    "line": 160,
    "text": "        qlib_data_1d_dir: str, Path",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of .iloc[0] without checking if the DataFrame is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      965,
      11,
      10644
    ],
    "start_token": 1192,
    "end_token": 1212,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      764,
      346,
      420,
      58,
      15,
      60,
      1231,
      10627,
      611,
      262,
      6060,
      19778,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of .iloc[0] without checking if the DataFrame is empty"
  },
  {
    "line": 162,
    "text": "        date_field_name: str",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of percentage change is common in financial data analysis",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      3245,
      62,
      3672,
      25,
      965
    ],
    "start_token": 1212,
    "end_token": 1226,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      5873,
      1487,
      318,
      2219,
      287,
      3176,
      1366,
      3781
    ],
    "label": "ml_signal",
    "reason": "Calculation of percentage change is common in financial data analysis"
  },
  {
    "line": 160,
    "text": "        qlib_data_1d_dir: str, Path",
    "annotation": "\ud83e\udde0 ML Signal: Method returns an iterable of timestamps, indicating time-based data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      25,
      965,
      11,
      10644
    ],
    "start_token": 1226,
    "end_token": 1246,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      5860,
      281,
      11629,
      540,
      286,
      4628,
      395,
      9430,
      11,
      12739,
      640,
      12,
      3106,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Method returns an iterable of timestamps, indicating time-based data processing"
  },
  {
    "line": 163,
    "text": "            date field name, default is date",
    "annotation": "\ud83e\udde0 ML Signal: Use of getattr to check for cached attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      2214,
      1438,
      11,
      4277,
      318,
      3128
    ],
    "start_token": 1246,
    "end_token": 1264,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      651,
      35226,
      284,
      2198,
      329,
      39986,
      11688
    ],
    "label": "ml_signal",
    "reason": "Use of getattr to check for cached attribute"
  },
  {
    "line": 166,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Lazy loading pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1264,
    "end_token": 1272,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      406,
      12582,
      11046,
      3912
    ],
    "label": "ml_signal",
    "reason": "Lazy loading pattern"
  },
  {
    "line": 167,
    "text": "        bs.login()",
    "annotation": "\ud83e\udde0 ML Signal: Use of setattr to cache attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      275,
      82,
      13,
      38235,
      3419
    ],
    "start_token": 1272,
    "end_token": 1284,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      900,
      35226,
      284,
      12940,
      11688
    ],
    "label": "ml_signal",
    "reason": "Use of setattr to cache attribute"
  },
  {
    "line": 169,
    "text": "        self.all_1d_data = D.features(D.instruments(\"all\"), [\"$paused\", \"$volume\", \"$factor\", \"$close\"], freq=\"day\")",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      439,
      62,
      16,
      67,
      62,
      7890,
      796,
      360,
      13,
      40890,
      7,
      35,
      13,
      259,
      2536,
      2886,
      7203,
      439,
      12340,
      14631,
      3,
      8957,
      1484,
      1600,
      17971,
      29048,
      1600,
      17971,
      31412,
      1600,
      17971,
      19836,
      33116,
      2030,
      80,
      2625,
      820,
      4943
    ],
    "start_token": 1284,
    "end_token": 1331,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the function parameters and return type for better readability and maintainability."
  },
  {
    "line": 177,
    "text": "        if last_close is not None:",
    "annotation": "\u2705 Best Practice: Early return for empty DataFrame improves code readability and efficiency.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      938,
      62,
      19836,
      318,
      407,
      6045,
      25
    ],
    "start_token": 1331,
    "end_token": 1346,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12556,
      1441,
      329,
      6565,
      6060,
      19778,
      19575,
      2438,
      1100,
      1799,
      290,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Early return for empty DataFrame improves code readability and efficiency."
  },
  {
    "line": 180,
    "text": "        return change_series",
    "annotation": "\ud83e\udde0 ML Signal: Extracting a symbol from the DataFrame could indicate a pattern of interest for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1487,
      62,
      25076
    ],
    "start_token": 1346,
    "end_token": 1357,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      257,
      6194,
      422,
      262,
      6060,
      19778,
      714,
      7603,
      257,
      3912,
      286,
      1393,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Extracting a symbol from the DataFrame could indicate a pattern of interest for ML models."
  },
  {
    "line": 182,
    "text": "    def _get_calendar_list(self) -> Iterable[pd.Timestamp]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Deep copying can be resource-intensive; ensure it's necessary.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      9948,
      9239,
      62,
      4868,
      7,
      944,
      8,
      4613,
      40806,
      540,
      58,
      30094,
      13,
      14967,
      27823,
      5974
    ],
    "start_token": 1357,
    "end_token": 1380,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      10766,
      23345,
      460,
      307,
      8271,
      12,
      38096,
      26,
      4155,
      340,
      338,
      3306,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Deep copying can be resource-intensive; ensure it's necessary."
  },
  {
    "line": 184,
    "text": "",
    "annotation": "\u2705 Best Practice: Copying the DataFrame before modifying it to avoid side effects on the original data.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1380,
    "end_token": 1380,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6955,
      1112,
      262,
      6060,
      19778,
      878,
      30620,
      340,
      284,
      3368,
      1735,
      3048,
      319,
      262,
      2656,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Copying the DataFrame before modifying it to avoid side effects on the original data."
  },
  {
    "line": 185,
    "text": "    @property",
    "annotation": "\u2705 Best Practice: Setting the index to a specific field improves data manipulation and access efficiency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1380,
    "end_token": 1385,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      6376,
      284,
      257,
      2176,
      2214,
      19575,
      1366,
      17512,
      290,
      1895,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Setting the index to a specific field improves data manipulation and access efficiency."
  },
  {
    "line": 190,
    "text": "            setattr(self, \"_calendar_list_1d\", calendar_list_1d)",
    "annotation": "\u2705 Best Practice: Converting index to datetime ensures proper date operations and comparisons.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      900,
      35226,
      7,
      944,
      11,
      45434,
      9948,
      9239,
      62,
      4868,
      62,
      16,
      67,
      1600,
      11845,
      62,
      4868,
      62,
      16,
      67,
      8
    ],
    "start_token": 1385,
    "end_token": 1417,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      6376,
      284,
      4818,
      8079,
      19047,
      1774,
      3128,
      4560,
      290,
      17909,
      13
    ],
    "label": "best_practice",
    "reason": "Converting index to datetime ensures proper date operations and comparisons."
  },
  {
    "line": 190,
    "text": "            setattr(self, \"_calendar_list_1d\", calendar_list_1d)",
    "annotation": "\u2705 Best Practice: Removing duplicate indices to maintain data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      900,
      35226,
      7,
      944,
      11,
      45434,
      9948,
      9239,
      62,
      4868,
      62,
      16,
      67,
      1600,
      11845,
      62,
      4868,
      62,
      16,
      67,
      8
    ],
    "start_token": 1417,
    "end_token": 1449,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3982,
      5165,
      23418,
      36525,
      284,
      5529,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Removing duplicate indices to maintain data integrity."
  },
  {
    "line": 193,
    "text": "    @staticmethod",
    "annotation": "\u2705 Best Practice: Reindexing with a calendar list ensures the DataFrame aligns with expected dates.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 1449,
    "end_token": 1455,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      9630,
      278,
      351,
      257,
      11845,
      1351,
      19047,
      262,
      6060,
      19778,
      10548,
      82,
      351,
      2938,
      9667,
      13
    ],
    "label": "best_practice",
    "reason": "Reindexing with a calendar list ensures the DataFrame aligns with expected dates."
  },
  {
    "line": 199,
    "text": "        last_close: float = None,",
    "annotation": "\u2705 Best Practice: Sorting the DataFrame by index ensures chronological order.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      938,
      62,
      19836,
      25,
      12178,
      796,
      6045,
      11
    ],
    "start_token": 1455,
    "end_token": 1470,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      262,
      6060,
      19778,
      416,
      6376,
      19047,
      45946,
      1502,
      13
    ],
    "label": "best_practice",
    "reason": "Sorting the DataFrame by index ensures chronological order."
  },
  {
    "line": 201,
    "text": "        if df.empty:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Directly manipulating DataFrame values; ensure proper handling of NaN and zero values.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1470,
    "end_token": 1482,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      306,
      29349,
      6060,
      19778,
      3815,
      26,
      4155,
      1774,
      9041,
      286,
      11013,
      45,
      290,
      6632,
      3815,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Directly manipulating DataFrame values; ensure proper handling of NaN and zero values."
  },
  {
    "line": 203,
    "text": "        symbol = df.loc[df[symbol_field_name].first_valid_index(), symbol_field_name]",
    "annotation": "\ud83e\udde0 ML Signal: Calculating change could be a feature of interest for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      22784,
      6194,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 1482,
    "end_token": 1516,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27131,
      803,
      1487,
      714,
      307,
      257,
      3895,
      286,
      1393,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Calculating change could be a feature of interest for ML models."
  },
  {
    "line": 203,
    "text": "        symbol = df.loc[df[symbol_field_name].first_valid_index(), symbol_field_name]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Reassigning NaN values based on conditions; ensure this logic is correct and safe.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      22784,
      6194,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 1516,
    "end_token": 1550,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      797,
      562,
      38944,
      11013,
      45,
      3815,
      1912,
      319,
      3403,
      26,
      4155,
      428,
      9156,
      318,
      3376,
      290,
      3338,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Reassigning NaN values based on conditions; ensure this logic is correct and safe."
  },
  {
    "line": 210,
    "text": "            df = df.reindex(",
    "annotation": "\ud83e\udde0 ML Signal: Assigning a constant symbol to a column could be a feature of interest for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      260,
      9630,
      7
    ],
    "start_token": 1550,
    "end_token": 1568,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2195,
      38944,
      257,
      6937,
      6194,
      284,
      257,
      5721,
      714,
      307,
      257,
      3895,
      286,
      1393,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Assigning a constant symbol to a column could be a feature of interest for ML models."
  },
  {
    "line": 210,
    "text": "            df = df.reindex(",
    "annotation": "\u2705 Best Practice: Naming the index improves code readability and data manipulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      260,
      9630,
      7
    ],
    "start_token": 1568,
    "end_token": 1586,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      399,
      3723,
      262,
      6376,
      19575,
      2438,
      1100,
      1799,
      290,
      1366,
      17512,
      13
    ],
    "label": "best_practice",
    "reason": "Naming the index improves code readability and data manipulation."
  },
  {
    "line": 212,
    "text": "                .loc[pd.Timestamp(df.index.min()).date() : pd.Timestamp(df.index.max()).date() + pd.Timedelta(days=1)]",
    "annotation": "\u2705 Best Practice: Resetting the index to return a DataFrame with a default integer index.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      17946,
      58,
      30094,
      13,
      14967,
      27823,
      7,
      7568,
      13,
      9630,
      13,
      1084,
      3419,
      737,
      4475,
      3419,
      1058,
      279,
      67,
      13,
      14967,
      27823,
      7,
      7568,
      13,
      9630,
      13,
      9806,
      3419,
      737,
      4475,
      3419,
      1343,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      12545,
      28,
      16,
      15437
    ],
    "start_token": 1586,
    "end_token": 1646,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      889,
      262,
      6376,
      284,
      1441,
      257,
      6060,
      19778,
      351,
      257,
      4277,
      18253,
      6376,
      13
    ],
    "label": "best_practice",
    "reason": "Resetting the index to return a DataFrame with a default integer index."
  },
  {
    "line": 198,
    "text": "        symbol_field_name: str = \"symbol\",",
    "annotation": "\ud83e\udde0 ML Signal: Method signature and parameter types can be used to infer function behavior and usage patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      62,
      3245,
      62,
      3672,
      25,
      965,
      796,
      366,
      1837,
      23650,
      1600
    ],
    "start_token": 1646,
    "end_token": 1665,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      290,
      11507,
      3858,
      460,
      307,
      973,
      284,
      13249,
      2163,
      4069,
      290,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method signature and parameter types can be used to infer function behavior and usage patterns"
  },
  {
    "line": 199,
    "text": "        last_close: float = None,",
    "annotation": "\ud83e\udde0 ML Signal: Function call with specific parameters can indicate common usage patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      938,
      62,
      19836,
      25,
      12178,
      796,
      6045,
      11
    ],
    "start_token": 1665,
    "end_token": 1680,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      2176,
      10007,
      460,
      7603,
      2219,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function call with specific parameters can indicate common usage patterns"
  },
  {
    "line": 202,
    "text": "            return df",
    "annotation": "\u2705 Best Practice: Using named parameters improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 1680,
    "end_token": 1693,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      3706,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Using named parameters improves code readability and maintainability"
  },
  {
    "line": 202,
    "text": "            return df",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764
    ],
    "start_token": 1693,
    "end_token": 1706,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 203,
    "text": "        symbol = df.loc[df[symbol_field_name].first_valid_index(), symbol_field_name]",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a DataFrame suggests data manipulation, which is common in ML pipelines",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      22784,
      6194,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 1706,
    "end_token": 1740,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      6060,
      19778,
      5644,
      1366,
      17512,
      11,
      543,
      318,
      2219,
      287,
      10373,
      31108
    ],
    "label": "ml_signal",
    "reason": "Usage of a DataFrame suggests data manipulation, which is common in ML pipelines"
  },
  {
    "line": 203,
    "text": "        symbol = df.loc[df[symbol_field_name].first_valid_index(), symbol_field_name]",
    "annotation": "\u2705 Best Practice: Reassigning the DataFrame to the same variable name can help in reducing memory usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      796,
      47764,
      13,
      17946,
      58,
      7568,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      4083,
      11085,
      62,
      12102,
      62,
      9630,
      22784,
      6194,
      62,
      3245,
      62,
      3672,
      60
    ],
    "start_token": 1740,
    "end_token": 1774,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      562,
      38944,
      262,
      6060,
      19778,
      284,
      262,
      976,
      7885,
      1438,
      460,
      1037,
      287,
      8868,
      4088,
      8748
    ],
    "label": "best_practice",
    "reason": "Reassigning the DataFrame to the same variable name can help in reducing memory usage"
  },
  {
    "line": 210,
    "text": "            df = df.reindex(",
    "annotation": "\ud83e\udde0 ML Signal: Named arguments indicate a pattern of using keyword arguments for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      260,
      9630,
      7
    ],
    "start_token": 1774,
    "end_token": 1792,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      34441,
      7159,
      7603,
      257,
      3912,
      286,
      1262,
      21179,
      7159,
      329,
      16287
    ],
    "label": "ml_signal",
    "reason": "Named arguments indicate a pattern of using keyword arguments for clarity"
  },
  {
    "line": 210,
    "text": "            df = df.reindex(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self attributes suggests object-oriented design patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      260,
      9630,
      7
    ],
    "start_token": 1792,
    "end_token": 1810,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      12608,
      5644,
      2134,
      12,
      17107,
      1486,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of self attributes suggests object-oriented design patterns"
  },
  {
    "line": 211,
    "text": "                pd.DataFrame(index=calendar_list)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self attributes suggests object-oriented design patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      7,
      9630,
      28,
      9948,
      9239,
      62,
      4868,
      8
    ],
    "start_token": 1810,
    "end_token": 1838,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      12608,
      5644,
      2134,
      12,
      17107,
      1486,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of self attributes suggests object-oriented design patterns"
  },
  {
    "line": 213,
    "text": "                .index",
    "annotation": "\ud83e\udde0 ML Signal: Specific frequency setting indicates time-series data processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 1838,
    "end_token": 1855,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17377,
      8373,
      4634,
      9217,
      640,
      12,
      25076,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Specific frequency setting indicates time-series data processing"
  },
  {
    "line": 215,
    "text": "        df.sort_index(inplace=True)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self attributes suggests object-oriented design patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      30619,
      62,
      9630,
      7,
      259,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 1855,
    "end_token": 1873,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      12608,
      5644,
      2134,
      12,
      17107,
      1486,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of self attributes suggests object-oriented design patterns"
  },
  {
    "line": 218,
    "text": "        df[\"change\"] = BaostockNormalizeHS3005min.calc_change(df, last_close)",
    "annotation": "\u2705 Best Practice: Returning the DataFrame directly is clear and concise",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      8973,
      796,
      8999,
      455,
      735,
      26447,
      1096,
      7998,
      6200,
      20,
      1084,
      13,
      9948,
      66,
      62,
      3803,
      7,
      7568,
      11,
      938,
      62,
      19836,
      8
    ],
    "start_token": 1873,
    "end_token": 1906,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      262,
      6060,
      19778,
      3264,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Returning the DataFrame directly is clear and concise"
  },
  {
    "line": 211,
    "text": "                pd.DataFrame(index=calendar_list)",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      7,
      9630,
      28,
      9948,
      9239,
      62,
      4868,
      8
    ],
    "start_token": 1906,
    "end_token": 1934,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 213,
    "text": "                .index",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Direct use of external library function without input validation or error handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 1934,
    "end_token": 1951,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      779,
      286,
      7097,
      5888,
      2163,
      1231,
      5128,
      21201,
      393,
      4049,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Direct use of external library function without input validation or error handling"
  },
  {
    "line": 213,
    "text": "                .index",
    "annotation": "\u2705 Best Practice: Include type hints for method parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 1951,
    "end_token": 1968,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2446,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for method parameters and return type for better readability and maintainability"
  },
  {
    "line": 215,
    "text": "        df.sort_index(inplace=True)",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with DataFrame operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      13,
      30619,
      62,
      9630,
      7,
      259,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 1968,
    "end_token": 1986,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      6060,
      19778,
      4560
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with DataFrame operations"
  },
  {
    "line": 217,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with DataFrame operations",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1986,
    "end_token": 1986,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      6060,
      19778,
      4560
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with DataFrame operations"
  },
  {
    "line": 219,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicit return of the DataFrame for clarity",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1986,
    "end_token": 1986,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      1441,
      286,
      262,
      6060,
      19778,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicit return of the DataFrame for clarity"
  },
  {
    "line": 218,
    "text": "        df[\"change\"] = BaostockNormalizeHS3005min.calc_change(df, last_close)",
    "annotation": "\u2705 Best Practice: Class docstring is missing, consider adding one to describe the purpose and usage of the class.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      8973,
      796,
      8999,
      455,
      735,
      26447,
      1096,
      7998,
      6200,
      20,
      1084,
      13,
      9948,
      66,
      62,
      3803,
      7,
      7568,
      11,
      938,
      62,
      19836,
      8
    ],
    "start_token": 1986,
    "end_token": 2019,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      318,
      4814,
      11,
      2074,
      4375,
      530,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring is missing, consider adding one to describe the purpose and usage of the class."
  },
  {
    "line": 219,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2019,
    "end_token": 2019,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 223,
    "text": "        df[symbol_field_name] = symbol",
    "annotation": "\u2705 Best Practice: Calling the superclass's __init__ method to ensure proper initialization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      60,
      796,
      6194
    ],
    "start_token": 2019,
    "end_token": 2037,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      32677,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      284,
      4155,
      1774,
      37588
    ],
    "label": "best_practice",
    "reason": "Calling the superclass's __init__ method to ensure proper initialization"
  },
  {
    "line": 225,
    "text": "        return df.reset_index()",
    "annotation": "\ud83e\udde0 ML Signal: Storing configuration or state information in instance variables",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764,
      13,
      42503,
      62,
      9630,
      3419
    ],
    "start_token": 2037,
    "end_token": 2051,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      8398,
      393,
      1181,
      1321,
      287,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Storing configuration or state information in instance variables"
  },
  {
    "line": 225,
    "text": "        return df.reset_index()",
    "annotation": "\ud83e\udde0 ML Signal: Method that constructs a class name based on attributes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764,
      13,
      42503,
      62,
      9630,
      3419
    ],
    "start_token": 2051,
    "end_token": 2065,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      326,
      34175,
      257,
      1398,
      1438,
      1912,
      319,
      12608
    ],
    "label": "ml_signal",
    "reason": "Method that constructs a class name based on attributes"
  },
  {
    "line": 226,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of f-string for dynamic string formatting",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2065,
    "end_token": 2065,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      277,
      12,
      8841,
      329,
      8925,
      4731,
      33313
    ],
    "label": "ml_signal",
    "reason": "Usage of f-string for dynamic string formatting"
  },
  {
    "line": 228,
    "text": "        return generate_minutes_calendar_from_daily(",
    "annotation": "\ud83e\udde0 ML Signal: Method for generating class names based on attributes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      7716,
      62,
      1084,
      1769,
      62,
      9948,
      9239,
      62,
      6738,
      62,
      29468,
      7
    ],
    "start_token": 2065,
    "end_token": 2085,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      15453,
      1398,
      3891,
      1912,
      319,
      12608
    ],
    "label": "ml_signal",
    "reason": "Method for generating class names based on attributes"
  },
  {
    "line": 229,
    "text": "            calendars, freq=\"5min\", am_range=self.AM_RANGE, pm_range=self.PM_RANGE",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      50215,
      11,
      2030,
      80,
      2625,
      20,
      1084,
      1600,
      716,
      62,
      9521,
      28,
      944,
      13,
      2390,
      62,
      49,
      27746,
      11,
      9114,
      62,
      9521,
      28,
      944,
      13,
      5868,
      62,
      49,
      27746
    ],
    "start_token": 2085,
    "end_token": 2125,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting"
  },
  {
    "line": 231,
    "text": "",
    "annotation": "\u2705 Best Practice: Specify the return type as a Union of Path and str for clarity.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2125,
    "end_token": 2125,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      1958,
      262,
      1441,
      2099,
      355,
      257,
      4479,
      286,
      10644,
      290,
      965,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Specify the return type as a Union of Path and str for clarity."
  },
  {
    "line": 233,
    "text": "        df = calc_adjusted_price(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): CUR_DIR should be validated to ensure it is a safe and expected path.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      42302,
      62,
      29117,
      62,
      20888,
      7
    ],
    "start_token": 2125,
    "end_token": 2140,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      327,
      4261,
      62,
      34720,
      815,
      307,
      31031,
      284,
      4155,
      340,
      318,
      257,
      3338,
      290,
      2938,
      3108,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "CUR_DIR should be validated to ensure it is a safe and expected path."
  },
  {
    "line": 242,
    "text": "    def _get_1d_calendar_list(self) -> Iterable[pd.Timestamp]:",
    "annotation": "\u2705 Best Practice: Docstring provides clear documentation for the function's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      16,
      67,
      62,
      9948,
      9239,
      62,
      4868,
      7,
      944,
      8,
      4613,
      40806,
      540,
      58,
      30094,
      13,
      14967,
      27823,
      5974
    ],
    "start_token": 2140,
    "end_token": 2166,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      10314,
      329,
      262,
      2163,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear documentation for the function's purpose and usage."
  },
  {
    "line": 252,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of `super()` indicates inheritance and method overriding, useful for understanding class hierarchies.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2166,
    "end_token": 2166,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4600,
      16668,
      3419,
      63,
      9217,
      24155,
      290,
      2446,
      44987,
      11,
      4465,
      329,
      4547,
      1398,
      28398,
      444,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of `super()` indicates inheritance and method overriding, useful for understanding class hierarchies."
  },
  {
    "line": 271,
    "text": "        return CUR_DIR",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if qlib_data_1d_dir is not validated properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      327,
      4261,
      62,
      34720
    ],
    "start_token": 2166,
    "end_token": 2178,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      10662,
      8019,
      62,
      7890,
      62,
      16,
      67,
      62,
      15908,
      318,
      407,
      31031,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if qlib_data_1d_dir is not validated properly"
  },
  {
    "line": 275,
    "text": "        max_collector_count=2,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of super() indicates inheritance and method overriding",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      33327,
      273,
      62,
      9127,
      28,
      17,
      11
    ],
    "start_token": 2178,
    "end_token": 2194,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2208,
      3419,
      9217,
      24155,
      290,
      2446,
      44987
    ],
    "label": "ml_signal",
    "reason": "Usage of super() indicates inheritance and method overriding"
  },
  {
    "line": 279,
    "text": "        check_data_length=None,",
    "annotation": "\ud83e\udde0 ML Signal: Entry point for command-line interface",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2198,
      62,
      7890,
      62,
      13664,
      28,
      14202,
      11
    ],
    "start_token": 2194,
    "end_token": 2209,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21617,
      966,
      329,
      3141,
      12,
      1370,
      7071
    ],
    "label": "ml_signal",
    "reason": "Entry point for command-line interface"
  },
  {
    "line": 279,
    "text": "        check_data_length=None,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of fire.Fire for command-line interface generation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2198,
      62,
      7890,
      62,
      13664,
      28,
      14202,
      11
    ],
    "start_token": 2209,
    "end_token": 2224,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2046,
      13,
      13543,
      329,
      3141,
      12,
      1370,
      7071,
      5270
    ],
    "label": "ml_signal",
    "reason": "Usage of fire.Fire for command-line interface generation"
  }
]