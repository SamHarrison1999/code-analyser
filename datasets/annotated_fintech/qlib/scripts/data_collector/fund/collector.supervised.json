[
  {
    "line": 14,
    "text": "from loguru import logger",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying sys.path can lead to import conflicts or security issues if not handled carefully.",
    "confidence": 1.0,
    "tokens": [
      6738,
      2604,
      14717,
      1330,
      49706
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      25064,
      13,
      6978,
      460,
      1085,
      284,
      1330,
      12333,
      393,
      2324,
      2428,
      611,
      407,
      12118,
      7773,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying sys.path can lead to import conflicts or security issues if not handled carefully."
  },
  {
    "line": 18,
    "text": "CUR_DIR = Path(__file__).resolve().parent",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Hardcoded URL can lead to security risks if the URL is not trusted or if it changes.",
    "confidence": 1.0,
    "tokens": [
      34,
      4261,
      62,
      34720,
      796,
      10644,
      7,
      834,
      7753,
      834,
      737,
      411,
      6442,
      22446,
      8000
    ],
    "start_token": 5,
    "end_token": 20,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      6912,
      40976,
      10289,
      460,
      1085,
      284,
      2324,
      7476,
      611,
      262,
      10289,
      318,
      407,
      13467,
      393,
      611,
      340,
      2458,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Hardcoded URL can lead to security risks if the URL is not trusted or if it changes."
  },
  {
    "line": 31,
    "text": "        end=None,",
    "annotation": "\u2705 Best Practice: Use of docstring to describe parameters and their defaults",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      28,
      14202,
      11
    ],
    "start_token": 20,
    "end_token": 31,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2205,
      8841,
      284,
      6901,
      10007,
      290,
      511,
      26235
    ],
    "label": "best_practice",
    "reason": "Use of docstring to describe parameters and their defaults"
  },
  {
    "line": 53,
    "text": "        start: str",
    "annotation": "\u2705 Best Practice: Explicit call to superclass initializer",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      25,
      965
    ],
    "start_token": 31,
    "end_token": 41,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      869,
      284,
      2208,
      4871,
      4238,
      7509
    ],
    "label": "best_practice",
    "reason": "Explicit call to superclass initializer"
  },
  {
    "line": 66,
    "text": "            interval=interval,",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of datetime-related functionality",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      28,
      3849,
      2100,
      11
    ],
    "start_token": 41,
    "end_token": 57,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4818,
      8079,
      12,
      5363,
      11244
    ],
    "label": "ml_signal",
    "reason": "Initialization of datetime-related functionality"
  },
  {
    "line": 66,
    "text": "            interval=interval,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of conditional logic to handle different intervals",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      28,
      3849,
      2100,
      11
    ],
    "start_token": 57,
    "end_token": 73,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      20016
    ],
    "label": "ml_signal",
    "reason": "Usage of conditional logic to handle different intervals"
  },
  {
    "line": 68,
    "text": "            max_collector_count=max_collector_count,",
    "annotation": "\ud83e\udde0 ML Signal: Use of max function to ensure start_datetime is not before a default value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      33327,
      273,
      62,
      9127,
      28,
      9806,
      62,
      33327,
      273,
      62,
      9127,
      11
    ],
    "start_token": 73,
    "end_token": 98,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3509,
      2163,
      284,
      4155,
      923,
      62,
      19608,
      8079,
      318,
      407,
      878,
      257,
      4277,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of max function to ensure start_datetime is not before a default value"
  },
  {
    "line": 69,
    "text": "            delay=delay,",
    "annotation": "\ud83e\udde0 ML Signal: Handling of specific interval case with no operation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5711,
      28,
      40850,
      11
    ],
    "start_token": 98,
    "end_token": 113,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      286,
      2176,
      16654,
      1339,
      351,
      645,
      4905
    ],
    "label": "ml_signal",
    "reason": "Handling of specific interval case with no operation"
  },
  {
    "line": 73,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without specific handling",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 113,
    "end_token": 113,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      2176,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without specific handling"
  },
  {
    "line": 76,
    "text": "    def init_datetime(self):",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of datetime to a specific timezone",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      2315,
      62,
      19608,
      8079,
      7,
      944,
      2599
    ],
    "start_token": 113,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      4818,
      8079,
      284,
      257,
      2176,
      640,
      11340
    ],
    "label": "ml_signal",
    "reason": "Conversion of datetime to a specific timezone"
  },
  {
    "line": 78,
    "text": "            self.start_datetime = max(self.start_datetime, self.DEFAULT_START_DATETIME_1MIN)",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of datetime to a specific timezone",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      796,
      3509,
      7,
      944,
      13,
      9688,
      62,
      19608,
      8079,
      11,
      2116,
      13,
      7206,
      38865,
      62,
      2257,
      7227,
      62,
      35,
      1404,
      2767,
      12789,
      62,
      16,
      23678,
      8
    ],
    "start_token": 124,
    "end_token": 167,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      4818,
      8079,
      284,
      257,
      2176,
      640,
      11340
    ],
    "label": "ml_signal",
    "reason": "Conversion of datetime to a specific timezone"
  },
  {
    "line": 75,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting with a list of types is not standard; consider using Union for clarity.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 167,
    "end_token": 167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      351,
      257,
      1351,
      286,
      3858,
      318,
      407,
      3210,
      26,
      2074,
      1262,
      4479,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting with a list of types is not standard; consider using Union for clarity."
  },
  {
    "line": 78,
    "text": "            self.start_datetime = max(self.start_datetime, self.DEFAULT_START_DATETIME_1MIN)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone-related issues if timezone is not validated.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      796,
      3509,
      7,
      944,
      13,
      9688,
      62,
      19608,
      8079,
      11,
      2116,
      13,
      7206,
      38865,
      62,
      2257,
      7227,
      62,
      35,
      1404,
      2767,
      12789,
      62,
      16,
      23678,
      8
    ],
    "start_token": 167,
    "end_token": 210,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      12,
      5363,
      2428,
      611,
      640,
      11340,
      318,
      407,
      31031,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone-related issues if timezone is not validated."
  },
  {
    "line": 80,
    "text": "            pass",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone-related issues if tzlocal() is not correctly handled.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1208
    ],
    "start_token": 210,
    "end_token": 222,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      12,
      5363,
      2428,
      611,
      256,
      89,
      12001,
      3419,
      318,
      407,
      9380,
      12118,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone-related issues if tzlocal() is not correctly handled."
  },
  {
    "line": 84,
    "text": "        self.start_datetime = self.convert_datetime(self.start_datetime, self._timezone)",
    "annotation": "\u2705 Best Practice: Consider logging the exception for better debugging.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9688,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      1102,
      1851,
      62,
      19608,
      8079,
      7,
      944,
      13,
      9688,
      62,
      19608,
      8079,
      11,
      2116,
      13557,
      2435,
      11340,
      8
    ],
    "start_token": 222,
    "end_token": 256,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      18931,
      262,
      6631,
      329,
      1365,
      28769,
      13
    ],
    "label": "best_practice",
    "reason": "Consider logging the exception for better debugging."
  },
  {
    "line": 85,
    "text": "        self.end_datetime = self.convert_datetime(self.end_datetime, self._timezone)",
    "annotation": "\u2705 Best Practice: Using @property with @abc.abstractmethod is a common pattern for defining abstract properties.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      1102,
      1851,
      62,
      19608,
      8079,
      7,
      944,
      13,
      437,
      62,
      19608,
      8079,
      11,
      2116,
      13557,
      2435,
      11340,
      8
    ],
    "start_token": 256,
    "end_token": 290,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2488,
      26745,
      351,
      2488,
      39305,
      13,
      397,
      8709,
      24396,
      318,
      257,
      2219,
      3912,
      329,
      16215,
      12531,
      6608,
      13
    ],
    "label": "best_practice",
    "reason": "Using @property with @abc.abstractmethod is a common pattern for defining abstract properties."
  },
  {
    "line": 85,
    "text": "        self.end_datetime = self.convert_datetime(self.end_datetime, self._timezone)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method raises NotImplementedError, which could lead to runtime errors if not properly overridden.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      437,
      62,
      19608,
      8079,
      796,
      2116,
      13,
      1102,
      1851,
      62,
      19608,
      8079,
      7,
      944,
      13,
      437,
      62,
      19608,
      8079,
      11,
      2116,
      13557,
      2435,
      11340,
      8
    ],
    "start_token": 290,
    "end_token": 324,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      6105,
      23170,
      4651,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method raises NotImplementedError, which could lead to runtime errors if not properly overridden."
  },
  {
    "line": 88,
    "text": "    def convert_datetime(dt: [pd.Timestamp, datetime.date, str], timezone):",
    "annotation": "\ud83e\udde0 ML Signal: Use of formatted strings for error messages",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      10385,
      62,
      19608,
      8079,
      7,
      28664,
      25,
      685,
      30094,
      13,
      14967,
      27823,
      11,
      4818,
      8079,
      13,
      4475,
      11,
      965,
      4357,
      640,
      11340,
      2599
    ],
    "start_token": 324,
    "end_token": 351,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      39559,
      13042,
      329,
      4049,
      6218
    ],
    "label": "ml_signal",
    "reason": "Use of formatted strings for error messages"
  },
  {
    "line": 90,
    "text": "            dt = pd.Timestamp(dt, tz=timezone).timestamp()",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potentially unsafe URL construction without validation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      83,
      796,
      279,
      67,
      13,
      14967,
      27823,
      7,
      28664,
      11,
      256,
      89,
      28,
      2435,
      11340,
      737,
      16514,
      27823,
      3419
    ],
    "start_token": 351,
    "end_token": 382,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      6902,
      3746,
      21596,
      10289,
      5103,
      1231,
      21201
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potentially unsafe URL construction without validation"
  },
  {
    "line": 95,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): No timeout specified for requests.get, can lead to hanging",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 382,
    "end_token": 382,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      1400,
      26827,
      7368,
      329,
      7007,
      13,
      1136,
      11,
      460,
      1085,
      284,
      10938
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "No timeout specified for requests.get, can lead to hanging"
  },
  {
    "line": 97,
    "text": "    @abc.abstractmethod",
    "annotation": "\u2705 Best Practice: Check for HTTP response status",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      39305,
      13,
      397,
      8709,
      24396
    ],
    "start_token": 382,
    "end_token": 391,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      14626,
      2882,
      3722
    ],
    "label": "best_practice",
    "reason": "Check for HTTP response status"
  },
  {
    "line": 100,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for JSON parsing errors",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 391,
    "end_token": 391,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      19449,
      32096,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for JSON parsing errors"
  },
  {
    "line": 102,
    "text": "    def get_data_from_remote(symbol, interval, start, end):",
    "annotation": "\ud83e\udde0 ML Signal: Checking specific keys in JSON response",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      62,
      6738,
      62,
      47960,
      7,
      1837,
      23650,
      11,
      16654,
      11,
      923,
      11,
      886,
      2599
    ],
    "start_token": 391,
    "end_token": 412,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      2176,
      8251,
      287,
      19449,
      2882
    ],
    "label": "ml_signal",
    "reason": "Checking specific keys in JSON response"
  },
  {
    "line": 105,
    "text": "        try:",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 412,
    "end_token": 421,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 108,
    "text": "                index_code=symbol, numberOfHistoricalDaysToCrawl=10000, startDate=start, endDate=end",
    "annotation": "\u2705 Best Practice: Check type before operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      62,
      8189,
      28,
      1837,
      23650,
      11,
      1271,
      5189,
      13749,
      12409,
      38770,
      2514,
      34,
      13132,
      28,
      49388,
      11,
      923,
      10430,
      28,
      9688,
      11,
      886,
      10430,
      28,
      437
    ],
    "start_token": 421,
    "end_token": 463,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      2099,
      878,
      4560
    ],
    "label": "best_practice",
    "reason": "Check type before operations"
  },
  {
    "line": 111,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging exceptions with context",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 463,
    "end_token": 463,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      13269,
      351,
      4732
    ],
    "label": "ml_signal",
    "reason": "Logging exceptions with context"
  },
  {
    "line": 105,
    "text": "        try:",
    "annotation": "\u2705 Best Practice: Consider specifying the return type as List[pd.DataFrame] for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 463,
    "end_token": 472,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      31577,
      262,
      1441,
      2099,
      355,
      7343,
      58,
      30094,
      13,
      6601,
      19778,
      60,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Consider specifying the return type as List[pd.DataFrame] for clarity"
  },
  {
    "line": 109,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 472,
    "end_token": 484,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters."
  },
  {
    "line": 111,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a sleep function indicates a delay or rate-limiting pattern.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 484,
    "end_token": 484,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      3993,
      2163,
      9217,
      257,
      5711,
      393,
      2494,
      12,
      2475,
      1780,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a sleep function indicates a delay or rate-limiting pattern."
  },
  {
    "line": 111,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of a global or outer-scope variable without clear definition in the function.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 484,
    "end_token": 484,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      257,
      3298,
      393,
      12076,
      12,
      29982,
      7885,
      1231,
      1598,
      6770,
      287,
      262,
      2163,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of a global or outer-scope variable without clear definition in the function."
  },
  {
    "line": 116,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of a global or outer-scope variable without clear definition in the function.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 484,
    "end_token": 484,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      257,
      3298,
      393,
      12076,
      12,
      29982,
      7885,
      1231,
      1598,
      6770,
      287,
      262,
      2163,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of a global or outer-scope variable without clear definition in the function."
  },
  {
    "line": 122,
    "text": "            # TODO: should we sort the value by datetime?",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on interval values can indicate time-based data processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      815,
      356,
      3297,
      262,
      1988,
      416,
      4818,
      8079,
      30
    ],
    "start_token": 484,
    "end_token": 508,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      16654,
      3815,
      460,
      7603,
      640,
      12,
      3106,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on interval values can indicate time-based data processing."
  },
  {
    "line": 126,
    "text": "                return _resp.reset_index()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through exception message.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      4363,
      13,
      42503,
      62,
      9630,
      3419
    ],
    "start_token": 508,
    "end_token": 531,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      6631,
      3275,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through exception message."
  },
  {
    "line": 128,
    "text": "            logger.warning(f\"{error_msg}:{e}\")",
    "annotation": "\u2705 Best Practice: Ensure that the function or method that contains this code has a clear return type.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      90,
      18224,
      62,
      19662,
      92,
      29164,
      68,
      92,
      4943
    ],
    "start_token": 531,
    "end_token": 557,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2163,
      393,
      2446,
      326,
      4909,
      428,
      2438,
      468,
      257,
      1598,
      1441,
      2099,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the function or method that contains this code has a clear return type."
  },
  {
    "line": 122,
    "text": "            # TODO: should we sort the value by datetime?",
    "annotation": "\u2705 Best Practice: Inheriting from ABC indicates that this class is intended to be abstract.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      815,
      356,
      3297,
      262,
      1988,
      416,
      4818,
      8079,
      30
    ],
    "start_token": 557,
    "end_token": 581,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      9738,
      9217,
      326,
      428,
      1398,
      318,
      5292,
      284,
      307,
      12531,
      13
    ],
    "label": "best_practice",
    "reason": "Inheriting from ABC indicates that this class is intended to be abstract."
  },
  {
    "line": 123,
    "text": "            _resp = pd.DataFrame(data[\"Data\"][\"LSJZList\"])",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its functionality",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      4363,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      7890,
      14692,
      6601,
      1,
      7131,
      1,
      6561,
      41,
      57,
      8053,
      8973,
      8
    ],
    "start_token": 581,
    "end_token": 613,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      11244
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its functionality"
  },
  {
    "line": 125,
    "text": "            if isinstance(_resp, pd.DataFrame):",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      28264,
      4363,
      11,
      279,
      67,
      13,
      6601,
      19778,
      2599
    ],
    "start_token": 613,
    "end_token": 636,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern"
  },
  {
    "line": 127,
    "text": "        except Exception as e:",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      35528,
      355,
      304,
      25
    ],
    "start_token": 636,
    "end_token": 648,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912
    ],
    "label": "ml_signal",
    "reason": "Function call pattern"
  },
  {
    "line": 129,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern with dynamic data",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 648,
    "end_token": 648,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      351,
      8925,
      1366
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern with dynamic data"
  },
  {
    "line": 131,
    "text": "        self, symbol: str, interval: str, start_datetime: pd.Timestamp, end_datetime: pd.Timestamp",
    "annotation": "\ud83e\udde0 ML Signal: Return statement pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      6194,
      25,
      965,
      11,
      16654,
      25,
      965,
      11,
      923,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11,
      886,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 648,
    "end_token": 686,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8229,
      2643,
      3912
    ],
    "label": "ml_signal",
    "reason": "Return statement pattern"
  },
  {
    "line": 129,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Function that returns input as output, indicating a potential placeholder or default behavior",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 686,
    "end_token": 686,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      326,
      5860,
      5128,
      355,
      5072,
      11,
      12739,
      257,
      2785,
      46076,
      393,
      4277,
      4069
    ],
    "label": "ml_signal",
    "reason": "Function that returns input as output, indicating a potential placeholder or default behavior"
  },
  {
    "line": 132,
    "text": "    ) -> [pd.DataFrame]:",
    "annotation": "\u2705 Best Practice: Use of @property decorator for defining a read-only attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      685,
      30094,
      13,
      6601,
      19778,
      5974
    ],
    "start_token": 686,
    "end_token": 697,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      16215,
      257,
      1100,
      12,
      8807,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for defining a read-only attribute"
  },
  {
    "line": 131,
    "text": "        self, symbol: str, interval: str, start_datetime: pd.Timestamp, end_datetime: pd.Timestamp",
    "annotation": "\u2705 Best Practice: Consider using a constant or configuration for timezone values to improve maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      6194,
      25,
      965,
      11,
      16654,
      25,
      965,
      11,
      923,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11,
      886,
      62,
      19608,
      8079,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 697,
    "end_token": 735,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      6937,
      393,
      8398,
      329,
      640,
      11340,
      3815,
      284,
      2987,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a constant or configuration for timezone values to improve maintainability."
  },
  {
    "line": 133,
    "text": "        def _get_simple(start_, end_):",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality from a parent class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      36439,
      7,
      9688,
      62,
      11,
      886,
      62,
      2599
    ],
    "start_token": 735,
    "end_token": 754,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      422,
      257,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality from a parent class"
  },
  {
    "line": 136,
    "text": "            return self.get_data_from_remote(",
    "annotation": "\u2705 Best Practice: Use of a static method for utility functions that do not require class or instance data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      1136,
      62,
      7890,
      62,
      6738,
      62,
      47960,
      7
    ],
    "start_token": 754,
    "end_token": 776,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      9037,
      2446,
      329,
      10361,
      5499,
      326,
      466,
      407,
      2421,
      1398,
      393,
      4554,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of a static method for utility functions that do not require class or instance data"
  },
  {
    "line": 144,
    "text": "            _result = _get_simple(start_datetime, end_datetime)",
    "annotation": "\u2705 Best Practice: Check for empty DataFrame to avoid unnecessary processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      20274,
      796,
      4808,
      1136,
      62,
      36439,
      7,
      9688,
      62,
      19608,
      8079,
      11,
      886,
      62,
      19608,
      8079,
      8
    ],
    "start_token": 776,
    "end_token": 805,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      6060,
      19778,
      284,
      3368,
      13114,
      7587
    ],
    "label": "best_practice",
    "reason": "Check for empty DataFrame to avoid unnecessary processing"
  },
  {
    "line": 147,
    "text": "        return _result",
    "annotation": "\u2705 Best Practice: Use copy to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      20274
    ],
    "start_token": 805,
    "end_token": 815,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      4866,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use copy to avoid modifying the original DataFrame"
  },
  {
    "line": 149,
    "text": "",
    "annotation": "\u2705 Best Practice: Set index for efficient time series operations",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 815,
    "end_token": 815,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5345,
      6376,
      329,
      6942,
      640,
      2168,
      4560
    ],
    "label": "best_practice",
    "reason": "Set index for efficient time series operations"
  },
  {
    "line": 151,
    "text": "    def get_instrument_list(self):",
    "annotation": "\u2705 Best Practice: Convert index to datetime for time series operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      259,
      43872,
      62,
      4868,
      7,
      944,
      2599
    ],
    "start_token": 815,
    "end_token": 828,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      6376,
      284,
      4818,
      8079,
      329,
      640,
      2168,
      4560
    ],
    "label": "best_practice",
    "reason": "Convert index to datetime for time series operations"
  },
  {
    "line": 151,
    "text": "    def get_instrument_list(self):",
    "annotation": "\u2705 Best Practice: Remove duplicate indices to ensure data integrity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      259,
      43872,
      62,
      4868,
      7,
      944,
      2599
    ],
    "start_token": 828,
    "end_token": 841,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17220,
      23418,
      36525,
      284,
      4155,
      1366,
      11540
    ],
    "label": "best_practice",
    "reason": "Remove duplicate indices to ensure data integrity"
  },
  {
    "line": 159,
    "text": "",
    "annotation": "\u2705 Best Practice: Reindex to align with a given calendar",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 841,
    "end_token": 841,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      9630,
      284,
      10548,
      351,
      257,
      1813,
      11845
    ],
    "label": "best_practice",
    "reason": "Reindex to align with a given calendar"
  },
  {
    "line": 160,
    "text": "    @property",
    "annotation": "\u2705 Best Practice: Use pd.Timestamp for consistent datetime operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 841,
    "end_token": 846,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      279,
      67,
      13,
      14967,
      27823,
      329,
      6414,
      4818,
      8079,
      4560
    ],
    "label": "best_practice",
    "reason": "Use pd.Timestamp for consistent datetime operations"
  },
  {
    "line": 166,
    "text": "    pass",
    "annotation": "\u2705 Best Practice: Sort index to maintain chronological order",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1208
    ],
    "start_token": 846,
    "end_token": 850,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      33947,
      6376,
      284,
      5529,
      45946,
      1502
    ],
    "label": "best_practice",
    "reason": "Sort index to maintain chronological order"
  },
  {
    "line": 168,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicitly set index names for clarity",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 850,
    "end_token": 850,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      900,
      6376,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly set index names for clarity"
  },
  {
    "line": 170,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u2705 Best Practice: Reset index to convert index back to a column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 850,
    "end_token": 868,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      30027,
      6376,
      284,
      10385,
      6376,
      736,
      284,
      257,
      5721
    ],
    "label": "best_practice",
    "reason": "Reset index to convert index back to a column"
  },
  {
    "line": 162,
    "text": "        return \"Asia/Shanghai\"",
    "annotation": "\u2705 Best Practice: Include type hints for method parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      38555,
      14,
      2484,
      272,
      20380,
      1
    ],
    "start_token": 868,
    "end_token": 883,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2446,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for method parameters and return type for better readability and maintainability"
  },
  {
    "line": 164,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with DataFrame operations",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 883,
    "end_token": 883,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      6060,
      19778,
      4560
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with DataFrame operations"
  },
  {
    "line": 165,
    "text": "class FundCollectorCN1d(FundollectorCN):",
    "annotation": "\u2705 Best Practice: Use descriptive variable names for better readability",
    "confidence": 1.0,
    "tokens": [
      4871,
      7557,
      31337,
      273,
      44175,
      16,
      67,
      7,
      24553,
      349,
      801,
      273,
      44175,
      2599
    ],
    "start_token": 883,
    "end_token": 897,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      35644,
      7885,
      3891,
      329,
      1365,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use descriptive variable names for better readability"
  },
  {
    "line": 167,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Returning a DataFrame after processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 897,
    "end_token": 897,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      6060,
      19778,
      706,
      7587
    ],
    "label": "ml_signal",
    "reason": "Returning a DataFrame after processing"
  },
  {
    "line": 165,
    "text": "class FundCollectorCN1d(FundollectorCN):",
    "annotation": "\u2705 Best Practice: Use of inheritance to extend functionality of a base class",
    "confidence": 1.0,
    "tokens": [
      4871,
      7557,
      31337,
      273,
      44175,
      16,
      67,
      7,
      24553,
      349,
      801,
      273,
      44175,
      2599
    ],
    "start_token": 897,
    "end_token": 911,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      24155,
      284,
      9117,
      11244,
      286,
      257,
      2779,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of inheritance to extend functionality of a base class"
  },
  {
    "line": 168,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a private method name indicates internal use within the class",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 911,
    "end_token": 911,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2839,
      2446,
      1438,
      9217,
      5387,
      779,
      1626,
      262,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of a private method name indicates internal use within the class"
  },
  {
    "line": 170,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\ud83e\udde0 ML Signal: Function call with a constant string argument",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 911,
    "end_token": 929,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      257,
      6937,
      4731,
      4578
    ],
    "label": "ml_signal",
    "reason": "Function call with a constant string argument"
  },
  {
    "line": 170,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u2705 Best Practice: Use of multiple inheritance to combine functionality from FundNormalizeCN and FundNormalize1d",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 929,
    "end_token": 947,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3294,
      24155,
      284,
      12082,
      11244,
      422,
      7557,
      26447,
      1096,
      44175,
      290,
      7557,
      26447,
      1096,
      16,
      67
    ],
    "label": "best_practice",
    "reason": "Use of multiple inheritance to combine functionality from FundNormalizeCN and FundNormalize1d"
  },
  {
    "line": 173,
    "text": "    def normalize_fund(",
    "annotation": "\u2705 Best Practice: Class definition should inherit from a base class for reusability and structure.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      10990,
      7
    ],
    "start_token": 947,
    "end_token": 956,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      16955,
      422,
      257,
      2779,
      1398,
      329,
      302,
      385,
      1799,
      290,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should inherit from a base class for reusability and structure."
  },
  {
    "line": 174,
    "text": "        df: pd.DataFrame,",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11
    ],
    "start_token": 956,
    "end_token": 971,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 189,
    "text": "                    pd.Timestamp(df.index.min()).date() : pd.Timestamp(df.index.max()).date()",
    "annotation": "\u2705 Best Practice: Calling the superclass's __init__ method to ensure proper initialization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      14967,
      27823,
      7,
      7568,
      13,
      9630,
      13,
      1084,
      3419,
      737,
      4475,
      3419,
      1058,
      279,
      67,
      13,
      14967,
      27823,
      7,
      7568,
      13,
      9630,
      13,
      9806,
      3419,
      737,
      4475,
      3419
    ],
    "start_token": 971,
    "end_token": 1021,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      32677,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      284,
      4155,
      1774,
      37588
    ],
    "label": "best_practice",
    "reason": "Calling the superclass's __init__ method to ensure proper initialization"
  },
  {
    "line": 191,
    "text": "                ]",
    "annotation": "\ud83e\udde0 ML Signal: Storing configuration or state information in instance variables",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 1021,
    "end_token": 1037,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      8398,
      393,
      1181,
      1321,
      287,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Storing configuration or state information in instance variables"
  },
  {
    "line": 191,
    "text": "                ]",
    "annotation": "\ud83e\udde0 ML Signal: Use of f-string for dynamic string formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 1037,
    "end_token": 1053,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      8925,
      4731,
      33313
    ],
    "label": "ml_signal",
    "reason": "Use of f-string for dynamic string formatting"
  },
  {
    "line": 192,
    "text": "                .index",
    "annotation": "\ud83e\udde0 ML Signal: Use of string manipulation methods",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9630
    ],
    "start_token": 1053,
    "end_token": 1070,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      17512,
      5050
    ],
    "label": "ml_signal",
    "reason": "Use of string manipulation methods"
  },
  {
    "line": 195,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for generating class names based on attributes",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1070,
    "end_token": 1070,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      15453,
      1398,
      3891,
      1912,
      319,
      12608
    ],
    "label": "ml_signal",
    "reason": "Method for generating class names based on attributes"
  },
  {
    "line": 197,
    "text": "        return df.reset_index()",
    "annotation": "\u2705 Best Practice: Specify the return type as a Union of Path and str for clarity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      47764,
      13,
      42503,
      62,
      9630,
      3419
    ],
    "start_token": 1070,
    "end_token": 1084,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      1958,
      262,
      1441,
      2099,
      355,
      257,
      4479,
      286,
      10644,
      290,
      965,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Specify the return type as a Union of Path and str for clarity."
  },
  {
    "line": 199,
    "text": "    def normalize(self, df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning a global variable like CUR_DIR can expose internal state.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      7,
      944,
      11,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 1084,
    "end_token": 1108,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      257,
      3298,
      7885,
      588,
      327,
      4261,
      62,
      34720,
      460,
      15651,
      5387,
      1181,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning a global variable like CUR_DIR can expose internal state."
  },
  {
    "line": 208,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides clear documentation of parameters and usage",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1108,
    "end_token": 1108,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      10314,
      286,
      10007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear documentation of parameters and usage"
  },
  {
    "line": 230,
    "text": "        interval: str",
    "annotation": "\ud83e\udde0 ML Signal: Method overriding in a class, useful for learning class hierarchies",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      25,
      965
    ],
    "start_token": 1108,
    "end_token": 1118,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      44987,
      287,
      257,
      1398,
      11,
      4465,
      329,
      4673,
      1398,
      28398,
      444
    ],
    "label": "ml_signal",
    "reason": "Method overriding in a class, useful for learning class hierarchies"
  },
  {
    "line": 231,
    "text": "            freq, value from [1min, 1d], default 1d",
    "annotation": "\u2705 Best Practice: Use of super() to call the parent class method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      11,
      1988,
      422,
      685,
      16,
      1084,
      11,
      352,
      67,
      4357,
      4277,
      352,
      67
    ],
    "start_token": 1118,
    "end_token": 1144,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      262,
      2560,
      1398,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of super() to call the parent class method"
  },
  {
    "line": 231,
    "text": "            freq, value from [1min, 1d], default 1d",
    "annotation": "\u2705 Best Practice: Use of default parameter values for flexibility and ease of use",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      11,
      1988,
      422,
      685,
      16,
      1084,
      11,
      352,
      67,
      4357,
      4277,
      352,
      67
    ],
    "start_token": 1144,
    "end_token": 1170,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      3815,
      329,
      13688,
      290,
      10152,
      286,
      779
    ],
    "label": "best_practice",
    "reason": "Use of default parameter values for flexibility and ease of use"
  },
  {
    "line": 243,
    "text": "    def normalize_class_name(self):",
    "annotation": "\ud83e\udde0 ML Signal: Method overriding in a class, indicating use of inheritance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3487,
      1096,
      62,
      4871,
      62,
      3672,
      7,
      944,
      2599
    ],
    "start_token": 1170,
    "end_token": 1183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      44987,
      287,
      257,
      1398,
      11,
      12739,
      779,
      286,
      24155
    ],
    "label": "ml_signal",
    "reason": "Method overriding in a class, indicating use of inheritance"
  },
  {
    "line": 244,
    "text": "        return f\"FundNormalize{self.region.upper()}{self.interval}\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using fire.Fire can execute arbitrary code if user input is not properly sanitized",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      277,
      1,
      24553,
      26447,
      1096,
      90,
      944,
      13,
      36996,
      13,
      45828,
      3419,
      18477,
      944,
      13,
      3849,
      2100,
      36786
    ],
    "start_token": 1183,
    "end_token": 1209,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      2046,
      13,
      13543,
      460,
      12260,
      14977,
      2438,
      611,
      2836,
      5128,
      318,
      407,
      6105,
      5336,
      36951
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using fire.Fire can execute arbitrary code if user input is not properly sanitized"
  },
  {
    "line": 244,
    "text": "        return f\"FundNormalize{self.region.upper()}{self.interval}\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of fire.Fire for command-line interface generation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      277,
      1,
      24553,
      26447,
      1096,
      90,
      944,
      13,
      36996,
      13,
      45828,
      3419,
      18477,
      944,
      13,
      3849,
      2100,
      36786
    ],
    "start_token": 1209,
    "end_token": 1235,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2046,
      13,
      13543,
      329,
      3141,
      12,
      1370,
      7071,
      5270
    ],
    "label": "ml_signal",
    "reason": "Use of fire.Fire for command-line interface generation"
  }
]