[
  {
    "line": 12,
    "text": "from typing import Iterable",
    "annotation": "\u2705 Best Practice: Use of fire library for creating CLIs easily",
    "confidence": 0.5,
    "tokens": [
      6738,
      19720,
      1330,
      40806,
      540
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2046,
      5888,
      329,
      4441,
      7852,
      3792,
      3538
    ],
    "label": "best_practice",
    "reason": "Use of fire library for creating CLIs easily"
  },
  {
    "line": 14,
    "text": "from concurrent.futures import ProcessPoolExecutor",
    "annotation": "\u2705 Best Practice: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      6738,
      24580,
      13,
      69,
      315,
      942,
      1330,
      10854,
      27201,
      23002,
      38409
    ],
    "start_token": 5,
    "end_token": 16,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "best_practice",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 16,
    "text": "import fire",
    "annotation": "\u2705 Best Practice: Use of tqdm for progress bar in loops",
    "confidence": 0.5,
    "tokens": [
      11748,
      2046
    ],
    "start_token": 16,
    "end_token": 18,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      256,
      80,
      36020,
      329,
      4371,
      2318,
      287,
      23607
    ],
    "label": "best_practice",
    "reason": "Use of tqdm for progress bar in loops"
  },
  {
    "line": 18,
    "text": "from tqdm import tqdm",
    "annotation": "\u2705 Best Practice: Use of loguru for logging",
    "confidence": 0.5,
    "tokens": [
      6738,
      256,
      80,
      36020,
      1330,
      256,
      80,
      36020
    ],
    "start_token": 18,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2604,
      14717,
      329,
      18931
    ],
    "label": "best_practice",
    "reason": "Use of loguru for logging"
  },
  {
    "line": 20,
    "text": "from qlib.utils import fname_to_code, get_period_offset",
    "annotation": "\ud83e\udde0 ML Signal: Importing specific functions from a module",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      26791,
      1330,
      277,
      3672,
      62,
      1462,
      62,
      8189,
      11,
      651,
      62,
      41007,
      62,
      28968
    ],
    "start_token": 26,
    "end_token": 44,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17267,
      278,
      2176,
      5499,
      422,
      257,
      8265
    ],
    "label": "ml_signal",
    "reason": "Importing specific functions from a module"
  },
  {
    "line": 22,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Importing specific configuration from a module",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 44,
    "end_token": 44,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17267,
      278,
      2176,
      8398,
      422,
      257,
      8265
    ],
    "label": "ml_signal",
    "reason": "Importing specific configuration from a module"
  },
  {
    "line": 18,
    "text": "from tqdm import tqdm",
    "annotation": "\ud83e\udde0 ML Signal: Class definition for data handling, indicating a pattern for data processing",
    "confidence": 0.5,
    "tokens": [
      6738,
      256,
      80,
      36020,
      1330,
      256,
      80,
      36020
    ],
    "start_token": 44,
    "end_token": 52,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      6770,
      329,
      1366,
      9041,
      11,
      12739,
      257,
      3912,
      329,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Class definition for data handling, indicating a pattern for data processing"
  },
  {
    "line": 20,
    "text": "from qlib.utils import fname_to_code, get_period_offset",
    "annotation": "\ud83e\udde0 ML Signal: Constants for directory and file naming conventions",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      26791,
      1330,
      277,
      3672,
      62,
      1462,
      62,
      8189,
      11,
      651,
      62,
      41007,
      62,
      28968
    ],
    "start_token": 52,
    "end_token": 70,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      329,
      8619,
      290,
      2393,
      19264,
      21396
    ],
    "label": "ml_signal",
    "reason": "Constants for directory and file naming conventions"
  },
  {
    "line": 22,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Constants for CSV file handling",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 70,
    "end_token": 70,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      329,
      44189,
      2393,
      9041
    ],
    "label": "ml_signal",
    "reason": "Constants for CSV file handling"
  },
  {
    "line": 24,
    "text": "class DumpPitData:",
    "annotation": "\ud83e\udde0 ML Signal: Constants for file suffixes",
    "confidence": 0.5,
    "tokens": [
      4871,
      360,
      931,
      47,
      270,
      6601,
      25
    ],
    "start_token": 70,
    "end_token": 77,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      329,
      2393,
      35488,
      274
    ],
    "label": "ml_signal",
    "reason": "Constants for file suffixes"
  },
  {
    "line": 27,
    "text": "    DATA_FILE_SUFFIX = \".data\"",
    "annotation": "\ud83e\udde0 ML Signal: Constants for data intervals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      42865,
      62,
      25664,
      62,
      12564,
      5777,
      10426,
      796,
      27071,
      7890,
      1
    ],
    "start_token": 77,
    "end_token": 91,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      329,
      1366,
      20016
    ],
    "label": "ml_signal",
    "reason": "Constants for data intervals"
  },
  {
    "line": 27,
    "text": "    DATA_FILE_SUFFIX = \".data\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external configuration for data types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      42865,
      62,
      25664,
      62,
      12564,
      5777,
      10426,
      796,
      27071,
      7890,
      1
    ],
    "start_token": 91,
    "end_token": 105,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      8398,
      329,
      1366,
      3858
    ],
    "label": "ml_signal",
    "reason": "Usage of external configuration for data types"
  },
  {
    "line": 35,
    "text": "    DATA_DTYPE = \"\".join(",
    "annotation": "\ud83e\udde0 ML Signal: Concatenation of data types for structured data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      42865,
      62,
      35,
      25216,
      796,
      366,
      1911,
      22179,
      7
    ],
    "start_token": 105,
    "end_token": 117,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1482,
      9246,
      268,
      341,
      286,
      1366,
      3858,
      329,
      20793,
      1366
    ],
    "label": "ml_signal",
    "reason": "Concatenation of data types for structured data"
  },
  {
    "line": 41,
    "text": "        ]",
    "annotation": "\ud83e\udde0 ML Signal: Handling of missing data with a specific constant",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 117,
    "end_token": 125,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      286,
      4814,
      1366,
      351,
      257,
      2176,
      6937
    ],
    "label": "ml_signal",
    "reason": "Handling of missing data with a specific constant"
  },
  {
    "line": 41,
    "text": "        ]",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of data type sizes for structured data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 125,
    "end_token": 133,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      1366,
      2099,
      10620,
      329,
      20793,
      1366
    ],
    "label": "ml_signal",
    "reason": "Calculation of data type sizes for structured data"
  },
  {
    "line": 41,
    "text": "        ]",
    "annotation": "\ud83e\udde0 ML Signal: Constants for operational modes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 133,
    "end_token": 141,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      329,
      13919,
      12881
    ],
    "label": "ml_signal",
    "reason": "Constants for operational modes"
  },
  {
    "line": 82,
    "text": "            number of threads",
    "annotation": "\u2705 Best Practice: Check if exclude_fields is a string before splitting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1271,
      286,
      14390
    ],
    "start_token": 141,
    "end_token": 155,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      19607,
      62,
      25747,
      318,
      257,
      4731,
      878,
      26021
    ],
    "label": "best_practice",
    "reason": "Check if exclude_fields is a string before splitting"
  },
  {
    "line": 85,
    "text": "        file_suffix: str, default \".csv\"",
    "annotation": "\u2705 Best Practice: Check if include_fields is a string before splitting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2393,
      62,
      37333,
      844,
      25,
      965,
      11,
      4277,
      27071,
      40664,
      1
    ],
    "start_token": 155,
    "end_token": 173,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      2291,
      62,
      25747,
      318,
      257,
      4731,
      878,
      26021
    ],
    "label": "best_practice",
    "reason": "Check if include_fields is a string before splitting"
  },
  {
    "line": 88,
    "text": "            dump fields",
    "annotation": "\u2705 Best Practice: Use tuple and filter to ensure fields are non-empty and stripped",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10285,
      7032
    ],
    "start_token": 173,
    "end_token": 186,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46545,
      290,
      8106,
      284,
      4155,
      7032,
      389,
      1729,
      12,
      28920,
      290,
      18818
    ],
    "label": "best_practice",
    "reason": "Use tuple and filter to ensure fields are non-empty and stripped"
  },
  {
    "line": 90,
    "text": "            fields not dumped",
    "annotation": "\u2705 Best Practice: Use tuple and filter to ensure fields are non-empty and stripped",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7032,
      407,
      24105
    ],
    "start_token": 186,
    "end_token": 200,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46545,
      290,
      8106,
      284,
      4155,
      7032,
      389,
      1729,
      12,
      28920,
      290,
      18818
    ],
    "label": "best_practice",
    "reason": "Use tuple and filter to ensure fields are non-empty and stripped"
  },
  {
    "line": 93,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of sorted and glob to list files in a directory",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 200,
    "end_token": 208,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      23243,
      290,
      15095,
      284,
      1351,
      3696,
      287,
      257,
      8619
    ],
    "label": "ml_signal",
    "reason": "Usage of sorted and glob to list files in a directory"
  },
  {
    "line": 95,
    "text": "        if isinstance(exclude_fields, str):",
    "annotation": "\u2705 Best Practice: Check if limit_nums is not None before slicing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      1069,
      9152,
      62,
      25747,
      11,
      965,
      2599
    ],
    "start_token": 208,
    "end_token": 226,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      4179,
      62,
      77,
      5700,
      318,
      407,
      6045,
      878,
      49289
    ],
    "label": "best_practice",
    "reason": "Check if limit_nums is not None before slicing"
  },
  {
    "line": 99,
    "text": "        self._exclude_fields = tuple(filter(lambda x: len(x) > 0, map(str.strip, exclude_fields)))",
    "annotation": "\u2705 Best Practice: Use Path.expanduser for consistent path handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      1069,
      9152,
      62,
      25747,
      796,
      46545,
      7,
      24455,
      7,
      50033,
      2124,
      25,
      18896,
      7,
      87,
      8,
      1875,
      657,
      11,
      3975,
      7,
      2536,
      13,
      36311,
      11,
      19607,
      62,
      25747,
      22305
    ],
    "start_token": 226,
    "end_token": 264,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      10644,
      13,
      11201,
      392,
      7220,
      329,
      6414,
      3108,
      9041
    ],
    "label": "best_practice",
    "reason": "Use Path.expanduser for consistent path handling"
  },
  {
    "line": 101,
    "text": "        self.file_suffix = file_suffix",
    "annotation": "\u2705 Best Practice: Check if backup_dir is not None before calling backup method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7753,
      62,
      37333,
      844,
      796,
      2393,
      62,
      37333,
      844
    ],
    "start_token": 264,
    "end_token": 282,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      11559,
      62,
      15908,
      318,
      407,
      6045,
      878,
      4585,
      11559,
      2446
    ],
    "label": "best_practice",
    "reason": "Check if backup_dir is not None before calling backup method"
  },
  {
    "line": 102,
    "text": "        self.csv_files = sorted(csv_path.glob(f\"*{self.file_suffix}\") if csv_path.is_dir() else [csv_path])",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Using shutil.copytree without exception handling can lead to unhandled exceptions if the source or target directories are invalid or inaccessible.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      40664,
      62,
      16624,
      796,
      23243,
      7,
      40664,
      62,
      6978,
      13,
      4743,
      672,
      7,
      69,
      1,
      9,
      90,
      944,
      13,
      7753,
      62,
      37333,
      844,
      92,
      4943,
      611,
      269,
      21370,
      62,
      6978,
      13,
      271,
      62,
      15908,
      3419,
      2073,
      685,
      40664,
      62,
      6978,
      12962
    ],
    "start_token": 282,
    "end_token": 332,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8554,
      4423,
      346,
      13,
      30073,
      21048,
      1231,
      6631,
      9041,
      460,
      1085,
      284,
      555,
      38788,
      13269,
      611,
      262,
      2723,
      393,
      2496,
      29196,
      389,
      12515,
      393,
      40604,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Using shutil.copytree without exception handling can lead to unhandled exceptions if the source or target directories are invalid or inaccessible."
  },
  {
    "line": 103,
    "text": "        if limit_nums is not None:",
    "annotation": "\u2705 Best Practice: Consider adding exception handling to manage potential errors during the copy process.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4179,
      62,
      77,
      5700,
      318,
      407,
      6045,
      25
    ],
    "start_token": 332,
    "end_token": 348,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      6631,
      9041,
      284,
      6687,
      2785,
      8563,
      1141,
      262,
      4866,
      1429,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding exception handling to manage potential errors during the copy process."
  },
  {
    "line": 105,
    "text": "        self.qlib_dir = Path(qlib_dir).expanduser()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of shutil.copytree indicates a pattern of directory duplication, which can be a feature for ML models to learn about file operations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      80,
      8019,
      62,
      15908,
      796,
      10644,
      7,
      80,
      8019,
      62,
      15908,
      737,
      11201,
      392,
      7220,
      3419
    ],
    "start_token": 348,
    "end_token": 373,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4423,
      346,
      13,
      30073,
      21048,
      9217,
      257,
      3912,
      286,
      8619,
      50124,
      11,
      543,
      460,
      307,
      257,
      3895,
      329,
      10373,
      4981,
      284,
      2193,
      546,
      2393,
      4560,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of shutil.copytree indicates a pattern of directory duplication, which can be a feature for ML models to learn about file operations."
  },
  {
    "line": 104,
    "text": "            self.csv_files = self.csv_files[: int(limit_nums)]",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      40664,
      62,
      16624,
      796,
      2116,
      13,
      40664,
      62,
      16624,
      58,
      25,
      493,
      7,
      32374,
      62,
      77,
      5700,
      15437
    ],
    "start_token": 373,
    "end_token": 404,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 106,
    "text": "        self.backup_dir = backup_dir if backup_dir is None else Path(backup_dir).expanduser()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pandas to read CSV files is a common pattern in data processing tasks",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1891,
      929,
      62,
      15908,
      796,
      11559,
      62,
      15908,
      611,
      11559,
      62,
      15908,
      318,
      6045,
      2073,
      10644,
      7,
      1891,
      929,
      62,
      15908,
      737,
      11201,
      392,
      7220,
      3419
    ],
    "start_token": 404,
    "end_token": 439,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      19798,
      292,
      284,
      1100,
      44189,
      3696,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      8861
    ],
    "label": "ml_signal",
    "reason": "Usage of pandas to read CSV files is a common pattern in data processing tasks"
  },
  {
    "line": 107,
    "text": "        if backup_dir is not None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large memory usage if the CSV file is very large",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      11559,
      62,
      15908,
      318,
      407,
      6045,
      25
    ],
    "start_token": 439,
    "end_token": 454,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      4088,
      8748,
      611,
      262,
      44189,
      2393,
      318,
      845,
      1588
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large memory usage if the CSV file is very large"
  },
  {
    "line": 109,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Converting data types to optimize memory usage is a common pattern",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 454,
    "end_token": 454,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      1366,
      3858,
      284,
      27183,
      4088,
      8748,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Converting data types to optimize memory usage is a common pattern"
  },
  {
    "line": 111,
    "text": "        self.date_column_name = date_column_name",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes date_column_name exists and is in the expected format",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      796,
      3128,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 454,
    "end_token": 474,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      3128,
      62,
      28665,
      62,
      3672,
      7160,
      290,
      318,
      287,
      262,
      2938,
      5794
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes date_column_name exists and is in the expected format"
  },
  {
    "line": 109,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 474,
    "end_token": 474,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 111,
    "text": "        self.date_column_name = date_column_name",
    "annotation": "\ud83e\udde0 ML Signal: Usage of string slicing and manipulation to extract information from a file name",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      796,
      3128,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 474,
    "end_token": 494,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4731,
      49289,
      290,
      17512,
      284,
      7925,
      1321,
      422,
      257,
      2393,
      1438
    ],
    "label": "ml_signal",
    "reason": "Usage of string slicing and manipulation to extract information from a file name"
  },
  {
    "line": 112,
    "text": "        self.period_column_name = period_column_name",
    "annotation": "\ud83e\udde0 ML Signal: Use of a method to convert file names to a specific code format",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      41007,
      62,
      28665,
      62,
      3672,
      796,
      2278,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 494,
    "end_token": 514,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2446,
      284,
      10385,
      2393,
      3891,
      284,
      257,
      2176,
      2438,
      5794
    ],
    "label": "ml_signal",
    "reason": "Use of a method to convert file names to a specific code format"
  },
  {
    "line": 111,
    "text": "        self.date_column_name = date_column_name",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      796,
      3128,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 514,
    "end_token": 534,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 112,
    "text": "        self.period_column_name = period_column_name",
    "annotation": "\u2705 Best Practice: Using set operations for efficient field inclusion/exclusion",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      41007,
      62,
      28665,
      62,
      3672,
      796,
      2278,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 534,
    "end_token": 554,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      900,
      4560,
      329,
      6942,
      2214,
      14900,
      14,
      1069,
      4717
    ],
    "label": "best_practice",
    "reason": "Using set operations for efficient field inclusion/exclusion"
  },
  {
    "line": 112,
    "text": "        self.period_column_name = period_column_name",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on instance attributes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      41007,
      62,
      28665,
      62,
      3672,
      796,
      2278,
      62,
      28665,
      62,
      3672
    ],
    "start_token": 554,
    "end_token": 574,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      4554,
      12608
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on instance attributes"
  },
  {
    "line": 119,
    "text": "        shutil.copytree(str(self.qlib_dir.resolve()), str(target_dir.resolve()))",
    "annotation": "\ud83e\udde0 ML Signal: Use of set operations to filter data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4423,
      346,
      13,
      30073,
      21048,
      7,
      2536,
      7,
      944,
      13,
      80,
      8019,
      62,
      15908,
      13,
      411,
      6442,
      3419,
      828,
      965,
      7,
      16793,
      62,
      15908,
      13,
      411,
      6442,
      3419,
      4008
    ],
    "start_token": 574,
    "end_token": 610,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      900,
      4560,
      284,
      8106,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of set operations to filter data"
  },
  {
    "line": 121,
    "text": "    def get_source_data(self, file_path: Path) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on instance attributes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      10459,
      62,
      7890,
      7,
      944,
      11,
      2393,
      62,
      6978,
      25,
      10644,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 610,
    "end_token": 635,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      4554,
      12608
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on instance attributes"
  },
  {
    "line": 122,
    "text": "        df = pd.read_csv(str(file_path.resolve()), low_memory=False)",
    "annotation": "\ud83e\udde0 ML Signal: Function signature and parameter names can be used to infer the purpose and usage of the function.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      2536,
      7,
      7753,
      62,
      6978,
      13,
      411,
      6442,
      3419,
      828,
      1877,
      62,
      31673,
      28,
      25101,
      8
    ],
    "start_token": 635,
    "end_token": 667,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      9877,
      290,
      11507,
      3891,
      460,
      307,
      973,
      284,
      13249,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163,
      13
    ],
    "label": "ml_signal",
    "reason": "Function signature and parameter names can be used to infer the purpose and usage of the function."
  },
  {
    "line": 124,
    "text": "        df[self.date_column_name] = df[self.date_column_name].str.replace(\"-\", \"\").astype(\"int32\")",
    "annotation": "\u2705 Best Practice: Using pathlib for path operations improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      944,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      60,
      796,
      47764,
      58,
      944,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      4083,
      2536,
      13,
      33491,
      7203,
      12,
      1600,
      366,
      11074,
      459,
      2981,
      7203,
      600,
      2624,
      4943
    ],
    "start_token": 667,
    "end_token": 709,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      3108,
      8019,
      329,
      3108,
      4560,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using pathlib for path operations improves code readability and maintainability."
  },
  {
    "line": 124,
    "text": "        df[self.date_column_name] = df[self.date_column_name].str.replace(\"-\", \"\").astype(\"int32\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Directory creation with user-controlled input could lead to directory traversal if not properly validated.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      944,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      60,
      796,
      47764,
      58,
      944,
      13,
      4475,
      62,
      28665,
      62,
      3672,
      4083,
      2536,
      13,
      33491,
      7203,
      12,
      1600,
      366,
      11074,
      459,
      2981,
      7203,
      600,
      2624,
      4943
    ],
    "start_token": 709,
    "end_token": 751,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      27387,
      6282,
      351,
      2836,
      12,
      14401,
      5128,
      714,
      1085,
      284,
      8619,
      33038,
      282,
      611,
      407,
      6105,
      31031,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Directory creation with user-controlled input could lead to directory traversal if not properly validated."
  },
  {
    "line": 128,
    "text": "    def get_symbol_from_file(self, file_path: Path) -> str:",
    "annotation": "\ud83e\udde0 ML Signal: The pattern of constructing file paths can be used to learn about file naming conventions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      1837,
      23650,
      62,
      6738,
      62,
      7753,
      7,
      944,
      11,
      2393,
      62,
      6978,
      25,
      10644,
      8,
      4613,
      965,
      25
    ],
    "start_token": 751,
    "end_token": 775,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      3912,
      286,
      30580,
      2393,
      13532,
      460,
      307,
      973,
      284,
      2193,
      546,
      2393,
      19264,
      21396,
      13
    ],
    "label": "ml_signal",
    "reason": "The pattern of constructing file paths can be used to learn about file naming conventions."
  },
  {
    "line": 128,
    "text": "    def get_symbol_from_file(self, file_path: Path) -> str:",
    "annotation": "\u2705 Best Practice: Using f-strings for string formatting is more readable and efficient.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      1837,
      23650,
      62,
      6738,
      62,
      7753,
      7,
      944,
      11,
      2393,
      62,
      6978,
      25,
      10644,
      8,
      4613,
      965,
      25
    ],
    "start_token": 775,
    "end_token": 799,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      277,
      12,
      37336,
      329,
      4731,
      33313,
      318,
      517,
      31744,
      290,
      6942,
      13
    ],
    "label": "best_practice",
    "reason": "Using f-strings for string formatting is more readable and efficient."
  },
  {
    "line": 155,
    "text": "    ):",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 799,
    "end_token": 803,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 157,
    "text": "        dump data as the following format:",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10285,
      1366,
      355,
      262,
      1708,
      5794,
      25
    ],
    "start_token": 803,
    "end_token": 817,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 160,
    "text": "                [date, period, value, _next]",
    "annotation": "\u2705 Best Practice: Logging provides insight into the program's execution flow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      685,
      4475,
      11,
      2278,
      11,
      1988,
      11,
      4808,
      19545,
      60
    ],
    "start_token": 817,
    "end_token": 842,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      3769,
      11281,
      656,
      262,
      1430,
      338,
      9706,
      5202,
      13
    ],
    "label": "best_practice",
    "reason": "Logging provides insight into the program's execution flow."
  },
  {
    "line": 163,
    "text": "                [first_year, index, index, ...]",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      685,
      11085,
      62,
      1941,
      11,
      6376,
      11,
      6376,
      11,
      2644,
      60
    ],
    "start_token": 842,
    "end_token": 868,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 165,
    "text": "        `<field.data>` contains the data as the point-in-time (PIT) order: `value` of `period`",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4600,
      27,
      3245,
      13,
      7890,
      29,
      63,
      4909,
      262,
      1366,
      355,
      262,
      966,
      12,
      259,
      12,
      2435,
      357,
      47,
      2043,
      8,
      1502,
      25,
      4600,
      8367,
      63,
      286,
      4600,
      41007,
      63
    ],
    "start_token": 868,
    "end_token": 905,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 168,
    "text": "        `<field>.index` contains the index of value for each period (quarter or year). To save",
    "annotation": "\u2705 Best Practice: Logging provides insight into the program's execution flow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4600,
      27,
      3245,
      28401,
      9630,
      63,
      4909,
      262,
      6376,
      286,
      1988,
      329,
      1123,
      2278,
      357,
      24385,
      393,
      614,
      737,
      1675,
      3613
    ],
    "start_token": 905,
    "end_token": 933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      3769,
      11281,
      656,
      262,
      1430,
      338,
      9706,
      5202,
      13
    ],
    "label": "best_practice",
    "reason": "Logging provides insight into the program's execution flow."
  },
  {
    "line": 171,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 933,
    "end_token": 941,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 173,
    "text": "        symbol: str",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      25,
      965
    ],
    "start_token": 941,
    "end_token": 951,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 175,
    "text": "        interval: str",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16654,
      25,
      965
    ],
    "start_token": 951,
    "end_token": 961,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 182,
    "text": "        if df.empty:",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 961,
    "end_token": 973,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 184,
    "text": "            return",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 973,
    "end_token": 985,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 194,
    "text": "            end_year = df_sub[self.period_column_name].max()",
    "annotation": "\u2705 Best Practice: Logging provides insight into the program's execution flow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      1941,
      796,
      47764,
      62,
      7266,
      58,
      944,
      13,
      41007,
      62,
      28665,
      62,
      3672,
      4083,
      9806,
      3419
    ],
    "start_token": 985,
    "end_token": 1014,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      3769,
      11281,
      656,
      262,
      1430,
      338,
      9706,
      5202,
      13
    ],
    "label": "best_practice",
    "reason": "Logging provides insight into the program's execution flow."
  },
  {
    "line": 206,
    "text": "                    start_year = first_year + n_years",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      1941,
      796,
      717,
      62,
      1941,
      1343,
      299,
      62,
      19002
    ],
    "start_token": 1014,
    "end_token": 1044,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 214,
    "text": "                logger.warning(f\"{symbol}-{field} data already exists, continue to the next field\")",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      43917,
      7,
      69,
      1,
      90,
      1837,
      23650,
      92,
      12,
      90,
      3245,
      92,
      1366,
      1541,
      7160,
      11,
      2555,
      284,
      262,
      1306,
      2214,
      4943
    ],
    "start_token": 1044,
    "end_token": 1083,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 217,
    "text": "            # dump index filled with NA",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10285,
      6376,
      5901,
      351,
      11746
    ],
    "start_token": 1083,
    "end_token": 1100,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 223,
    "text": "                        fi.write(struct.pack(self.INDEX_DTYPE, self.NA_INDEX))",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25912,
      13,
      13564,
      7,
      7249,
      13,
      8002,
      7,
      944,
      13,
      12115,
      6369,
      62,
      35,
      25216,
      11,
      2116,
      13,
      4535,
      62,
      12115,
      6369,
      4008
    ],
    "start_token": 1100,
    "end_token": 1146,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 225,
    "text": "            # if data already exists, remove overlapped data",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      611,
      1366,
      1541,
      7160,
      11,
      4781,
      12893,
      6320,
      1366
    ],
    "start_token": 1146,
    "end_token": 1167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 219,
    "text": "                for year in range(start_year, end_year + 1):",
    "annotation": "\ud83e\udde0 ML Signal: Method parameters with default values indicate common usage patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      614,
      287,
      2837,
      7,
      9688,
      62,
      1941,
      11,
      886,
      62,
      1941,
      1343,
      352,
      2599
    ],
    "start_token": 1167,
    "end_token": 1197,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      10007,
      351,
      4277,
      3815,
      7603,
      2219,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Method parameters with default values indicate common usage patterns."
  },
  {
    "line": 220,
    "text": "                    if interval == self.INTERVAL_quarterly:",
    "annotation": "\u2705 Best Practice: Logging the start of a process helps in debugging and tracking execution flow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      16654,
      6624,
      2116,
      13,
      41358,
      23428,
      62,
      24385,
      306,
      25
    ],
    "start_token": 1197,
    "end_token": 1227,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      262,
      923,
      286,
      257,
      1429,
      5419,
      287,
      28769,
      290,
      9646,
      9706,
      5202,
      13
    ],
    "label": "best_practice",
    "reason": "Logging the start of a process helps in debugging and tracking execution flow."
  },
  {
    "line": 222,
    "text": "                    else:",
    "annotation": "\ud83e\udde0 ML Signal: Use of partial functions indicates a pattern of function customization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1227,
    "end_token": 1248,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      13027,
      5499,
      9217,
      257,
      3912,
      286,
      2163,
      31344,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of partial functions indicates a pattern of function customization."
  },
  {
    "line": 224,
    "text": "",
    "annotation": "\u2705 Best Practice: Using tqdm for progress indication improves user experience in long-running processes.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1248,
    "end_token": 1248,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      256,
      80,
      36020,
      329,
      4371,
      12955,
      19575,
      2836,
      1998,
      287,
      890,
      12,
      20270,
      7767,
      13
    ],
    "label": "best_practice",
    "reason": "Using tqdm for progress indication improves user experience in long-running processes."
  },
  {
    "line": 226,
    "text": "            if not overwrite and data_file.exists():",
    "annotation": "\ud83e\udde0 ML Signal: Use of ProcessPoolExecutor indicates parallel processing patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      49312,
      290,
      1366,
      62,
      7753,
      13,
      1069,
      1023,
      33529
    ],
    "start_token": 1248,
    "end_token": 1270,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      9217,
      10730,
      7587,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of ProcessPoolExecutor indicates parallel processing patterns."
  },
  {
    "line": 227,
    "text": "                with open(data_file, \"rb\") as fd:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the function _dump_pit is thread-safe when used with ProcessPoolExecutor.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      1280,
      7,
      7890,
      62,
      7753,
      11,
      366,
      26145,
      4943,
      355,
      277,
      67,
      25
    ],
    "start_token": 1270,
    "end_token": 1299,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      2163,
      4808,
      39455,
      62,
      15544,
      318,
      4704,
      12,
      21230,
      618,
      973,
      351,
      10854,
      27201,
      23002,
      38409,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the function _dump_pit is thread-safe when used with ProcessPoolExecutor."
  },
  {
    "line": 228,
    "text": "                    fd.seek(-self.DATA_DTYPE_SIZE, 2)",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over executor.map shows a pattern of processing items in parallel.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      277,
      67,
      13,
      36163,
      32590,
      944,
      13,
      26947,
      62,
      35,
      25216,
      62,
      33489,
      11,
      362,
      8
    ],
    "start_token": 1299,
    "end_token": 1334,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      3121,
      273,
      13,
      8899,
      2523,
      257,
      3912,
      286,
      7587,
      3709,
      287,
      10730,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over executor.map shows a pattern of processing items in parallel."
  },
  {
    "line": 228,
    "text": "                    fd.seek(-self.DATA_DTYPE_SIZE, 2)",
    "annotation": "\u2705 Best Practice: Updating progress bar inside the loop provides real-time feedback.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      277,
      67,
      13,
      36163,
      32590,
      944,
      13,
      26947,
      62,
      35,
      25216,
      62,
      33489,
      11,
      362,
      8
    ],
    "start_token": 1334,
    "end_token": 1369,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3205,
      38734,
      4371,
      2318,
      2641,
      262,
      9052,
      3769,
      1103,
      12,
      2435,
      7538,
      13
    ],
    "label": "best_practice",
    "reason": "Updating progress bar inside the loop provides real-time feedback."
  },
  {
    "line": 226,
    "text": "            if not overwrite and data_file.exists():",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of this method.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      49312,
      290,
      1366,
      62,
      7753,
      13,
      1069,
      1023,
      33529
    ],
    "start_token": 1369,
    "end_token": 1391,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      428,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of this method."
  },
  {
    "line": 228,
    "text": "                    fd.seek(-self.DATA_DTYPE_SIZE, 2)",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern within a special method like __call__ can indicate dynamic behavior or usage patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      277,
      67,
      13,
      36163,
      32590,
      944,
      13,
      26947,
      62,
      35,
      25216,
      62,
      33489,
      11,
      362,
      8
    ],
    "start_token": 1391,
    "end_token": 1426,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      1626,
      257,
      2041,
      2446,
      588,
      11593,
      13345,
      834,
      460,
      7603,
      8925,
      4069,
      393,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call pattern within a special method like __call__ can indicate dynamic behavior or usage patterns."
  },
  {
    "line": 228,
    "text": "                    fd.seek(-self.DATA_DTYPE_SIZE, 2)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using fire.Fire can execute arbitrary code if input is not properly sanitized.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      277,
      67,
      13,
      36163,
      32590,
      944,
      13,
      26947,
      62,
      35,
      25216,
      62,
      33489,
      11,
      362,
      8
    ],
    "start_token": 1426,
    "end_token": 1461,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      2046,
      13,
      13543,
      460,
      12260,
      14977,
      2438,
      611,
      5128,
      318,
      407,
      6105,
      5336,
      36951,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using fire.Fire can execute arbitrary code if input is not properly sanitized."
  },
  {
    "line": 228,
    "text": "                    fd.seek(-self.DATA_DTYPE_SIZE, 2)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of fire.Fire indicates a command-line interface pattern.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      277,
      67,
      13,
      36163,
      32590,
      944,
      13,
      26947,
      62,
      35,
      25216,
      62,
      33489,
      11,
      362,
      8
    ],
    "start_token": 1461,
    "end_token": 1496,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2046,
      13,
      13543,
      9217,
      257,
      3141,
      12,
      1370,
      7071,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of fire.Fire indicates a command-line interface pattern."
  }
]