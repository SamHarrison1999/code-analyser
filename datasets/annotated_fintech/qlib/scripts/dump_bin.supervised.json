[
  {
    "line": 13,
    "text": "import numpy as np",
    "annotation": "\ud83e\udde0 ML Signal: Importing utility functions for encoding and decoding filenames",
    "confidence": 1.0,
    "tokens": [
      11748,
      299,
      32152,
      355,
      45941
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17267,
      278,
      10361,
      5499,
      329,
      21004,
      290,
      39938,
      1226,
      268,
      1047
    ],
    "label": "ml_signal",
    "reason": "Importing utility functions for encoding and decoding filenames"
  },
  {
    "line": 27,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\ud83e\udde0 ML Signal: Constants and configuration patterns can be used to identify application settings and defaults",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 5,
    "end_token": 23,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      290,
      8398,
      7572,
      460,
      307,
      973,
      284,
      5911,
      3586,
      6460,
      290,
      26235
    ],
    "label": "ml_signal",
    "reason": "Constants and configuration patterns can be used to identify application settings and defaults"
  },
  {
    "line": 27,
    "text": "    DAILY_FORMAT = \"%Y-%m-%d\"",
    "annotation": "\u2705 Best Practice: Use of class-level constants for configuration improves maintainability and readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      17051,
      33340,
      62,
      21389,
      1404,
      796,
      36521,
      56,
      12,
      4,
      76,
      12,
      4,
      67,
      1
    ],
    "start_token": 23,
    "end_token": 41,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      12,
      5715,
      38491,
      329,
      8398,
      19575,
      5529,
      1799,
      290,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of class-level constants for configuration improves maintainability and readability"
  },
  {
    "line": 68,
    "text": "            symbol field name",
    "annotation": "\u2705 Best Practice: Check if exclude_fields is a string before splitting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      2214,
      1438
    ],
    "start_token": 41,
    "end_token": 55,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      19607,
      62,
      25747,
      318,
      257,
      4731,
      878,
      26021
    ],
    "label": "best_practice",
    "reason": "Check if exclude_fields is a string before splitting"
  },
  {
    "line": 71,
    "text": "        exclude_fields: tuple",
    "annotation": "\u2705 Best Practice: Check if include_fields is a string before splitting",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      19607,
      62,
      25747,
      25,
      46545
    ],
    "start_token": 55,
    "end_token": 67,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      2291,
      62,
      25747,
      318,
      257,
      4731,
      878,
      26021
    ],
    "label": "best_practice",
    "reason": "Check if include_fields is a string before splitting"
  },
  {
    "line": 74,
    "text": "            Use when debugging, default None",
    "annotation": "\u2705 Best Practice: Use tuple and filter to ensure fields are stripped and non-empty",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5765,
      618,
      28769,
      11,
      4277,
      6045
    ],
    "start_token": 67,
    "end_token": 84,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46545,
      290,
      8106,
      284,
      4155,
      7032,
      389,
      18818,
      290,
      1729,
      12,
      28920
    ],
    "label": "best_practice",
    "reason": "Use tuple and filter to ensure fields are stripped and non-empty"
  },
  {
    "line": 76,
    "text": "        csv_path = Path(csv_path).expanduser()",
    "annotation": "\u2705 Best Practice: Use tuple and filter to ensure fields are stripped and non-empty",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      269,
      21370,
      62,
      6978,
      796,
      10644,
      7,
      40664,
      62,
      6978,
      737,
      11201,
      392,
      7220,
      3419
    ],
    "start_token": 84,
    "end_token": 106,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46545,
      290,
      8106,
      284,
      4155,
      7032,
      389,
      18818,
      290,
      1729,
      12,
      28920
    ],
    "label": "best_practice",
    "reason": "Use tuple and filter to ensure fields are stripped and non-empty"
  },
  {
    "line": 80,
    "text": "            include_fields = include_fields.split(\",\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potentially large number of files could be loaded into memory",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2291,
      62,
      25747,
      796,
      2291,
      62,
      25747,
      13,
      35312,
      7,
      2430,
      8
    ],
    "start_token": 106,
    "end_token": 129,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6902,
      3746,
      1588,
      1271,
      286,
      3696,
      714,
      307,
      9639,
      656,
      4088
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potentially large number of files could be loaded into memory"
  },
  {
    "line": 82,
    "text": "        self._include_fields = tuple(filter(lambda x: len(x) > 0, map(str.strip, include_fields)))",
    "annotation": "\u2705 Best Practice: Limit the number of CSV files if limit_nums is specified",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      17256,
      62,
      25747,
      796,
      46545,
      7,
      24455,
      7,
      50033,
      2124,
      25,
      18896,
      7,
      87,
      8,
      1875,
      657,
      11,
      3975,
      7,
      2536,
      13,
      36311,
      11,
      2291,
      62,
      25747,
      22305
    ],
    "start_token": 129,
    "end_token": 166,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27272,
      262,
      1271,
      286,
      44189,
      3696,
      611,
      4179,
      62,
      77,
      5700,
      318,
      7368
    ],
    "label": "best_practice",
    "reason": "Limit the number of CSV files if limit_nums is specified"
  },
  {
    "line": 87,
    "text": "            self.csv_files = self.csv_files[: int(limit_nums)]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Backup operation could overwrite existing data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      40664,
      62,
      16624,
      796,
      2116,
      13,
      40664,
      62,
      16624,
      58,
      25,
      493,
      7,
      32374,
      62,
      77,
      5700,
      15437
    ],
    "start_token": 166,
    "end_token": 197,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      35071,
      4905,
      714,
      49312,
      4683,
      1366
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Backup operation could overwrite existing data"
  },
  {
    "line": 91,
    "text": "            self._backup_qlib_dir(Path(backup_dir).expanduser())",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on frequency could indicate different processing paths",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      1891,
      929,
      62,
      80,
      8019,
      62,
      15908,
      7,
      15235,
      7,
      1891,
      929,
      62,
      15908,
      737,
      11201,
      392,
      7220,
      28955
    ],
    "start_token": 197,
    "end_token": 229,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      8373,
      714,
      7603,
      1180,
      7587,
      13532
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on frequency could indicate different processing paths"
  },
  {
    "line": 93,
    "text": "        self.freq = freq",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Using shutil.copytree without exception handling can lead to unhandled exceptions if the source or target directories are invalid or inaccessible.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      19503,
      80,
      796,
      2030,
      80
    ],
    "start_token": 229,
    "end_token": 243,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8554,
      4423,
      346,
      13,
      30073,
      21048,
      1231,
      6631,
      9041,
      460,
      1085,
      284,
      555,
      38788,
      13269,
      611,
      262,
      2723,
      393,
      2496,
      29196,
      389,
      12515,
      393,
      40604,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Using shutil.copytree without exception handling can lead to unhandled exceptions if the source or target directories are invalid or inaccessible."
  },
  {
    "line": 94,
    "text": "        self.calendar_format = self.DAILY_FORMAT if self.freq == \"day\" else self.HIGH_FREQ_FORMAT",
    "annotation": "\u2705 Best Practice: Consider adding exception handling to manage potential errors during the copy process.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9948,
      9239,
      62,
      18982,
      796,
      2116,
      13,
      5631,
      33340,
      62,
      21389,
      1404,
      611,
      2116,
      13,
      19503,
      80,
      6624,
      366,
      820,
      1,
      2073,
      2116,
      13,
      39,
      18060,
      62,
      37,
      2200,
      48,
      62,
      21389,
      1404
    ],
    "start_token": 243,
    "end_token": 285,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      6631,
      9041,
      284,
      6687,
      2785,
      8563,
      1141,
      262,
      4866,
      1429,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding exception handling to manage potential errors during the copy process."
  },
  {
    "line": 96,
    "text": "        self.works = max_workers",
    "annotation": "\ud83e\udde0 ML Signal: Usage of shutil.copytree indicates a pattern of directory duplication, which can be a feature for ML models to learn about file operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      5225,
      796,
      3509,
      62,
      22896
    ],
    "start_token": 285,
    "end_token": 299,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4423,
      346,
      13,
      30073,
      21048,
      9217,
      257,
      3912,
      286,
      8619,
      50124,
      11,
      543,
      460,
      307,
      257,
      3895,
      329,
      10373,
      4981,
      284,
      2193,
      546,
      2393,
      4560,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of shutil.copytree indicates a pattern of directory duplication, which can be a feature for ML models to learn about file operations."
  },
  {
    "line": 95,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 299,
    "end_token": 299,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the return type for better readability and maintainability"
  },
  {
    "line": 97,
    "text": "        self.date_field_name = date_field_name",
    "annotation": "\u2705 Best Practice: Converting input to a consistent type at the start of the function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      796,
      3128,
      62,
      3245,
      62,
      3672
    ],
    "start_token": 299,
    "end_token": 319,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      5128,
      284,
      257,
      6414,
      2099,
      379,
      262,
      923,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Converting input to a consistent type at the start of the function"
  },
  {
    "line": 98,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of strftime for date formatting",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 319,
    "end_token": 319,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      965,
      31387,
      329,
      3128,
      33313
    ],
    "label": "ml_signal",
    "reason": "Usage of strftime for date formatting"
  },
  {
    "line": 101,
    "text": "        self._instruments_dir = self.qlib_dir.joinpath(self.INSTRUMENTS_DIR_NAME)",
    "annotation": "\u2705 Best Practice: Check if input is a DataFrame to handle different input types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      259,
      2536,
      2886,
      62,
      15908,
      796,
      2116,
      13,
      80,
      8019,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      944,
      13,
      1268,
      18601,
      5883,
      15365,
      62,
      34720,
      62,
      20608,
      8
    ],
    "start_token": 319,
    "end_token": 355,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      5128,
      318,
      257,
      6060,
      19778,
      284,
      5412,
      1180,
      5128,
      3858
    ],
    "label": "best_practice",
    "reason": "Check if input is a DataFrame to handle different input types"
  },
  {
    "line": 102,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a helper function to retrieve data",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 355,
    "end_token": 355,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      31904,
      2163,
      284,
      19818,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of a helper function to retrieve data"
  },
  {
    "line": 106,
    "text": "        self._kwargs = {}",
    "annotation": "\u2705 Best Practice: Check for empty DataFrame or missing column to prevent errors",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      46265,
      22046,
      796,
      23884
    ],
    "start_token": 355,
    "end_token": 368,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      6060,
      19778,
      393,
      4814,
      5721,
      284,
      2948,
      8563
    ],
    "label": "best_practice",
    "reason": "Check for empty DataFrame or missing column to prevent errors"
  },
  {
    "line": 112,
    "text": "        datetime_d = pd.Timestamp(datetime_d)",
    "annotation": "\u2705 Best Practice: Return different data structures based on flags for flexibility",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4818,
      8079,
      62,
      67,
      796,
      279,
      67,
      13,
      14967,
      27823,
      7,
      19608,
      8079,
      62,
      67,
      8
    ],
    "start_token": 368,
    "end_token": 391,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1180,
      1366,
      8573,
      1912,
      319,
      9701,
      329,
      13688
    ],
    "label": "best_practice",
    "reason": "Return different data structures based on flags for flexibility"
  },
  {
    "line": 117,
    "text": "    ) -> Iterable[pd.Timestamp]:",
    "annotation": "\u2705 Best Practice: Use of type hint for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      40806,
      540,
      58,
      30094,
      13,
      14967,
      27823,
      5974
    ],
    "start_token": 391,
    "end_token": 404,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hint for the return type improves code readability and maintainability"
  },
  {
    "line": 119,
    "text": "            df = self._get_source_data(file_or_df)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using `low_memory=False` can lead to high memory usage with large files",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      2116,
      13557,
      1136,
      62,
      10459,
      62,
      7890,
      7,
      7753,
      62,
      273,
      62,
      7568,
      8
    ],
    "start_token": 404,
    "end_token": 431,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      4600,
      9319,
      62,
      31673,
      28,
      25101,
      63,
      460,
      1085,
      284,
      1029,
      4088,
      8748,
      351,
      1588,
      3696
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using `low_memory=False` can lead to high memory usage with large files"
  },
  {
    "line": 121,
    "text": "            df = file_or_df",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of date fields to datetime format is a common data preprocessing step",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      2393,
      62,
      273,
      62,
      7568
    ],
    "start_token": 431,
    "end_token": 449,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      3128,
      7032,
      284,
      4818,
      8079,
      5794,
      318,
      257,
      2219,
      1366,
      662,
      36948,
      2239
    ],
    "label": "ml_signal",
    "reason": "Conversion of date fields to datetime format is a common data preprocessing step"
  },
  {
    "line": 121,
    "text": "            df = file_or_df",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      2393,
      62,
      273,
      62,
      7568
    ],
    "start_token": 449,
    "end_token": 467,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 123,
    "text": "            _calendars = pd.Series(dtype=np.float32)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of string manipulation methods like strip() and lower()",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9948,
      44942,
      796,
      279,
      67,
      13,
      27996,
      7,
      67,
      4906,
      28,
      37659,
      13,
      22468,
      2624,
      8
    ],
    "start_token": 467,
    "end_token": 495,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4731,
      17512,
      5050,
      588,
      10283,
      3419,
      290,
      2793,
      3419
    ],
    "label": "ml_signal",
    "reason": "Usage of string manipulation methods like strip() and lower()"
  },
  {
    "line": 124,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of slicing to manipulate file names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 495,
    "end_token": 504,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      49289,
      284,
      18510,
      2393,
      3891
    ],
    "label": "ml_signal",
    "reason": "Usage of slicing to manipulate file names"
  },
  {
    "line": 124,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Using Path object for file paths is more robust than using strings",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 504,
    "end_token": 513,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      10644,
      2134,
      329,
      2393,
      13532,
      318,
      517,
      12373,
      621,
      1262,
      13042
    ],
    "label": "best_practice",
    "reason": "Using Path object for file paths is more robust than using strings"
  },
  {
    "line": 124,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Use of ternary conditional operator for concise conditional logic",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 513,
    "end_token": 522,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1059,
      77,
      560,
      26340,
      10088,
      329,
      35327,
      26340,
      9156
    ],
    "label": "best_practice",
    "reason": "Use of ternary conditional operator for concise conditional logic"
  },
  {
    "line": 130,
    "text": "            return _calendars.min(), _calendars.max()",
    "annotation": "\u2705 Best Practice: Use of type hinting for function return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      9948,
      44942,
      13,
      1084,
      22784,
      4808,
      9948,
      44942,
      13,
      9806,
      3419
    ],
    "start_token": 522,
    "end_token": 546,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      2163,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for function return type improves code readability and maintainability"
  },
  {
    "line": 131,
    "text": "        elif as_set:",
    "annotation": "\u2705 Best Practice: Use of sorted() to ensure the list of timestamps is ordered",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      355,
      62,
      2617,
      25
    ],
    "start_token": 546,
    "end_token": 559,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      23243,
      3419,
      284,
      4155,
      262,
      1351,
      286,
      4628,
      395,
      9430,
      318,
      6149
    ],
    "label": "best_practice",
    "reason": "Use of sorted() to ensure the list of timestamps is ordered"
  },
  {
    "line": 131,
    "text": "        elif as_set:",
    "annotation": "\ud83e\udde0 ML Signal: Use of map() function to apply pd.Timestamp to each element in the list",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      355,
      62,
      2617,
      25
    ],
    "start_token": 559,
    "end_token": 572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3975,
      3419,
      2163,
      284,
      4174,
      279,
      67,
      13,
      14967,
      27823,
      284,
      1123,
      5002,
      287,
      262,
      1351
    ],
    "label": "ml_signal",
    "reason": "Use of map() function to apply pd.Timestamp to each element in the list"
  },
  {
    "line": 137,
    "text": "        df = pd.read_csv(str(file_path.resolve()), low_memory=False)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes the CSV file is well-formed and does not handle potential exceptions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      2536,
      7,
      7753,
      62,
      6978,
      13,
      411,
      6442,
      3419,
      828,
      1877,
      62,
      31673,
      28,
      25101,
      8
    ],
    "start_token": 572,
    "end_token": 604,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      262,
      44189,
      2393,
      318,
      880,
      12,
      12214,
      290,
      857,
      407,
      5412,
      2785,
      13269
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes the CSV file is well-formed and does not handle potential exceptions"
  },
  {
    "line": 137,
    "text": "        df = pd.read_csv(str(file_path.resolve()), low_memory=False)",
    "annotation": "\u2705 Best Practice: Use of type hinting for function return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      2536,
      7,
      7753,
      62,
      6978,
      13,
      411,
      6442,
      3419,
      828,
      1877,
      62,
      31673,
      28,
      25101,
      8
    ],
    "start_token": 604,
    "end_token": 636,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      2163,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for function return type improves code readability and maintainability"
  },
  {
    "line": 138,
    "text": "        df[self.date_field_name] = df[self.date_field_name].astype(str).astype(\"datetime64[ns]\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas to read CSV files is a common pattern in data processing tasks",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      944,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      60,
      796,
      47764,
      58,
      944,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      4083,
      459,
      2981,
      7,
      2536,
      737,
      459,
      2981,
      7203,
      19608,
      8079,
      2414,
      58,
      5907,
      60,
      4943
    ],
    "start_token": 636,
    "end_token": 679,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      284,
      1100,
      44189,
      3696,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      8861
    ],
    "label": "ml_signal",
    "reason": "Use of pandas to read CSV files is a common pattern in data processing tasks"
  },
  {
    "line": 149,
    "text": "            else set(df_columns) - set(self._exclude_fields) if self._exclude_fields else df_columns",
    "annotation": "\u2705 Best Practice: Returning the DataFrame directly is clear and concise",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      900,
      7,
      7568,
      62,
      28665,
      82,
      8,
      532,
      900,
      7,
      944,
      13557,
      1069,
      9152,
      62,
      25747,
      8,
      611,
      2116,
      13557,
      1069,
      9152,
      62,
      25747,
      2073,
      47764,
      62,
      28665,
      82
    ],
    "start_token": 679,
    "end_token": 720,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      262,
      6060,
      19778,
      3264,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Returning the DataFrame directly is clear and concise"
  },
  {
    "line": 149,
    "text": "            else set(df_columns) - set(self._exclude_fields) if self._exclude_fields else df_columns",
    "annotation": "\u2705 Best Practice: Ensure the directory exists before saving files",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      900,
      7,
      7568,
      62,
      28665,
      82,
      8,
      532,
      900,
      7,
      944,
      13557,
      1069,
      9152,
      62,
      25747,
      8,
      611,
      2116,
      13557,
      1069,
      9152,
      62,
      25747,
      2073,
      47764,
      62,
      28665,
      82
    ],
    "start_token": 720,
    "end_token": 761,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      8619,
      7160,
      878,
      8914,
      3696
    ],
    "label": "best_practice",
    "reason": "Ensure the directory exists before saving files"
  },
  {
    "line": 151,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage pattern of constructing file paths",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 761,
    "end_token": 761,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      3912,
      286,
      30580,
      2393,
      13532
    ],
    "label": "ml_signal",
    "reason": "Usage pattern of constructing file paths"
  },
  {
    "line": 153,
    "text": "    def _read_calendars(calendar_path: Path) -> List[pd.Timestamp]:",
    "annotation": "\ud83e\udde0 ML Signal: List comprehension for data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      961,
      62,
      9948,
      44942,
      7,
      9948,
      9239,
      62,
      6978,
      25,
      10644,
      8,
      4613,
      7343,
      58,
      30094,
      13,
      14967,
      27823,
      5974
    ],
    "start_token": 761,
    "end_token": 786,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7343,
      35915,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "List comprehension for data transformation"
  },
  {
    "line": 155,
    "text": "            map(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the data being saved is properly sanitized to prevent injection attacks",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3975,
      7
    ],
    "start_token": 786,
    "end_token": 799,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      1366,
      852,
      7448,
      318,
      6105,
      5336,
      36951,
      284,
      2948,
      16954,
      3434
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the data being saved is properly sanitized to prevent injection attacks"
  },
  {
    "line": 156,
    "text": "                pd.Timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of numpy to save text files",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      14967,
      27823,
      11
    ],
    "start_token": 799,
    "end_token": 820,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      299,
      32152,
      284,
      3613,
      2420,
      3696
    ],
    "label": "ml_signal",
    "reason": "Usage of numpy to save text files"
  },
  {
    "line": 154,
    "text": "        return sorted(",
    "annotation": "\u2705 Best Practice: Ensure the directory exists before saving files to avoid errors.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      23243,
      7
    ],
    "start_token": 820,
    "end_token": 830,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      8619,
      7160,
      878,
      8914,
      3696,
      284,
      3368,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure the directory exists before saving files to avoid errors."
  },
  {
    "line": 156,
    "text": "                pd.Timestamp,",
    "annotation": "\u2705 Best Practice: Use resolve() to get the absolute path, which helps in debugging and file management.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      14967,
      27823,
      11
    ],
    "start_token": 830,
    "end_token": 851,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      10568,
      3419,
      284,
      651,
      262,
      4112,
      3108,
      11,
      543,
      5419,
      287,
      28769,
      290,
      2393,
      4542,
      13
    ],
    "label": "best_practice",
    "reason": "Use resolve() to get the absolute path, which helps in debugging and file management."
  },
  {
    "line": 158,
    "text": "            )",
    "annotation": "\ud83e\udde0 ML Signal: Checking the type of data can indicate different processing paths, useful for ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 851,
    "end_token": 863,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      262,
      2099,
      286,
      1366,
      460,
      7603,
      1180,
      7587,
      13532,
      11,
      4465,
      329,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Checking the type of data can indicate different processing paths, useful for ML models."
  },
  {
    "line": 159,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Selecting specific fields from a DataFrame can indicate feature selection.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 863,
    "end_token": 871,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9683,
      278,
      2176,
      7032,
      422,
      257,
      6060,
      19778,
      460,
      7603,
      3895,
      6356,
      13
    ],
    "label": "ml_signal",
    "reason": "Selecting specific fields from a DataFrame can indicate feature selection."
  },
  {
    "line": 162,
    "text": "        df = pd.read_csv(",
    "annotation": "\ud83e\udde0 ML Signal: Applying transformations to data fields can be a signal for data preprocessing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7
    ],
    "start_token": 871,
    "end_token": 887,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      38226,
      284,
      1366,
      7032,
      460,
      307,
      257,
      6737,
      329,
      1366,
      662,
      36948,
      13
    ],
    "label": "ml_signal",
    "reason": "Applying transformations to data fields can be a signal for data preprocessing."
  },
  {
    "line": 167,
    "text": "                self.INSTRUMENTS_START_FIELD,",
    "annotation": "\u2705 Best Practice: Use to_csv with explicit parameters for clarity and to avoid default behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1268,
      18601,
      5883,
      15365,
      62,
      2257,
      7227,
      62,
      44603,
      11
    ],
    "start_token": 887,
    "end_token": 914,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      284,
      62,
      40664,
      351,
      7952,
      10007,
      329,
      16287,
      290,
      284,
      3368,
      4277,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Use to_csv with explicit parameters for clarity and to avoid default behavior."
  },
  {
    "line": 168,
    "text": "                self.INSTRUMENTS_END_FIELD,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that instruments_data is sanitized to prevent injection attacks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1268,
      18601,
      5883,
      15365,
      62,
      10619,
      62,
      44603,
      11
    ],
    "start_token": 914,
    "end_token": 940,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      12834,
      62,
      7890,
      318,
      5336,
      36951,
      284,
      2948,
      16954,
      3434,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that instruments_data is sanitized to prevent injection attacks."
  },
  {
    "line": 166,
    "text": "                self.symbol_field_name,",
    "annotation": "\u2705 Best Practice: Use descriptive variable names for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      11
    ],
    "start_token": 940,
    "end_token": 964,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      35644,
      7885,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Use descriptive variable names for clarity"
  },
  {
    "line": 168,
    "text": "                self.INSTRUMENTS_END_FIELD,",
    "annotation": "\u2705 Best Practice: Explicitly specify data types for consistency and clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1268,
      18601,
      5883,
      15365,
      62,
      10619,
      62,
      44603,
      11
    ],
    "start_token": 964,
    "end_token": 990,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      11986,
      1366,
      3858,
      329,
      15794,
      290,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly specify data types for consistency and clarity"
  },
  {
    "line": 168,
    "text": "                self.INSTRUMENTS_END_FIELD,",
    "annotation": "\u2705 Best Practice: Use parentheses for clarity in complex expressions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      1268,
      18601,
      5883,
      15365,
      62,
      10619,
      62,
      44603,
      11
    ],
    "start_token": 990,
    "end_token": 1016,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46672,
      329,
      16287,
      287,
      3716,
      14700
    ],
    "label": "best_practice",
    "reason": "Use parentheses for clarity in complex expressions"
  },
  {
    "line": 175,
    "text": "        self._calendars_dir.mkdir(parents=True, exist_ok=True)",
    "annotation": "\u2705 Best Practice: Use inplace=True to modify the DataFrame in place and save memory",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      9948,
      44942,
      62,
      15908,
      13,
      28015,
      15908,
      7,
      23743,
      28,
      17821,
      11,
      2152,
      62,
      482,
      28,
      17821,
      8
    ],
    "start_token": 1016,
    "end_token": 1043,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      287,
      5372,
      28,
      17821,
      284,
      13096,
      262,
      6060,
      19778,
      287,
      1295,
      290,
      3613,
      4088
    ],
    "label": "best_practice",
    "reason": "Use inplace=True to modify the DataFrame in place and save memory"
  },
  {
    "line": 177,
    "text": "        result_calendars_list = [self._format_datetime(x) for x in calendars_data]",
    "annotation": "\u2705 Best Practice: Use inplace=True to modify the DataFrame in place and save memory",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1255,
      62,
      9948,
      44942,
      62,
      4868,
      796,
      685,
      944,
      13557,
      18982,
      62,
      19608,
      8079,
      7,
      87,
      8,
      329,
      2124,
      287,
      50215,
      62,
      7890,
      60
    ],
    "start_token": 1043,
    "end_token": 1074,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      287,
      5372,
      28,
      17821,
      284,
      13096,
      262,
      6060,
      19778,
      287,
      1295,
      290,
      3613,
      4088
    ],
    "label": "best_practice",
    "reason": "Use inplace=True to modify the DataFrame in place and save memory"
  },
  {
    "line": 179,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Reindexing DataFrame based on another DataFrame's index",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1074,
    "end_token": 1074,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      797,
      9630,
      278,
      6060,
      19778,
      1912,
      319,
      1194,
      6060,
      19778,
      338,
      6376
    ],
    "label": "ml_signal",
    "reason": "Reindexing DataFrame based on another DataFrame's index"
  },
  {
    "line": 177,
    "text": "        result_calendars_list = [self._format_datetime(x) for x in calendars_data]",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with specific input types and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1255,
      62,
      9948,
      44942,
      62,
      4868,
      796,
      685,
      944,
      13557,
      18982,
      62,
      19608,
      8079,
      7,
      87,
      8,
      329,
      2124,
      287,
      50215,
      62,
      7890,
      60
    ],
    "start_token": 1074,
    "end_token": 1105,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      2176,
      5128,
      3858,
      290,
      1441,
      2099
    ],
    "label": "ml_signal",
    "reason": "Function definition with specific input types and return type"
  },
  {
    "line": 179,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential ValueError if df.index.min() is not in calendar_list",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1105,
    "end_token": 1105,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      11052,
      12331,
      611,
      47764,
      13,
      9630,
      13,
      1084,
      3419,
      318,
      407,
      287,
      11845,
      62,
      4868
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential ValueError if df.index.min() is not in calendar_list"
  },
  {
    "line": 180,
    "text": "    def save_instruments(self, instruments_data: Union[list, pd.DataFrame]):",
    "annotation": "\ud83e\udde0 ML Signal: Use of DataFrame index and list operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3613,
      62,
      259,
      2536,
      2886,
      7,
      944,
      11,
      12834,
      62,
      7890,
      25,
      4479,
      58,
      4868,
      11,
      279,
      67,
      13,
      6601,
      19778,
      60,
      2599
    ],
    "start_token": 1105,
    "end_token": 1132,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6060,
      19778,
      6376,
      290,
      1351,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of DataFrame index and list operations"
  },
  {
    "line": 180,
    "text": "    def save_instruments(self, instruments_data: Union[list, pd.DataFrame]):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging potentially sensitive information (features_dir.name)",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      3613,
      62,
      259,
      2536,
      2886,
      7,
      944,
      11,
      12834,
      62,
      7890,
      25,
      4479,
      58,
      4868,
      11,
      279,
      67,
      13,
      6601,
      19778,
      60,
      2599
    ],
    "start_token": 1132,
    "end_token": 1159,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6196,
      8564,
      1321,
      357,
      40890,
      62,
      15908,
      13,
      3672,
      8
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging potentially sensitive information (features_dir.name)"
  },
  {
    "line": 185,
    "text": "            instruments_data = instruments_data.loc[:, _df_fields]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging potentially sensitive information (calendar_list)",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12834,
      62,
      7890,
      796,
      12834,
      62,
      7890,
      13,
      17946,
      58,
      45299,
      4808,
      7568,
      62,
      25747,
      60
    ],
    "start_token": 1159,
    "end_token": 1186,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6196,
      8564,
      1321,
      357,
      9948,
      9239,
      62,
      4868,
      8
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging potentially sensitive information (calendar_list)"
  },
  {
    "line": 190,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging potentially sensitive information (features_dir.name)",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1186,
    "end_token": 1195,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6196,
      8564,
      1321,
      357,
      40890,
      62,
      15908,
      13,
      3672,
      8
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging potentially sensitive information (features_dir.name)"
  },
  {
    "line": 194,
    "text": "        # calendars",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over fields to process data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      50215
    ],
    "start_token": 1195,
    "end_token": 1204,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      7032,
      284,
      1429,
      1366
    ],
    "label": "ml_signal",
    "reason": "Iterating over fields to process data"
  },
  {
    "line": 196,
    "text": "        calendars_df[self.date_field_name] = calendars_df[self.date_field_name].astype(\"datetime64[ns]\")",
    "annotation": "\u2705 Best Practice: Use Path.joinpath for better readability and compatibility",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      50215,
      62,
      7568,
      58,
      944,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      60,
      796,
      50215,
      62,
      7568,
      58,
      944,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      4083,
      459,
      2981,
      7203,
      19608,
      8079,
      2414,
      58,
      5907,
      60,
      4943
    ],
    "start_token": 1204,
    "end_token": 1246,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      10644,
      13,
      22179,
      6978,
      329,
      1365,
      1100,
      1799,
      290,
      17764
    ],
    "label": "best_practice",
    "reason": "Use Path.joinpath for better readability and compatibility"
  },
  {
    "line": 200,
    "text": "        ]",
    "annotation": "\ud83e\udde0 ML Signal: Checking file existence and mode for conditional processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 1246,
    "end_token": 1254,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      2393,
      6224,
      290,
      4235,
      329,
      26340,
      7587
    ],
    "label": "ml_signal",
    "reason": "Checking file existence and mode for conditional processing"
  },
  {
    "line": 202,
    "text": "        cal_df.set_index(self.date_field_name, inplace=True)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Opening files in append mode without validation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2386,
      62,
      7568,
      13,
      2617,
      62,
      9630,
      7,
      944,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      11,
      287,
      5372,
      28,
      17821,
      8
    ],
    "start_token": 1254,
    "end_token": 1282,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      25522,
      3696,
      287,
      24443,
      4235,
      1231,
      21201
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Opening files in append mode without validation"
  },
  {
    "line": 204,
    "text": "        r_df = df.reindex(cal_df.index)",
    "annotation": "\ud83e\udde0 ML Signal: Converting data to binary format",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      374,
      62,
      7568,
      796,
      47764,
      13,
      260,
      9630,
      7,
      9948,
      62,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 1282,
    "end_token": 1304,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      1366,
      284,
      13934,
      5794
    ],
    "label": "ml_signal",
    "reason": "Converting data to binary format"
  },
  {
    "line": 207,
    "text": "    @staticmethod",
    "annotation": "\ud83e\udde0 ML Signal: Converting and saving data to binary format",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 1304,
    "end_token": 1310,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      290,
      8914,
      1366,
      284,
      13934,
      5794
    ],
    "label": "ml_signal",
    "reason": "Converting and saving data to binary format"
  },
  {
    "line": 201,
    "text": "        # align index",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging warning without additional context may not be sufficient for debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10548,
      6376
    ],
    "start_token": 1310,
    "end_token": 1320,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6509,
      1231,
      3224,
      4732,
      743,
      407,
      307,
      6751,
      329,
      28769
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging warning without additional context may not be sufficient for debugging"
  },
  {
    "line": 205,
    "text": "        return r_df",
    "annotation": "\u2705 Best Practice: Use isinstance for type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      374,
      62,
      7568
    ],
    "start_token": 1320,
    "end_token": 1331,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      318,
      39098,
      329,
      2099,
      10627
    ],
    "label": "best_practice",
    "reason": "Use isinstance for type checking"
  },
  {
    "line": 207,
    "text": "    @staticmethod",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning without logging or error may lead to silent failures",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 1331,
    "end_token": 1337,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      1231,
      18931,
      393,
      4049,
      743,
      1085,
      284,
      10574,
      15536
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning without logging or error may lead to silent failures"
  },
  {
    "line": 210,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Extracting code from DataFrame for further processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1337,
    "end_token": 1337,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      2438,
      422,
      6060,
      19778,
      329,
      2252,
      7587
    ],
    "label": "ml_signal",
    "reason": "Extracting code from DataFrame for further processing"
  },
  {
    "line": 214,
    "text": "            return",
    "annotation": "\ud83e\udde0 ML Signal: Extracting code from file path for further processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 1337,
    "end_token": 1349,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      2438,
      422,
      2393,
      3108,
      329,
      2252,
      7587
    ],
    "label": "ml_signal",
    "reason": "Extracting code from file path for further processing"
  },
  {
    "line": 218,
    "text": "        # align index",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising generic ValueError without specific error handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10548,
      6376
    ],
    "start_token": 1349,
    "end_token": 1359,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      14276,
      11052,
      12331,
      1231,
      2176,
      4049,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising generic ValueError without specific error handling"
  },
  {
    "line": 220,
    "text": "        if _df.empty:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging warning without additional context may not be sufficient for debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4808,
      7568,
      13,
      28920,
      25
    ],
    "start_token": 1359,
    "end_token": 1372,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      6509,
      1231,
      3224,
      4732,
      743,
      407,
      307,
      6751,
      329,
      28769
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging warning without additional context may not be sufficient for debugging"
  },
  {
    "line": 224,
    "text": "        date_index = self.get_datetime_index(_df, calendar_list)",
    "annotation": "\u2705 Best Practice: Dropping duplicates to ensure data integrity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      9630,
      796,
      2116,
      13,
      1136,
      62,
      19608,
      8079,
      62,
      9630,
      28264,
      7568,
      11,
      11845,
      62,
      4868,
      8
    ],
    "start_token": 1372,
    "end_token": 1398,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      14184,
      16856,
      284,
      4155,
      1366,
      11540
    ],
    "label": "best_practice",
    "reason": "Dropping duplicates to ensure data integrity"
  },
  {
    "line": 226,
    "text": "            bin_path = features_dir.joinpath(f\"{field.lower()}.{self.freq}{self.DUMP_FILE_SUFFIX}\")",
    "annotation": "\ud83e\udde0 ML Signal: Creating directory structure based on code",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9874,
      62,
      6978,
      796,
      3033,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      3245,
      13,
      21037,
      3419,
      27422,
      90,
      944,
      13,
      19503,
      80,
      18477,
      944,
      13,
      35,
      20476,
      62,
      25664,
      62,
      12564,
      5777,
      10426,
      92,
      4943
    ],
    "start_token": 1398,
    "end_token": 1446,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      8619,
      4645,
      1912,
      319,
      2438
    ],
    "label": "ml_signal",
    "reason": "Creating directory structure based on code"
  },
  {
    "line": 228,
    "text": "                continue",
    "annotation": "\u2705 Best Practice: Using mkdir with exist_ok=True to avoid exceptions if directory exists",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2555
    ],
    "start_token": 1446,
    "end_token": 1462,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      33480,
      15908,
      351,
      2152,
      62,
      482,
      28,
      17821,
      284,
      3368,
      13269,
      611,
      8619,
      7160
    ],
    "label": "best_practice",
    "reason": "Using mkdir with exist_ok=True to avoid exceptions if directory exists"
  },
  {
    "line": 230,
    "text": "                # update",
    "annotation": "\ud83e\udde0 ML Signal: Converting data to binary format for storage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      4296
    ],
    "start_token": 1462,
    "end_token": 1479,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      1366,
      284,
      13934,
      5794,
      329,
      6143
    ],
    "label": "ml_signal",
    "reason": "Converting data to binary format for storage"
  },
  {
    "line": 222,
    "text": "            return",
    "annotation": "\u2705 Best Practice: Method raises NotImplementedError to indicate it should be overridden in subclasses",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 1479,
    "end_token": 1491,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      284,
      7603,
      340,
      815,
      307,
      23170,
      4651,
      287,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Method raises NotImplementedError to indicate it should be overridden in subclasses"
  },
  {
    "line": 224,
    "text": "        date_index = self.get_datetime_index(_df, calendar_list)",
    "annotation": "\u2705 Best Practice: Provides a clear error message for unimplemented method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      9630,
      796,
      2116,
      13,
      1136,
      62,
      19608,
      8079,
      62,
      9630,
      28264,
      7568,
      11,
      11845,
      62,
      4868,
      8
    ],
    "start_token": 1491,
    "end_token": 1517,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47081,
      257,
      1598,
      4049,
      3275,
      329,
      28418,
      1154,
      12061,
      2446
    ],
    "label": "best_practice",
    "reason": "Provides a clear error message for unimplemented method"
  },
  {
    "line": 224,
    "text": "        date_index = self.get_datetime_index(_df, calendar_list)",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the __call__ method.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      9630,
      796,
      2116,
      13,
      1136,
      62,
      19608,
      8079,
      62,
      9630,
      28264,
      7568,
      11,
      11845,
      62,
      4868,
      8
    ],
    "start_token": 1517,
    "end_token": 1543,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      11593,
      13345,
      834,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the __call__ method."
  },
  {
    "line": 226,
    "text": "            bin_path = features_dir.joinpath(f\"{field.lower()}.{self.freq}{self.DUMP_FILE_SUFFIX}\")",
    "annotation": "\ud83e\udde0 ML Signal: Method invocation pattern for callable objects.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9874,
      62,
      6978,
      796,
      3033,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      3245,
      13,
      21037,
      3419,
      27422,
      90,
      944,
      13,
      19503,
      80,
      18477,
      944,
      13,
      35,
      20476,
      62,
      25664,
      62,
      12564,
      5777,
      10426,
      92,
      4943
    ],
    "start_token": 1543,
    "end_token": 1591,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      43219,
      3912,
      329,
      869,
      540,
      5563,
      13
    ],
    "label": "ml_signal",
    "reason": "Method invocation pattern for callable objects."
  },
  {
    "line": 227,
    "text": "            if field not in _df.columns:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the dump method does not expose sensitive information.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2214,
      407,
      287,
      4808,
      7568,
      13,
      28665,
      82,
      25
    ],
    "start_token": 1591,
    "end_token": 1612,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      10285,
      2446,
      857,
      407,
      15651,
      8564,
      1321,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the dump method does not expose sensitive information."
  },
  {
    "line": 226,
    "text": "            bin_path = features_dir.joinpath(f\"{field.lower()}.{self.freq}{self.DUMP_FILE_SUFFIX}\")",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9874,
      62,
      6978,
      796,
      3033,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      69,
      1,
      90,
      3245,
      13,
      21037,
      3419,
      27422,
      90,
      944,
      13,
      19503,
      80,
      18477,
      944,
      13,
      35,
      20476,
      62,
      25664,
      62,
      12564,
      5777,
      10426,
      92,
      4943
    ],
    "start_token": 1612,
    "end_token": 1660,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 229,
    "text": "            if bin_path.exists() and self._mode == self.UPDATE_MODE:",
    "annotation": "\ud83e\udde0 ML Signal: Logging the start of a process can be used to identify function entry points.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      9874,
      62,
      6978,
      13,
      1069,
      1023,
      3419,
      290,
      2116,
      13557,
      14171,
      6624,
      2116,
      13,
      16977,
      62,
      49058,
      25
    ],
    "start_token": 1660,
    "end_token": 1690,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      262,
      923,
      286,
      257,
      1429,
      460,
      307,
      973,
      284,
      5911,
      2163,
      5726,
      2173,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging the start of a process can be used to identify function entry points."
  },
  {
    "line": 233,
    "text": "            else:",
    "annotation": "\u2705 Best Practice: Using tqdm for progress indication improves user experience in long-running tasks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1690,
    "end_token": 1703,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      256,
      80,
      36020,
      329,
      4371,
      12955,
      19575,
      2836,
      1998,
      287,
      890,
      12,
      20270,
      8861,
      13
    ],
    "label": "best_practice",
    "reason": "Using tqdm for progress indication improves user experience in long-running tasks."
  },
  {
    "line": 234,
    "text": "                # append; self._mode == self.ALL_MODE or not bin_path.exists()",
    "annotation": "\u2705 Best Practice: Using ProcessPoolExecutor for parallel processing can improve performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24443,
      26,
      2116,
      13557,
      14171,
      6624,
      2116,
      13,
      7036,
      62,
      49058,
      393,
      407,
      9874,
      62,
      6978,
      13,
      1069,
      1023,
      3419
    ],
    "start_token": 1703,
    "end_token": 1739,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      7587,
      460,
      2987,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Using ProcessPoolExecutor for parallel processing can improve performance."
  },
  {
    "line": 251,
    "text": "        if df is None or df.empty:",
    "annotation": "\ud83e\udde0 ML Signal: Logging the end of a process can be used to identify function exit points.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      318,
      6045,
      393,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1739,
    "end_token": 1755,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      262,
      886,
      286,
      257,
      1429,
      460,
      307,
      973,
      284,
      5911,
      2163,
      8420,
      2173,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging the end of a process can be used to identify function exit points."
  },
  {
    "line": 249,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Use logging to track the start of a process for better debugging and monitoring.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1755,
    "end_token": 1764,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      18931,
      284,
      2610,
      262,
      923,
      286,
      257,
      1429,
      329,
      1365,
      28769,
      290,
      9904,
      13
    ],
    "label": "best_practice",
    "reason": "Use logging to track the start of a process for better debugging and monitoring."
  },
  {
    "line": 251,
    "text": "        if df is None or df.empty:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of sorted and map functions indicates data transformation patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      47764,
      318,
      6045,
      393,
      47764,
      13,
      28920,
      25
    ],
    "start_token": 1764,
    "end_token": 1780,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      23243,
      290,
      3975,
      5499,
      9217,
      1366,
      13389,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of sorted and map functions indicates data transformation patterns."
  },
  {
    "line": 253,
    "text": "            return",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for saving data, useful for understanding data persistence behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 1780,
    "end_token": 1792,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      8914,
      1366,
      11,
      4465,
      329,
      4547,
      1366,
      30802,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for saving data, useful for understanding data persistence behavior."
  },
  {
    "line": 255,
    "text": "        # try to remove dup rows or it will cause exception when reindex.",
    "annotation": "\u2705 Best Practice: Use logging to track the end of a process for better debugging and monitoring.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1949,
      284,
      4781,
      32597,
      15274,
      393,
      340,
      481,
      2728,
      6631,
      618,
      302,
      9630,
      13
    ],
    "start_token": 1792,
    "end_token": 1814,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      18931,
      284,
      2610,
      262,
      886,
      286,
      257,
      1429,
      329,
      1365,
      28769,
      290,
      9904,
      13
    ],
    "label": "best_practice",
    "reason": "Use logging to track the end of a process for better debugging and monitoring."
  },
  {
    "line": 253,
    "text": "            return",
    "annotation": "\u2705 Best Practice: Method name suggests it's a private method; consider using a single underscore for convention.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 1814,
    "end_token": 1826,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      5644,
      340,
      338,
      257,
      2839,
      2446,
      26,
      2074,
      1262,
      257,
      2060,
      44810,
      329,
      9831,
      13
    ],
    "label": "best_practice",
    "reason": "Method name suggests it's a private method; consider using a single underscore for convention."
  },
  {
    "line": 255,
    "text": "        # try to remove dup rows or it will cause exception when reindex.",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern can be used to identify logging practices.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1949,
      284,
      4781,
      32597,
      15274,
      393,
      340,
      481,
      2728,
      6631,
      618,
      302,
      9630,
      13
    ],
    "start_token": 1826,
    "end_token": 1848,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      460,
      307,
      973,
      284,
      5911,
      18931,
      6593,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern can be used to identify logging practices."
  },
  {
    "line": 257,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method call with self indicates instance method usage pattern.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1848,
    "end_token": 1848,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      2116,
      9217,
      4554,
      2446,
      8748,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call with self indicates instance method usage pattern."
  },
  {
    "line": 259,
    "text": "        features_dir = self._features_dir.joinpath(code_to_fname(code).lower())",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern can be used to identify logging practices.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3033,
      62,
      15908,
      796,
      2116,
      13557,
      40890,
      62,
      15908,
      13,
      22179,
      6978,
      7,
      8189,
      62,
      1462,
      62,
      69,
      3672,
      7,
      8189,
      737,
      21037,
      28955
    ],
    "start_token": 1848,
    "end_token": 1879,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      460,
      307,
      973,
      284,
      5911,
      18931,
      6593,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern can be used to identify logging practices."
  },
  {
    "line": 258,
    "text": "        # features save dir",
    "annotation": "\u2705 Best Practice: Use of logging for tracking the execution flow and debugging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      3033,
      3613,
      26672
    ],
    "start_token": 1879,
    "end_token": 1890,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      329,
      9646,
      262,
      9706,
      5202,
      290,
      28769
    ],
    "label": "best_practice",
    "reason": "Use of logging for tracking the execution flow and debugging"
  },
  {
    "line": 260,
    "text": "        features_dir.mkdir(parents=True, exist_ok=True)",
    "annotation": "\ud83e\udde0 ML Signal: Use of partial function to pre-fill arguments for another function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3033,
      62,
      15908,
      13,
      28015,
      15908,
      7,
      23743,
      28,
      17821,
      11,
      2152,
      62,
      482,
      28,
      17821,
      8
    ],
    "start_token": 1890,
    "end_token": 1914,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      13027,
      2163,
      284,
      662,
      12,
      20797,
      7159,
      329,
      1194,
      2163
    ],
    "label": "ml_signal",
    "reason": "Use of partial function to pre-fill arguments for another function"
  },
  {
    "line": 262,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of tqdm for progress tracking in loops",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1914,
    "end_token": 1914,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      256,
      80,
      36020,
      329,
      4371,
      9646,
      287,
      23607
    ],
    "label": "best_practice",
    "reason": "Use of tqdm for progress tracking in loops"
  },
  {
    "line": 264,
    "text": "    def dump(self):",
    "annotation": "\u2705 Best Practice: Use of ProcessPoolExecutor for parallel processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      10285,
      7,
      944,
      2599
    ],
    "start_token": 1914,
    "end_token": 1922,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      7587
    ],
    "label": "best_practice",
    "reason": "Use of ProcessPoolExecutor for parallel processing"
  },
  {
    "line": 266,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of executor.map for parallel execution of a function over a list",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1922,
    "end_token": 1922,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3121,
      273,
      13,
      8899,
      329,
      10730,
      9706,
      286,
      257,
      2163,
      625,
      257,
      1351
    ],
    "label": "ml_signal",
    "reason": "Use of executor.map for parallel execution of a function over a list"
  },
  {
    "line": 268,
    "text": "        self.dump()",
    "annotation": "\u2705 Best Practice: Updating progress bar inside the loop",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      39455,
      3419
    ],
    "start_token": 1922,
    "end_token": 1933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3205,
      38734,
      4371,
      2318,
      2641,
      262,
      9052
    ],
    "label": "best_practice",
    "reason": "Updating progress bar inside the loop"
  },
  {
    "line": 270,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of logging for tracking the execution flow and debugging",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1933,
    "end_token": 1933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      18931,
      329,
      9646,
      262,
      9706,
      5202,
      290,
      28769
    ],
    "label": "best_practice",
    "reason": "Use of logging for tracking the execution flow and debugging"
  },
  {
    "line": 266,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and functionality of the method.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1933,
    "end_token": 1933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      11244,
      286,
      262,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and functionality of the method."
  },
  {
    "line": 268,
    "text": "        self.dump()",
    "annotation": "\u2705 Best Practice: Ensure that the method name '_get_all_date' accurately reflects its functionality.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      39455,
      3419
    ],
    "start_token": 1933,
    "end_token": 1944,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      1438,
      705,
      62,
      1136,
      62,
      439,
      62,
      4475,
      6,
      14351,
      12497,
      663,
      11244,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the method name '_get_all_date' accurately reflects its functionality."
  },
  {
    "line": 270,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensure that the method name '_dump_calendars' accurately reflects its functionality.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1944,
    "end_token": 1944,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      1438,
      705,
      62,
      39455,
      62,
      9948,
      44942,
      6,
      14351,
      12497,
      663,
      11244,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the method name '_dump_calendars' accurately reflects its functionality."
  },
  {
    "line": 272,
    "text": "    def _get_all_date(self):",
    "annotation": "\u2705 Best Practice: Ensure that the method name '_dump_instruments' accurately reflects its functionality.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      439,
      62,
      4475,
      7,
      944,
      2599
    ],
    "start_token": 1944,
    "end_token": 1957,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      1438,
      705,
      62,
      39455,
      62,
      259,
      2536,
      2886,
      6,
      14351,
      12497,
      663,
      11244,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the method name '_dump_instruments' accurately reflects its functionality."
  },
  {
    "line": 274,
    "text": "        all_datetime = set()",
    "annotation": "\u2705 Best Practice: Ensure that the method name '_dump_features' accurately reflects its functionality.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      62,
      19608,
      8079,
      796,
      900,
      3419
    ],
    "start_token": 1957,
    "end_token": 1971,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      1438,
      705,
      62,
      39455,
      62,
      40890,
      6,
      14351,
      12497,
      663,
      11244,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the method name '_dump_features' accurately reflects its functionality."
  },
  {
    "line": 271,
    "text": "class DumpDataAll(DumpDataBase):",
    "annotation": "\u2705 Best Practice: Class names should follow the CapWords convention for readability.",
    "confidence": 0.5,
    "tokens": [
      4871,
      360,
      931,
      6601,
      3237,
      7,
      35,
      931,
      6601,
      14881,
      2599
    ],
    "start_token": 1971,
    "end_token": 1982,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      3891,
      815,
      1061,
      262,
      4476,
      37117,
      9831,
      329,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class names should follow the CapWords convention for readability."
  },
  {
    "line": 273,
    "text": "        logger.info(\"start get all date......\")",
    "annotation": "\ud83e\udde0 ML Signal: Logging at the start of a function indicates a common pattern for tracking execution flow.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      9688,
      651,
      477,
      3128,
      16317,
      4943
    ],
    "start_token": 1982,
    "end_token": 1999,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      379,
      262,
      923,
      286,
      257,
      2163,
      9217,
      257,
      2219,
      3912,
      329,
      9646,
      9706,
      5202,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging at the start of a function indicates a common pattern for tracking execution flow."
  },
  {
    "line": 274,
    "text": "        all_datetime = set()",
    "annotation": "\u2705 Best Practice: Using partial functions can improve code readability and reusability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      62,
      19608,
      8079,
      796,
      900,
      3419
    ],
    "start_token": 1999,
    "end_token": 2013,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      13027,
      5499,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      302,
      385,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using partial functions can improve code readability and reusability."
  },
  {
    "line": 283,
    "text": "                    if isinstance(_begin_time, pd.Timestamp) and isinstance(_end_time, pd.Timestamp):",
    "annotation": "\u2705 Best Practice: Using sorted and filter together is a common pattern for processing collections.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      28264,
      27471,
      62,
      2435,
      11,
      279,
      67,
      13,
      14967,
      27823,
      8,
      290,
      318,
      39098,
      28264,
      437,
      62,
      2435,
      11,
      279,
      67,
      13,
      14967,
      27823,
      2599
    ],
    "start_token": 2013,
    "end_token": 2060,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      23243,
      290,
      8106,
      1978,
      318,
      257,
      2219,
      3912,
      329,
      7587,
      17268,
      13
    ],
    "label": "best_practice",
    "reason": "Using sorted and filter together is a common pattern for processing collections."
  },
  {
    "line": 285,
    "text": "                        _end_time = self._format_datetime(_end_time)",
    "annotation": "\u2705 Best Practice: Using tqdm for progress indication is a good practice for long-running operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      437,
      62,
      2435,
      796,
      2116,
      13557,
      18982,
      62,
      19608,
      8079,
      28264,
      437,
      62,
      2435,
      8
    ],
    "start_token": 2060,
    "end_token": 2099,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      256,
      80,
      36020,
      329,
      4371,
      12955,
      318,
      257,
      922,
      3357,
      329,
      890,
      12,
      20270,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Using tqdm for progress indication is a good practice for long-running operations."
  },
  {
    "line": 287,
    "text": "                        _inst_fields = [symbol.upper(), _begin_time, _end_time]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the number of workers is controlled to prevent resource exhaustion.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      8625,
      62,
      25747,
      796,
      685,
      1837,
      23650,
      13,
      45828,
      22784,
      4808,
      27471,
      62,
      2435,
      11,
      4808,
      437,
      62,
      2435,
      60
    ],
    "start_token": 2099,
    "end_token": 2143,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      1271,
      286,
      3259,
      318,
      6856,
      284,
      2948,
      8271,
      32493,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the number of workers is controlled to prevent resource exhaustion."
  },
  {
    "line": 290,
    "text": "        self._kwargs[\"all_datetime_set\"] = all_datetime",
    "annotation": "\u2705 Best Practice: Type checking ensures that the variables are of expected types.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      46265,
      22046,
      14692,
      439,
      62,
      19608,
      8079,
      62,
      2617,
      8973,
      796,
      477,
      62,
      19608,
      8079
    ],
    "start_token": 2143,
    "end_token": 2167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      10627,
      19047,
      326,
      262,
      9633,
      389,
      286,
      2938,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Type checking ensures that the variables are of expected types."
  },
  {
    "line": 296,
    "text": "        self._calendars_list = sorted(map(pd.Timestamp, self._kwargs[\"all_datetime_set\"]))",
    "annotation": "\u2705 Best Practice: Using from_dict with orient=\"index\" is a common pattern for DataFrame creation.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      9948,
      44942,
      62,
      4868,
      796,
      23243,
      7,
      8899,
      7,
      30094,
      13,
      14967,
      27823,
      11,
      2116,
      13557,
      46265,
      22046,
      14692,
      439,
      62,
      19608,
      8079,
      62,
      2617,
      8973,
      4008
    ],
    "start_token": 2167,
    "end_token": 2203,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      422,
      62,
      11600,
      351,
      11367,
      2625,
      9630,
      1,
      318,
      257,
      2219,
      3912,
      329,
      6060,
      19778,
      6282,
      13
    ],
    "label": "best_practice",
    "reason": "Using from_dict with orient=\"index\" is a common pattern for DataFrame creation."
  },
  {
    "line": 301,
    "text": "        logger.info(\"start dump instruments......\")",
    "annotation": "\ud83e\udde0 ML Signal: Saving data to a persistent storage is a common pattern for data processing tasks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      9688,
      10285,
      12834,
      16317,
      4943
    ],
    "start_token": 2203,
    "end_token": 2219,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      34689,
      1366,
      284,
      257,
      16218,
      6143,
      318,
      257,
      2219,
      3912,
      329,
      1366,
      7587,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Saving data to a persistent storage is a common pattern for data processing tasks."
  },
  {
    "line": 302,
    "text": "        self.save_instruments(self._kwargs[\"date_range_list\"])",
    "annotation": "\ud83e\udde0 ML Signal: Logging at the end of a function indicates a common pattern for tracking execution flow.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      21928,
      62,
      259,
      2536,
      2886,
      7,
      944,
      13557,
      46265,
      22046,
      14692,
      4475,
      62,
      9521,
      62,
      4868,
      8973,
      8
    ],
    "start_token": 2219,
    "end_token": 2246,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      379,
      262,
      886,
      286,
      257,
      2163,
      9217,
      257,
      2219,
      3912,
      329,
      9646,
      9706,
      5202,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging at the end of a function indicates a common pattern for tracking execution flow."
  },
  {
    "line": 295,
    "text": "        logger.info(\"start dump calendars......\")",
    "annotation": "\ud83e\udde0 ML Signal: Method name 'dump' suggests data serialization or export operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      9688,
      10285,
      50215,
      16317,
      4943
    ],
    "start_token": 2246,
    "end_token": 2262,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      705,
      39455,
      6,
      5644,
      1366,
      11389,
      1634,
      393,
      10784,
      4905
    ],
    "label": "ml_signal",
    "reason": "Method name 'dump' suggests data serialization or export operation"
  },
  {
    "line": 296,
    "text": "        self._calendars_list = sorted(map(pd.Timestamp, self._kwargs[\"all_datetime_set\"]))",
    "annotation": "\u2705 Best Practice: Use of joinpath for file path construction improves readability and OS compatibility",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      9948,
      44942,
      62,
      4868,
      796,
      23243,
      7,
      8899,
      7,
      30094,
      13,
      14967,
      27823,
      11,
      2116,
      13557,
      46265,
      22046,
      14692,
      439,
      62,
      19608,
      8079,
      62,
      2617,
      8973,
      4008
    ],
    "start_token": 2262,
    "end_token": 2298,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4654,
      6978,
      329,
      2393,
      3108,
      5103,
      19575,
      1100,
      1799,
      290,
      7294,
      17764
    ],
    "label": "best_practice",
    "reason": "Use of joinpath for file path construction improves readability and OS compatibility"
  },
  {
    "line": 301,
    "text": "        logger.info(\"start dump instruments......\")",
    "annotation": "\u2705 Best Practice: Chaining methods for concise and readable data transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      10951,
      7203,
      9688,
      10285,
      12834,
      16317,
      4943
    ],
    "start_token": 2298,
    "end_token": 2314,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      609,
      1397,
      5050,
      329,
      35327,
      290,
      31744,
      1366,
      13389
    ],
    "label": "best_practice",
    "reason": "Chaining methods for concise and readable data transformation"
  },
  {
    "line": 304,
    "text": "",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2314,
    "end_token": 2314,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 318,
    "text": "        self._dump_instruments()",
    "annotation": "\u2705 Best Practice: Docstring provides clear parameter descriptions and default values.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      39455,
      62,
      259,
      2536,
      2886,
      3419
    ],
    "start_token": 2314,
    "end_token": 2329,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      11507,
      16969,
      290,
      4277,
      3815,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear parameter descriptions and default values."
  },
  {
    "line": 344,
    "text": "        self.save_instruments(_inst_df.reset_index())",
    "annotation": "\ud83e\udde0 ML Signal: Use of super() indicates inheritance, which is a common pattern in OOP.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      21928,
      62,
      259,
      2536,
      2886,
      28264,
      8625,
      62,
      7568,
      13,
      42503,
      62,
      9630,
      28955
    ],
    "start_token": 2329,
    "end_token": 2352,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2208,
      3419,
      9217,
      24155,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      440,
      3185,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of super() indicates inheritance, which is a common pattern in OOP."
  },
  {
    "line": 358,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of self indicates instance variable assignment, common in class methods.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2352,
    "end_token": 2352,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2116,
      9217,
      4554,
      7885,
      16237,
      11,
      2219,
      287,
      1398,
      5050,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of self indicates instance variable assignment, common in class methods."
  },
  {
    "line": 358,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of joinpath for path operations improves readability and cross-platform compatibility.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2352,
    "end_token": 2352,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4654,
      6978,
      329,
      3108,
      4560,
      19575,
      1100,
      1799,
      290,
      3272,
      12,
      24254,
      17764,
      13
    ],
    "label": "best_practice",
    "reason": "Use of joinpath for path operations improves readability and cross-platform compatibility."
  },
  {
    "line": 363,
    "text": "        qlib_dir: str,",
    "annotation": "\u2705 Best Practice: Chaining methods like set_index and to_dict improves readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      15908,
      25,
      965,
      11
    ],
    "start_token": 2352,
    "end_token": 2366,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      609,
      1397,
      5050,
      588,
      900,
      62,
      9630,
      290,
      284,
      62,
      11600,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Chaining methods like set_index and to_dict improves readability."
  },
  {
    "line": 368,
    "text": "        file_suffix: str = \".csv\",",
    "annotation": "\ud83e\udde0 ML Signal: Loading all source data at once could indicate a pattern for batch processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2393,
      62,
      37333,
      844,
      25,
      965,
      796,
      27071,
      40664,
      1600
    ],
    "start_token": 2366,
    "end_token": 2383,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      12320,
      477,
      2723,
      1366,
      379,
      1752,
      714,
      7603,
      257,
      3912,
      329,
      15458,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Loading all source data at once could indicate a pattern for batch processing."
  },
  {
    "line": 370,
    "text": "        exclude_fields: str = \"\",",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of large memory usage if _all_data is very large.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      19607,
      62,
      25747,
      25,
      965,
      796,
      366,
      1600
    ],
    "start_token": 2383,
    "end_token": 2398,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      1588,
      4088,
      8748,
      611,
      4808,
      439,
      62,
      7890,
      318,
      845,
      1588,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of large memory usage if _all_data is very large."
  },
  {
    "line": 372,
    "text": "        limit_nums: int = None,",
    "annotation": "\u2705 Best Practice: Use of lambda for inline filtering improves code conciseness.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4179,
      62,
      77,
      5700,
      25,
      493,
      796,
      6045,
      11
    ],
    "start_token": 2398,
    "end_token": 2414,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      37456,
      329,
      26098,
      25431,
      19575,
      2438,
      1673,
      271,
      9449,
      13
    ],
    "label": "best_practice",
    "reason": "Use of lambda for inline filtering improves code conciseness."
  },
  {
    "line": 368,
    "text": "        file_suffix: str = \".csv\",",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2393,
      62,
      37333,
      844,
      25,
      965,
      796,
      27071,
      40664,
      1600
    ],
    "start_token": 2414,
    "end_token": 2431,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern"
  },
  {
    "line": 370,
    "text": "        exclude_fields: str = \"\",",
    "annotation": "\u2705 Best Practice: Initialize variables before use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      19607,
      62,
      25747,
      25,
      965,
      796,
      366,
      1600
    ],
    "start_token": 2431,
    "end_token": 2446,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      9633,
      878,
      779
    ],
    "label": "best_practice",
    "reason": "Initialize variables before use"
  },
  {
    "line": 371,
    "text": "        include_fields: str = \"\",",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for file path traversal if file_path is not validated",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2291,
      62,
      25747,
      25,
      965,
      796,
      366,
      1600
    ],
    "start_token": 2446,
    "end_token": 2461,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      2393,
      3108,
      33038,
      282,
      611,
      2393,
      62,
      6978,
      318,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for file path traversal if file_path is not validated"
  },
  {
    "line": 373,
    "text": "    ):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes self.date_field_name is a valid column name, potential KeyError",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15179
    ],
    "start_token": 2461,
    "end_token": 2465,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      2116,
      13,
      4475,
      62,
      3245,
      62,
      3672,
      318,
      257,
      4938,
      5721,
      1438,
      11,
      2785,
      7383,
      12331
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes self.date_field_name is a valid column name, potential KeyError"
  },
  {
    "line": 375,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes get_symbol_from_file returns a valid value for the column",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2465,
    "end_token": 2465,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      651,
      62,
      1837,
      23650,
      62,
      6738,
      62,
      7753,
      5860,
      257,
      4938,
      1988,
      329,
      262,
      5721
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes get_symbol_from_file returns a valid value for the column"
  },
  {
    "line": 378,
    "text": "        csv_path: str",
    "annotation": "\u2705 Best Practice: Use of tqdm for progress indication improves user experience",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      269,
      21370,
      62,
      6978,
      25,
      965
    ],
    "start_token": 2465,
    "end_token": 2478,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      256,
      80,
      36020,
      329,
      4371,
      12955,
      19575,
      2836,
      1998
    ],
    "label": "best_practice",
    "reason": "Use of tqdm for progress indication improves user experience"
  },
  {
    "line": 380,
    "text": "        qlib_dir: str",
    "annotation": "\u2705 Best Practice: Use of ThreadPoolExecutor for parallel processing improves performance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10662,
      8019,
      62,
      15908,
      25,
      965
    ],
    "start_token": 2478,
    "end_token": 2491,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      14122,
      27201,
      23002,
      38409,
      329,
      10730,
      7587,
      19575,
      2854
    ],
    "label": "best_practice",
    "reason": "Use of ThreadPoolExecutor for parallel processing improves performance"
  },
  {
    "line": 384,
    "text": "        freq: str, default \"day\"",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of appending non-empty DataFrames to a list",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      25,
      965,
      11,
      4277,
      366,
      820,
      1
    ],
    "start_token": 2491,
    "end_token": 2507,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      598,
      1571,
      1729,
      12,
      28920,
      6060,
      35439,
      284,
      257,
      1351
    ],
    "label": "ml_signal",
    "reason": "Pattern of appending non-empty DataFrames to a list"
  },
  {
    "line": 387,
    "text": "            number of threads",
    "annotation": "\u2705 Best Practice: Logging provides traceability and debugging information",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1271,
      286,
      14390
    ],
    "start_token": 2507,
    "end_token": 2521,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      2667,
      3769,
      12854,
      1799,
      290,
      28769,
      1321
    ],
    "label": "best_practice",
    "reason": "Logging provides traceability and debugging information"
  },
  {
    "line": 389,
    "text": "            the name of the date field in the csv",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes all_df contains DataFrames with compatible schemas for concatenation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      1438,
      286,
      262,
      3128,
      2214,
      287,
      262,
      269,
      21370
    ],
    "start_token": 2521,
    "end_token": 2542,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      477,
      62,
      7568,
      4909,
      6060,
      35439,
      351,
      11670,
      3897,
      5356,
      329,
      1673,
      36686,
      341
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes all_df contains DataFrames with compatible schemas for concatenation"
  },
  {
    "line": 383,
    "text": "            if backup_dir is not None, backup qlib_dir to backup_dir",
    "annotation": "\u2705 Best Practice: Method name suggests a private method, which is a good practice for encapsulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      11559,
      62,
      15908,
      318,
      407,
      6045,
      11,
      11559,
      10662,
      8019,
      62,
      15908,
      284,
      11559,
      62,
      15908
    ],
    "start_token": 2542,
    "end_token": 2570,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      5644,
      257,
      2839,
      2446,
      11,
      543,
      318,
      257,
      922,
      3357,
      329,
      32652,
      1741
    ],
    "label": "best_practice",
    "reason": "Method name suggests a private method, which is a good practice for encapsulation"
  },
  {
    "line": 385,
    "text": "            transaction frequency",
    "annotation": "\u2705 Best Practice: Placeholder method with 'pass' indicates future implementation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8611,
      8373
    ],
    "start_token": 2570,
    "end_token": 2583,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8474,
      13829,
      2446,
      351,
      705,
      6603,
      6,
      9217,
      2003,
      7822
    ],
    "label": "best_practice",
    "reason": "Placeholder method with 'pass' indicates future implementation"
  },
  {
    "line": 385,
    "text": "            transaction frequency",
    "annotation": "\u2705 Best Practice: Method is defined but not implemented; consider adding a docstring or implementation.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8611,
      8373
    ],
    "start_token": 2583,
    "end_token": 2596,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      318,
      5447,
      475,
      407,
      9177,
      26,
      2074,
      4375,
      257,
      2205,
      8841,
      393,
      7822,
      13
    ],
    "label": "best_practice",
    "reason": "Method is defined but not implemented; consider adding a docstring or implementation."
  },
  {
    "line": 390,
    "text": "        file_suffix: str, default \".csv\"",
    "annotation": "\u2705 Best Practice: Use of ProcessPoolExecutor for parallel processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2393,
      62,
      37333,
      844,
      25,
      965,
      11,
      4277,
      27071,
      40664,
      1
    ],
    "start_token": 2596,
    "end_token": 2614,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      7587
    ],
    "label": "best_practice",
    "reason": "Use of ProcessPoolExecutor for parallel processing"
  },
  {
    "line": 393,
    "text": "            symbol field name",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over grouped data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6194,
      2214,
      1438
    ],
    "start_token": 2614,
    "end_token": 2628,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      32824,
      1366
    ],
    "label": "ml_signal",
    "reason": "Iterating over grouped data"
  },
  {
    "line": 395,
    "text": "            dump fields",
    "annotation": "\ud83e\udde0 ML Signal: Data transformation and normalization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10285,
      7032
    ],
    "start_token": 2628,
    "end_token": 2641,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6060,
      13389,
      290,
      3487,
      1634
    ],
    "label": "ml_signal",
    "reason": "Data transformation and normalization"
  },
  {
    "line": 397,
    "text": "            fields not dumped",
    "annotation": "\ud83e\udde0 ML Signal: Extracting date range from data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7032,
      407,
      24105
    ],
    "start_token": 2641,
    "end_token": 2655,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      3128,
      2837,
      422,
      1366
    ],
    "label": "ml_signal",
    "reason": "Extracting date range from data"
  },
  {
    "line": 405,
    "text": "            freq,",
    "annotation": "\ud83e\udde0 ML Signal: Filtering and sorting data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      11
    ],
    "start_token": 2655,
    "end_token": 2669,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      290,
      29407,
      1366
    ],
    "label": "ml_signal",
    "reason": "Filtering and sorting data"
  },
  {
    "line": 411,
    "text": "            include_fields,",
    "annotation": "\ud83e\udde0 ML Signal: Updating data structures with new information",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2291,
      62,
      25747,
      11
    ],
    "start_token": 2669,
    "end_token": 2684,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3205,
      38734,
      1366,
      8573,
      351,
      649,
      1321
    ],
    "label": "ml_signal",
    "reason": "Updating data structures with new information"
  },
  {
    "line": 413,
    "text": "        self._mode = self.UPDATE_MODE",
    "annotation": "\u2705 Best Practice: Submitting tasks to executor for parallel execution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      14171,
      796,
      2116,
      13,
      16977,
      62,
      49058
    ],
    "start_token": 2684,
    "end_token": 2700,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3834,
      16138,
      8861,
      284,
      3121,
      273,
      329,
      10730,
      9706
    ],
    "label": "best_practice",
    "reason": "Submitting tasks to executor for parallel execution"
  },
  {
    "line": 419,
    "text": "            .set_index([self.symbol_field_name])",
    "annotation": "\u2705 Best Practice: Submitting tasks to executor for parallel execution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      2617,
      62,
      9630,
      26933,
      944,
      13,
      1837,
      23650,
      62,
      3245,
      62,
      3672,
      12962
    ],
    "start_token": 2700,
    "end_token": 2725,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3834,
      16138,
      8861,
      284,
      3121,
      273,
      329,
      10730,
      9706
    ],
    "label": "best_practice",
    "reason": "Submitting tasks to executor for parallel execution"
  },
  {
    "line": 421,
    "text": "        )  # type: dict",
    "annotation": "\u2705 Best Practice: Use of tqdm for progress tracking",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267,
      220,
      1303,
      2099,
      25,
      8633
    ],
    "start_token": 2725,
    "end_token": 2738,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      256,
      80,
      36020,
      329,
      4371,
      9646
    ],
    "label": "best_practice",
    "reason": "Use of tqdm for progress tracking"
  },
  {
    "line": 427,
    "text": "        )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Catching broad exceptions can hide specific errors",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 2738,
    "end_token": 2746,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      327,
      19775,
      3154,
      13269,
      460,
      7808,
      2176,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Catching broad exceptions can hide specific errors"
  },
  {
    "line": 423,
    "text": "        # load all csv files",
    "annotation": "\ud83e\udde0 ML Signal: Method that involves saving or dumping data, indicating a data persistence pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      3440,
      477,
      269,
      21370,
      3696
    ],
    "start_token": 2746,
    "end_token": 2759,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      326,
      9018,
      8914,
      393,
      30231,
      1366,
      11,
      12739,
      257,
      1366,
      30802,
      3912
    ],
    "label": "ml_signal",
    "reason": "Method that involves saving or dumping data, indicating a data persistence pattern"
  },
  {
    "line": 425,
    "text": "        self._new_calendar_list = self._old_calendar_list + sorted(",
    "annotation": "\ud83e\udde0 ML Signal: Method call that suggests feature processing or transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      3605,
      62,
      9948,
      9239,
      62,
      4868,
      796,
      2116,
      13557,
      727,
      62,
      9948,
      9239,
      62,
      4868,
      1343,
      23243,
      7
    ],
    "start_token": 2759,
    "end_token": 2786,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      326,
      5644,
      3895,
      7587,
      393,
      13389
    ],
    "label": "ml_signal",
    "reason": "Method call that suggests feature processing or transformation"
  },
  {
    "line": 427,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: DataFrame creation from a dictionary, indicating data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 2786,
    "end_token": 2794,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6060,
      19778,
      6282,
      422,
      257,
      22155,
      11,
      12739,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "DataFrame creation from a dictionary, indicating data manipulation"
  },
  {
    "line": 429,
    "text": "    def _load_all_source_data(self):",
    "annotation": "\ud83e\udde0 ML Signal: Setting index names, indicating data labeling or organization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      2220,
      62,
      439,
      62,
      10459,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 2794,
    "end_token": 2809,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      6376,
      3891,
      11,
      12739,
      1366,
      27393,
      393,
      4009
    ],
    "label": "ml_signal",
    "reason": "Setting index names, indicating data labeling or organization"
  },
  {
    "line": 429,
    "text": "    def _load_all_source_data(self):",
    "annotation": "\ud83e\udde0 ML Signal: Saving a DataFrame, indicating data persistence",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      2220,
      62,
      439,
      62,
      10459,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 2809,
    "end_token": 2824,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      34689,
      257,
      6060,
      19778,
      11,
      12739,
      1366,
      30802
    ],
    "label": "ml_signal",
    "reason": "Saving a DataFrame, indicating data persistence"
  },
  {
    "line": 429,
    "text": "    def _load_all_source_data(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using fire.Fire can execute arbitrary code if input is not controlled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      2220,
      62,
      439,
      62,
      10459,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 2824,
    "end_token": 2839,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      2046,
      13,
      13543,
      460,
      12260,
      14977,
      2438,
      611,
      5128,
      318,
      407,
      6856
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using fire.Fire can execute arbitrary code if input is not controlled"
  },
  {
    "line": 429,
    "text": "    def _load_all_source_data(self):",
    "annotation": "\ud83e\udde0 ML Signal: Command-line interface pattern using fire.Fire",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      2220,
      62,
      439,
      62,
      10459,
      62,
      7890,
      7,
      944,
      2599
    ],
    "start_token": 2839,
    "end_token": 2854,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9455,
      12,
      1370,
      7071,
      3912,
      1262,
      2046,
      13,
      13543
    ],
    "label": "ml_signal",
    "reason": "Command-line interface pattern using fire.Fire"
  }
]