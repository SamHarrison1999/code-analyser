[
  {
    "line": 2,
    "text": "# Licensed under the MIT License.",
    "annotation": "\u2705 Best Practice: Grouping imports by standard, third-party, and local modules improves readability.",
    "confidence": 0.5,
    "tokens": [
      2,
      49962,
      739,
      262,
      17168,
      13789,
      13
    ],
    "start_token": 0,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      416,
      3210,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      13103,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports by standard, third-party, and local modules improves readability."
  },
  {
    "line": 5,
    "text": "import logging",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code clarity and reduce memory usage.",
    "confidence": 0.5,
    "tokens": [
      11748,
      18931
    ],
    "start_token": 7,
    "end_token": 9,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      16287,
      290,
      4646,
      4088,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code clarity and reduce memory usage."
  },
  {
    "line": 8,
    "text": "from logging import config as logging_config",
    "annotation": "\u2705 Best Practice: Using context managers can help manage resources more efficiently.",
    "confidence": 0.5,
    "tokens": [
      6738,
      18931,
      1330,
      4566,
      355,
      18931,
      62,
      11250
    ],
    "start_token": 9,
    "end_token": 17,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4732,
      11663,
      460,
      1037,
      6687,
      4133,
      517,
      18306,
      13
    ],
    "label": "best_practice",
    "reason": "Using context managers can help manage resources more efficiently."
  },
  {
    "line": 10,
    "text": "from contextlib import contextmanager",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing from a relative path can lead to module resolution issues.",
    "confidence": 1.0,
    "tokens": [
      6738,
      4732,
      8019,
      1330,
      4732,
      37153
    ],
    "start_token": 17,
    "end_token": 23,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      422,
      257,
      3585,
      3108,
      460,
      1085,
      284,
      8265,
      6323,
      2428,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing from a relative path can lead to module resolution issues."
  },
  {
    "line": 10,
    "text": "from contextlib import contextmanager",
    "annotation": "\ud83e\udde0 ML Signal: Use of metaclass pattern, which is an advanced Python feature",
    "confidence": 0.5,
    "tokens": [
      6738,
      4732,
      8019,
      1330,
      4732,
      37153
    ],
    "start_token": 23,
    "end_token": 29,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1138,
      330,
      31172,
      3912,
      11,
      543,
      318,
      281,
      6190,
      11361,
      3895
    ],
    "label": "ml_signal",
    "reason": "Use of metaclass pattern, which is an advanced Python feature"
  },
  {
    "line": 12,
    "text": "from .config import C",
    "annotation": "\u2705 Best Practice: Copying dictionary to avoid modifying the original",
    "confidence": 0.5,
    "tokens": [
      6738,
      764,
      11250,
      1330,
      327
    ],
    "start_token": 29,
    "end_token": 34,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6955,
      1112,
      22155,
      284,
      3368,
      30620,
      262,
      2656
    ],
    "label": "best_practice",
    "reason": "Copying dictionary to avoid modifying the original"
  },
  {
    "line": 15,
    "text": "class MetaLogger(type):",
    "annotation": "\u2705 Best Practice: Checking for key existence before assignment to avoid overwriting",
    "confidence": 1.0,
    "tokens": [
      4871,
      30277,
      11187,
      1362,
      7,
      4906,
      2599
    ],
    "start_token": 34,
    "end_token": 41,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      329,
      1994,
      6224,
      878,
      16237,
      284,
      3368,
      6993,
      799,
      278
    ],
    "label": "best_practice",
    "reason": "Checking for key existence before assignment to avoid overwriting"
  },
  {
    "line": 19,
    "text": "            if key not in attrs and key != \"__reduce__\":",
    "annotation": "\u2705 Best Practice: Using type.__new__ to create a new class instance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1994,
      407,
      287,
      708,
      3808,
      290,
      1994,
      14512,
      366,
      834,
      445,
      7234,
      834,
      1298
    ],
    "start_token": 41,
    "end_token": 67,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2099,
      13,
      834,
      3605,
      834,
      284,
      2251,
      257,
      649,
      1398,
      4554
    ],
    "label": "best_practice",
    "reason": "Using type.__new__ to create a new class instance"
  },
  {
    "line": 19,
    "text": "            if key not in attrs and key != \"__reduce__\":",
    "annotation": "\u2705 Best Practice: Class docstring provides a brief description of the class purpose.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1994,
      407,
      287,
      708,
      3808,
      290,
      1994,
      14512,
      366,
      834,
      445,
      7234,
      834,
      1298
    ],
    "start_token": 67,
    "end_token": 93,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      1398,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a brief description of the class purpose."
  },
  {
    "line": 20,
    "text": "                attrs[key] = val",
    "annotation": "\ud83e\udde0 ML Signal: Initialization pattern for class with module_name attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      708,
      3808,
      58,
      2539,
      60,
      796,
      1188
    ],
    "start_token": 93,
    "end_token": 115,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      3912,
      329,
      1398,
      351,
      8265,
      62,
      3672,
      11688
    ],
    "label": "ml_signal",
    "reason": "Initialization pattern for class with module_name attribute"
  },
  {
    "line": 21,
    "text": "        return type.__new__(mcs, name, bases, attrs)",
    "annotation": "\ud83e\udde0 ML Signal: Private attribute pattern with double underscore",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2099,
      13,
      834,
      3605,
      834,
      7,
      76,
      6359,
      11,
      1438,
      11,
      12536,
      11,
      708,
      3808,
      8
    ],
    "start_token": 115,
    "end_token": 139,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15348,
      11688,
      3912,
      351,
      4274,
      44810
    ],
    "label": "ml_signal",
    "reason": "Private attribute pattern with double underscore"
  },
  {
    "line": 25,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Use of @property decorator for encapsulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 139,
    "end_token": 143,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      32652,
      1741
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for encapsulation"
  },
  {
    "line": 23,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for creating or configuring a logger",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 143,
    "end_token": 143,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      4441,
      393,
      4566,
      870,
      257,
      49706
    ],
    "label": "ml_signal",
    "reason": "Method for creating or configuring a logger"
  },
  {
    "line": 25,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of logging library to get a logger instance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 143,
    "end_token": 147,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      18931,
      5888,
      284,
      651,
      257,
      49706,
      4554
    ],
    "label": "ml_signal",
    "reason": "Usage of logging library to get a logger instance"
  },
  {
    "line": 27,
    "text": "    \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logger level set from a potentially mutable attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 147,
    "end_token": 151,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      1362,
      1241,
      900,
      422,
      257,
      6196,
      4517,
      540,
      11688
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logger level set from a potentially mutable attribute"
  },
  {
    "line": 29,
    "text": "    def __init__(self, module_name):",
    "annotation": "\ud83e\udde0 ML Signal: Returning a configured logger instance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      8265,
      62,
      3672,
      2599
    ],
    "start_token": 151,
    "end_token": 165,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      17839,
      49706,
      4554
    ],
    "label": "ml_signal",
    "reason": "Returning a configured logger instance"
  },
  {
    "line": 27,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Method names should follow snake_case naming convention in Python",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 165,
    "end_token": 169,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      3891,
      815,
      1061,
      17522,
      62,
      7442,
      19264,
      9831,
      287,
      11361
    ],
    "label": "best_practice",
    "reason": "Method names should follow snake_case naming convention in Python"
  },
  {
    "line": 29,
    "text": "    def __init__(self, module_name):",
    "annotation": "\ud83e\udde0 ML Signal: Setting an attribute directly from a method parameter",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      8265,
      62,
      3672,
      2599
    ],
    "start_token": 169,
    "end_token": 183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      281,
      11688,
      3264,
      422,
      257,
      2446,
      11507
    ],
    "label": "ml_signal",
    "reason": "Setting an attribute directly from a method parameter"
  },
  {
    "line": 29,
    "text": "    def __init__(self, module_name):",
    "annotation": "\u2705 Best Practice: Use of __getattr__ to handle attribute access dynamically",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      8265,
      62,
      3672,
      2599
    ],
    "start_token": 183,
    "end_token": 197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      1136,
      35226,
      834,
      284,
      5412,
      11688,
      1895,
      32366
    ],
    "label": "best_practice",
    "reason": "Use of __getattr__ to handle attribute access dynamically"
  },
  {
    "line": 31,
    "text": "        # this feature name conflicts with the attribute with Logger",
    "annotation": "\u2705 Best Practice: Use of a set for membership testing is efficient",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      428,
      3895,
      1438,
      12333,
      351,
      262,
      11688,
      351,
      5972,
      1362
    ],
    "start_token": 197,
    "end_token": 215,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      900,
      329,
      9931,
      4856,
      318,
      6942
    ],
    "label": "best_practice",
    "reason": "Use of a set for membership testing is efficient"
  },
  {
    "line": 33,
    "text": "        self.__level = 0",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic AttributeError without a message",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      834,
      5715,
      796,
      657
    ],
    "start_token": 215,
    "end_token": 228,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      3460,
      4163,
      12331,
      1231,
      257,
      3275
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic AttributeError without a message"
  },
  {
    "line": 35,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Delegating attribute access to another object's method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 228,
    "end_token": 233,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1024,
      1455,
      803,
      11688,
      1895,
      284,
      1194,
      2134,
      338,
      2446
    ],
    "label": "ml_signal",
    "reason": "Delegating attribute access to another object's method"
  },
  {
    "line": 34,
    "text": "",
    "annotation": "\u2705 Best Practice: Initialize class attributes in the constructor for clarity and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 233,
    "end_token": 233,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      1398,
      12608,
      287,
      262,
      23772,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Initialize class attributes in the constructor for clarity and maintainability"
  },
  {
    "line": 38,
    "text": "        logger.setLevel(self.__level)",
    "annotation": "\u2705 Best Practice: Use of a method to retrieve or create a logger promotes encapsulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      2617,
      4971,
      7,
      944,
      13,
      834,
      5715,
      8
    ],
    "start_token": 233,
    "end_token": 250,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2446,
      284,
      19818,
      393,
      2251,
      257,
      49706,
      21068,
      32652,
      1741
    ],
    "label": "best_practice",
    "reason": "Use of a method to retrieve or create a logger promotes encapsulation"
  },
  {
    "line": 40,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking existence before creating an object",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 250,
    "end_token": 250,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      6224,
      878,
      4441,
      281,
      2134
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking existence before creating an object"
  },
  {
    "line": 40,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of creating and storing objects in a dictionary",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 250,
    "end_token": 250,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      4441,
      290,
      23069,
      5563,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Pattern of creating and storing objects in a dictionary"
  },
  {
    "line": 48,
    "text": "        return self.logger.__getattribute__(name)",
    "annotation": "\u2705 Best Practice: Separate method for creating a logger improves code readability and reusability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      6404,
      1362,
      13,
      834,
      1136,
      42348,
      834,
      7,
      3672,
      8
    ],
    "start_token": 250,
    "end_token": 270,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8621,
      30748,
      2446,
      329,
      4441,
      257,
      49706,
      19575,
      2438,
      1100,
      1799,
      290,
      302,
      385,
      1799
    ],
    "label": "best_practice",
    "reason": "Separate method for creating a logger improves code readability and reusability"
  },
  {
    "line": 49,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a consistent logger naming convention",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 270,
    "end_token": 270,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      6414,
      49706,
      19264,
      9831
    ],
    "label": "best_practice",
    "reason": "Use of a consistent logger naming convention"
  },
  {
    "line": 51,
    "text": "class _QLibLoggerManager:",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of setting logger level",
    "confidence": 0.5,
    "tokens": [
      4871,
      4808,
      9711,
      571,
      11187,
      1362,
      13511,
      25
    ],
    "start_token": 270,
    "end_token": 278,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      4634,
      49706,
      1241
    ],
    "label": "ml_signal",
    "reason": "Pattern of setting logger level"
  },
  {
    "line": 53,
    "text": "        self._loggers = {}",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of adding handlers to a logger",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      6404,
      5355,
      796,
      23884
    ],
    "start_token": 278,
    "end_token": 291,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      4375,
      32847,
      284,
      257,
      49706
    ],
    "label": "ml_signal",
    "reason": "Pattern of adding handlers to a logger"
  },
  {
    "line": 55,
    "text": "    def setLevel(self, level):",
    "annotation": "\u2705 Best Practice: Use of StreamHandler for logging to console",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      900,
      4971,
      7,
      944,
      11,
      1241,
      2599
    ],
    "start_token": 291,
    "end_token": 302,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      13860,
      25060,
      329,
      18931,
      284,
      8624
    ],
    "label": "best_practice",
    "reason": "Use of StreamHandler for logging to console"
  },
  {
    "line": 57,
    "text": "            logger.setLevel(level)",
    "annotation": "\u2705 Best Practice: Use of a formatter for consistent log message format",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      2617,
      4971,
      7,
      5715,
      8
    ],
    "start_token": 302,
    "end_token": 320,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      1296,
      1436,
      329,
      6414,
      2604,
      3275,
      5794
    ],
    "label": "best_practice",
    "reason": "Use of a formatter for consistent log message format"
  },
  {
    "line": 35,
    "text": "    @property",
    "annotation": "\u2705 Best Practice: Initialize instance variables in the constructor for clarity and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 320,
    "end_token": 325,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      4554,
      9633,
      287,
      262,
      23772,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Initialize instance variables in the constructor for clarity and maintainability."
  },
  {
    "line": 37,
    "text": "        logger = logging.getLogger(self.module_name)",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a collection to apply a method to each item",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      796,
      18931,
      13,
      1136,
      11187,
      1362,
      7,
      944,
      13,
      21412,
      62,
      3672,
      8
    ],
    "start_token": 325,
    "end_token": 346,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      4947,
      284,
      4174,
      257,
      2446,
      284,
      1123,
      2378
    ],
    "label": "ml_signal",
    "reason": "Iterating over a collection to apply a method to each item"
  },
  {
    "line": 39,
    "text": "        return logger",
    "annotation": "\ud83e\udde0 ML Signal: Method call on an object within a loop",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      49706
    ],
    "start_token": 346,
    "end_token": 355,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      319,
      281,
      2134,
      1626,
      257,
      9052
    ],
    "label": "ml_signal",
    "reason": "Method call on an object within a loop"
  },
  {
    "line": 40,
    "text": "",
    "annotation": "\u2705 Best Practice: Delegating level setting to individual logger objects",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 355,
    "end_token": 355,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      1024,
      1455,
      803,
      1241,
      4634,
      284,
      1981,
      49706,
      5563
    ],
    "label": "best_practice",
    "reason": "Delegating level setting to individual logger objects"
  },
  {
    "line": 52,
    "text": "    def __init__(self):",
    "annotation": "\u2705 Best Practice: Using setdefault to retrieve or create a logger ensures a single instance per module.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      2599
    ],
    "start_token": 355,
    "end_token": 365,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      900,
      12286,
      284,
      19818,
      393,
      2251,
      257,
      49706,
      19047,
      257,
      2060,
      4554,
      583,
      8265,
      13
    ],
    "label": "best_practice",
    "reason": "Using setdefault to retrieve or create a logger ensures a single instance per module."
  },
  {
    "line": 54,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Adjusting logger levels dynamically can indicate different logging needs or environments.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 365,
    "end_token": 365,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20292,
      278,
      49706,
      2974,
      32366,
      460,
      7603,
      1180,
      18931,
      2476,
      393,
      12493,
      13
    ],
    "label": "ml_signal",
    "reason": "Adjusting logger levels dynamically can indicate different logging needs or environments."
  },
  {
    "line": 57,
    "text": "            logger.setLevel(level)",
    "annotation": "\ud83e\udde0 ML Signal: Singleton pattern usage for logger management can be a useful feature for ML models to recognize.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      2617,
      4971,
      7,
      5715,
      8
    ],
    "start_token": 365,
    "end_token": 383,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5573,
      10565,
      3912,
      8748,
      329,
      49706,
      4542,
      460,
      307,
      257,
      4465,
      3895,
      329,
      10373,
      4981,
      284,
      7564,
      13
    ],
    "label": "ml_signal",
    "reason": "Singleton pattern usage for logger management can be a useful feature for ML models to recognize."
  },
  {
    "line": 57,
    "text": "            logger.setLevel(level)",
    "annotation": "\ud83e\udde0 ML Signal: Use of a logger indicates logging behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49706,
      13,
      2617,
      4971,
      7,
      5715,
      8
    ],
    "start_token": 383,
    "end_token": 401,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      49706,
      9217,
      18931,
      4069
    ],
    "label": "ml_signal",
    "reason": "Use of a logger indicates logging behavior"
  },
  {
    "line": 58,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive information through logging",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 401,
    "end_token": 401,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1321,
      832,
      18931
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive information through logging"
  },
  {
    "line": 60,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of a list to store time marks indicates time tracking behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 401,
    "end_token": 409,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      1351,
      284,
      3650,
      640,
      8849,
      9217,
      640,
      9646,
      4069
    ],
    "label": "ml_signal",
    "reason": "Use of a list to store time marks indicates time tracking behavior"
  },
  {
    "line": 60,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Add a decorator to indicate this is a class method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 409,
    "end_token": 417,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      257,
      11705,
      1352,
      284,
      7603,
      428,
      318,
      257,
      1398,
      2446
    ],
    "label": "best_practice",
    "reason": "Add a decorator to indicate this is a class method"
  },
  {
    "line": 68,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of time function to get current timestamp",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 417,
    "end_token": 425,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      640,
      2163,
      284,
      651,
      1459,
      41033
    ],
    "label": "ml_signal",
    "reason": "Usage of time function to get current timestamp"
  },
  {
    "line": 70,
    "text": "            level = C.logging_level",
    "annotation": "\ud83e\udde0 ML Signal: Appending to a list, indicating stack-like behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      796,
      327,
      13,
      6404,
      2667,
      62,
      5715
    ],
    "start_token": 425,
    "end_token": 444,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      284,
      257,
      1351,
      11,
      12739,
      8931,
      12,
      2339,
      4069
    ],
    "label": "ml_signal",
    "reason": "Appending to a list, indicating stack-like behavior"
  },
  {
    "line": 74,
    "text": "            # If the module_name is already qlib.xxx, we do not format here. Otherwise, it will become qlib.qlib.xxx.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Popping from a list without checking if it's empty can raise an IndexError.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1002,
      262,
      8265,
      62,
      3672,
      318,
      1541,
      10662,
      8019,
      13,
      31811,
      11,
      356,
      466,
      407,
      5794,
      994,
      13,
      15323,
      11,
      340,
      481,
      1716,
      10662,
      8019,
      13,
      80,
      8019,
      13,
      31811,
      13
    ],
    "start_token": 444,
    "end_token": 487,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7695,
      2105,
      422,
      257,
      1351,
      1231,
      10627,
      611,
      340,
      338,
      6565,
      460,
      5298,
      281,
      12901,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Popping from a list without checking if it's empty can raise an IndexError."
  },
  {
    "line": 76,
    "text": "",
    "annotation": "\u2705 Best Practice: Use @classmethod decorator to indicate that the method is a class method.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 487,
    "end_token": 487,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      2488,
      4871,
      24396,
      11705,
      1352,
      284,
      7603,
      326,
      262,
      2446,
      318,
      257,
      1398,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Use @classmethod decorator to indicate that the method is a class method."
  },
  {
    "line": 82,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using pop() without checking if the list is empty can lead to an IndexError.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 487,
    "end_token": 487,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1461,
      3419,
      1231,
      10627,
      611,
      262,
      1351,
      318,
      6565,
      460,
      1085,
      284,
      281,
      12901,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using pop() without checking if the list is empty can lead to an IndexError."
  },
  {
    "line": 85,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 487,
    "end_token": 487,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the parameters and return type for better readability and maintainability."
  },
  {
    "line": 92,
    "text": "    def set_time_mark(cls):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using pop() without checking if the list is empty can lead to an IndexError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      900,
      62,
      2435,
      62,
      4102,
      7,
      565,
      82,
      2599
    ],
    "start_token": 487,
    "end_token": 500,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1461,
      3419,
      1231,
      10627,
      611,
      262,
      1351,
      318,
      6565,
      460,
      1085,
      284,
      281,
      12901,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using pop() without checking if the list is empty can lead to an IndexError."
  },
  {
    "line": 95,
    "text": "        :return: float",
    "annotation": "\ud83e\udde0 ML Signal: Logging patterns can be used to train models to detect logging practices.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      7783,
      25,
      12178
    ],
    "start_token": 500,
    "end_token": 511,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      7572,
      460,
      307,
      973,
      284,
      4512,
      4981,
      284,
      4886,
      18931,
      6593,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging patterns can be used to train models to detect logging practices."
  },
  {
    "line": 96,
    "text": "            A timestamp for current time.",
    "annotation": "\u2705 Best Practice: Provide a clear and concise docstring for the function.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      317,
      41033,
      329,
      1459,
      640,
      13
    ],
    "start_token": 511,
    "end_token": 528,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      1598,
      290,
      35327,
      2205,
      8841,
      329,
      262,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a clear and concise docstring for the function."
  },
  {
    "line": 107,
    "text": "        return cls.time_marks.pop()",
    "annotation": "\ud83e\udde0 ML Signal: Logging behavior can be used to understand how often and when functions are called.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      537,
      82,
      13,
      2435,
      62,
      14306,
      13,
      12924,
      3419
    ],
    "start_token": 528,
    "end_token": 545,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      4069,
      460,
      307,
      973,
      284,
      1833,
      703,
      1690,
      290,
      618,
      5499,
      389,
      1444,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging behavior can be used to understand how often and when functions are called."
  },
  {
    "line": 109,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Tracking time marks can be used to analyze performance patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 545,
    "end_token": 551,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      37169,
      640,
      8849,
      460,
      307,
      973,
      284,
      16602,
      2854,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Tracking time marks can be used to analyze performance patterns."
  },
  {
    "line": 112,
    "text": "        Get last time mark from stack, calculate time diff with current time.",
    "annotation": "\ud83e\udde0 ML Signal: Use of 'yield' indicates this function is a generator, which can be a pattern of interest.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3497,
      938,
      640,
      1317,
      422,
      8931,
      11,
      15284,
      640,
      814,
      351,
      1459,
      640,
      13
    ],
    "start_token": 551,
    "end_token": 572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      705,
      88,
      1164,
      6,
      9217,
      428,
      2163,
      318,
      257,
      17301,
      11,
      543,
      460,
      307,
      257,
      3912,
      286,
      1393,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of 'yield' indicates this function is a generator, which can be a pattern of interest."
  },
  {
    "line": 114,
    "text": "            Time diff calculated by last time mark with current time.",
    "annotation": "\ud83e\udde0 ML Signal: Logging completion times can be used to analyze function execution duration.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3862,
      814,
      10488,
      416,
      938,
      640,
      1317,
      351,
      1459,
      640,
      13
    ],
    "start_token": 572,
    "end_token": 594,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      11939,
      1661,
      460,
      307,
      973,
      284,
      16602,
      2163,
      9706,
      9478,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging completion times can be used to analyze function execution duration."
  },
  {
    "line": 113,
    "text": "        :return: float",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      7783,
      25,
      12178
    ],
    "start_token": 594,
    "end_token": 605,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 119,
    "text": "    @classmethod",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Directly using external input in logging configuration can lead to code execution if not validated",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 605,
    "end_token": 611,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      4128,
      306,
      1262,
      7097,
      5128,
      287,
      18931,
      8398,
      460,
      1085,
      284,
      2438,
      9706,
      611,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Directly using external input in logging configuration can lead to code execution if not validated"
  },
  {
    "line": 120,
    "text": "    def log_cost_time(cls, info=\"Done\"):",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      2604,
      62,
      15805,
      62,
      2435,
      7,
      565,
      82,
      11,
      7508,
      2625,
      45677,
      1,
      2599
    ],
    "start_token": 611,
    "end_token": 629,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 121,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of default parameter value for flexibility",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 629,
    "end_token": 637,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      1988,
      329,
      13688
    ],
    "label": "best_practice",
    "reason": "Use of default parameter value for flexibility"
  },
  {
    "line": 122,
    "text": "        Get last time mark from stack, calculate time diff with current time, and log time diff and info.",
    "annotation": "\u2705 Best Practice: Proper use of superclass initialization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3497,
      938,
      640,
      1317,
      422,
      8931,
      11,
      15284,
      640,
      814,
      351,
      1459,
      640,
      11,
      290,
      2604,
      640,
      814,
      290,
      7508,
      13
    ],
    "start_token": 637,
    "end_token": 665,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      45989,
      779,
      286,
      2208,
      4871,
      37588
    ],
    "label": "best_practice",
    "reason": "Proper use of superclass initialization"
  },
  {
    "line": 125,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Storing parameter in instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 665,
    "end_token": 673,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      11507,
      287,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "ml_signal",
    "reason": "Storing parameter in instance variable for later use"
  },
  {
    "line": 124,
    "text": "            Info that will be logged into stdout.",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14151,
      326,
      481,
      307,
      18832,
      656,
      14367,
      448,
      13
    ],
    "start_token": 673,
    "end_token": 693,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 126,
    "text": "        cost_time = time() - cls.time_marks.pop()",
    "annotation": "\u2705 Best Practice: Initialize variables at the point of declaration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1575,
      62,
      2435,
      796,
      640,
      3419,
      532,
      537,
      82,
      13,
      2435,
      62,
      14306,
      13,
      12924,
      3419
    ],
    "start_token": 693,
    "end_token": 716,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      9633,
      379,
      262,
      966,
      286,
      14305
    ],
    "label": "best_practice",
    "reason": "Initialize variables at the point of declaration"
  },
  {
    "line": 128,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Using re.match with user-controlled input can lead to ReDoS (Regular Expression Denial of Service)",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 716,
    "end_token": 716,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8554,
      302,
      13,
      15699,
      351,
      2836,
      12,
      14401,
      5128,
      460,
      1085,
      284,
      797,
      46498,
      357,
      40164,
      41986,
      5601,
      498,
      286,
      4809,
      8
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Using re.match with user-controlled input can lead to ReDoS (Regular Expression Denial of Service)"
  },
  {
    "line": 132,
    "text": "        \"\"\"logt.",
    "annotation": "\u2705 Best Practice: Catch specific exceptions instead of a generic Exception",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      6404,
      83,
      13
    ],
    "start_token": 716,
    "end_token": 727,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25750,
      2176,
      13269,
      2427,
      286,
      257,
      14276,
      35528
    ],
    "label": "best_practice",
    "reason": "Catch specific exceptions instead of a generic Exception"
  },
  {
    "line": 135,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Explicitly return the boolean value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 727,
    "end_token": 735,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      1441,
      262,
      25131,
      1988
    ],
    "label": "best_practice",
    "reason": "Explicitly return the boolean value"
  },
  {
    "line": 134,
    "text": "",
    "annotation": "\u2705 Best Practice: Use isinstance to check the type of 'self.param'",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 735,
    "end_token": 735,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      318,
      39098,
      284,
      2198,
      262,
      2099,
      286,
      705,
      944,
      13,
      17143,
      6
    ],
    "label": "best_practice",
    "reason": "Use isinstance to check the type of 'self.param'"
  },
  {
    "line": 136,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of negating a boolean result",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 735,
    "end_token": 744,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      2469,
      803,
      257,
      25131,
      1255
    ],
    "label": "ml_signal",
    "reason": "Pattern of negating a boolean result"
  },
  {
    "line": 138,
    "text": "            name",
    "annotation": "\u2705 Best Practice: Use isinstance to check the type of 'self.param'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1438
    ],
    "start_token": 744,
    "end_token": 756,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      318,
      39098,
      284,
      2198,
      262,
      2099,
      286,
      705,
      944,
      13,
      17143,
      6
    ],
    "label": "best_practice",
    "reason": "Use isinstance to check the type of 'self.param'"
  },
  {
    "line": 140,
    "text": "            show_start",
    "annotation": "\ud83e\udde0 ML Signal: Use of generator expression with any() for short-circuit evaluation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      905,
      62,
      9688
    ],
    "start_token": 756,
    "end_token": 770,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      17301,
      5408,
      351,
      597,
      3419,
      329,
      1790,
      12,
      21170,
      5013,
      12660
    ],
    "label": "ml_signal",
    "reason": "Use of generator expression with any() for short-circuit evaluation"
  },
  {
    "line": 162,
    "text": "    def __init__(self, param=None):",
    "annotation": "\u2705 Best Practice: Use of a dictionary to map handler levels for easy access and modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      5772,
      28,
      14202,
      2599
    ],
    "start_token": 770,
    "end_token": 784,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      22155,
      284,
      3975,
      21360,
      2974,
      329,
      2562,
      1895,
      290,
      17613
    ],
    "label": "best_practice",
    "reason": "Use of a dictionary to map handler levels for easy access and modification"
  },
  {
    "line": 164,
    "text": "        self.param = param",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Direct access to logging.root.manager.loggerDict can lead to unexpected behavior if not handled carefully",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      17143,
      796,
      5772
    ],
    "start_token": 784,
    "end_token": 796,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      1895,
      284,
      18931,
      13,
      15763,
      13,
      37153,
      13,
      6404,
      1362,
      35,
      713,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      407,
      12118,
      7773
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Direct access to logging.root.manager.loggerDict can lead to unexpected behavior if not handled carefully"
  },
  {
    "line": 168,
    "text": "        match = False",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over logger handlers to modify their levels",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2872,
      796,
      10352
    ],
    "start_token": 796,
    "end_token": 806,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      49706,
      32847,
      284,
      13096,
      511,
      2974
    ],
    "label": "ml_signal",
    "reason": "Iterating over logger handlers to modify their levels"
  },
  {
    "line": 171,
    "text": "                match = True",
    "annotation": "\u2705 Best Practice: Conditional return to provide flexibility in function output",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2872,
      796,
      6407
    ],
    "start_token": 806,
    "end_token": 824,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      9724,
      1859,
      1441,
      284,
      2148,
      13688,
      287,
      2163,
      5072
    ],
    "label": "best_practice",
    "reason": "Conditional return to provide flexibility in function output"
  },
  {
    "line": 192,
    "text": "",
    "annotation": "\u2705 Best Practice: Using a context manager to manage resource setup and teardown",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 824,
    "end_token": 824,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      4732,
      4706,
      284,
      6687,
      8271,
      9058,
      290,
      573,
      446,
      593
    ],
    "label": "best_practice",
    "reason": "Using a context manager to manage resource setup and teardown"
  },
  {
    "line": 197,
    "text": "    ---------",
    "annotation": "\u2705 Best Practice: Ensuring resources are cleaned up in a finally block",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      45337
    ],
    "start_token": 824,
    "end_token": 828,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      870,
      4133,
      389,
      20750,
      510,
      287,
      257,
      3443,
      2512
    ],
    "label": "best_practice",
    "reason": "Ensuring resources are cleaned up in a finally block"
  },
  {
    "line": 197,
    "text": "    ---------",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Directly modifying handler levels could lead to misconfigured logging if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      45337
    ],
    "start_token": 828,
    "end_token": 832,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      306,
      30620,
      21360,
      2974,
      714,
      1085,
      284,
      2984,
      11250,
      1522,
      18931,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Directly modifying handler levels could lead to misconfigured logging if not handled properly"
  }
]