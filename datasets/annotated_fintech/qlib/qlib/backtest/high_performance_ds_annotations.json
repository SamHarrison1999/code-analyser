[
  {
    "line": 6,
    "text": "import inspect",
    "annotation": "\u2705 Best Practice: Use of type hints improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      10104
    ],
    "start_token": 0,
    "end_token": 2,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints improves code readability and maintainability."
  },
  {
    "line": 10,
    "text": "from typing import Any, Callable, Dict, Iterable, List, Optional, Text, Union, cast",
    "annotation": "\u2705 Best Practice: Importing specific modules or functions helps avoid namespace pollution.",
    "confidence": 1.0,
    "tokens": [
      6738,
      19720,
      1330,
      4377,
      11,
      4889,
      540,
      11,
      360,
      713,
      11,
      40806,
      540,
      11,
      7343,
      11,
      32233,
      11,
      8255,
      11,
      4479,
      11,
      3350
    ],
    "start_token": 2,
    "end_token": 25,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      13103,
      393,
      5499,
      5419,
      3368,
      25745,
      12231,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific modules or functions helps avoid namespace pollution."
  },
  {
    "line": 12,
    "text": "import numpy as np",
    "annotation": "\ud83e\udde0 ML Signal: Custom logging setup can indicate specific logging practices or configurations.",
    "confidence": 0.5,
    "tokens": [
      11748,
      299,
      32152,
      355,
      45941
    ],
    "start_token": 25,
    "end_token": 30,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      18931,
      9058,
      460,
      7603,
      2176,
      18931,
      6593,
      393,
      25412,
      13
    ],
    "label": "ml_signal",
    "reason": "Custom logging setup can indicate specific logging practices or configurations."
  },
  {
    "line": 16,
    "text": "",
    "annotation": "\u2705 Best Practice: Initialize logger for consistent logging throughout the class",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 30,
    "end_token": 30,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      49706,
      329,
      6414,
      18931,
      3690,
      262,
      1398
    ],
    "label": "best_practice",
    "reason": "Initialize logger for consistent logging throughout the class"
  },
  {
    "line": 17,
    "text": "from ..log import get_module_logger",
    "annotation": "\u2705 Best Practice: Include type hint for return type to improve code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      6738,
      11485,
      6404,
      1330,
      651,
      62,
      21412,
      62,
      6404,
      1362
    ],
    "start_token": 30,
    "end_token": 40,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      9254,
      329,
      1441,
      2099,
      284,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hint for return type to improve code readability and maintainability"
  },
  {
    "line": 25,
    "text": "        self.logger = get_module_logger(\"online operator\", level=logging.INFO)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError with a formatted string could expose internal information if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      6404,
      1362,
      796,
      651,
      62,
      21412,
      62,
      6404,
      1362,
      7203,
      25119,
      10088,
      1600,
      1241,
      28,
      6404,
      2667,
      13,
      10778,
      8
    ],
    "start_token": 40,
    "end_token": 69,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      351,
      257,
      39559,
      4731,
      714,
      15651,
      5387,
      1321,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError with a formatted string could expose internal information if not handled properly"
  },
  {
    "line": 33,
    "text": "            all stock codes",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the function's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      4283,
      12416
    ],
    "start_token": 69,
    "end_token": 83,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2163,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the function's purpose and usage."
  },
  {
    "line": 77,
    "text": "                    IndexData([86.778313, 87.433578, 85.713585], [2010-01-04, 2010-01-05, 2010-01-06])",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if not handled.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12901,
      6601,
      26933,
      4521,
      13,
      3324,
      5999,
      1485,
      11,
      10083,
      13,
      42117,
      38907,
      11,
      7600,
      13,
      50055,
      38905,
      4357,
      685,
      10333,
      12,
      486,
      12,
      3023,
      11,
      3050,
      12,
      486,
      12,
      2713,
      11,
      3050,
      12,
      486,
      12,
      3312,
      12962
    ],
    "start_token": 83,
    "end_token": 140,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if not handled."
  },
  {
    "line": 79,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Explicitly define the types of parameters for better readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 140,
    "end_token": 148,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      8160,
      262,
      3858,
      286,
      10007,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Explicitly define the types of parameters for better readability and maintainability"
  },
  {
    "line": 81,
    "text": "        stock_id: str",
    "annotation": "\u2705 Best Practice: Initialize variables before using them",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      312,
      25,
      965
    ],
    "start_token": 148,
    "end_token": 160,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      9633,
      878,
      1262,
      606
    ],
    "label": "best_practice",
    "reason": "Initialize variables before using them"
  },
  {
    "line": 83,
    "text": "            closed start time for backtest",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over DataFrame groups can indicate data processing patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4838,
      923,
      640,
      329,
      736,
      9288
    ],
    "start_token": 160,
    "end_token": 177,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      6060,
      19778,
      2628,
      460,
      7603,
      1366,
      7587,
      7572
    ],
    "label": "ml_signal",
    "reason": "Iterating over DataFrame groups can indicate data processing patterns"
  },
  {
    "line": 85,
    "text": "            closed end time for backtest",
    "annotation": "\ud83e\udde0 ML Signal: Dropping levels from a DataFrame can indicate data transformation steps",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4838,
      886,
      640,
      329,
      736,
      9288
    ],
    "start_token": 177,
    "end_token": 194,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21045,
      2105,
      2974,
      422,
      257,
      6060,
      19778,
      460,
      7603,
      1366,
      13389,
      4831
    ],
    "label": "ml_signal",
    "reason": "Dropping levels from a DataFrame can indicate data transformation steps"
  },
  {
    "line": 87,
    "text": "            the columns of data to fetch",
    "annotation": "\u2705 Best Practice: Storing processed data in an instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      15180,
      286,
      1366,
      284,
      21207
    ],
    "start_token": 194,
    "end_token": 211,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      520,
      3255,
      13686,
      1366,
      287,
      281,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "best_practice",
    "reason": "Storing processed data in an instance variable for later use"
  },
  {
    "line": 84,
    "text": "        end_time : Union[pd.Timestamp, str]",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its action, consider renaming to `get_all_stock_keys`.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      2435,
      1058,
      4479,
      58,
      30094,
      13,
      14967,
      27823,
      11,
      965,
      60
    ],
    "start_token": 211,
    "end_token": 231,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      2223,
      11,
      2074,
      8851,
      3723,
      284,
      4600,
      1136,
      62,
      439,
      62,
      13578,
      62,
      13083,
      44646
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its action, consider renaming to `get_all_stock_keys`."
  },
  {
    "line": 86,
    "text": "        field : str",
    "annotation": "\ud83e\udde0 ML Signal: Usage of `self` indicates this is a method within a class, which is useful for class-based pattern recognition.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2214,
      1058,
      965
    ],
    "start_token": 231,
    "end_token": 241,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4600,
      944,
      63,
      9217,
      428,
      318,
      257,
      2446,
      1626,
      257,
      1398,
      11,
      543,
      318,
      4465,
      329,
      1398,
      12,
      3106,
      3912,
      9465,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of `self` indicates this is a method within a class, which is useful for class-based pattern recognition."
  },
  {
    "line": 87,
    "text": "            the columns of data to fetch",
    "annotation": "\ud83e\udde0 ML Signal: Accessing `self.data` suggests `data` is an instance variable, indicating object state management.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      15180,
      286,
      1366,
      284,
      21207
    ],
    "start_token": 241,
    "end_token": 258,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      4600,
      944,
      13,
      7890,
      63,
      5644,
      4600,
      7890,
      63,
      318,
      281,
      4554,
      7885,
      11,
      12739,
      2134,
      1181,
      4542,
      13
    ],
    "label": "ml_signal",
    "reason": "Accessing `self.data` suggests `data` is an instance variable, indicating object state management."
  },
  {
    "line": 87,
    "text": "            the columns of data to fetch",
    "annotation": "\ud83e\udde0 ML Signal: Method parameter allows dynamic behavior based on input",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      15180,
      286,
      1366,
      284,
      21207
    ],
    "start_token": 258,
    "end_token": 275,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      11507,
      3578,
      8925,
      4069,
      1912,
      319,
      5128
    ],
    "label": "ml_signal",
    "reason": "Method parameter allows dynamic behavior based on input"
  },
  {
    "line": 89,
    "text": "            the method apply to data.",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on method name",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      2446,
      4174,
      284,
      1366,
      13
    ],
    "start_token": 275,
    "end_token": 292,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      2446,
      1438
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on method name"
  },
  {
    "line": 91,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if stock_id or field is not in self.data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 292,
    "end_token": 292,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      4283,
      62,
      312,
      393,
      2214,
      318,
      407,
      287,
      2116,
      13,
      7890
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if stock_id or field is not in self.data"
  },
  {
    "line": 93,
    "text": "        ----------",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Check for None to prevent further processing on invalid data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 292,
    "end_token": 301,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6822,
      329,
      6045,
      284,
      2948,
      2252,
      7587,
      319,
      12515,
      1366
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Check for None to prevent further processing on invalid data"
  },
  {
    "line": 95,
    "text": "            it will return None in following cases",
    "annotation": "\u2705 Best Practice: Explicit type checking for clarity and error prevention",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      340,
      481,
      1441,
      6045,
      287,
      1708,
      2663
    ],
    "start_token": 301,
    "end_token": 319,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      2099,
      10627,
      329,
      16287,
      290,
      4049,
      14196
    ],
    "label": "best_practice",
    "reason": "Explicit type checking for clarity and error prevention"
  },
  {
    "line": 99,
    "text": "",
    "annotation": "\u2705 Best Practice: Handling specific data types separately for clarity",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 319,
    "end_token": 319,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      49500,
      2176,
      1366,
      3858,
      13869,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Handling specific data types separately for clarity"
  },
  {
    "line": 100,
    "text": "        raise NotImplementedError(f\"Please implement the `get_data` method\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raise specific error for unexpected data types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      4600,
      1136,
      62,
      7890,
      63,
      2446,
      4943
    ],
    "start_token": 319,
    "end_token": 345,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      35123,
      2176,
      4049,
      329,
      10059,
      1366,
      3858
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raise specific error for unexpected data types"
  },
  {
    "line": 100,
    "text": "        raise NotImplementedError(f\"Please implement the `get_data` method\")",
    "annotation": "\u2705 Best Practice: Type annotations for function parameters improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      4600,
      1136,
      62,
      7890,
      63,
      2446,
      4943
    ],
    "start_token": 345,
    "end_token": 371,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      37647,
      329,
      2163,
      10007,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type annotations for function parameters improve code readability and maintainability."
  },
  {
    "line": 109,
    "text": "        self.data = quote_dict",
    "annotation": "\u2705 Best Practice: Using descriptive variable names like `quote_dict` improves code readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7890,
      796,
      9577,
      62,
      11600
    ],
    "start_token": 371,
    "end_token": 385,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      35644,
      7885,
      3891,
      588,
      4600,
      22708,
      62,
      11600,
      63,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using descriptive variable names like `quote_dict` improves code readability."
  },
  {
    "line": 112,
    "text": "        return self.data.keys()",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over grouped data is a common pattern in data processing tasks.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      7890,
      13,
      13083,
      3419
    ],
    "start_token": 385,
    "end_token": 399,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      32824,
      1366,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over grouped data is a common pattern in data processing tasks."
  },
  {
    "line": 114,
    "text": "    def get_data(self, stock_id, start_time, end_time, field, method=None):",
    "annotation": "\ud83e\udde0 ML Signal: Sorting data is a frequent operation in data preprocessing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      7890,
      7,
      944,
      11,
      4283,
      62,
      312,
      11,
      923,
      62,
      2435,
      11,
      886,
      62,
      2435,
      11,
      2214,
      11,
      2446,
      28,
      14202,
      2599
    ],
    "start_token": 399,
    "end_token": 427,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      24707,
      1366,
      318,
      257,
      10792,
      4905,
      287,
      1366,
      662,
      36948,
      13
    ],
    "label": "ml_signal",
    "reason": "Sorting data is a frequent operation in data preprocessing."
  },
  {
    "line": 120,
    "text": "        elif isinstance(stock_data, (bool, np.bool_, int, float, np.number)):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without specific handling might lead to unhandled exceptions.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      13578,
      62,
      7890,
      11,
      357,
      30388,
      11,
      45941,
      13,
      30388,
      62,
      11,
      493,
      11,
      12178,
      11,
      45941,
      13,
      17618,
      8,
      2599
    ],
    "start_token": 427,
    "end_token": 460,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      2176,
      9041,
      1244,
      1085,
      284,
      555,
      38788,
      13269,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without specific handling might lead to unhandled exceptions."
  },
  {
    "line": 122,
    "text": "        elif isinstance(stock_data, pd.Series):",
    "annotation": "\u2705 Best Practice: Using lru_cache to cache results for improved performance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      13578,
      62,
      7890,
      11,
      279,
      67,
      13,
      27996,
      2599
    ],
    "start_token": 460,
    "end_token": 481,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      300,
      622,
      62,
      23870,
      284,
      12940,
      2482,
      329,
      6596,
      2854
    ],
    "label": "best_practice",
    "reason": "Using lru_cache to cache results for improved performance"
  },
  {
    "line": 123,
    "text": "            return idd.SingleData(stock_data)",
    "annotation": "\ud83e\udde0 ML Signal: Checks if stock_id is valid by comparing against a list of all stocks",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      220,
      1638,
      13,
      28008,
      6601,
      7,
      13578,
      62,
      7890,
      8
    ],
    "start_token": 481,
    "end_token": 503,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      611,
      4283,
      62,
      312,
      318,
      4938,
      416,
      14176,
      1028,
      257,
      1351,
      286,
      477,
      14420
    ],
    "label": "ml_signal",
    "reason": "Checks if stock_id is valid by comparing against a list of all stocks"
  },
  {
    "line": 126,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Determines if the request is for a single value based on time and frequency",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 503,
    "end_token": 503,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      360,
      13221,
      274,
      611,
      262,
      2581,
      318,
      329,
      257,
      2060,
      1988,
      1912,
      319,
      640,
      290,
      8373
    ],
    "label": "ml_signal",
    "reason": "Determines if the request is for a single value based on time and frequency"
  },
  {
    "line": 129,
    "text": "    def __init__(self, quote_df: pd.DataFrame, freq: str, region: str = \"cn\") -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Attempts to access a specific data point in a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      9577,
      62,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11,
      2030,
      80,
      25,
      965,
      11,
      3814,
      25,
      965,
      796,
      366,
      31522,
      4943,
      4613,
      6045,
      25
    ],
    "start_token": 503,
    "end_token": 538,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25770,
      82,
      284,
      1895,
      257,
      2176,
      1366,
      966,
      287,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Attempts to access a specific data point in a DataFrame"
  },
  {
    "line": 132,
    "text": "        Parameters",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): KeyError is caught, but no logging or error handling is done",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 538,
    "end_token": 546,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7383,
      12331,
      318,
      4978,
      11,
      475,
      645,
      18931,
      393,
      4049,
      9041,
      318,
      1760
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "KeyError is caught, but no logging or error handling is done"
  },
  {
    "line": 135,
    "text": "            the init dataframe from qlib.",
    "annotation": "\ud83e\udde0 ML Signal: Accesses a range of data points in a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      2315,
      1366,
      14535,
      422,
      10662,
      8019,
      13
    ],
    "start_token": 546,
    "end_token": 565,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      274,
      257,
      2837,
      286,
      1366,
      2173,
      287,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accesses a range of data points in a DataFrame"
  },
  {
    "line": 139,
    "text": "        quote_dict = {}",
    "annotation": "\ud83e\udde0 ML Signal: Applies an aggregation method if provided",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9577,
      62,
      11600,
      796,
      23884
    ],
    "start_token": 565,
    "end_token": 577,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      13508,
      281,
      46500,
      2446,
      611,
      2810
    ],
    "label": "ml_signal",
    "reason": "Applies an aggregation method if provided"
  },
  {
    "line": 140,
    "text": "        for stock_id, stock_val in quote_df.groupby(level=\"instrument\", group_keys=False):",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different aggregation methods",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      4283,
      62,
      312,
      11,
      4283,
      62,
      2100,
      287,
      9577,
      62,
      7568,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      259,
      43872,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      2599
    ],
    "start_token": 577,
    "end_token": 611,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      46500,
      5050
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different aggregation methods"
  },
  {
    "line": 142,
    "text": "            quote_dict[stock_id].sort_index()  # To support more flexible slicing, we must sort data first",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for data type issues if 'data' is not numeric",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9577,
      62,
      11600,
      58,
      13578,
      62,
      312,
      4083,
      30619,
      62,
      9630,
      3419,
      220,
      1303,
      1675,
      1104,
      517,
      12846,
      49289,
      11,
      356,
      1276,
      3297,
      1366,
      717
    ],
    "start_token": 611,
    "end_token": 647,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1366,
      2099,
      2428,
      611,
      705,
      7890,
      6,
      318,
      407,
      35575
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for data type issues if 'data' is not numeric"
  },
  {
    "line": 145,
    "text": "        n, unit = Freq.parse(freq)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for data type issues if 'data' is not numeric",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      299,
      11,
      4326,
      796,
      4848,
      80,
      13,
      29572,
      7,
      19503,
      80,
      8
    ],
    "start_token": 647,
    "end_token": 666,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1366,
      2099,
      2428,
      611,
      705,
      7890,
      6,
      318,
      407,
      35575
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for data type issues if 'data' is not numeric"
  },
  {
    "line": 148,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Possible IndexError if 'data' is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 666,
    "end_token": 675,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      33671,
      12901,
      12331,
      611,
      705,
      7890,
      6,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Possible IndexError if 'data' is empty"
  },
  {
    "line": 151,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for incorrect results if 'data' is not boolean",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 675,
    "end_token": 675,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11491,
      2482,
      611,
      705,
      7890,
      6,
      318,
      407,
      25131
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for incorrect results if 'data' is not boolean"
  },
  {
    "line": 153,
    "text": "        return self.data.keys()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for incorrect results if 'data' is not a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      7890,
      13,
      13083,
      3419
    ],
    "start_token": 675,
    "end_token": 689,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11491,
      2482,
      611,
      705,
      7890,
      6,
      318,
      407,
      257,
      6060,
      19778
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for incorrect results if 'data' is not a DataFrame"
  },
  {
    "line": 157,
    "text": "        # check stock id",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Possible IndexError if 'valid_data' is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2198,
      4283,
      4686
    ],
    "start_token": 689,
    "end_token": 700,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      33671,
      12901,
      12331,
      611,
      705,
      12102,
      62,
      7890,
      6,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Possible IndexError if 'valid_data' is empty"
  },
  {
    "line": 162,
    "text": "        # If it don't consider the classification of single data, it will consume a lot of time.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of ValueError to handle unsupported methods",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1002,
      340,
      836,
      470,
      2074,
      262,
      17923,
      286,
      2060,
      1366,
      11,
      340,
      481,
      15000,
      257,
      1256,
      286,
      640,
      13
    ],
    "start_token": 700,
    "end_token": 727,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      11052,
      12331,
      284,
      5412,
      24222,
      5050
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of ValueError to handle unsupported methods"
  },
  {
    "line": 161,
    "text": "        # single data",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the class purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2060,
      1366
    ],
    "start_token": 727,
    "end_token": 737,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1398,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the class purpose and usage."
  },
  {
    "line": 161,
    "text": "        # single data",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2060,
      1366
    ],
    "start_token": 737,
    "end_token": 747,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 176,
    "text": "            data = self.data[stock_id].loc[start_time:end_time, field]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      796,
      2116,
      13,
      7890,
      58,
      13578,
      62,
      312,
      4083,
      17946,
      58,
      9688,
      62,
      2435,
      25,
      437,
      62,
      2435,
      11,
      2214,
      60
    ],
    "start_token": 747,
    "end_token": 780,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors"
  },
  {
    "line": 176,
    "text": "            data = self.data[stock_id].loc[start_time:end_time, field]",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      796,
      2116,
      13,
      7890,
      58,
      13578,
      62,
      312,
      4083,
      17946,
      58,
      9688,
      62,
      2435,
      25,
      437,
      62,
      2435,
      11,
      2214,
      60
    ],
    "start_token": 780,
    "end_token": 813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 178,
    "text": "                return None",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation to avoid runtime errors",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 813,
    "end_token": 830,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822,
      284,
      3368,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation to avoid runtime errors"
  },
  {
    "line": 178,
    "text": "                return None",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 830,
    "end_token": 847,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 180,
    "text": "                data = self._agg_data(data, method)",
    "annotation": "\ud83e\udde0 ML Signal: Use of operator overloading can indicate custom behavior for built-in operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      796,
      2116,
      13557,
      9460,
      62,
      7890,
      7,
      7890,
      11,
      2446,
      8
    ],
    "start_token": 847,
    "end_token": 874,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      10088,
      625,
      25138,
      460,
      7603,
      2183,
      4069,
      329,
      3170,
      12,
      259,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of operator overloading can indicate custom behavior for built-in operations"
  },
  {
    "line": 180,
    "text": "                data = self._agg_data(data, method)",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      796,
      2116,
      13557,
      9460,
      62,
      7890,
      7,
      7890,
      11,
      2446,
      8
    ],
    "start_token": 874,
    "end_token": 901,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 182,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation to avoid runtime errors",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 901,
    "end_token": 901,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822,
      284,
      3368,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation to avoid runtime errors"
  },
  {
    "line": 182,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 901,
    "end_token": 901,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 184,
    "text": "    def _agg_data(data: IndexData, method: str) -> Union[IndexData, np.ndarray, None]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising NotImplementedError without implementation may lead to runtime errors if not handled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      9460,
      62,
      7890,
      7,
      7890,
      25,
      12901,
      6601,
      11,
      2446,
      25,
      965,
      8,
      4613,
      4479,
      58,
      15732,
      6601,
      11,
      45941,
      13,
      358,
      18747,
      11,
      6045,
      5974
    ],
    "start_token": 901,
    "end_token": 932,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      743,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising NotImplementedError without implementation may lead to runtime errors if not handled"
  },
  {
    "line": 184,
    "text": "    def _agg_data(data: IndexData, method: str) -> Union[IndexData, np.ndarray, None]:",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      9460,
      62,
      7890,
      7,
      7890,
      25,
      12901,
      6601,
      11,
      2446,
      25,
      965,
      8,
      4613,
      4479,
      58,
      15732,
      6601,
      11,
      45941,
      13,
      358,
      18747,
      11,
      6045,
      5974
    ],
    "start_token": 932,
    "end_token": 963,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 186,
    "text": "        # FIXME: why not call the method of data directly?",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation to avoid runtime errors",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      1521,
      407,
      869,
      262,
      2446,
      286,
      1366,
      3264,
      30
    ],
    "start_token": 963,
    "end_token": 983,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822,
      284,
      3368,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation to avoid runtime errors"
  },
  {
    "line": 186,
    "text": "        # FIXME: why not call the method of data directly?",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      1521,
      407,
      869,
      262,
      2446,
      286,
      1366,
      3264,
      30
    ],
    "start_token": 983,
    "end_token": 1003,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 188,
    "text": "            return np.nansum(data)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be used cautiously as it may expose internal logic",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      45941,
      13,
      77,
      504,
      388,
      7,
      7890,
      8
    ],
    "start_token": 1003,
    "end_token": 1023,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      973,
      39640,
      355,
      340,
      743,
      15651,
      5387,
      9156
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be used cautiously as it may expose internal logic"
  },
  {
    "line": 188,
    "text": "            return np.nansum(data)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising NotImplementedError without implementation can lead to runtime errors if the method is called.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      45941,
      13,
      77,
      504,
      388,
      7,
      7890,
      8
    ],
    "start_token": 1023,
    "end_token": 1043,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      262,
      2446,
      318,
      1444,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising NotImplementedError without implementation can lead to runtime errors if the method is called."
  },
  {
    "line": 189,
    "text": "        elif method == \"mean\":",
    "annotation": "\u2705 Best Practice: Consider providing a meaningful implementation or a more descriptive error message.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      2446,
      6624,
      366,
      32604,
      1298
    ],
    "start_token": 1043,
    "end_token": 1057,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4955,
      257,
      11570,
      7822,
      393,
      257,
      517,
      35644,
      4049,
      3275,
      13
    ],
    "label": "best_practice",
    "reason": "Consider providing a meaningful implementation or a more descriptive error message."
  },
  {
    "line": 190,
    "text": "            return np.nanmean(data)",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      45941,
      13,
      12647,
      32604,
      7,
      7890,
      8
    ],
    "start_token": 1057,
    "end_token": 1076,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 192,
    "text": "            # FIXME: I've never seen that this method was called.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation to avoid runtime errors",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      314,
      1053,
      1239,
      1775,
      326,
      428,
      2446,
      373,
      1444,
      13
    ],
    "start_token": 1076,
    "end_token": 1101,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822,
      284,
      3368,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation to avoid runtime errors"
  },
  {
    "line": 192,
    "text": "            # FIXME: I've never seen that this method was called.",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      314,
      1053,
      1239,
      1775,
      326,
      428,
      2446,
      373,
      1444,
      13
    ],
    "start_token": 1101,
    "end_token": 1126,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 194,
    "text": "            return data[-1]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising NotImplementedError without implementation may lead to runtime errors if not handled",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1366,
      58,
      12,
      16,
      60
    ],
    "start_token": 1126,
    "end_token": 1143,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      743,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising NotImplementedError without implementation may lead to runtime errors if not handled"
  },
  {
    "line": 194,
    "text": "            return data[-1]",
    "annotation": "\u2705 Best Practice: Use of NotImplementedError to indicate an abstract method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1366,
      58,
      12,
      16,
      60
    ],
    "start_token": 1143,
    "end_token": 1160,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      284,
      7603,
      281,
      12531,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of NotImplementedError to indicate an abstract method"
  },
  {
    "line": 196,
    "text": "            return data.all()",
    "annotation": "\u2705 Best Practice: Clear error message guiding the developer to implement the method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1366,
      13,
      439,
      3419
    ],
    "start_token": 1160,
    "end_token": 1176,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      4049,
      3275,
      26727,
      262,
      8517,
      284,
      3494,
      262,
      2446
    ],
    "label": "best_practice",
    "reason": "Clear error message guiding the developer to implement the method"
  },
  {
    "line": 196,
    "text": "            return data.all()",
    "annotation": "\u2705 Best Practice: Method signature includes a return type hint for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1366,
      13,
      439,
      3419
    ],
    "start_token": 1176,
    "end_token": 1192,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      9877,
      3407,
      257,
      1441,
      2099,
      9254,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Method signature includes a return type hint for better readability and maintainability"
  },
  {
    "line": 198,
    "text": "            valid_data = data.loc[~data.isna().data.astype(bool)]",
    "annotation": "\u2705 Best Practice: Using NotImplementedError to indicate that the method should be implemented by subclasses",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4938,
      62,
      7890,
      796,
      1366,
      13,
      17946,
      58,
      93,
      7890,
      13,
      271,
      2616,
      22446,
      7890,
      13,
      459,
      2981,
      7,
      30388,
      15437
    ],
    "start_token": 1192,
    "end_token": 1224,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      284,
      7603,
      326,
      262,
      2446,
      815,
      307,
      9177,
      416,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Using NotImplementedError to indicate that the method should be implemented by subclasses"
  },
  {
    "line": 198,
    "text": "            valid_data = data.loc[~data.isna().data.astype(bool)]",
    "annotation": "\u2705 Best Practice: Method signature includes type hint for return value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4938,
      62,
      7890,
      796,
      1366,
      13,
      17946,
      58,
      93,
      7890,
      13,
      271,
      2616,
      22446,
      7890,
      13,
      459,
      2981,
      7,
      30388,
      15437
    ],
    "start_token": 1224,
    "end_token": 1256,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      9877,
      3407,
      2099,
      9254,
      329,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Method signature includes type hint for return value"
  },
  {
    "line": 200,
    "text": "                return None",
    "annotation": "\u2705 Best Practice: Use of NotImplementedError to indicate an abstract method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 1256,
    "end_token": 1273,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      284,
      7603,
      281,
      12531,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of NotImplementedError to indicate an abstract method"
  },
  {
    "line": 200,
    "text": "                return None",
    "annotation": "\u2705 Best Practice: Method docstring provides a clear description of the method's purpose.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 1273,
    "end_token": 1290,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      2446,
      338,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Method docstring provides a clear description of the method's purpose."
  },
  {
    "line": 203,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError with a formatted string could expose internal information if not handled properly.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1290,
    "end_token": 1299,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      351,
      257,
      39559,
      4731,
      714,
      15651,
      5387,
      1321,
      611,
      407,
      12118,
      6105,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError with a formatted string could expose internal information if not handled properly."
  },
  {
    "line": 203,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method raises NotImplementedError, which is a placeholder and should be implemented to avoid runtime errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1299,
    "end_token": 1308,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      12073,
      1892,
      3546,
      1154,
      12061,
      12331,
      11,
      543,
      318,
      257,
      46076,
      290,
      815,
      307,
      9177,
      284,
      3368,
      19124,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method raises NotImplementedError, which is a placeholder and should be implemented to avoid runtime errors."
  },
  {
    "line": 206,
    "text": "",
    "annotation": "\u2705 Best Practice: Method docstring provides a clear description of the method's purpose.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1308,
    "end_token": 1308,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      2446,
      338,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Method docstring provides a clear description of the method's purpose."
  },
  {
    "line": 208,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 1308,
    "end_token": 1312,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability."
  },
  {
    "line": 210,
    "text": "    The following methods are used for computing metrics in one indicator.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError is generally safe, but ensure it's not exposed in production.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      383,
      1708,
      5050,
      389,
      973,
      329,
      14492,
      20731,
      287,
      530,
      16916,
      13
    ],
    "start_token": 1312,
    "end_token": 1327,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      4143,
      3338,
      11,
      475,
      4155,
      340,
      338,
      407,
      7362,
      287,
      3227,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError is generally safe, but ensure it's not exposed in production."
  },
  {
    "line": 209,
    "text": "    The data structure of the single metric.",
    "annotation": "\u2705 Best Practice: Type hinting for parameters and return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      383,
      1366,
      4645,
      286,
      262,
      2060,
      18663,
      13
    ],
    "start_token": 1327,
    "end_token": 1338,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for parameters and return type improves code readability and maintainability"
  },
  {
    "line": 212,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method is not implemented, which could lead to runtime errors if called",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1338,
    "end_token": 1338,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      318,
      407,
      9177,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      1444
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method is not implemented, which could lead to runtime errors if called"
  },
  {
    "line": 212,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for the parameter and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1338,
    "end_token": 1338,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      11507,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for the parameter and return type improves code readability and maintainability."
  },
  {
    "line": 215,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if the method is called.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1338,
    "end_token": 1338,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      262,
      2446,
      318,
      1444,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if the method is called."
  },
  {
    "line": 215,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for 'func' improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1338,
    "end_token": 1338,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      705,
      20786,
      6,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for 'func' improves code readability and maintainability"
  },
  {
    "line": 220,
    "text": "            for example:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using 'NotImplementedError' without implementation may lead to runtime errors if not handled",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1672,
      25
    ],
    "start_token": 1338,
    "end_token": 1352,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      705,
      3673,
      3546,
      1154,
      12061,
      12331,
      6,
      1231,
      7822,
      743,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using 'NotImplementedError' without implementation may lead to runtime errors if not handled"
  },
  {
    "line": 231,
    "text": "        raise NotImplementedError(f\"Please implement the `__add__` method\")",
    "annotation": "\u2705 Best Practice: Provide a clear and detailed docstring to explain the class purpose and usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      4600,
      834,
      2860,
      834,
      63,
      2446,
      4943
    ],
    "start_token": 1352,
    "end_token": 1378,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      1598,
      290,
      6496,
      2205,
      8841,
      284,
      4727,
      262,
      1398,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a clear and detailed docstring to explain the class purpose and usage."
  },
  {
    "line": 232,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: The choice between two data structure designs can be used to understand developer preferences.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1378,
    "end_token": 1378,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      3572,
      1022,
      734,
      1366,
      4645,
      9824,
      460,
      307,
      973,
      284,
      1833,
      8517,
      15387,
      13
    ],
    "label": "ml_signal",
    "reason": "The choice between two data structure designs can be used to understand developer preferences."
  },
  {
    "line": 232,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of instance variables",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1378,
    "end_token": 1378,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Initialization of instance variables"
  },
  {
    "line": 234,
    "text": "        return self + other",
    "annotation": "\ud83e\udde0 ML Signal: Logger initialization pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      1343,
      584
    ],
    "start_token": 1378,
    "end_token": 1389,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      1362,
      37588,
      3912
    ],
    "label": "ml_signal",
    "reason": "Logger initialization pattern"
  },
  {
    "line": 235,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure logger is properly configured to avoid information leakage",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1389,
    "end_token": 1389,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      49706,
      318,
      6105,
      17839,
      284,
      3368,
      1321,
      47988
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure logger is properly configured to avoid information leakage"
  },
  {
    "line": 235,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1389,
    "end_token": 1389,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 251,
    "text": "    def __gt__(self, other: Union[BaseSingleMetric, int, float]) -> BaseSingleMetric:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The method is not implemented, which could lead to runtime errors if called.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      13655,
      834,
      7,
      944,
      11,
      584,
      25,
      4479,
      58,
      14881,
      28008,
      9171,
      1173,
      11,
      493,
      11,
      12178,
      12962,
      4613,
      7308,
      28008,
      9171,
      1173,
      25
    ],
    "start_token": 1389,
    "end_token": 1418,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      2446,
      318,
      407,
      9177,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      1444,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The method is not implemented, which could lead to runtime errors if called."
  },
  {
    "line": 268,
    "text": "",
    "annotation": "\u2705 Best Practice: Using inspect.signature to dynamically retrieve function parameters",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1418,
    "end_token": 1418,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      10104,
      13,
      12683,
      1300,
      284,
      32366,
      19818,
      2163,
      10007
    ],
    "label": "best_practice",
    "reason": "Using inspect.signature to dynamically retrieve function parameters"
  },
  {
    "line": 270,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic function argument mapping based on function signature",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1418,
    "end_token": 1418,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      2163,
      4578,
      16855,
      1912,
      319,
      2163,
      9877
    ],
    "label": "ml_signal",
    "reason": "Dynamic function argument mapping based on function signature"
  },
  {
    "line": 272,
    "text": "        raise NotImplementedError(f\"Please implement the `abs` method\")",
    "annotation": "\ud83e\udde0 ML Signal: Invocation of a user-provided function with dynamically mapped arguments",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      4600,
      8937,
      63,
      2446,
      4943
    ],
    "start_token": 1418,
    "end_token": 1442,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      10001,
      5040,
      286,
      257,
      2836,
      12,
      41279,
      2163,
      351,
      32366,
      27661,
      7159
    ],
    "label": "ml_signal",
    "reason": "Invocation of a user-provided function with dynamically mapped arguments"
  },
  {
    "line": 275,
    "text": "    def empty(self) -> bool:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for overwriting existing data in self.data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      6565,
      7,
      944,
      8,
      4613,
      20512,
      25
    ],
    "start_token": 1442,
    "end_token": 1453,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6993,
      799,
      278,
      4683,
      1366,
      287,
      2116,
      13,
      7890
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for overwriting existing data in self.data"
  },
  {
    "line": 277,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return type",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1453,
    "end_token": 1453,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return type"
  },
  {
    "line": 289,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError should be replaced with actual implementation to avoid runtime errors",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1453,
    "end_token": 1453,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      815,
      307,
      6928,
      351,
      4036,
      7822,
      284,
      3368,
      19124,
      8563
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError should be replaced with actual implementation to avoid runtime errors"
  },
  {
    "line": 290,
    "text": "    def apply(self, func: Callable) -> BaseSingleMetric:",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose and parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4174,
      7,
      944,
      11,
      25439,
      25,
      4889,
      540,
      8,
      4613,
      7308,
      28008,
      9171,
      1173,
      25
    ],
    "start_token": 1453,
    "end_token": 1472,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose and parameters"
  },
  {
    "line": 300,
    "text": "    The data structure of order indicator.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if not handled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      383,
      1366,
      4645,
      286,
      1502,
      16916,
      13
    ],
    "start_token": 1472,
    "end_token": 1482,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if not handled"
  },
  {
    "line": 308,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the function's purpose and parameters.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 1482,
    "end_token": 1486,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2163,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the function's purpose and parameters."
  },
  {
    "line": 323,
    "text": "            for example:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Function is not implemented, which could lead to runtime errors if called.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1672,
      25
    ],
    "start_token": 1486,
    "end_token": 1500,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      15553,
      318,
      407,
      9177,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      1444,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Function is not implemented, which could lead to runtime errors if called."
  },
  {
    "line": 323,
    "text": "            for example:",
    "annotation": "\u2705 Best Practice: Include type hints for return type to improve code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1672,
      25
    ],
    "start_token": 1500,
    "end_token": 1514,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      1441,
      2099,
      284,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for return type to improve code readability and maintainability"
  },
  {
    "line": 336,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if the method is called",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1514,
    "end_token": 1514,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      262,
      2446,
      318,
      1444
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if the method is called"
  },
  {
    "line": 338,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Use of constructor to initialize object state",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 1514,
    "end_token": 1523,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      23772,
      284,
      41216,
      2134,
      1181
    ],
    "label": "best_practice",
    "reason": "Use of constructor to initialize object state"
  },
  {
    "line": 340,
    "text": "            the func of computing new metric.",
    "annotation": "\u2705 Best Practice: Storing parameter as an instance variable",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      25439,
      286,
      14492,
      649,
      18663,
      13
    ],
    "start_token": 1523,
    "end_token": 1541,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      520,
      3255,
      11507,
      355,
      281,
      4554,
      7885
    ],
    "label": "best_practice",
    "reason": "Storing parameter as an instance variable"
  },
  {
    "line": 339,
    "text": "        func : Callable",
    "annotation": "\u2705 Best Practice: Use of __add__ method to define addition behavior for the class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25439,
      1058,
      4889,
      540
    ],
    "start_token": 1541,
    "end_token": 1552,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      2860,
      834,
      2446,
      284,
      8160,
      3090,
      4069,
      329,
      262,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of __add__ method to define addition behavior for the class"
  },
  {
    "line": 341,
    "text": "            the kwargs of func will be replaced with metric data by name in this function.",
    "annotation": "\u2705 Best Practice: Check for instance type to ensure correct operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      479,
      86,
      22046,
      286,
      25439,
      481,
      307,
      6928,
      351,
      18663,
      1366,
      416,
      1438,
      287,
      428,
      2163,
      13
    ],
    "start_token": 1552,
    "end_token": 1581,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      4554,
      2099,
      284,
      4155,
      3376,
      4905
    ],
    "label": "best_practice",
    "reason": "Check for instance type to ensure correct operation"
  },
  {
    "line": 343,
    "text": "                def func(pa):",
    "annotation": "\ud83e\udde0 ML Signal: Custom addition with primitive types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      825,
      25439,
      7,
      8957,
      2599
    ],
    "start_token": 1581,
    "end_token": 1601,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      3090,
      351,
      20049,
      3858
    ],
    "label": "ml_signal",
    "reason": "Custom addition with primitive types"
  },
  {
    "line": 345,
    "text": "        new_col : str, optional",
    "annotation": "\u2705 Best Practice: Check for instance type to ensure correct operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      649,
      62,
      4033,
      1058,
      965,
      11,
      11902
    ],
    "start_token": 1601,
    "end_token": 1615,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      4554,
      2099,
      284,
      4155,
      3376,
      4905
    ],
    "label": "best_practice",
    "reason": "Check for instance type to ensure correct operation"
  },
  {
    "line": 347,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Custom addition with same class type",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1615,
    "end_token": 1615,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      3090,
      351,
      976,
      1398,
      2099
    ],
    "label": "ml_signal",
    "reason": "Custom addition with same class type"
  },
  {
    "line": 350,
    "text": "        BaseSingleMetric",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7308,
      28008,
      9171,
      1173
    ],
    "start_token": 1615,
    "end_token": 1626,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types"
  },
  {
    "line": 347,
    "text": "",
    "annotation": "\u2705 Best Practice: Check if 'other' is an instance of expected types before proceeding",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1626,
    "end_token": 1626,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      281,
      4554,
      286,
      2938,
      3858,
      878,
      18788
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is an instance of expected types before proceeding"
  },
  {
    "line": 349,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Overloading the subtraction operator for custom class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 1626,
    "end_token": 1635,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3827,
      25138,
      262,
      13284,
      7861,
      10088,
      329,
      2183,
      1398
    ],
    "label": "ml_signal",
    "reason": "Overloading the subtraction operator for custom class"
  },
  {
    "line": 352,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Handling subtraction between instances of the same class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1635,
    "end_token": 1643,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      13284,
      7861,
      1022,
      10245,
      286,
      262,
      976,
      1398
    ],
    "label": "ml_signal",
    "reason": "Handling subtraction between instances of the same class"
  },
  {
    "line": 355,
    "text": "        tmp_metric = func(**func_kwargs)",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types to allow other operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      45218,
      62,
      4164,
      1173,
      796,
      25439,
      7,
      1174,
      20786,
      62,
      46265,
      22046,
      8
    ],
    "start_token": 1643,
    "end_token": 1663,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858,
      284,
      1249,
      584,
      4560
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types to allow other operations"
  },
  {
    "line": 354,
    "text": "        func_kwargs = {sig: self.data[sig] for sig in func_sig}",
    "annotation": "\u2705 Best Practice: Check for specific types before performing operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25439,
      62,
      46265,
      22046,
      796,
      1391,
      82,
      328,
      25,
      2116,
      13,
      7890,
      58,
      82,
      328,
      60,
      329,
      43237,
      287,
      25439,
      62,
      82,
      328,
      92
    ],
    "start_token": 1663,
    "end_token": 1694,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      2176,
      3858,
      878,
      9489,
      4560
    ],
    "label": "best_practice",
    "reason": "Check for specific types before performing operations"
  },
  {
    "line": 356,
    "text": "        if new_col is not None:",
    "annotation": "\ud83e\udde0 ML Signal: Custom subtraction behavior with numeric types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      649,
      62,
      4033,
      318,
      407,
      6045,
      25
    ],
    "start_token": 1694,
    "end_token": 1709,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      13284,
      7861,
      4069,
      351,
      35575,
      3858
    ],
    "label": "ml_signal",
    "reason": "Custom subtraction behavior with numeric types"
  },
  {
    "line": 359,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Custom subtraction behavior with same class instances",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1709,
    "end_token": 1718,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      13284,
      7861,
      4069,
      351,
      976,
      1398,
      10245
    ],
    "label": "ml_signal",
    "reason": "Custom subtraction behavior with same class instances"
  },
  {
    "line": 362,
    "text": "    def get_metric_series(self, metric: str) -> pd.Series:",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      4164,
      1173,
      62,
      25076,
      7,
      944,
      11,
      18663,
      25,
      965,
      8,
      4613,
      279,
      67,
      13,
      27996,
      25
    ],
    "start_token": 1718,
    "end_token": 1741,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types"
  },
  {
    "line": 361,
    "text": "",
    "annotation": "\u2705 Best Practice: Check for type before performing operations to ensure correct behavior.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1741,
    "end_token": 1741,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      2099,
      878,
      9489,
      4560,
      284,
      4155,
      3376,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Check for type before performing operations to ensure correct behavior."
  },
  {
    "line": 363,
    "text": "        \"\"\"return the single metric with pd.Series format.",
    "annotation": "\ud83e\udde0 ML Signal: Overloading the multiplication operator for custom behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      7783,
      262,
      2060,
      18663,
      351,
      279,
      67,
      13,
      27996,
      5794,
      13
    ],
    "start_token": 1741,
    "end_token": 1760,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3827,
      25138,
      262,
      48473,
      10088,
      329,
      2183,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Overloading the multiplication operator for custom behavior."
  },
  {
    "line": 364,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of isinstance to handle different types in a method.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1760,
    "end_token": 1760,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      318,
      39098,
      284,
      5412,
      1180,
      3858,
      287,
      257,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Use of isinstance to handle different types in a method."
  },
  {
    "line": 367,
    "text": "        metric : str",
    "annotation": "\ud83e\udde0 ML Signal: Overloading the multiplication operator for custom behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      18663,
      1058,
      965
    ],
    "start_token": 1760,
    "end_token": 1770,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3827,
      25138,
      262,
      48473,
      10088,
      329,
      2183,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Overloading the multiplication operator for custom behavior."
  },
  {
    "line": 370,
    "text": "        Return",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types to allow other operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8229
    ],
    "start_token": 1770,
    "end_token": 1778,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858,
      284,
      1249,
      584,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types to allow other operations."
  },
  {
    "line": 368,
    "text": "            the metric name.",
    "annotation": "\u2705 Best Practice: Check if 'other' is an instance of int or float for safe division",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      18663,
      1438,
      13
    ],
    "start_token": 1778,
    "end_token": 1793,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      281,
      4554,
      286,
      493,
      393,
      12178,
      329,
      3338,
      7297
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is an instance of int or float for safe division"
  },
  {
    "line": 370,
    "text": "        Return",
    "annotation": "\ud83e\udde0 ML Signal: Custom division behavior for numeric types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8229
    ],
    "start_token": 1793,
    "end_token": 1801,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      7297,
      4069,
      329,
      35575,
      3858
    ],
    "label": "ml_signal",
    "reason": "Custom division behavior for numeric types"
  },
  {
    "line": 371,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Check if 'other' is an instance of the same class for safe division",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 1801,
    "end_token": 1810,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      281,
      4554,
      286,
      262,
      976,
      1398,
      329,
      3338,
      7297
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is an instance of the same class for safe division"
  },
  {
    "line": 374,
    "text": "            If there is no metric name in the data, return pd.Series().",
    "annotation": "\ud83e\udde0 ML Signal: Custom division behavior for instances of the same class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1002,
      612,
      318,
      645,
      18663,
      1438,
      287,
      262,
      1366,
      11,
      1441,
      279,
      67,
      13,
      27996,
      22446
    ],
    "start_token": 1810,
    "end_token": 1837,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      7297,
      4069,
      329,
      10245,
      286,
      262,
      976,
      1398
    ],
    "label": "ml_signal",
    "reason": "Custom division behavior for instances of the same class"
  },
  {
    "line": 377,
    "text": "        raise NotImplementedError(f\"Please implement the 'get_metric_series' method\")",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types to allow other operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      705,
      1136,
      62,
      4164,
      1173,
      62,
      25076,
      6,
      2446,
      4943
    ],
    "start_token": 1837,
    "end_token": 1866,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858,
      284,
      1249,
      584,
      4560
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types to allow other operations"
  },
  {
    "line": 375,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Check if 'other' is an instance of expected types before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1866,
    "end_token": 1874,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      281,
      4554,
      286,
      2938,
      3858,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is an instance of expected types before comparison"
  },
  {
    "line": 377,
    "text": "        raise NotImplementedError(f\"Please implement the 'get_metric_series' method\")",
    "annotation": "\ud83e\udde0 ML Signal: Custom equality logic for numeric types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      705,
      1136,
      62,
      4164,
      1173,
      62,
      25076,
      6,
      2446,
      4943
    ],
    "start_token": 1874,
    "end_token": 1903,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      10537,
      9156,
      329,
      35575,
      3858
    ],
    "label": "ml_signal",
    "reason": "Custom equality logic for numeric types"
  },
  {
    "line": 380,
    "text": "        \"\"\"get one metric with the format of SingleData",
    "annotation": "\ud83e\udde0 ML Signal: Custom equality logic for instances of the same class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      1136,
      530,
      18663,
      351,
      262,
      5794,
      286,
      14206,
      6601
    ],
    "start_token": 1903,
    "end_token": 1920,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      10537,
      9156,
      329,
      10245,
      286,
      262,
      976,
      1398
    ],
    "label": "ml_signal",
    "reason": "Custom equality logic for instances of the same class"
  },
  {
    "line": 383,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types to allow other comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 1920,
    "end_token": 1929,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858,
      284,
      1249,
      584,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types to allow other comparisons"
  },
  {
    "line": 382,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Check if 'other' is an instance of expected types before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 1929,
    "end_token": 1937,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      281,
      4554,
      286,
      2938,
      3858,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is an instance of expected types before comparison"
  },
  {
    "line": 384,
    "text": "        metric : str",
    "annotation": "\ud83e\udde0 ML Signal: Custom greater-than logic for numeric comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      18663,
      1058,
      965
    ],
    "start_token": 1937,
    "end_token": 1947,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      3744,
      12,
      14813,
      9156,
      329,
      35575,
      7208
    ],
    "label": "ml_signal",
    "reason": "Custom greater-than logic for numeric comparison"
  },
  {
    "line": 387,
    "text": "        Return",
    "annotation": "\ud83e\udde0 ML Signal: Custom greater-than logic for class instance comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8229
    ],
    "start_token": 1947,
    "end_token": 1955,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      3744,
      12,
      14813,
      9156,
      329,
      1398,
      4554,
      7208
    ],
    "label": "ml_signal",
    "reason": "Custom greater-than logic for class instance comparison"
  },
  {
    "line": 390,
    "text": "            one metric with the format of SingleData",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types to allow other comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      18663,
      351,
      262,
      5794,
      286,
      14206,
      6601
    ],
    "start_token": 1955,
    "end_token": 1974,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858,
      284,
      1249,
      584,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types to allow other comparisons"
  },
  {
    "line": 388,
    "text": "        ------",
    "annotation": "\u2705 Best Practice: Use of dunder method for operator overloading",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40103
    ],
    "start_token": 1974,
    "end_token": 1982,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      288,
      4625,
      2446,
      329,
      10088,
      625,
      25138
    ],
    "label": "best_practice",
    "reason": "Use of dunder method for operator overloading"
  },
  {
    "line": 390,
    "text": "            one metric with the format of SingleData",
    "annotation": "\u2705 Best Practice: Check type of 'other' before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      18663,
      351,
      262,
      5794,
      286,
      14206,
      6601
    ],
    "start_token": 1982,
    "end_token": 2001,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      2099,
      286,
      705,
      847,
      6,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check type of 'other' before comparison"
  },
  {
    "line": 392,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of self.__class__ for creating new instance",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2001,
    "end_token": 2001,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2116,
      13,
      834,
      4871,
      834,
      329,
      4441,
      649,
      4554
    ],
    "label": "best_practice",
    "reason": "Use of self.__class__ for creating new instance"
  },
  {
    "line": 394,
    "text": "",
    "annotation": "\u2705 Best Practice: Check type of 'other' before comparison",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2001,
    "end_token": 2001,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      2099,
      286,
      705,
      847,
      6,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check type of 'other' before comparison"
  },
  {
    "line": 396,
    "text": "    def sum_all_indicators(",
    "annotation": "\u2705 Best Practice: Use of self.__class__ for creating new instance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      2160,
      62,
      439,
      62,
      521,
      44549,
      7
    ],
    "start_token": 2001,
    "end_token": 2012,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2116,
      13,
      834,
      4871,
      834,
      329,
      4441,
      649,
      4554
    ],
    "label": "best_practice",
    "reason": "Use of self.__class__ for creating new instance"
  },
  {
    "line": 399,
    "text": "        metrics: Union[str, List[str]],",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      20731,
      25,
      4479,
      58,
      2536,
      11,
      7343,
      58,
      2536,
      60,
      4357
    ],
    "start_token": 2012,
    "end_token": 2030,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      3858
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported types"
  },
  {
    "line": 395,
    "text": "    @staticmethod",
    "annotation": "\u2705 Best Practice: Implementing __len__ allows objects to be used with len() function, enhancing usability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 2030,
    "end_token": 2036,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48282,
      278,
      11593,
      11925,
      834,
      3578,
      5563,
      284,
      307,
      973,
      351,
      18896,
      3419,
      2163,
      11,
      27496,
      42863,
      13
    ],
    "label": "best_practice",
    "reason": "Implementing __len__ allows objects to be used with len() function, enhancing usability."
  },
  {
    "line": 397,
    "text": "        order_indicator: BaseOrderIndicator,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of len() on an attribute suggests the attribute is a collection.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      62,
      521,
      26407,
      25,
      7308,
      18743,
      5497,
      26407,
      11
    ],
    "start_token": 2036,
    "end_token": 2053,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      18896,
      3419,
      319,
      281,
      11688,
      5644,
      262,
      11688,
      318,
      257,
      4947,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of len() on an attribute suggests the attribute is a collection."
  },
  {
    "line": 399,
    "text": "        metrics: Union[str, List[str]],",
    "annotation": "\u2705 Best Practice: Class docstring provides a brief description of the class purpose.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      20731,
      25,
      4479,
      58,
      2536,
      11,
      7343,
      58,
      2536,
      60,
      4357
    ],
    "start_token": 2053,
    "end_token": 2071,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      1398,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a brief description of the class purpose."
  },
  {
    "line": 399,
    "text": "        metrics: Union[str, List[str]],",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument (dictionary) can lead to unexpected behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      20731,
      25,
      4479,
      58,
      2536,
      11,
      7343,
      58,
      2536,
      60,
      4357
    ],
    "start_token": 2071,
    "end_token": 2089,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      357,
      67,
      14188,
      8,
      460,
      1085,
      284,
      10059,
      4069,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument (dictionary) can lead to unexpected behavior."
  },
  {
    "line": 401,
    "text": "    ) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Type checking and conversion based on input type.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      6045,
      25
    ],
    "start_token": 2089,
    "end_token": 2096,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      10627,
      290,
      11315,
      1912,
      319,
      5128,
      2099,
      13
    ],
    "label": "ml_signal",
    "reason": "Type checking and conversion based on input type."
  },
  {
    "line": 403,
    "text": "        and assign to the order_indicator(BaseOrderIndicator).",
    "annotation": "\ud83e\udde0 ML Signal: Handling different input types for initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      290,
      8333,
      284,
      262,
      1502,
      62,
      521,
      26407,
      7,
      14881,
      18743,
      5497,
      26407,
      737
    ],
    "start_token": 2096,
    "end_token": 2117,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      1180,
      5128,
      3858,
      329,
      37588,
      13
    ],
    "label": "ml_signal",
    "reason": "Handling different input types for initialization."
  },
  {
    "line": 407,
    "text": "        ----------",
    "annotation": "\ud83e\udde0 ML Signal: Error handling for invalid input types.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 2117,
    "end_token": 2126,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      13047,
      9041,
      329,
      12515,
      5128,
      3858,
      13
    ],
    "label": "ml_signal",
    "reason": "Error handling for invalid input types."
  },
  {
    "line": 406,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 2126,
    "end_token": 2134,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose"
  },
  {
    "line": 408,
    "text": "        order_indicator : BaseOrderIndicator",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self indicates this is a method in a class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      62,
      521,
      26407,
      1058,
      7308,
      18743,
      5497,
      26407
    ],
    "start_token": 2134,
    "end_token": 2150,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      9217,
      428,
      318,
      257,
      2446,
      287,
      257,
      1398
    ],
    "label": "ml_signal",
    "reason": "Usage of self indicates this is a method in a class"
  },
  {
    "line": 409,
    "text": "            the order indicator to assign.",
    "annotation": "\ud83e\udde0 ML Signal: Calling a method on an attribute suggests metric is an object with a sum method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      1502,
      16916,
      284,
      8333,
      13
    ],
    "start_token": 2150,
    "end_token": 2167,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      32677,
      257,
      2446,
      319,
      281,
      11688,
      5644,
      18663,
      318,
      281,
      2134,
      351,
      257,
      2160,
      2446
    ],
    "label": "ml_signal",
    "reason": "Calling a method on an attribute suggests metric is an object with a sum method"
  },
  {
    "line": 408,
    "text": "        order_indicator : BaseOrderIndicator",
    "annotation": "\ud83e\udde0 ML Signal: Method delegation pattern, useful for understanding class design and behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      62,
      521,
      26407,
      1058,
      7308,
      18743,
      5497,
      26407
    ],
    "start_token": 2167,
    "end_token": 2183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      22635,
      3912,
      11,
      4465,
      329,
      4547,
      1398,
      1486,
      290,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method delegation pattern, useful for understanding class design and behavior"
  },
  {
    "line": 410,
    "text": "        indicators : List[BaseOrderIndicator]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for NoneType or unexpected object if self.metric is not properly initialized",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      21337,
      1058,
      7343,
      58,
      14881,
      18743,
      5497,
      26407,
      60
    ],
    "start_token": 2183,
    "end_token": 2199,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6045,
      6030,
      393,
      10059,
      2134,
      611,
      2116,
      13,
      4164,
      1173,
      318,
      407,
      6105,
      23224
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for NoneType or unexpected object if self.metric is not properly initialized"
  },
  {
    "line": 410,
    "text": "        indicators : List[BaseOrderIndicator]",
    "annotation": "\ud83e\udde0 ML Signal: Method delegation pattern, where a method calls another method on an attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      21337,
      1058,
      7343,
      58,
      14881,
      18743,
      5497,
      26407,
      60
    ],
    "start_token": 2199,
    "end_token": 2215,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      22635,
      3912,
      11,
      810,
      257,
      2446,
      3848,
      1194,
      2446,
      319,
      281,
      11688
    ],
    "label": "ml_signal",
    "reason": "Method delegation pattern, where a method calls another method on an attribute"
  },
  {
    "line": 412,
    "text": "        metrics : Union[str, List[str]]",
    "annotation": "\ud83e\udde0 ML Signal: Returning the result of a method call on an attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      20731,
      1058,
      4479,
      58,
      2536,
      11,
      7343,
      58,
      2536,
      11907
    ],
    "start_token": 2215,
    "end_token": 2232,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      262,
      1255,
      286,
      257,
      2446,
      869,
      319,
      281,
      11688
    ],
    "label": "ml_signal",
    "reason": "Returning the result of a method call on an attribute"
  },
  {
    "line": 413,
    "text": "            all metrics needs to be sumed.",
    "annotation": "\u2705 Best Practice: Use of self.__class__ allows for correct subclassing behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      20731,
      2476,
      284,
      307,
      2160,
      276,
      13
    ],
    "start_token": 2232,
    "end_token": 2251,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2116,
      13,
      834,
      4871,
      834,
      3578,
      329,
      3376,
      47611,
      278,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Use of self.__class__ allows for correct subclassing behavior."
  },
  {
    "line": 416,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of a method to encapsulate access to the metric's empty property",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 2251,
    "end_token": 2259,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2446,
      284,
      32652,
      5039,
      1895,
      284,
      262,
      18663,
      338,
      6565,
      3119
    ],
    "label": "best_practice",
    "reason": "Use of a method to encapsulate access to the metric's empty property"
  },
  {
    "line": 418,
    "text": "        raise NotImplementedError(f\"Please implement the 'sum_all_indicators' method\")",
    "annotation": "\u2705 Best Practice: Use of self indicates this is a method in a class, which is a good practice for organizing code.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      5492,
      3494,
      262,
      705,
      16345,
      62,
      439,
      62,
      521,
      44549,
      6,
      2446,
      4943
    ],
    "start_token": 2259,
    "end_token": 2288,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2116,
      9217,
      428,
      318,
      257,
      2446,
      287,
      257,
      1398,
      11,
      543,
      318,
      257,
      922,
      3357,
      329,
      16924,
      2438,
      13
    ],
    "label": "best_practice",
    "reason": "Use of self indicates this is a method in a class, which is a good practice for organizing code."
  },
  {
    "line": 420,
    "text": "    def to_series(self) -> Dict[Text, pd.Series]:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing an attribute of an object, which is a common pattern in object-oriented programming.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      284,
      62,
      25076,
      7,
      944,
      8,
      4613,
      360,
      713,
      58,
      8206,
      11,
      279,
      67,
      13,
      27996,
      5974
    ],
    "start_token": 2288,
    "end_token": 2309,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      281,
      11688,
      286,
      281,
      2134,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      2134,
      12,
      17107,
      8300,
      13
    ],
    "label": "ml_signal",
    "reason": "Accessing an attribute of an object, which is a common pattern in object-oriented programming."
  },
  {
    "line": 421,
    "text": "        \"\"\"return the metrics as pandas series",
    "annotation": "\u2705 Best Practice: Returning a list from a method is a clear and explicit way to provide data to the caller.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      7783,
      262,
      20731,
      355,
      19798,
      292,
      2168
    ],
    "start_token": 2309,
    "end_token": 2324,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      1351,
      422,
      257,
      2446,
      318,
      257,
      1598,
      290,
      7952,
      835,
      284,
      2148,
      1366,
      284,
      262,
      24955,
      13
    ],
    "label": "best_practice",
    "reason": "Returning a list from a method is a clear and explicit way to provide data to the caller."
  },
  {
    "line": 420,
    "text": "    def to_series(self) -> Dict[Text, pd.Series]:",
    "annotation": "\u2705 Best Practice: Type hinting for parameters and return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      284,
      62,
      25076,
      7,
      944,
      8,
      4613,
      360,
      713,
      58,
      8206,
      11,
      279,
      67,
      13,
      27996,
      5974
    ],
    "start_token": 2324,
    "end_token": 2345,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for parameters and return type improves code readability and maintainability"
  },
  {
    "line": 422,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of type casting indicates a pattern where runtime type checks are necessary",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2345,
    "end_token": 2345,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2099,
      13092,
      9217,
      257,
      3912,
      810,
      19124,
      2099,
      8794,
      389,
      3306
    ],
    "label": "ml_signal",
    "reason": "Use of type casting indicates a pattern where runtime type checks are necessary"
  },
  {
    "line": 424,
    "text": "                SH600068    NaN",
    "annotation": "\u2705 Best Practice: Using self.__class__ allows for better subclassing support",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6006,
      43434,
      3104,
      220,
      220,
      220,
      11013,
      45
    ],
    "start_token": 2345,
    "end_token": 2368,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2116,
      13,
      834,
      4871,
      834,
      3578,
      329,
      1365,
      47611,
      278,
      1104
    ],
    "label": "best_practice",
    "reason": "Using self.__class__ allows for better subclassing support"
  },
  {
    "line": 423,
    "text": "        for example: { \"ffr\":",
    "annotation": "\u2705 Best Practice: Type hinting for the method return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1672,
      25,
      1391,
      366,
      487,
      81,
      1298
    ],
    "start_token": 2368,
    "end_token": 2383,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      2446,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the method return type improves code readability and maintainability"
  },
  {
    "line": 425,
    "text": "                SH600079    1.0",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self.__class__ indicates a pattern of returning an instance of the same class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6006,
      43434,
      3720,
      220,
      220,
      220,
      352,
      13,
      15
    ],
    "start_token": 2383,
    "end_token": 2407,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      13,
      834,
      4871,
      834,
      9217,
      257,
      3912,
      286,
      8024,
      281,
      4554,
      286,
      262,
      976,
      1398
    ],
    "label": "ml_signal",
    "reason": "Usage of self.__class__ indicates a pattern of returning an instance of the same class"
  },
  {
    "line": 426,
    "text": "                SH600266    NaN",
    "annotation": "\ud83e\udde0 ML Signal: Usage of the replace method on self.metric suggests a pattern of data transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6006,
      8054,
      25540,
      220,
      220,
      220,
      11013,
      45
    ],
    "start_token": 2407,
    "end_token": 2430,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      262,
      6330,
      2446,
      319,
      2116,
      13,
      4164,
      1173,
      5644,
      257,
      3912,
      286,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Usage of the replace method on self.metric suggests a pattern of data transformation"
  },
  {
    "line": 425,
    "text": "                SH600079    1.0",
    "annotation": "\u2705 Best Practice: Type hinting for the 'func' parameter improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6006,
      43434,
      3720,
      220,
      220,
      220,
      352,
      13,
      15
    ],
    "start_token": 2430,
    "end_token": 2454,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      705,
      20786,
      6,
      11507,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for the 'func' parameter improves code readability and maintainability."
  },
  {
    "line": 427,
    "text": "                           ...",
    "annotation": "\ud83e\udde0 ML Signal: Usage of class method and returning an instance of the class.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2644
    ],
    "start_token": 2454,
    "end_token": 2481,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      1398,
      2446,
      290,
      8024,
      281,
      4554,
      286,
      262,
      1398,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of class method and returning an instance of the class."
  },
  {
    "line": 428,
    "text": "                SZ300692    NaN",
    "annotation": "\u2705 Best Practice: Using 'self.__class__' allows for correct subclassing behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      311,
      57,
      6200,
      46589,
      220,
      220,
      220,
      11013,
      45
    ],
    "start_token": 2481,
    "end_token": 2505,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      705,
      944,
      13,
      834,
      4871,
      834,
      6,
      3578,
      329,
      3376,
      47611,
      278,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Using 'self.__class__' allows for correct subclassing behavior."
  },
  {
    "line": 427,
    "text": "                           ...",
    "annotation": "\u2705 Best Practice: Type hint for 'index' is too generic; consider using a more specific type if possible",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2644
    ],
    "start_token": 2505,
    "end_token": 2532,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      329,
      705,
      9630,
      6,
      318,
      1165,
      14276,
      26,
      2074,
      1262,
      257,
      517,
      2176,
      2099,
      611,
      1744
    ],
    "label": "best_practice",
    "reason": "Type hint for 'index' is too generic; consider using a more specific type if possible"
  },
  {
    "line": 429,
    "text": "                SZ300719    NaN,",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining with 'self.__class__' indicates a pattern of returning a new instance of the same class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      311,
      57,
      6200,
      22,
      1129,
      220,
      220,
      220,
      11013,
      45,
      11
    ],
    "start_token": 2532,
    "end_token": 2558,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      351,
      705,
      944,
      13,
      834,
      4871,
      834,
      6,
      9217,
      257,
      3912,
      286,
      8024,
      257,
      649,
      4554,
      286,
      262,
      976,
      1398
    ],
    "label": "ml_signal",
    "reason": "Method chaining with 'self.__class__' indicates a pattern of returning a new instance of the same class"
  },
  {
    "line": 430,
    "text": "                ...",
    "annotation": "\u2705 Best Practice: Using 'self.__class__' allows for better subclassing support",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2644
    ],
    "start_token": 2558,
    "end_token": 2574,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      705,
      944,
      13,
      834,
      4871,
      834,
      6,
      3578,
      329,
      1365,
      47611,
      278,
      1104
    ],
    "label": "best_practice",
    "reason": "Using 'self.__class__' allows for better subclassing support"
  },
  {
    "line": 429,
    "text": "                SZ300719    NaN,",
    "annotation": "\u2705 Best Practice: Use __repr__ to provide an unambiguous string representation of the object",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      311,
      57,
      6200,
      22,
      1129,
      220,
      220,
      220,
      11013,
      45,
      11
    ],
    "start_token": 2574,
    "end_token": 2600,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      11593,
      260,
      1050,
      834,
      284,
      2148,
      281,
      42053,
      29709,
      4731,
      10552,
      286,
      262,
      2134
    ],
    "label": "best_practice",
    "reason": "Use __repr__ to provide an unambiguous string representation of the object"
  },
  {
    "line": 431,
    "text": "         }",
    "annotation": "\ud83e\udde0 ML Signal: Usage of repr() to return a string representation of an attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 2600,
    "end_token": 2609,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      41575,
      3419,
      284,
      1441,
      257,
      4731,
      10552,
      286,
      281,
      11688
    ],
    "label": "ml_signal",
    "reason": "Usage of repr() to return a string representation of an attribute"
  },
  {
    "line": 431,
    "text": "         }",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear explanation of the data structure and its components",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 2609,
    "end_token": 2618,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1366,
      4645,
      290,
      663,
      6805
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear explanation of the data structure and its components"
  },
  {
    "line": 438,
    "text": "        self.metric = metric",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization of the base class.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4164,
      1173,
      796,
      18663
    ],
    "start_token": 2618,
    "end_token": 2631,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      286,
      262,
      2779,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization of the base class."
  },
  {
    "line": 440,
    "text": "    def __add__(self, other):",
    "annotation": "\u2705 Best Practice: Type hinting for self.data improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      2860,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 2631,
    "end_token": 2643,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2116,
      13,
      7890,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for self.data improves code readability and maintainability."
  },
  {
    "line": 440,
    "text": "    def __add__(self, other):",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      2860,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 2643,
    "end_token": 2655,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 442,
    "text": "            return self.__class__(self.metric + other)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of Pandas and custom classes can indicate data manipulation patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1343,
      584,
      8
    ],
    "start_token": 2655,
    "end_token": 2680,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      16492,
      292,
      290,
      2183,
      6097,
      460,
      7603,
      1366,
      17512,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of Pandas and custom classes can indicate data manipulation patterns"
  },
  {
    "line": 443,
    "text": "        elif isinstance(other, self.__class__):",
    "annotation": "\ud83e\udde0 ML Signal: Function uses a conditional check to determine behavior based on input",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      847,
      11,
      2116,
      13,
      834,
      4871,
      834,
      2599
    ],
    "start_token": 2680,
    "end_token": 2700,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3544,
      257,
      26340,
      2198,
      284,
      5004,
      4069,
      1912,
      319,
      5128
    ],
    "label": "ml_signal",
    "reason": "Function uses a conditional check to determine behavior based on input"
  },
  {
    "line": 444,
    "text": "            return self.__class__(self.metric + other.metric)",
    "annotation": "\ud83e\udde0 ML Signal: Accessing dictionary with a key to retrieve data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1343,
      584,
      13,
      4164,
      1173,
      8
    ],
    "start_token": 2700,
    "end_token": 2728,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      22155,
      351,
      257,
      1994,
      284,
      19818,
      1366
    ],
    "label": "ml_signal",
    "reason": "Accessing dictionary with a key to retrieve data"
  },
  {
    "line": 448,
    "text": "    def __sub__(self, other):",
    "annotation": "\u2705 Best Practice: Explicitly handling the case where the metric is not found",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      7266,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 2728,
    "end_token": 2740,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      9041,
      262,
      1339,
      810,
      262,
      18663,
      318,
      407,
      1043
    ],
    "label": "best_practice",
    "reason": "Explicitly handling the case where the metric is not found"
  },
  {
    "line": 447,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hint should include all possible return types, use Tuple for multiple types",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2740,
    "end_token": 2740,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      815,
      2291,
      477,
      1744,
      1441,
      3858,
      11,
      779,
      309,
      29291,
      329,
      3294,
      3858
    ],
    "label": "best_practice",
    "reason": "Type hint should include all possible return types, use Tuple for multiple types"
  },
  {
    "line": 449,
    "text": "        if isinstance(other, (int, float)):",
    "annotation": "\ud83e\udde0 ML Signal: Checking if a key exists in a dictionary",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      357,
      600,
      11,
      12178,
      8,
      2599
    ],
    "start_token": 2740,
    "end_token": 2759,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      257,
      1994,
      7160,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Checking if a key exists in a dictionary"
  },
  {
    "line": 451,
    "text": "        elif isinstance(other, self.__class__):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential AttributeError if 'metric' attribute does not exist",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      847,
      11,
      2116,
      13,
      834,
      4871,
      834,
      2599
    ],
    "start_token": 2759,
    "end_token": 2779,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      3460,
      4163,
      12331,
      611,
      705,
      4164,
      1173,
      6,
      11688,
      857,
      407,
      2152
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential AttributeError if 'metric' attribute does not exist"
  },
  {
    "line": 453,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning an empty Series without specifying dtype can lead to warnings",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 2779,
    "end_token": 2788,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      281,
      6565,
      7171,
      1231,
      31577,
      288,
      4906,
      460,
      1085,
      284,
      14601
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning an empty Series without specifying dtype can lead to warnings"
  },
  {
    "line": 453,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dictionary comprehension to transform data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 2788,
    "end_token": 2797,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      22155,
      35915,
      284,
      6121,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of dictionary comprehension to transform data"
  },
  {
    "line": 455,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hints improve code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2797,
    "end_token": 2797,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hints improve code readability and maintainability"
  },
  {
    "line": 462,
    "text": "            return NotImplemented",
    "annotation": "\u2705 Best Practice: Checking and converting types for consistent processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1892,
      3546,
      1154,
      12061
    ],
    "start_token": 2797,
    "end_token": 2813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      290,
      23202,
      3858,
      329,
      6414,
      7587
    ],
    "label": "best_practice",
    "reason": "Checking and converting types for consistent processing"
  },
  {
    "line": 466,
    "text": "            return self.__class__(self.metric * other)",
    "annotation": "\u2705 Best Practice: Initializing variables before use",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1635,
      584,
      8
    ],
    "start_token": 2813,
    "end_token": 2838,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      9633,
      878,
      779
    ],
    "label": "best_practice",
    "reason": "Initializing variables before use"
  },
  {
    "line": 469,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'metric' is not in 'indicator.data'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 2838,
    "end_token": 2847,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      4164,
      1173,
      6,
      318,
      407,
      287,
      705,
      521,
      26407,
      13,
      7890,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'metric' is not in 'indicator.data'"
  },
  {
    "line": 471,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage pattern of assigning computed metrics",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2847,
    "end_token": 2847,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      3912,
      286,
      38875,
      29231,
      20731
    ],
    "label": "ml_signal",
    "reason": "Usage pattern of assigning computed metrics"
  },
  {
    "line": 468,
    "text": "            return self.__class__(self.metric * other.metric)",
    "annotation": "\u2705 Best Practice: Implementing __repr__ for better debugging and logging",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1635,
      584,
      13,
      4164,
      1173,
      8
    ],
    "start_token": 2847,
    "end_token": 2875,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48282,
      278,
      11593,
      260,
      1050,
      834,
      329,
      1365,
      28769,
      290,
      18931
    ],
    "label": "best_practice",
    "reason": "Implementing __repr__ for better debugging and logging"
  },
  {
    "line": 470,
    "text": "            return NotImplemented",
    "annotation": "\ud83e\udde0 ML Signal: Usage of __repr__ to return a string representation of an object",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1892,
      3546,
      1154,
      12061
    ],
    "start_token": 2875,
    "end_token": 2891,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      11593,
      260,
      1050,
      834,
      284,
      1441,
      257,
      4731,
      10552,
      286,
      281,
      2134
    ],
    "label": "ml_signal",
    "reason": "Usage of __repr__ to return a string representation of an object"
  },
  {
    "line": 471,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the data structure and its purpose.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2891,
    "end_token": 2891,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1366,
      4645,
      290,
      663,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the data structure and its purpose."
  },
  {
    "line": 477,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 2891,
    "end_token": 2900,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization."
  },
  {
    "line": 479,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for self.data improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2900,
    "end_token": 2900,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2116,
      13,
      7890,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for self.data improves code readability and maintainability."
  },
  {
    "line": 479,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method signature with specific parameter types and return type",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2900,
    "end_token": 2900,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      351,
      2176,
      11507,
      3858,
      290,
      1441,
      2099
    ],
    "label": "ml_signal",
    "reason": "Method signature with specific parameter types and return type"
  },
  {
    "line": 481,
    "text": "        if isinstance(other, (int, float)):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dictionary to store data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      357,
      600,
      11,
      12178,
      8,
      2599
    ],
    "start_token": 2900,
    "end_token": 2919,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      22155,
      284,
      3650,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of dictionary to store data"
  },
  {
    "line": 482,
    "text": "            return self.__class__(self.metric == other)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if 'metric' contains sensitive data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      6624,
      584,
      8
    ],
    "start_token": 2919,
    "end_token": 2944,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      705,
      4164,
      1173,
      6,
      4909,
      8564,
      1366
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if 'metric' contains sensitive data"
  },
  {
    "line": 483,
    "text": "        elif isinstance(other, self.__class__):",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      847,
      11,
      2116,
      13,
      834,
      4871,
      834,
      2599
    ],
    "start_token": 2944,
    "end_token": 2964,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names for clarity"
  },
  {
    "line": 481,
    "text": "        if isinstance(other, (int, float)):",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the purpose and usage of the function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      357,
      600,
      11,
      12178,
      8,
      2599
    ],
    "start_token": 2964,
    "end_token": 2983,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the purpose and usage of the function"
  },
  {
    "line": 483,
    "text": "        elif isinstance(other, self.__class__):",
    "annotation": "\u2705 Best Practice: Check for key existence using 'in' for better readability and performance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      847,
      11,
      2116,
      13,
      834,
      4871,
      834,
      2599
    ],
    "start_token": 2983,
    "end_token": 3003,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      1994,
      6224,
      1262,
      705,
      259,
      6,
      329,
      1365,
      1100,
      1799,
      290,
      2854
    ],
    "label": "best_practice",
    "reason": "Check for key existence using 'in' for better readability and performance"
  },
  {
    "line": 485,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing dictionary values using a key",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 3003,
    "end_token": 3012,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      22155,
      3815,
      1262,
      257,
      1994
    ],
    "label": "ml_signal",
    "reason": "Accessing dictionary values using a key"
  },
  {
    "line": 488,
    "text": "    def __gt__(self, other):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential issue if idd.SingleData() is not properly initialized or handled",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      13655,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 3012,
    "end_token": 3024,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2071,
      611,
      220,
      1638,
      13,
      28008,
      6601,
      3419,
      318,
      407,
      6105,
      23224,
      393,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential issue if idd.SingleData() is not properly initialized or handled"
  },
  {
    "line": 486,
    "text": "            return NotImplemented",
    "annotation": "\u2705 Best Practice: Include type hint for return value as List or Tuple for Union",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1892,
      3546,
      1154,
      12061
    ],
    "start_token": 3024,
    "end_token": 3040,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      9254,
      329,
      1441,
      1988,
      355,
      7343,
      393,
      309,
      29291,
      329,
      4479
    ],
    "label": "best_practice",
    "reason": "Include type hint for return value as List or Tuple for Union"
  },
  {
    "line": 488,
    "text": "    def __gt__(self, other):",
    "annotation": "\ud83e\udde0 ML Signal: Accessing a dictionary with a dynamic key",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      13655,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 3040,
    "end_token": 3052,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      257,
      22155,
      351,
      257,
      8925,
      1994
    ],
    "label": "ml_signal",
    "reason": "Accessing a dictionary with a dynamic key"
  },
  {
    "line": 489,
    "text": "        if isinstance(other, (int, float)):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'metric' is not in 'self.data'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      357,
      600,
      11,
      12178,
      8,
      2599
    ],
    "start_token": 3052,
    "end_token": 3071,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      4164,
      1173,
      6,
      318,
      407,
      287,
      705,
      944,
      13,
      7890,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'metric' is not in 'self.data'"
  },
  {
    "line": 489,
    "text": "        if isinstance(other, (int, float)):",
    "annotation": "\u2705 Best Practice: Initialize an empty dictionary before populating it in a loop",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      357,
      600,
      11,
      12178,
      8,
      2599
    ],
    "start_token": 3071,
    "end_token": 3090,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      281,
      6565,
      22155,
      878,
      1461,
      8306,
      340,
      287,
      257,
      9052
    ],
    "label": "best_practice",
    "reason": "Initialize an empty dictionary before populating it in a loop"
  },
  {
    "line": 491,
    "text": "        elif isinstance(other, self.__class__):",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over self.data to process each metric",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      847,
      11,
      2116,
      13,
      834,
      4871,
      834,
      2599
    ],
    "start_token": 3090,
    "end_token": 3110,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      2116,
      13,
      7890,
      284,
      1429,
      1123,
      18663
    ],
    "label": "ml_signal",
    "reason": "Iterating over self.data to process each metric"
  },
  {
    "line": 492,
    "text": "            return self.__class__(self.metric > other.metric)",
    "annotation": "\ud83e\udde0 ML Signal: Using a method to transform data into a series",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1875,
      584,
      13,
      4164,
      1173,
      8
    ],
    "start_token": 3110,
    "end_token": 3138,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      257,
      2446,
      284,
      6121,
      1366,
      656,
      257,
      2168
    ],
    "label": "ml_signal",
    "reason": "Using a method to transform data into a series"
  },
  {
    "line": 494,
    "text": "            return NotImplemented",
    "annotation": "\u2705 Best Practice: Returning a dictionary of processed data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1892,
      3546,
      1154,
      12061
    ],
    "start_token": 3138,
    "end_token": 3154,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      22155,
      286,
      13686,
      1366
    ],
    "label": "best_practice",
    "reason": "Returning a dictionary of processed data"
  },
  {
    "line": 500,
    "text": "            return self.__class__(self.metric < other.metric)",
    "annotation": "\u2705 Best Practice: Initialize an empty set for stock_set to collect unique stock indices",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      834,
      4871,
      834,
      7,
      944,
      13,
      4164,
      1173,
      1279,
      584,
      13,
      4164,
      1173,
      8
    ],
    "start_token": 3154,
    "end_token": 3182,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      281,
      6565,
      900,
      329,
      4283,
      62,
      2617,
      284,
      2824,
      3748,
      4283,
      36525
    ],
    "label": "best_practice",
    "reason": "Initialize an empty set for stock_set to collect unique stock indices"
  },
  {
    "line": 503,
    "text": "",
    "annotation": "\u2705 Best Practice: Use set union to combine indices from each indicator",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3182,
    "end_token": 3182,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      900,
      6441,
      284,
      12082,
      36525,
      422,
      1123,
      16916
    ],
    "label": "best_practice",
    "reason": "Use set union to combine indices from each indicator"
  },
  {
    "line": 505,
    "text": "        return len(self.metric)",
    "annotation": "\u2705 Best Practice: Convert the set to a sorted list for consistent ordering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      18896,
      7,
      944,
      13,
      4164,
      1173,
      8
    ],
    "start_token": 3182,
    "end_token": 3197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      262,
      900,
      284,
      257,
      23243,
      1351,
      329,
      6414,
      16216
    ],
    "label": "best_practice",
    "reason": "Convert the set to a sorted list for consistent ordering"
  },
  {
    "line": 507,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensure metrics is always a list for consistent processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3197,
    "end_token": 3197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      20731,
      318,
      1464,
      257,
      1351,
      329,
      6414,
      7587
    ],
    "label": "best_practice",
    "reason": "Ensure metrics is always a list for consistent processing"
  },
  {
    "line": 512,
    "text": "        if isinstance(metric, dict):",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over metrics to sum data could indicate a pattern of data aggregation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      4164,
      1173,
      11,
      8633,
      2599
    ],
    "start_token": 3197,
    "end_token": 3213,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      20731,
      284,
      2160,
      1366,
      714,
      7603,
      257,
      3912,
      286,
      1366,
      46500
    ],
    "label": "ml_signal",
    "reason": "Iterating over metrics to sum data could indicate a pattern of data aggregation"
  },
  {
    "line": 512,
    "text": "        if isinstance(metric, dict):",
    "annotation": "\ud83e\udde0 ML Signal: Using a fill_value parameter suggests handling missing data, which is a common pattern in data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      4164,
      1173,
      11,
      8633,
      2599
    ],
    "start_token": 3213,
    "end_token": 3229,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      257,
      6070,
      62,
      8367,
      11507,
      5644,
      9041,
      4814,
      1366,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Using a fill_value parameter suggests handling missing data, which is a common pattern in data processing"
  },
  {
    "line": 512,
    "text": "        if isinstance(metric, dict):",
    "annotation": "\u2705 Best Practice: Implementing __repr__ for a class improves debugging and logging by providing a clear string representation.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      4164,
      1173,
      11,
      8633,
      2599
    ],
    "start_token": 3229,
    "end_token": 3245,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48282,
      278,
      11593,
      260,
      1050,
      834,
      329,
      257,
      1398,
      19575,
      28769,
      290,
      18931,
      416,
      4955,
      257,
      1598,
      4731,
      10552,
      13
    ],
    "label": "best_practice",
    "reason": "Implementing __repr__ for a class improves debugging and logging by providing a clear string representation."
  },
  {
    "line": 513,
    "text": "            self.metric = pd.Series(metric)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of __repr__ can indicate the class is intended for debugging or logging purposes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      4164,
      1173,
      796,
      279,
      67,
      13,
      27996,
      7,
      4164,
      1173,
      8
    ],
    "start_token": 3245,
    "end_token": 3269,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      11593,
      260,
      1050,
      834,
      460,
      7603,
      262,
      1398,
      318,
      5292,
      329,
      28769,
      393,
      18931,
      4959,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of __repr__ can indicate the class is intended for debugging or logging purposes."
  }
]