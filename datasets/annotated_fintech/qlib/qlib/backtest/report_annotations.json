[
  {
    "line": 4,
    "text": "from __future__ import annotations",
    "annotation": "\u2705 Best Practice: Grouping imports into standard, third-party, and local can improve readability.",
    "confidence": 1.0,
    "tokens": [
      6738,
      11593,
      37443,
      834,
      1330,
      37647
    ],
    "start_token": 0,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      656,
      3210,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      460,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports into standard, third-party, and local can improve readability."
  },
  {
    "line": 8,
    "text": "from typing import Any, Dict, List, Optional, Text, Tuple, Type, Union, cast",
    "annotation": "\u2705 Best Practice: Importing specific modules or functions can help avoid namespace pollution.",
    "confidence": 0.5,
    "tokens": [
      6738,
      19720,
      1330,
      4377,
      11,
      360,
      713,
      11,
      7343,
      11,
      32233,
      11,
      8255,
      11,
      309,
      29291,
      11,
      5994,
      11,
      4479,
      11,
      3350
    ],
    "start_token": 6,
    "end_token": 28,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      13103,
      393,
      5499,
      460,
      1037,
      3368,
      25745,
      12231,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific modules or functions can help avoid namespace pollution."
  },
  {
    "line": 29,
    "text": "        daily portfolio metrics of the account",
    "annotation": "\ud83e\udde0 ML Signal: Class definition for financial metrics, useful for ML models in finance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4445,
      15320,
      20731,
      286,
      262,
      1848
    ],
    "start_token": 28,
    "end_token": 41,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      6770,
      329,
      3176,
      20731,
      11,
      4465,
      329,
      10373,
      4981,
      287,
      9604
    ],
    "label": "ml_signal",
    "reason": "Class definition for financial metrics, useful for ML models in finance"
  },
  {
    "line": 30,
    "text": "        contain those followings: return, cost, turnover, account, cash, bench, value",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the class purpose and implementation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3994,
      883,
      1061,
      654,
      25,
      1441,
      11,
      1575,
      11,
      25079,
      11,
      1848,
      11,
      5003,
      11,
      7624,
      11,
      1988
    ],
    "start_token": 41,
    "end_token": 66,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      4007,
      290,
      7822
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the class purpose and implementation"
  },
  {
    "line": 30,
    "text": "        contain those followings: return, cost, turnover, account, cash, bench, value",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument (dict) can lead to unexpected behavior if modified.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3994,
      883,
      1061,
      654,
      25,
      1441,
      11,
      1575,
      11,
      25079,
      11,
      1848,
      11,
      5003,
      11,
      7624,
      11,
      1988
    ],
    "start_token": 66,
    "end_token": 91,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      357,
      11600,
      8,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      9518,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument (dict) can lead to unexpected behavior if modified."
  },
  {
    "line": 61,
    "text": "                            2017-01-10   -0.003350",
    "annotation": "\u2705 Best Practice: Initialize instance variables in a separate method for better organization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2177,
      12,
      486,
      12,
      940,
      220,
      220,
      532,
      15,
      13,
      405,
      2091,
      1120
    ],
    "start_token": 91,
    "end_token": 131,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      4554,
      9633,
      287,
      257,
      4553,
      2446,
      329,
      1365,
      4009,
      13
    ],
    "label": "best_practice",
    "reason": "Initialize instance variables in a separate method for better organization."
  },
  {
    "line": 63,
    "text": "                    'bench'.",
    "annotation": "\ud83e\udde0 ML Signal: Method call with parameters indicating configuration or setup behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      705,
      26968,
      4458
    ],
    "start_token": 131,
    "end_token": 153,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      10007,
      12739,
      8398,
      393,
      9058,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call with parameters indicating configuration or setup behavior."
  },
  {
    "line": 63,
    "text": "                    'bench'.",
    "annotation": "\u2705 Best Practice: Use of type annotations for better code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      705,
      26968,
      4458
    ],
    "start_token": 153,
    "end_token": 175,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      37647,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type annotations for better code readability and maintainability"
  },
  {
    "line": 73,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of Optional type hint for variables that can be None",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 175,
    "end_token": 183,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      32233,
      2099,
      9254,
      329,
      9633,
      326,
      460,
      307,
      6045
    ],
    "label": "best_practice",
    "reason": "Use of Optional type hint for variables that can be None"
  },
  {
    "line": 74,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 183,
    "end_token": 183,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 77,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method call with instance variables and parameters, useful for understanding object state changes.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 183,
    "end_token": 183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      4554,
      9633,
      290,
      10007,
      11,
      4465,
      329,
      4547,
      2134,
      1181,
      2458,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call with instance variables and parameters, useful for understanding object state changes."
  },
  {
    "line": 79,
    "text": "        self.accounts: dict = OrderedDict()  # account position value for each trade time",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23317,
      82,
      25,
      8633,
      796,
      14230,
      1068,
      35,
      713,
      3419,
      220,
      1303,
      1848,
      2292,
      1988,
      329,
      1123,
      3292,
      640
    ],
    "start_token": 183,
    "end_token": 211,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 83,
    "text": "        self.total_costs: dict = OrderedDict()  # total trade cost for each trade time",
    "annotation": "\ud83e\udde0 ML Signal: Use of default values in dictionary access patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23350,
      62,
      15805,
      82,
      25,
      8633,
      796,
      14230,
      1068,
      35,
      713,
      3419,
      220,
      1303,
      2472,
      3292,
      1575,
      329,
      1123,
      3292,
      640
    ],
    "start_token": 211,
    "end_token": 241,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      3815,
      287,
      22155,
      1895,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of default values in dictionary access patterns."
  },
  {
    "line": 86,
    "text": "        self.cashes: dict = OrderedDict()",
    "annotation": "\ud83e\udde0 ML Signal: Type checking pattern for handling different data types.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      66,
      7465,
      25,
      8633,
      796,
      14230,
      1068,
      35,
      713,
      3419
    ],
    "start_token": 241,
    "end_token": 260,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      10627,
      3912,
      329,
      9041,
      1180,
      1366,
      3858,
      13
    ],
    "label": "ml_signal",
    "reason": "Type checking pattern for handling different data types."
  },
  {
    "line": 91,
    "text": "        if freq is not None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of default values in dictionary access patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2030,
      80,
      318,
      407,
      6045,
      25
    ],
    "start_token": 260,
    "end_token": 274,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      3815,
      287,
      22155,
      1895,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of default values in dictionary access patterns."
  },
  {
    "line": 95,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError without additional context.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 274,
    "end_token": 274,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      1231,
      3224,
      4732,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError without additional context."
  },
  {
    "line": 97,
    "text": "    def _cal_benchmark(benchmark_config: Optional[dict], freq: str) -> Optional[pd.Series]:",
    "annotation": "\ud83e\udde0 ML Signal: Type checking pattern for handling different data types.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      9948,
      62,
      26968,
      4102,
      7,
      26968,
      4102,
      62,
      11250,
      25,
      32233,
      58,
      11600,
      4357,
      2030,
      80,
      25,
      965,
      8,
      4613,
      32233,
      58,
      30094,
      13,
      27996,
      5974
    ],
    "start_token": 274,
    "end_token": 305,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      10627,
      3912,
      329,
      9041,
      1180,
      1366,
      3858,
      13
    ],
    "label": "ml_signal",
    "reason": "Type checking pattern for handling different data types."
  },
  {
    "line": 100,
    "text": "        benchmark = benchmark_config.get(\"benchmark\", CSI300_BENCH)",
    "annotation": "\ud83e\udde0 ML Signal: Function call with multiple parameters, indicating complex data processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      18335,
      796,
      18335,
      62,
      11250,
      13,
      1136,
      7203,
      26968,
      4102,
      1600,
      49911,
      6200,
      62,
      33,
      1677,
      3398,
      8
    ],
    "start_token": 305,
    "end_token": 330,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      3294,
      10007,
      11,
      12739,
      3716,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Function call with multiple parameters, indicating complex data processing."
  },
  {
    "line": 102,
    "text": "            return None",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic ValueError with user-provided data.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 330,
    "end_token": 343,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      11052,
      12331,
      351,
      2836,
      12,
      41279,
      1366,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic ValueError with user-provided data."
  },
  {
    "line": 102,
    "text": "            return None",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas groupby and aggregation functions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 343,
    "end_token": 356,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      1448,
      1525,
      290,
      46500,
      5499,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of pandas groupby and aggregation functions."
  },
  {
    "line": 108,
    "text": "            end_time = benchmark_config.get(\"end_time\", None)",
    "annotation": "\u2705 Best Practice: Check for None to avoid AttributeError when accessing properties",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      2435,
      796,
      18335,
      62,
      11250,
      13,
      1136,
      7203,
      437,
      62,
      2435,
      1600,
      6045,
      8
    ],
    "start_token": 356,
    "end_token": 383,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6045,
      284,
      3368,
      3460,
      4163,
      12331,
      618,
      22534,
      6608
    ],
    "label": "best_practice",
    "reason": "Check for None to avoid AttributeError when accessing properties"
  },
  {
    "line": 110,
    "text": "            if freq is None:",
    "annotation": "\u2705 Best Practice: Function definition should be at the top level, not indented, for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2030,
      80,
      318,
      6045,
      25
    ],
    "start_token": 383,
    "end_token": 400,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15553,
      6770,
      815,
      307,
      379,
      262,
      1353,
      1241,
      11,
      407,
      773,
      4714,
      11,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Function definition should be at the top level, not indented, for better readability and maintainability."
  },
  {
    "line": 112,
    "text": "            _codes = benchmark if isinstance(benchmark, (list, dict)) else [benchmark]",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      40148,
      796,
      18335,
      611,
      318,
      39098,
      7,
      26968,
      4102,
      11,
      357,
      4868,
      11,
      8633,
      4008,
      2073,
      685,
      26968,
      4102,
      60
    ],
    "start_token": 400,
    "end_token": 432,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 115,
    "text": "            if len(_temp_result) == 0:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a custom function as a method parameter indicates a higher-order function pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      28264,
      29510,
      62,
      20274,
      8,
      6624,
      657,
      25
    ],
    "start_token": 432,
    "end_token": 453,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2183,
      2163,
      355,
      257,
      2446,
      11507,
      9217,
      257,
      2440,
      12,
      2875,
      2163,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a custom function as a method parameter indicates a higher-order function pattern."
  },
  {
    "line": 118,
    "text": "                _temp_result.groupby(level=\"datetime\", group_keys=False)[_temp_result.columns.tolist()[0]]",
    "annotation": "\u2705 Best Practice: Use of a conditional expression for concise code.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      29510,
      62,
      20274,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      19608,
      8079,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      8,
      29795,
      29510,
      62,
      20274,
      13,
      28665,
      82,
      13,
      83,
      349,
      396,
      3419,
      58,
      15,
      11907
    ],
    "start_token": 453,
    "end_token": 502,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      26340,
      5408,
      329,
      35327,
      2438,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a conditional expression for concise code."
  },
  {
    "line": 114,
    "text": "            _temp_result, _ = get_higher_eq_freq_feature(_codes, fields, start_time, end_time, freq=freq)",
    "annotation": "\ud83e\udde0 ML Signal: Method to check if a collection is empty",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      29510,
      62,
      20274,
      11,
      4808,
      796,
      651,
      62,
      46503,
      62,
      27363,
      62,
      19503,
      80,
      62,
      30053,
      28264,
      40148,
      11,
      7032,
      11,
      923,
      62,
      2435,
      11,
      886,
      62,
      2435,
      11,
      2030,
      80,
      28,
      19503,
      80,
      8
    ],
    "start_token": 502,
    "end_token": 549,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      284,
      2198,
      611,
      257,
      4947,
      318,
      6565
    ],
    "label": "ml_signal",
    "reason": "Method to check if a collection is empty"
  },
  {
    "line": 116,
    "text": "                raise ValueError(f\"The benchmark {_codes} does not exist. Please provide the right benchmark\")",
    "annotation": "\u2705 Best Practice: Using len() to check for emptiness is clear and concise",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      464,
      18335,
      1391,
      62,
      40148,
      92,
      857,
      407,
      2152,
      13,
      4222,
      2148,
      262,
      826,
      18335,
      4943
    ],
    "start_token": 549,
    "end_token": 586,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      18896,
      3419,
      284,
      2198,
      329,
      49333,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Using len() to check for emptiness is clear and concise"
  },
  {
    "line": 116,
    "text": "                raise ValueError(f\"The benchmark {_codes} does not exist. Please provide the right benchmark\")",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the purpose and behavior of the method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7,
      69,
      1,
      464,
      18335,
      1391,
      62,
      40148,
      92,
      857,
      407,
      2152,
      13,
      4222,
      2148,
      262,
      826,
      18335,
      4943
    ],
    "start_token": 586,
    "end_token": 623,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      4069,
      286,
      262,
      2446
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the purpose and behavior of the method"
  },
  {
    "line": 118,
    "text": "                _temp_result.groupby(level=\"datetime\", group_keys=False)[_temp_result.columns.tolist()[0]]",
    "annotation": "\u2705 Best Practice: Ensure that the method returns a consistent type as indicated in the type hint",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      29510,
      62,
      20274,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      19608,
      8079,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      8,
      29795,
      29510,
      62,
      20274,
      13,
      28665,
      82,
      13,
      83,
      349,
      396,
      3419,
      58,
      15,
      11907
    ],
    "start_token": 623,
    "end_token": 672,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      5860,
      257,
      6414,
      2099,
      355,
      8203,
      287,
      262,
      2099,
      9254
    ],
    "label": "best_practice",
    "reason": "Ensure that the method returns a consistent type as indicated in the type hint"
  },
  {
    "line": 118,
    "text": "                _temp_result.groupby(level=\"datetime\", group_keys=False)[_temp_result.columns.tolist()[0]]",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose and behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      29510,
      62,
      20274,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      19608,
      8079,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      8,
      29795,
      29510,
      62,
      20274,
      13,
      28665,
      82,
      13,
      83,
      349,
      396,
      3419,
      58,
      15,
      11907
    ],
    "start_token": 672,
    "end_token": 721,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      4069
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose and behavior"
  },
  {
    "line": 120,
    "text": "                .fillna(0)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'latest_pm_time' is not a key in 'accounts'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      20797,
      2616,
      7,
      15,
      8
    ],
    "start_token": 721,
    "end_token": 742,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      42861,
      62,
      4426,
      62,
      2435,
      6,
      318,
      407,
      257,
      1994,
      287,
      705,
      23317,
      82,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'latest_pm_time' is not a key in 'accounts'"
  },
  {
    "line": 121,
    "text": "            )",
    "annotation": "\ud83e\udde0 ML Signal: Accessing dictionary with a dynamic key",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 742,
    "end_token": 754,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      22155,
      351,
      257,
      8925,
      1994
    ],
    "label": "ml_signal",
    "reason": "Accessing dictionary with a dynamic key"
  },
  {
    "line": 120,
    "text": "                .fillna(0)",
    "annotation": "\ud83e\udde0 ML Signal: Method returning a value from a dictionary using a key",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      20797,
      2616,
      7,
      15,
      8
    ],
    "start_token": 754,
    "end_token": 775,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8024,
      257,
      1988,
      422,
      257,
      22155,
      1262,
      257,
      1994
    ],
    "label": "ml_signal",
    "reason": "Method returning a value from a dictionary using a key"
  },
  {
    "line": 122,
    "text": "",
    "annotation": "\u2705 Best Practice: Return statement is simple and clear",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 775,
    "end_token": 775,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      2643,
      318,
      2829,
      290,
      1598
    ],
    "label": "best_practice",
    "reason": "Return statement is simple and clear"
  },
  {
    "line": 122,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method accessing a dictionary with a specific key pattern",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 775,
    "end_token": 775,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      22534,
      257,
      22155,
      351,
      257,
      2176,
      1994,
      3912
    ],
    "label": "ml_signal",
    "reason": "Method accessing a dictionary with a specific key pattern"
  },
  {
    "line": 123,
    "text": "    def _sample_benchmark(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'latest_pm_time' is not in 'total_turnovers'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      39873,
      62,
      26968,
      4102,
      7
    ],
    "start_token": 775,
    "end_token": 785,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      42861,
      62,
      4426,
      62,
      2435,
      6,
      318,
      407,
      287,
      705,
      23350,
      62,
      15344,
      13801,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'latest_pm_time' is not in 'total_turnovers'"
  },
  {
    "line": 138,
    "text": "    def is_empty(self) -> bool:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for NoneType errors if not all parameters are validated",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      318,
      62,
      28920,
      7,
      944,
      8,
      4613,
      20512,
      25
    ],
    "start_token": 785,
    "end_token": 798,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6045,
      6030,
      8563,
      611,
      407,
      477,
      10007,
      389,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for NoneType errors if not all parameters are validated"
  },
  {
    "line": 154,
    "text": "        self,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for NoneType errors if not all parameters are validated",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 798,
    "end_token": 807,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6045,
      6030,
      8563,
      611,
      407,
      477,
      10007,
      389,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for NoneType errors if not all parameters are validated"
  },
  {
    "line": 158,
    "text": "        cash: float | None = None,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a fallback mechanism when a parameter is None",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5003,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      11
    ],
    "start_token": 807,
    "end_token": 822,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2121,
      1891,
      9030,
      618,
      257,
      11507,
      318,
      6045
    ],
    "label": "ml_signal",
    "reason": "Usage of a fallback mechanism when a parameter is None"
  },
  {
    "line": 160,
    "text": "        total_turnover: float | None = None,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15344,
      2502,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      11
    ],
    "start_token": 822,
    "end_token": 840,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 162,
    "text": "        total_cost: float | None = None,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15805,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      11
    ],
    "start_token": 840,
    "end_token": 857,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 164,
    "text": "        stock_value: float | None = None,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      8367,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      11
    ],
    "start_token": 857,
    "end_token": 874,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 166,
    "text": "    ) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      6045,
      25
    ],
    "start_token": 874,
    "end_token": 881,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 168,
    "text": "        if None in [",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      6045,
      287,
      685
    ],
    "start_token": 881,
    "end_token": 892,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 170,
    "text": "            account_value,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1848,
      62,
      8367,
      11
    ],
    "start_token": 892,
    "end_token": 907,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 172,
    "text": "            return_rate,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      62,
      4873,
      11
    ],
    "start_token": 907,
    "end_token": 922,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 174,
    "text": "            turnover_rate,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25079,
      62,
      4873,
      11
    ],
    "start_token": 922,
    "end_token": 937,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 176,
    "text": "            cost_rate,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of storing metrics in a dictionary with timestamps as keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1575,
      62,
      4873,
      11
    ],
    "start_token": 937,
    "end_token": 952,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      23069,
      20731,
      287,
      257,
      22155,
      351,
      4628,
      395,
      9430,
      355,
      8251
    ],
    "label": "ml_signal",
    "reason": "Pattern of storing metrics in a dictionary with timestamps as keys"
  },
  {
    "line": 178,
    "text": "        ]:",
    "annotation": "\ud83e\udde0 ML Signal: Tracking the latest update time for portfolio metrics",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361,
      25
    ],
    "start_token": 952,
    "end_token": 961,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      37169,
      262,
      3452,
      4296,
      640,
      329,
      15320,
      20731
    ],
    "label": "ml_signal",
    "reason": "Tracking the latest update time for portfolio metrics"
  },
  {
    "line": 167,
    "text": "        # check data",
    "annotation": "\ud83e\udde0 ML Signal: Method generates a DataFrame from multiple series, indicating a pattern of data aggregation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2198,
      1366
    ],
    "start_token": 961,
    "end_token": 971,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      18616,
      257,
      6060,
      19778,
      422,
      3294,
      2168,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      46500
    ],
    "label": "ml_signal",
    "reason": "Method generates a DataFrame from multiple series, indicating a pattern of data aggregation"
  },
  {
    "line": 169,
    "text": "            trade_start_time,",
    "annotation": "\u2705 Best Practice: Initialize DataFrame before populating it with data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      9688,
      62,
      2435,
      11
    ],
    "start_token": 971,
    "end_token": 988,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      6060,
      19778,
      878,
      1461,
      8306,
      340,
      351,
      1366
    ],
    "label": "best_practice",
    "reason": "Initialize DataFrame before populating it with data"
  },
  {
    "line": 171,
    "text": "            cash,",
    "annotation": "\ud83e\udde0 ML Signal: Mapping account data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5003,
      11
    ],
    "start_token": 988,
    "end_token": 1001,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      1848,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping account data to a DataFrame column"
  },
  {
    "line": 173,
    "text": "            total_turnover,",
    "annotation": "\ud83e\udde0 ML Signal: Mapping return data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15344,
      2502,
      11
    ],
    "start_token": 1001,
    "end_token": 1017,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      1441,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping return data to a DataFrame column"
  },
  {
    "line": 175,
    "text": "            total_cost,",
    "annotation": "\ud83e\udde0 ML Signal: Mapping total turnover data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15805,
      11
    ],
    "start_token": 1017,
    "end_token": 1032,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      2472,
      25079,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping total turnover data to a DataFrame column"
  },
  {
    "line": 177,
    "text": "            stock_value,",
    "annotation": "\ud83e\udde0 ML Signal: Mapping turnover data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      8367,
      11
    ],
    "start_token": 1032,
    "end_token": 1047,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      25079,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping turnover data to a DataFrame column"
  },
  {
    "line": 179,
    "text": "            raise ValueError(",
    "annotation": "\ud83e\udde0 ML Signal: Mapping total cost data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      11052,
      12331,
      7
    ],
    "start_token": 1047,
    "end_token": 1062,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      2472,
      1575,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping total cost data to a DataFrame column"
  },
  {
    "line": 181,
    "text": "                \"total_cost, cost_rate, stock_value]\",",
    "annotation": "\ud83e\udde0 ML Signal: Mapping cost data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      23350,
      62,
      15805,
      11,
      1575,
      62,
      4873,
      11,
      4283,
      62,
      8367,
      60,
      1600
    ],
    "start_token": 1062,
    "end_token": 1091,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      1575,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping cost data to a DataFrame column"
  },
  {
    "line": 183,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Mapping value data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1091,
    "end_token": 1091,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      1988,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping value data to a DataFrame column"
  },
  {
    "line": 184,
    "text": "        if trade_end_time is None and bench_value is None:",
    "annotation": "\ud83e\udde0 ML Signal: Mapping cash data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      3292,
      62,
      437,
      62,
      2435,
      318,
      6045,
      290,
      7624,
      62,
      8367,
      318,
      6045,
      25
    ],
    "start_token": 1091,
    "end_token": 1113,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      5003,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping cash data to a DataFrame column"
  },
  {
    "line": 184,
    "text": "        if trade_end_time is None and bench_value is None:",
    "annotation": "\ud83e\udde0 ML Signal: Mapping benchmark data to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      3292,
      62,
      437,
      62,
      2435,
      318,
      6045,
      290,
      7624,
      62,
      8367,
      318,
      6045,
      25
    ],
    "start_token": 1113,
    "end_token": 1135,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      18335,
      1366,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Mapping benchmark data to a DataFrame column"
  },
  {
    "line": 190,
    "text": "        self.accounts[trade_start_time] = account_value",
    "annotation": "\u2705 Best Practice: Setting the index name for better DataFrame readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23317,
      82,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      1848,
      62,
      8367
    ],
    "start_token": 1135,
    "end_token": 1157,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      6376,
      1438,
      329,
      1365,
      6060,
      19778,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Setting the index name for better DataFrame readability"
  },
  {
    "line": 191,
    "text": "        self.returns[trade_start_time] = return_rate",
    "annotation": "\u2705 Best Practice: Return the DataFrame after all operations are complete",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7783,
      82,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      1441,
      62,
      4873
    ],
    "start_token": 1157,
    "end_token": 1179,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      262,
      6060,
      19778,
      706,
      477,
      4560,
      389,
      1844
    ],
    "label": "best_practice",
    "reason": "Return the DataFrame after all operations are complete"
  },
  {
    "line": 181,
    "text": "                \"total_cost, cost_rate, stock_value]\",",
    "annotation": "\ud83e\udde0 ML Signal: Method for saving data to a file, indicating file I/O operation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      23350,
      62,
      15805,
      11,
      1575,
      62,
      4873,
      11,
      4283,
      62,
      8367,
      60,
      1600
    ],
    "start_token": 1179,
    "end_token": 1208,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      8914,
      1366,
      284,
      257,
      2393,
      11,
      12739,
      2393,
      314,
      14,
      46,
      4905
    ],
    "label": "ml_signal",
    "reason": "Method for saving data to a file, indicating file I/O operation"
  },
  {
    "line": 182,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Type hinting for method parameters and return type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1208,
    "end_token": 1220,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2446,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Type hinting for method parameters and return type"
  },
  {
    "line": 184,
    "text": "        if trade_end_time is None and bench_value is None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pandas DataFrame method to_csv for exporting data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      3292,
      62,
      437,
      62,
      2435,
      318,
      6045,
      290,
      7624,
      62,
      8367,
      318,
      6045,
      25
    ],
    "start_token": 1220,
    "end_token": 1242,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      19798,
      292,
      6060,
      19778,
      2446,
      284,
      62,
      40664,
      329,
      39133,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of pandas DataFrame method to_csv for exporting data"
  },
  {
    "line": 184,
    "text": "        if trade_end_time is None and bench_value is None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of overwriting existing files without warning",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      3292,
      62,
      437,
      62,
      2435,
      318,
      6045,
      290,
      7624,
      62,
      8367,
      318,
      6045,
      25
    ],
    "start_token": 1242,
    "end_token": 1264,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      6993,
      799,
      278,
      4683,
      3696,
      1231,
      6509
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of overwriting existing files without warning"
  },
  {
    "line": 190,
    "text": "        self.accounts[trade_start_time] = account_value",
    "annotation": "\u2705 Best Practice: Use of pathlib for file path handling is recommended for cross-platform compatibility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23317,
      82,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      1848,
      62,
      8367
    ],
    "start_token": 1264,
    "end_token": 1286,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3108,
      8019,
      329,
      2393,
      3108,
      9041,
      318,
      7151,
      329,
      3272,
      12,
      24254,
      17764,
      13
    ],
    "label": "best_practice",
    "reason": "Use of pathlib for file path handling is recommended for cross-platform compatibility."
  },
  {
    "line": 192,
    "text": "        self.total_turnovers[trade_start_time] = total_turnover",
    "annotation": "\ud83e\udde0 ML Signal: Reading CSV files is a common operation that can be used to identify data loading patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23350,
      62,
      15344,
      13801,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      2472,
      62,
      15344,
      2502
    ],
    "start_token": 1286,
    "end_token": 1311,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      44189,
      3696,
      318,
      257,
      2219,
      4905,
      326,
      460,
      307,
      973,
      284,
      5911,
      1366,
      11046,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Reading CSV files is a common operation that can be used to identify data loading patterns."
  },
  {
    "line": 194,
    "text": "        self.total_costs[trade_start_time] = total_cost",
    "annotation": "\ud83e\udde0 ML Signal: Converting index to DatetimeIndex is a common preprocessing step for time series data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      23350,
      62,
      15805,
      82,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      2472,
      62,
      15805
    ],
    "start_token": 1311,
    "end_token": 1335,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      6376,
      284,
      16092,
      8079,
      15732,
      318,
      257,
      2219,
      662,
      36948,
      2239,
      329,
      640,
      2168,
      1366,
      13
    ],
    "label": "ml_signal",
    "reason": "Converting index to DatetimeIndex is a common preprocessing step for time series data."
  },
  {
    "line": 196,
    "text": "        self.values[trade_start_time] = stock_value",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of variables before a loop is a common pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      27160,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      4283,
      62,
      8367
    ],
    "start_token": 1335,
    "end_token": 1356,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      9633,
      878,
      257,
      9052,
      318,
      257,
      2219,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Initialization of variables before a loop is a common pattern."
  },
  {
    "line": 196,
    "text": "        self.values[trade_start_time] = stock_value",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over time series data is a common pattern in financial applications.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      27160,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      4283,
      62,
      8367
    ],
    "start_token": 1356,
    "end_token": 1377,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      640,
      2168,
      1366,
      318,
      257,
      2219,
      3912,
      287,
      3176,
      5479,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over time series data is a common pattern in financial applications."
  },
  {
    "line": 196,
    "text": "        self.values[trade_start_time] = stock_value",
    "annotation": "\ud83e\udde0 ML Signal: Accessing DataFrame rows by index is a common data manipulation pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      27160,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      4283,
      62,
      8367
    ],
    "start_token": 1377,
    "end_token": 1398,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      6060,
      19778,
      15274,
      416,
      6376,
      318,
      257,
      2219,
      1366,
      17512,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Accessing DataFrame rows by index is a common data manipulation pattern."
  },
  {
    "line": 232,
    "text": "        index = r.index",
    "annotation": "\ud83e\udde0 ML Signal: Class definition with detailed docstring, useful for understanding class purpose and usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      796,
      374,
      13,
      9630
    ],
    "start_token": 1398,
    "end_token": 1410,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      6770,
      351,
      6496,
      2205,
      8841,
      11,
      4465,
      329,
      4547,
      1398,
      4007,
      290,
      8748
    ],
    "label": "ml_signal",
    "reason": "Class definition with detailed docstring, useful for understanding class purpose and usage"
  },
  {
    "line": 233,
    "text": "        self.init_vars()",
    "annotation": "\u2705 Best Practice: Comprehensive docstring explaining class attributes and behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      15003,
      62,
      85,
      945,
      3419
    ],
    "start_token": 1410,
    "end_token": 1424,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40917,
      2205,
      8841,
      11170,
      1398,
      12608,
      290,
      4069
    ],
    "label": "best_practice",
    "reason": "Comprehensive docstring explaining class attributes and behavior"
  },
  {
    "line": 233,
    "text": "        self.init_vars()",
    "annotation": "\u2705 Best Practice: Use of type annotations for constructor parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      15003,
      62,
      85,
      945,
      3419
    ],
    "start_token": 1424,
    "end_token": 1438,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      37647,
      329,
      23772,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type annotations for constructor parameters improves code readability and maintainability."
  },
  {
    "line": 235,
    "text": "            self.update_portfolio_metrics_record(",
    "annotation": "\u2705 Best Practice: Initializing attributes in the constructor ensures they are always defined.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      19119,
      62,
      634,
      13652,
      62,
      4164,
      10466,
      62,
      22105,
      7
    ],
    "start_token": 1438,
    "end_token": 1461,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      12608,
      287,
      262,
      23772,
      19047,
      484,
      389,
      1464,
      5447,
      13
    ],
    "label": "best_practice",
    "reason": "Initializing attributes in the constructor ensures they are always defined."
  },
  {
    "line": 237,
    "text": "                account_value=r.loc[trade_start_time][\"account\"],",
    "annotation": "\u2705 Best Practice: Use of type annotations for attributes improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1848,
      62,
      8367,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      23317,
      33116
    ],
    "start_token": 1461,
    "end_token": 1493,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      37647,
      329,
      12608,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type annotations for attributes improves code readability and maintainability."
  },
  {
    "line": 239,
    "text": "                return_rate=r.loc[trade_start_time][\"return\"],",
    "annotation": "\u2705 Best Practice: Initializing attributes in the constructor ensures they are always defined.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      62,
      4873,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      7783,
      33116
    ],
    "start_token": 1493,
    "end_token": 1525,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      12608,
      287,
      262,
      23772,
      19047,
      484,
      389,
      1464,
      5447,
      13
    ],
    "label": "best_practice",
    "reason": "Initializing attributes in the constructor ensures they are always defined."
  },
  {
    "line": 241,
    "text": "                turnover_rate=r.loc[trade_start_time][\"turnover\"],",
    "annotation": "\u2705 Best Practice: Use of type annotations for attributes improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25079,
      62,
      4873,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      15344,
      2502,
      33116
    ],
    "start_token": 1525,
    "end_token": 1558,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      37647,
      329,
      12608,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type annotations for attributes improves code readability and maintainability."
  },
  {
    "line": 243,
    "text": "                cost_rate=r.loc[trade_start_time][\"cost\"],",
    "annotation": "\u2705 Best Practice: Initializing attributes in the constructor ensures they are always defined.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1575,
      62,
      4873,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      15805,
      33116
    ],
    "start_token": 1558,
    "end_token": 1590,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      12608,
      287,
      262,
      23772,
      19047,
      484,
      389,
      1464,
      5447,
      13
    ],
    "label": "best_practice",
    "reason": "Initializing attributes in the constructor ensures they are always defined."
  },
  {
    "line": 240,
    "text": "                total_turnover=r.loc[trade_start_time][\"total_turnover\"],",
    "annotation": "\u2705 Best Practice: Use of type hinting for the return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15344,
      2502,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      23350,
      62,
      15344,
      2502,
      33116
    ],
    "start_token": 1590,
    "end_token": 1626,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for the return type improves code readability and maintainability."
  },
  {
    "line": 242,
    "text": "                total_cost=r.loc[trade_start_time][\"total_cost\"],",
    "annotation": "\ud83e\udde0 ML Signal: Instantiating an object using a class attribute, indicating a pattern of dynamic class usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15805,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      23350,
      62,
      15805,
      33116
    ],
    "start_token": 1626,
    "end_token": 1660,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2262,
      17096,
      803,
      281,
      2134,
      1262,
      257,
      1398,
      11688,
      11,
      12739,
      257,
      3912,
      286,
      8925,
      1398,
      8748,
      13
    ],
    "label": "ml_signal",
    "reason": "Instantiating an object using a class attribute, indicating a pattern of dynamic class usage."
  },
  {
    "line": 244,
    "text": "                stock_value=r.loc[trade_start_time][\"value\"],",
    "annotation": "\ud83e\udde0 ML Signal: Use of OrderedDict suggests a pattern where order of elements is important.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      8367,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      8367,
      33116
    ],
    "start_token": 1660,
    "end_token": 1692,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      14230,
      1068,
      35,
      713,
      5644,
      257,
      3912,
      810,
      1502,
      286,
      4847,
      318,
      1593,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of OrderedDict suggests a pattern where order of elements is important."
  },
  {
    "line": 242,
    "text": "                total_cost=r.loc[trade_start_time][\"total_cost\"],",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2472,
      62,
      15805,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      23350,
      62,
      15805,
      33116
    ],
    "start_token": 1692,
    "end_token": 1726,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 244,
    "text": "                stock_value=r.loc[trade_start_time][\"value\"],",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dictionary to store historical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      8367,
      28,
      81,
      13,
      17946,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      7131,
      1,
      8367,
      33116
    ],
    "start_token": 1726,
    "end_token": 1758,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      22155,
      284,
      3650,
      6754,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of dictionary to store historical data"
  },
  {
    "line": 246,
    "text": "            )",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dictionary to store historical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1758,
    "end_token": 1770,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      22155,
      284,
      3650,
      6754,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of dictionary to store historical data"
  },
  {
    "line": 246,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Initialize dictionaries to store trade information for each order",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1770,
    "end_token": 1782,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      48589,
      3166,
      284,
      3650,
      3292,
      1321,
      329,
      1123,
      1502
    ],
    "label": "best_practice",
    "reason": "Initialize dictionaries to store trade information for each order"
  },
  {
    "line": 255,
    "text": "    | indicator    | desc.                                                        |",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over trade_info to extract and store trade details",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      930,
      16916,
      220,
      220,
      220,
      930,
      1715,
      13,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      930
    ],
    "start_token": 1782,
    "end_token": 1849,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      3292,
      62,
      10951,
      284,
      7925,
      290,
      3650,
      3292,
      3307
    ],
    "label": "ml_signal",
    "reason": "Iterating over trade_info to extract and store trade details"
  },
  {
    "line": 263,
    "text": "    | trade_dir    | the trading direction                                        |",
    "annotation": "\u2705 Best Practice: Use a method to assign values to order_indicator, improving maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      930,
      3292,
      62,
      15908,
      220,
      220,
      220,
      930,
      262,
      7313,
      4571,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      930
    ],
    "start_token": 1849,
    "end_token": 1903,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      257,
      2446,
      284,
      8333,
      3815,
      284,
      1502,
      62,
      521,
      26407,
      11,
      10068,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use a method to assign values to order_indicator, improving maintainability"
  },
  {
    "line": 269,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a private method to encapsulate functionality",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1903,
    "end_token": 1903,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2839,
      2446,
      284,
      32652,
      5039,
      11244
    ],
    "label": "best_practice",
    "reason": "Use of a private method to encapsulate functionality"
  },
  {
    "line": 271,
    "text": "    The `base_price` and `base_volume` can't be NaN when there are not trading on that step. Otherwise",
    "annotation": "\u2705 Best Practice: Use meaningful variable names for better readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      383,
      4600,
      8692,
      62,
      20888,
      63,
      290,
      4600,
      8692,
      62,
      29048,
      63,
      460,
      470,
      307,
      11013,
      45,
      618,
      612,
      389,
      407,
      7313,
      319,
      326,
      2239,
      13,
      15323
    ],
    "start_token": 1903,
    "end_token": 1933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      11570,
      7885,
      3891,
      329,
      1365,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use meaningful variable names for better readability"
  },
  {
    "line": 273,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if 'amount' contains zeros",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1933,
    "end_token": 1933,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      705,
      17287,
      6,
      4909,
      1976,
      27498
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if 'amount' contains zeros"
  },
  {
    "line": 276,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Custom function passed as an argument, indicating higher-order function usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 1933,
    "end_token": 1937,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      2163,
      3804,
      355,
      281,
      4578,
      11,
      12739,
      2440,
      12,
      2875,
      2163,
      8748
    ],
    "label": "ml_signal",
    "reason": "Custom function passed as an argument, indicating higher-order function usage"
  },
  {
    "line": 275,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for method parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1937,
    "end_token": 1937,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2446,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for method parameters and return type improves code readability and maintainability."
  },
  {
    "line": 277,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method call with a complex data structure as an argument, indicating a pattern of data handling.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1937,
    "end_token": 1937,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      257,
      3716,
      1366,
      4645,
      355,
      281,
      4578,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      9041,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call with a complex data structure as an argument, indicating a pattern of data handling."
  },
  {
    "line": 279,
    "text": "        self.order_indicator_cls = order_indicator_cls",
    "annotation": "\ud83e\udde0 ML Signal: Method call without arguments, indicating a pattern of internal state update.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      62,
      565,
      82,
      796,
      1502,
      62,
      521,
      26407,
      62,
      565,
      82
    ],
    "start_token": 1937,
    "end_token": 1961,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      1231,
      7159,
      11,
      12739,
      257,
      3912,
      286,
      5387,
      1181,
      4296,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call without arguments, indicating a pattern of internal state update."
  },
  {
    "line": 278,
    "text": "    def __init__(self, order_indicator_cls: Type[BaseOrderIndicator] = NumpyOrderIndicator) -> None:",
    "annotation": "\u2705 Best Practice: Type hinting for function parameters and return type improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      1502,
      62,
      521,
      26407,
      62,
      565,
      82,
      25,
      5994,
      58,
      14881,
      18743,
      5497,
      26407,
      60,
      796,
      399,
      32152,
      18743,
      5497,
      26407,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 1961,
    "end_token": 1996,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for function parameters and return type improves code readability and maintainability"
  },
  {
    "line": 281,
    "text": "        # order indicator is metrics for a single order for a specific step",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a collection of indicators, which may be useful for pattern recognition in ML models",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1502,
      16916,
      318,
      20731,
      329,
      257,
      2060,
      1502,
      329,
      257,
      2176,
      2239
    ],
    "start_token": 1996,
    "end_token": 2016,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      4947,
      286,
      21337,
      11,
      543,
      743,
      307,
      4465,
      329,
      3912,
      9465,
      287,
      10373,
      4981
    ],
    "label": "ml_signal",
    "reason": "Iterating over a collection of indicators, which may be useful for pattern recognition in ML models"
  },
  {
    "line": 283,
    "text": "        self.order_indicator: BaseOrderIndicator = self.order_indicator_cls()",
    "annotation": "\ud83e\udde0 ML Signal: Use of a transfer method, indicating a transformation or mapping operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      25,
      7308,
      18743,
      5497,
      26407,
      796,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      62,
      565,
      82,
      3419
    ],
    "start_token": 2016,
    "end_token": 2045,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      4351,
      2446,
      11,
      12739,
      257,
      13389,
      393,
      16855,
      4905
    ],
    "label": "ml_signal",
    "reason": "Use of a transfer method, indicating a transformation or mapping operation"
  },
  {
    "line": 284,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a list of metrics, which could be features in an ML model",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2045,
    "end_token": 2045,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      1351,
      286,
      20731,
      11,
      543,
      714,
      307,
      3033,
      287,
      281,
      10373,
      2746
    ],
    "label": "ml_signal",
    "reason": "Use of a list of metrics, which could be features in an ML model"
  },
  {
    "line": 284,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a method to sum indicators, promoting code reuse and readability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2045,
    "end_token": 2045,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2446,
      284,
      2160,
      21337,
      11,
      11560,
      2438,
      32349,
      290,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of a method to sum indicators, promoting code reuse and readability"
  },
  {
    "line": 291,
    "text": "    # def reset(self, trade_calendar: TradeCalendarManager):",
    "annotation": "\u2705 Best Practice: Consider checking if 'deal_amount' is a pandas Series before using 'replace'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      825,
      13259,
      7,
      944,
      11,
      3292,
      62,
      9948,
      9239,
      25,
      9601,
      9771,
      9239,
      13511,
      2599
    ],
    "start_token": 2045,
    "end_token": 2064,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      10627,
      611,
      705,
      31769,
      62,
      17287,
      6,
      318,
      257,
      19798,
      292,
      7171,
      878,
      1262,
      705,
      33491,
      6
    ],
    "label": "best_practice",
    "reason": "Consider checking if 'deal_amount' is a pandas Series before using 'replace'"
  },
  {
    "line": 292,
    "text": "    def reset(self) -> None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if 'deal_amount' contains zeros not replaced by NaN",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      13259,
      7,
      944,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2064,
    "end_token": 2075,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      705,
      31769,
      62,
      17287,
      6,
      4909,
      1976,
      27498,
      407,
      6928,
      416,
      11013,
      45
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if 'deal_amount' contains zeros not replaced by NaN"
  },
  {
    "line": 294,
    "text": "        self.trade_indicator = OrderedDict()",
    "annotation": "\ud83e\udde0 ML Signal: Function returns a division result, which might be used for financial calculations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      25351,
      62,
      521,
      26407,
      796,
      14230,
      1068,
      35,
      713,
      3419
    ],
    "start_token": 2075,
    "end_token": 2094,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      5860,
      257,
      7297,
      1255,
      11,
      543,
      1244,
      307,
      973,
      329,
      3176,
      16765
    ],
    "label": "ml_signal",
    "reason": "Function returns a division result, which might be used for financial calculations"
  },
  {
    "line": 296,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of 'transfer' method indicates a pattern of applying transformations to data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2094,
    "end_token": 2094,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      705,
      39437,
      6,
      2446,
      9217,
      257,
      3912,
      286,
      11524,
      38226,
      284,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of 'transfer' method indicates a pattern of applying transformations to data"
  },
  {
    "line": 294,
    "text": "        self.trade_indicator = OrderedDict()",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with a single parameter",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      25351,
      62,
      521,
      26407,
      796,
      14230,
      1068,
      35,
      713,
      3419
    ],
    "start_token": 2094,
    "end_token": 2113,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      257,
      2060,
      11507
    ],
    "label": "ml_signal",
    "reason": "Function definition with a single parameter"
  },
  {
    "line": 296,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas apply function",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2113,
    "end_token": 2113,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      4174,
      2163
    ],
    "label": "ml_signal",
    "reason": "Use of pandas apply function"
  },
  {
    "line": 298,
    "text": "        self.order_indicator_his[trade_start_time] = self.get_order_indicator()",
    "annotation": "\ud83e\udde0 ML Signal: Method call with a function and string argument",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      62,
      14363,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      2116,
      13,
      1136,
      62,
      2875,
      62,
      521,
      26407,
      3419
    ],
    "start_token": 2113,
    "end_token": 2145,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      257,
      2163,
      290,
      4731,
      4578
    ],
    "label": "ml_signal",
    "reason": "Method call with a function and string argument"
  },
  {
    "line": 298,
    "text": "        self.order_indicator_his[trade_start_time] = self.get_order_indicator()",
    "annotation": "\u2705 Best Practice: Type hinting for 'decision' improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      62,
      14363,
      58,
      25351,
      62,
      9688,
      62,
      2435,
      60,
      796,
      2116,
      13,
      1136,
      62,
      2875,
      62,
      521,
      26407,
      3419
    ],
    "start_token": 2145,
    "end_token": 2177,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      705,
      12501,
      1166,
      6,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for 'decision' improves code readability and maintainability."
  },
  {
    "line": 300,
    "text": "",
    "annotation": "\u2705 Best Practice: Checking for an empty list before processing helps avoid unnecessary operations.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2177,
    "end_token": 2177,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      329,
      281,
      6565,
      1351,
      878,
      7587,
      5419,
      3368,
      13114,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Checking for an empty list before processing helps avoid unnecessary operations."
  },
  {
    "line": 302,
    "text": "        amount = dict()",
    "annotation": "\ud83e\udde0 ML Signal: The use of 'assign' method with specific keys and values could indicate a pattern in data handling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2033,
      796,
      8633,
      3419
    ],
    "start_token": 2177,
    "end_token": 2188,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      779,
      286,
      705,
      562,
      570,
      6,
      2446,
      351,
      2176,
      8251,
      290,
      3815,
      714,
      7603,
      257,
      3912,
      287,
      1366,
      9041,
      13
    ],
    "label": "ml_signal",
    "reason": "The use of 'assign' method with specific keys and values could indicate a pattern in data handling."
  },
  {
    "line": 303,
    "text": "        deal_amount = dict()",
    "annotation": "\ud83e\udde0 ML Signal: Dictionary comprehension usage can be a pattern for transforming data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1730,
      62,
      17287,
      796,
      8633,
      3419
    ],
    "start_token": 2188,
    "end_token": 2201,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28261,
      35915,
      8748,
      460,
      307,
      257,
      3912,
      329,
      25449,
      1366,
      13
    ],
    "label": "ml_signal",
    "reason": "Dictionary comprehension usage can be a pattern for transforming data."
  },
  {
    "line": 317,
    "text": "            # The PA in the innermost layer is meanless",
    "annotation": "\ud83e\udde0 ML Signal: Usage of configuration pattern with default values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      383,
      8147,
      287,
      262,
      8434,
      1712,
      7679,
      318,
      1612,
      1203
    ],
    "start_token": 2201,
    "end_token": 2223,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8398,
      3912,
      351,
      4277,
      3815
    ],
    "label": "ml_signal",
    "reason": "Usage of configuration pattern with default values"
  },
  {
    "line": 319,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of configuration pattern with default values",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2223,
    "end_token": 2223,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8398,
      3912,
      351,
      4277,
      3815
    ],
    "label": "ml_signal",
    "reason": "Usage of configuration pattern with default values"
  },
  {
    "line": 320,
    "text": "        self.order_indicator.assign(\"amount\", amount)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of time range clipping",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      13,
      562,
      570,
      7203,
      17287,
      1600,
      2033,
      8
    ],
    "start_token": 2223,
    "end_token": 2244,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      640,
      2837,
      45013
    ],
    "label": "ml_signal",
    "reason": "Usage of time range clipping"
  },
  {
    "line": 325,
    "text": "        self.order_indicator.assign(\"trade_value\", trade_value)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional API call based on configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      13,
      562,
      570,
      7203,
      25351,
      62,
      8367,
      1600,
      3292,
      62,
      8367,
      8
    ],
    "start_token": 2244,
    "end_token": 2269,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      7824,
      869,
      1912,
      319,
      8398
    ],
    "label": "ml_signal",
    "reason": "Conditional API call based on configuration"
  },
  {
    "line": 337,
    "text": "        self.order_indicator.transfer(func, \"ffr\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of NotImplementedError for unsupported cases",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      13,
      39437,
      7,
      20786,
      11,
      366,
      487,
      81,
      4943
    ],
    "start_token": 2269,
    "end_token": 2291,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      329,
      24222,
      2663
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of NotImplementedError for unsupported cases"
  },
  {
    "line": 342,
    "text": "",
    "annotation": "\u2705 Best Practice: Encapsulation of scalar into SingleData",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2291,
    "end_token": 2291,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14711,
      1686,
      1741,
      286,
      16578,
      283,
      656,
      14206,
      6601
    ],
    "label": "best_practice",
    "reason": "Encapsulation of scalar into SingleData"
  },
  {
    "line": 347,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of NotImplementedError for unsupported cases",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2291,
    "end_token": 2291,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      329,
      24222,
      2663
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of NotImplementedError for unsupported cases"
  },
  {
    "line": 349,
    "text": "            indicator.transfer(trade_amount_func, \"trade_price\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16916,
      13,
      39437,
      7,
      25351,
      62,
      17287,
      62,
      20786,
      11,
      366,
      25351,
      62,
      20888,
      4943
    ],
    "start_token": 2291,
    "end_token": 2317,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      2099,
      10627
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for type checking"
  },
  {
    "line": 351,
    "text": "        # sum inner order indicators with same metric.",
    "annotation": "\u2705 Best Practice: Filtering data based on condition",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2160,
      8434,
      1502,
      21337,
      351,
      976,
      18663,
      13
    ],
    "start_token": 2317,
    "end_token": 2333,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7066,
      20212,
      1366,
      1912,
      319,
      4006
    ],
    "label": "best_practice",
    "reason": "Filtering data based on condition"
  },
  {
    "line": 354,
    "text": "            self.order_indicator,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      11
    ],
    "start_token": 2333,
    "end_token": 2351,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      2099,
      10627
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for type checking"
  },
  {
    "line": 358,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on aggregation method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 2351,
    "end_token": 2359,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      46500,
      2446
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on aggregation method"
  },
  {
    "line": 361,
    "text": "            # trade_price is np.nan instead of inf when deal_amount is zero.",
    "annotation": "\u2705 Best Practice: Encapsulation of scalar into SingleData",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      3292,
      62,
      20888,
      318,
      45941,
      13,
      12647,
      2427,
      286,
      1167,
      618,
      1730,
      62,
      17287,
      318,
      6632,
      13
    ],
    "start_token": 2359,
    "end_token": 2388,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14711,
      1686,
      1741,
      286,
      16578,
      283,
      656,
      14206,
      6601
    ],
    "label": "best_practice",
    "reason": "Encapsulation of scalar into SingleData"
  },
  {
    "line": 361,
    "text": "            # trade_price is np.nan instead of inf when deal_amount is zero.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      3292,
      62,
      20888,
      318,
      45941,
      13,
      12647,
      2427,
      286,
      1167,
      618,
      1730,
      62,
      17287,
      318,
      6632,
      13
    ],
    "start_token": 2388,
    "end_token": 2417,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      2099,
      10627
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for type checking"
  },
  {
    "line": 365,
    "text": "        self.order_indicator.transfer(func, \"trade_price\")",
    "annotation": "\u2705 Best Practice: Reindexing data to match another dataset",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      13,
      39437,
      7,
      20786,
      11,
      366,
      25351,
      62,
      20888,
      4943
    ],
    "start_token": 2417,
    "end_token": 2440,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      797,
      9630,
      278,
      1366,
      284,
      2872,
      1194,
      27039
    ],
    "label": "best_practice",
    "reason": "Reindexing data to match another dataset"
  },
  {
    "line": 368,
    "text": "            return trade_dir.apply(Order.parse_dir)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on aggregation method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      15908,
      13,
      39014,
      7,
      18743,
      13,
      29572,
      62,
      15908,
      8
    ],
    "start_token": 2440,
    "end_token": 2464,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      46500,
      2446
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on aggregation method"
  },
  {
    "line": 368,
    "text": "            return trade_dir.apply(Order.parse_dir)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of NotImplementedError for unsupported cases",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      15908,
      13,
      39014,
      7,
      18743,
      13,
      29572,
      62,
      15908,
      8
    ],
    "start_token": 2464,
    "end_token": 2488,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      329,
      24222,
      2663
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of NotImplementedError for unsupported cases"
  },
  {
    "line": 368,
    "text": "            return trade_dir.apply(Order.parse_dir)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      15908,
      13,
      39014,
      7,
      18743,
      13,
      29572,
      62,
      15908,
      8
    ],
    "start_token": 2488,
    "end_token": 2512,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      2099,
      10627
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for type checking"
  },
  {
    "line": 368,
    "text": "            return trade_dir.apply(Order.parse_dir)",
    "annotation": "\u2705 Best Practice: Calculation of aggregate values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      15908,
      13,
      39014,
      7,
      18743,
      13,
      29572,
      62,
      15908,
      8
    ],
    "start_token": 2512,
    "end_token": 2536,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2199,
      14902,
      286,
      19406,
      3815
    ],
    "label": "best_practice",
    "reason": "Calculation of aggregate values"
  },
  {
    "line": 368,
    "text": "            return trade_dir.apply(Order.parse_dir)",
    "annotation": "\u2705 Best Practice: Docstring provides clear parameter descriptions and expected types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      15908,
      13,
      39014,
      7,
      18743,
      13,
      29572,
      62,
      15908,
      8
    ],
    "start_token": 2536,
    "end_token": 2560,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      11507,
      16969,
      290,
      2938,
      3858
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear parameter descriptions and expected types"
  },
  {
    "line": 393,
    "text": "        \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for None values if _get_base_vol_pri returns None",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 2560,
    "end_token": 2568,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6045,
      3815,
      611,
      4808,
      1136,
      62,
      8692,
      62,
      10396,
      62,
      3448,
      5860,
      6045
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for None values if _get_base_vol_pri returns None"
  },
  {
    "line": 408,
    "text": "                trade_end_time,",
    "annotation": "\u2705 Best Practice: Using idd.SingleData for consistent data handling",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      437,
      62,
      2435,
      11
    ],
    "start_token": 2568,
    "end_token": 2589,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      220,
      1638,
      13,
      28008,
      6601,
      329,
      6414,
      1366,
      9041
    ],
    "label": "best_practice",
    "reason": "Using idd.SingleData for consistent data handling"
  },
  {
    "line": 413,
    "text": "            raise NotImplementedError(f\"This type of input is not supported\")",
    "annotation": "\u2705 Best Practice: Using idd.concat for efficient data concatenation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      1212,
      2099,
      286,
      5128,
      318,
      407,
      4855,
      4943
    ],
    "start_token": 2589,
    "end_token": 2617,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      220,
      1638,
      13,
      1102,
      9246,
      329,
      6942,
      1366,
      1673,
      36686,
      341
    ],
    "label": "best_practice",
    "reason": "Using idd.concat for efficient data concatenation"
  },
  {
    "line": 418,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Assigning calculated values to order_indicator",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2617,
    "end_token": 2617,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2195,
      38944,
      10488,
      3815,
      284,
      1502,
      62,
      521,
      26407
    ],
    "label": "ml_signal",
    "reason": "Assigning calculated values to order_indicator"
  },
  {
    "line": 419,
    "text": "        if isinstance(price_s, (int, float, np.number)):",
    "annotation": "\ud83e\udde0 ML Signal: Calculating weighted average price",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      357,
      600,
      11,
      12178,
      11,
      45941,
      13,
      17618,
      8,
      2599
    ],
    "start_token": 2617,
    "end_token": 2642,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27131,
      803,
      26356,
      2811,
      2756
    ],
    "label": "ml_signal",
    "reason": "Calculating weighted average price"
  },
  {
    "line": 418,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a private method to encapsulate functionality",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2642,
    "end_token": 2642,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2839,
      2446,
      284,
      32652,
      5039,
      11244
    ],
    "label": "best_practice",
    "reason": "Use of a private method to encapsulate functionality"
  },
  {
    "line": 419,
    "text": "        if isinstance(price_s, (int, float, np.number)):",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      357,
      600,
      11,
      12178,
      11,
      45941,
      13,
      17618,
      8,
      2599
    ],
    "start_token": 2642,
    "end_token": 2667,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 421,
    "text": "        elif isinstance(price_s, idd.SingleData):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of the 'empty' attribute to check for empty data structures",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      220,
      1638,
      13,
      28008,
      6601,
      2599
    ],
    "start_token": 2667,
    "end_token": 2689,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      262,
      705,
      28920,
      6,
      11688,
      284,
      2198,
      329,
      6565,
      1366,
      8573
    ],
    "label": "ml_signal",
    "reason": "Usage of the 'empty' attribute to check for empty data structures"
  },
  {
    "line": 423,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with 'transfer' function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 2689,
    "end_token": 2698,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      705,
      39437,
      6,
      2163
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with 'transfer' function"
  },
  {
    "line": 425,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional check pattern",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2698,
    "end_token": 2698,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      2198,
      3912
    ],
    "label": "ml_signal",
    "reason": "Conditional check pattern"
  },
  {
    "line": 424,
    "text": "            raise NotImplementedError(f\"This type of input is not supported\")",
    "annotation": "\u2705 Best Practice: Use of descriptive variable names improves code readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      1212,
      2099,
      286,
      5128,
      318,
      407,
      4855,
      4943
    ],
    "start_token": 2698,
    "end_token": 2726,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      7885,
      3891,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of descriptive variable names improves code readability."
  },
  {
    "line": 426,
    "text": "        # NOTE: there are some zeros in the trading price. These cases are known meaningless",
    "annotation": "\u2705 Best Practice: Clear mathematical operation for calculating 'sign'.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      612,
      389,
      617,
      1976,
      27498,
      287,
      262,
      7313,
      2756,
      13,
      2312,
      2663,
      389,
      1900,
      24513
    ],
    "start_token": 2726,
    "end_token": 2751,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      18069,
      4905,
      329,
      26019,
      705,
      12683,
      4458
    ],
    "label": "best_practice",
    "reason": "Clear mathematical operation for calculating 'sign'."
  },
  {
    "line": 428,
    "text": "        # remove zero and negative values.",
    "annotation": "\u2705 Best Practice: Return statement is concise and clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      4781,
      6632,
      290,
      4633,
      3815,
      13
    ],
    "start_token": 2751,
    "end_token": 2765,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      2643,
      318,
      35327,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Return statement is concise and clear."
  },
  {
    "line": 429,
    "text": "        assert isinstance(price_s, idd.SingleData)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a transfer method with a function and a string parameter.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6818,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      220,
      1638,
      13,
      28008,
      6601,
      8
    ],
    "start_token": 2765,
    "end_token": 2786,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      4351,
      2446,
      351,
      257,
      2163,
      290,
      257,
      4731,
      11507,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a transfer method with a function and a string parameter."
  },
  {
    "line": 429,
    "text": "        assert isinstance(price_s, idd.SingleData)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of an assign method with a string and dictionary parameter.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6818,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      220,
      1638,
      13,
      28008,
      6601,
      8
    ],
    "start_token": 2786,
    "end_token": 2807,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      281,
      8333,
      2446,
      351,
      257,
      4731,
      290,
      22155,
      11507,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of an assign method with a string and dictionary parameter."
  },
  {
    "line": 429,
    "text": "        assert isinstance(price_s, idd.SingleData)",
    "annotation": "\u2705 Best Practice: Type hints for parameters improve code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6818,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      220,
      1638,
      13,
      28008,
      6601,
      8
    ],
    "start_token": 2807,
    "end_token": 2828,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      329,
      10007,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hints for parameters improve code readability and maintainability"
  },
  {
    "line": 438,
    "text": "        assert isinstance(price_s, idd.SingleData)",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern could be used to understand function behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6818,
      318,
      39098,
      7,
      20888,
      62,
      82,
      11,
      220,
      1638,
      13,
      28008,
      6601,
      8
    ],
    "start_token": 2828,
    "end_token": 2849,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      714,
      307,
      973,
      284,
      1833,
      2163,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern could be used to understand function behavior"
  },
  {
    "line": 440,
    "text": "            volume_s = trade_exchange.get_volume(inst, trade_start_time, trade_end_time, method=None)",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern could be used to understand function behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6115,
      62,
      82,
      796,
      3292,
      62,
      1069,
      3803,
      13,
      1136,
      62,
      29048,
      7,
      8625,
      11,
      3292,
      62,
      9688,
      62,
      2435,
      11,
      3292,
      62,
      437,
      62,
      2435,
      11,
      2446,
      28,
      14202,
      8
    ],
    "start_token": 2849,
    "end_token": 2891,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      714,
      307,
      973,
      284,
      1833,
      2163,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern could be used to understand function behavior"
  },
  {
    "line": 442,
    "text": "                volume_s = idd.SingleData(volume_s, [trade_start_time])",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern could be used to understand function behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6115,
      62,
      82,
      796,
      220,
      1638,
      13,
      28008,
      6601,
      7,
      29048,
      62,
      82,
      11,
      685,
      25351,
      62,
      9688,
      62,
      2435,
      12962
    ],
    "start_token": 2891,
    "end_token": 2927,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      714,
      307,
      973,
      284,
      1833,
      2163,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern could be used to understand function behavior"
  },
  {
    "line": 444,
    "text": "            volume_s = volume_s.reindex(price_s.index)",
    "annotation": "\u2705 Best Practice: Using get() with a default value prevents KeyError",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6115,
      62,
      82,
      796,
      6115,
      62,
      82,
      13,
      260,
      9630,
      7,
      20888,
      62,
      82,
      13,
      9630,
      8
    ],
    "start_token": 2927,
    "end_token": 2955,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      651,
      3419,
      351,
      257,
      4277,
      1988,
      15174,
      7383,
      12331
    ],
    "label": "best_practice",
    "reason": "Using get() with a default value prevents KeyError"
  },
  {
    "line": 445,
    "text": "        elif agg == \"twap\":",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern could be used to understand function behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      4194,
      6624,
      366,
      4246,
      499,
      1298
    ],
    "start_token": 2955,
    "end_token": 2970,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      714,
      307,
      973,
      284,
      1833,
      2163,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern could be used to understand function behavior"
  },
  {
    "line": 448,
    "text": "            raise NotImplementedError(f\"This type of input is not supported\")",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern could be used to understand function behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      1212,
      2099,
      286,
      5128,
      318,
      407,
      4855,
      4943
    ],
    "start_token": 2970,
    "end_token": 2998,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      714,
      307,
      973,
      284,
      1833,
      2163,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method call pattern could be used to understand function behavior"
  },
  {
    "line": 444,
    "text": "            volume_s = volume_s.reindex(price_s.index)",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameter values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6115,
      62,
      82,
      796,
      6115,
      62,
      82,
      13,
      260,
      9630,
      7,
      20888,
      62,
      82,
      13,
      9630,
      8
    ],
    "start_token": 2998,
    "end_token": 3026,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      11507,
      3815
    ],
    "label": "ml_signal",
    "reason": "Use of default parameter values"
  },
  {
    "line": 445,
    "text": "        elif agg == \"twap\":",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      4194,
      6624,
      366,
      4246,
      499,
      1298
    ],
    "start_token": 3026,
    "end_token": 3041,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 452,
    "text": "        base_price = (price_s * volume_s).sum() / base_volume",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2779,
      62,
      20888,
      796,
      357,
      20888,
      62,
      82,
      1635,
      6115,
      62,
      82,
      737,
      16345,
      3419,
      1220,
      2779,
      62,
      29048
    ],
    "start_token": 3041,
    "end_token": 3067,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 457,
    "text": "        inner_order_indicators: List[BaseOrderIndicator],",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8434,
      62,
      2875,
      62,
      521,
      44549,
      25,
      7343,
      58,
      14881,
      18743,
      5497,
      26407,
      4357
    ],
    "start_token": 3067,
    "end_token": 3088,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 461,
    "text": "    ) -> None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for unhandled exception if method is not supported",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      6045,
      25
    ],
    "start_token": 3088,
    "end_token": 3095,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      555,
      38788,
      6631,
      611,
      2446,
      318,
      407,
      4855
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for unhandled exception if method is not supported"
  },
  {
    "line": 459,
    "text": "        trade_exchange: Exchange,",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameter values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      1069,
      3803,
      25,
      12516,
      11
    ],
    "start_token": 3095,
    "end_token": 3109,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      11507,
      3815
    ],
    "label": "ml_signal",
    "reason": "Use of default parameter values"
  },
  {
    "line": 461,
    "text": "    ) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      6045,
      25
    ],
    "start_token": 3109,
    "end_token": 3116,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 465,
    "text": "        # the correctness of the base_price relies on that the **same** exchange is used",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      262,
      29409,
      286,
      262,
      2779,
      62,
      20888,
      16507,
      319,
      326,
      262,
      12429,
      31642,
      1174,
      5163,
      318,
      973
    ],
    "start_token": 3116,
    "end_token": 3141,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 470,
    "text": "            the indicators of account of inner executor",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      262,
      21337,
      286,
      1848,
      286,
      8434,
      3121,
      273
    ],
    "start_token": 3141,
    "end_token": 3160,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions"
  },
  {
    "line": 474,
    "text": "            for retrieving trading price",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for unhandled exception if method is not supported",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      50122,
      7313,
      2756
    ],
    "start_token": 3160,
    "end_token": 3175,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      555,
      38788,
      6631,
      611,
      2446,
      318,
      407,
      4855
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for unhandled exception if method is not supported"
  },
  {
    "line": 471,
    "text": "        decision_list: List[Tuple[BaseTradeDecision, pd.Timestamp, pd.Timestamp]],",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2551,
      62,
      4868,
      25,
      7343,
      58,
      51,
      29291,
      58,
      14881,
      35965,
      10707,
      1166,
      11,
      279,
      67,
      13,
      14967,
      27823,
      11,
      279,
      67,
      13,
      14967,
      27823,
      60,
      4357
    ],
    "start_token": 3175,
    "end_token": 3209,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 473,
    "text": "        trade_exchange : Exchange",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda-like function for data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      1069,
      3803,
      1058,
      12516
    ],
    "start_token": 3209,
    "end_token": 3222,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      12,
      2339,
      2163,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Use of lambda-like function for data transformation"
  },
  {
    "line": 475,
    "text": "        pa_config : dict",
    "annotation": "\ud83e\udde0 ML Signal: Use of custom method 'transfer' for data processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14187,
      62,
      11250,
      1058,
      8633
    ],
    "start_token": 3222,
    "end_token": 3234,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2183,
      2446,
      705,
      39437,
      6,
      329,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of custom method 'transfer' for data processing"
  },
  {
    "line": 476,
    "text": "            For example",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and functionality of the method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1114,
      1672
    ],
    "start_token": 3234,
    "end_token": 3247,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      11244,
      286,
      262,
      2446
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and functionality of the method"
  },
  {
    "line": 477,
    "text": "            {",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas-like operations (abs, sum) on data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1391
    ],
    "start_token": 3247,
    "end_token": 3259,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      12,
      2339,
      4560,
      357,
      8937,
      11,
      2160,
      8,
      319,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of pandas-like operations (abs, sum) on data"
  },
  {
    "line": 479,
    "text": "                \"price\": \"$close\",  # TODO: this is not supported now!!!!!",
    "annotation": "\ud83e\udde0 ML Signal: Use of higher-order functions (passing a function as an argument)",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      20888,
      1298,
      17971,
      19836,
      1600,
      220,
      1303,
      16926,
      46,
      25,
      428,
      318,
      407,
      4855,
      783,
      50184
    ],
    "start_token": 3259,
    "end_token": 3291,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2440,
      12,
      2875,
      5499,
      357,
      6603,
      278,
      257,
      2163,
      355,
      281,
      4578,
      8
    ],
    "label": "ml_signal",
    "reason": "Use of higher-order functions (passing a function as an argument)"
  },
  {
    "line": 479,
    "text": "                \"price\": \"$close\",  # TODO: this is not supported now!!!!!",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      20888,
      1298,
      17971,
      19836,
      1600,
      220,
      1303,
      16926,
      46,
      25,
      428,
      318,
      407,
      4855,
      783,
      50184
    ],
    "start_token": 3291,
    "end_token": 3323,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 481,
    "text": "            }",
    "annotation": "\ud83e\udde0 ML Signal: Use of method chaining with pandas-like operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 3323,
    "end_token": 3335,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2446,
      442,
      1397,
      351,
      19798,
      292,
      12,
      2339,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of method chaining with pandas-like operations"
  },
  {
    "line": 483,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential misuse if `self.order_indicator` is not validated",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3335,
    "end_token": 3335,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      29169,
      611,
      4600,
      944,
      13,
      2875,
      62,
      521,
      26407,
      63,
      318,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential misuse if `self.order_indicator` is not validated"
  },
  {
    "line": 484,
    "text": "        # TODO: I think there are potentials to be optimized",
    "annotation": "\u2705 Best Practice: Ensure `self.order_indicator` is initialized and valid",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      314,
      892,
      612,
      389,
      2785,
      82,
      284,
      307,
      23392
    ],
    "start_token": 3335,
    "end_token": 3355,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      4600,
      944,
      13,
      2875,
      62,
      521,
      26407,
      63,
      318,
      23224,
      290,
      4938
    ],
    "label": "best_practice",
    "reason": "Ensure `self.order_indicator` is initialized and valid"
  },
  {
    "line": 483,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3355,
    "end_token": 3355,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 485,
    "text": "        trade_dir = self.order_indicator.get_index_data(\"trade_dir\")",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with a single parameter, common pattern in ML data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3292,
      62,
      15908,
      796,
      2116,
      13,
      2875,
      62,
      521,
      26407,
      13,
      1136,
      62,
      9630,
      62,
      7890,
      7203,
      25351,
      62,
      15908,
      4943
    ],
    "start_token": 3355,
    "end_token": 3383,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      257,
      2060,
      11507,
      11,
      2219,
      3912,
      287,
      10373,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Function definition with a single parameter, common pattern in ML data processing"
  },
  {
    "line": 486,
    "text": "        if len(trade_dir) > 0:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential misuse if 'amount' is not a list or does not have a 'count' method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      25351,
      62,
      15908,
      8,
      1875,
      657,
      25
    ],
    "start_token": 3383,
    "end_token": 3400,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      29169,
      611,
      705,
      17287,
      6,
      318,
      407,
      257,
      1351,
      393,
      857,
      407,
      423,
      257,
      705,
      9127,
      6,
      2446
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential misuse if 'amount' is not a list or does not have a 'count' method"
  },
  {
    "line": 487,
    "text": "            bp_all, bv_all = [], []",
    "annotation": "\ud83e\udde0 ML Signal: Use of higher-order function, passing a function as an argument",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      275,
      79,
      62,
      439,
      11,
      275,
      85,
      62,
      439,
      796,
      685,
      4357,
      17635
    ],
    "start_token": 3400,
    "end_token": 3424,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2440,
      12,
      2875,
      2163,
      11,
      6427,
      257,
      2163,
      355,
      281,
      4578
    ],
    "label": "ml_signal",
    "reason": "Use of higher-order function, passing a function as an argument"
  },
  {
    "line": 487,
    "text": "            bp_all, bv_all = [], []",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if 'self.order_indicator.transfer' executes untrusted code",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      275,
      79,
      62,
      439,
      11,
      275,
      85,
      62,
      439,
      796,
      685,
      4357,
      17635
    ],
    "start_token": 3424,
    "end_token": 3448,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      705,
      944,
      13,
      2875,
      62,
      521,
      26407,
      13,
      39437,
      6,
      42985,
      1418,
      81,
      8459,
      2438
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if 'self.order_indicator.transfer' executes untrusted code"
  },
  {
    "line": 487,
    "text": "            bp_all, bv_all = [], []",
    "annotation": "\u2705 Best Practice: Consider adding error handling for robustness",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      275,
      79,
      62,
      439,
      11,
      275,
      85,
      62,
      439,
      796,
      685,
      4357,
      17635
    ],
    "start_token": 3448,
    "end_token": 3472,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      4049,
      9041,
      329,
      12373,
      1108
    ],
    "label": "best_practice",
    "reason": "Consider adding error handling for robustness"
  },
  {
    "line": 493,
    "text": "                bp_new, bv_new = {}, {}",
    "annotation": "\u2705 Best Practice: Use of get() method with default values for dictionary access",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      275,
      79,
      62,
      3605,
      11,
      275,
      85,
      62,
      3605,
      796,
      1391,
      5512,
      23884
    ],
    "start_token": 3472,
    "end_token": 3500,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      3419,
      2446,
      351,
      4277,
      3815,
      329,
      22155,
      1895
    ],
    "label": "best_practice",
    "reason": "Use of get() method with default values for dictionary access"
  },
  {
    "line": 497,
    "text": "                            inst,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of method calls to calculate trade metrics",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      916,
      11
    ],
    "start_token": 3500,
    "end_token": 3529,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2446,
      3848,
      284,
      15284,
      3292,
      20731
    ],
    "label": "ml_signal",
    "reason": "Usage of method calls to calculate trade metrics"
  },
  {
    "line": 504,
    "text": "                        )",
    "annotation": "\ud83e\udde0 ML Signal: Storing calculated indicators in a dictionary",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 3529,
    "end_token": 3553,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      10488,
      21337,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Storing calculated indicators in a dictionary"
  },
  {
    "line": 509,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through print statements",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 3553,
    "end_token": 3553,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      3601,
      6299
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through print statements"
  },
  {
    "line": 522,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 3553,
    "end_token": 3565,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 524,
    "text": "    def _agg_order_price_advantage(self) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of conditional return based on a boolean flag",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      9460,
      62,
      2875,
      62,
      20888,
      62,
      13461,
      496,
      7,
      944,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3565,
    "end_token": 3584,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      26340,
      1441,
      1912,
      319,
      257,
      25131,
      6056
    ],
    "label": "ml_signal",
    "reason": "Usage of conditional return based on a boolean flag"
  },
  {
    "line": 524,
    "text": "    def _agg_order_price_advantage(self) -> None:",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose and return value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      9460,
      62,
      2875,
      62,
      20888,
      62,
      13461,
      496,
      7,
      944,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3584,
    "end_token": 3603,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose and return value"
  },
  {
    "line": 526,
    "text": "            return trade_price.empty",
    "annotation": "\u2705 Best Practice: Consider using a property decorator if this method is intended to be an attribute accessor",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      20888,
      13,
      28920
    ],
    "start_token": 3603,
    "end_token": 3620,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      3119,
      11705,
      1352,
      611,
      428,
      2446,
      318,
      5292,
      284,
      307,
      281,
      11688,
      1895,
      273
    ],
    "label": "best_practice",
    "reason": "Consider using a property decorator if this method is intended to be an attribute accessor"
  },
  {
    "line": 526,
    "text": "            return trade_price.empty",
    "annotation": "\ud83e\udde0 ML Signal: Method returns a DataFrame, indicating usage of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3292,
      62,
      20888,
      13,
      28920
    ],
    "start_token": 3620,
    "end_token": 3637,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      5860,
      257,
      6060,
      19778,
      11,
      12739,
      8748,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Method returns a DataFrame, indicating usage of pandas for data manipulation"
  },
  {
    "line": 527,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of dictionary to DataFrame, common in data processing tasks",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3637,
    "end_token": 3637,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      22155,
      284,
      6060,
      19778,
      11,
      2219,
      287,
      1366,
      7587,
      8861
    ],
    "label": "ml_signal",
    "reason": "Conversion of dictionary to DataFrame, common in data processing tasks"
  },
  {
    "line": 527,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of 'from_dict' with 'orient=\"index\"' for clear DataFrame structure",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3637,
    "end_token": 3637,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      6738,
      62,
      11600,
      6,
      351,
      705,
      13989,
      2625,
      9630,
      30543,
      329,
      1598,
      6060,
      19778,
      4645
    ],
    "label": "best_practice",
    "reason": "Use of 'from_dict' with 'orient=\"index\"' for clear DataFrame structure"
  }
]