[
  {
    "line": 2,
    "text": "# Licensed under the MIT License.",
    "annotation": "\u2705 Best Practice: Ensures compatibility with future Python versions for type annotations",
    "confidence": 1.0,
    "tokens": [
      2,
      49962,
      739,
      262,
      17168,
      13789,
      13
    ],
    "start_token": 0,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      942,
      17764,
      351,
      2003,
      11361,
      6300,
      329,
      2099,
      37647
    ],
    "label": "best_practice",
    "reason": "Ensures compatibility with future Python versions for type annotations"
  },
  {
    "line": 4,
    "text": "from __future__ import annotations",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes improves code readability and avoids namespace pollution",
    "confidence": 1.0,
    "tokens": [
      6738,
      11593,
      37443,
      834,
      1330,
      37647
    ],
    "start_token": 7,
    "end_token": 13,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      19575,
      2438,
      1100,
      1799,
      290,
      30940,
      25745,
      12231
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes improves code readability and avoids namespace pollution"
  },
  {
    "line": 7,
    "text": "",
    "annotation": "\u2705 Best Practice: Grouping related imports together improves code organization",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 13,
    "end_token": 13,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      3519,
      17944,
      1978,
      19575,
      2438,
      4009
    ],
    "label": "best_practice",
    "reason": "Grouping related imports together improves code organization"
  },
  {
    "line": 11,
    "text": "from qlib.backtest.decision import OrderDir",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes improves code readability and avoids namespace pollution",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      1891,
      9288,
      13,
      12501,
      1166,
      1330,
      8284,
      35277
    ],
    "start_token": 13,
    "end_token": 25,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      19575,
      2438,
      1100,
      1799,
      290,
      30940,
      25745,
      12231
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes improves code readability and avoids namespace pollution"
  },
  {
    "line": 8,
    "text": "import numpy as np",
    "annotation": "\ud83e\udde0 ML Signal: Function signature indicates usage of pandas DataFrame, common in data processing tasks",
    "confidence": 0.5,
    "tokens": [
      11748,
      299,
      32152,
      355,
      45941
    ],
    "start_token": 25,
    "end_token": 30,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      9877,
      9217,
      8748,
      286,
      19798,
      292,
      6060,
      19778,
      11,
      2219,
      287,
      1366,
      7587,
      8861
    ],
    "label": "ml_signal",
    "reason": "Function signature indicates usage of pandas DataFrame, common in data processing tasks"
  },
  {
    "line": 10,
    "text": "",
    "annotation": "\u2705 Best Practice: Converting 'other' to DataFrame ensures compatibility with 'df'",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 30,
    "end_token": 30,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      705,
      847,
      6,
      284,
      6060,
      19778,
      19047,
      17764,
      351,
      705,
      7568,
      6
    ],
    "label": "best_practice",
    "reason": "Converting 'other' to DataFrame ensures compatibility with 'df'"
  },
  {
    "line": 11,
    "text": "from qlib.backtest.decision import OrderDir",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'other' can be converted to DataFrame and has 'datetime' column",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      1891,
      9288,
      13,
      12501,
      1166,
      1330,
      8284,
      35277
    ],
    "start_token": 30,
    "end_token": 42,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      847,
      6,
      460,
      307,
      11513,
      284,
      6060,
      19778,
      290,
      468,
      705,
      19608,
      8079,
      6,
      5721
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'other' can be converted to DataFrame and has 'datetime' column"
  },
  {
    "line": 13,
    "text": "from qlib.constant import float_or_ndarray",
    "annotation": "\u2705 Best Practice: Explicitly setting index name improves DataFrame readability",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      9979,
      415,
      1330,
      12178,
      62,
      273,
      62,
      358,
      18747
    ],
    "start_token": 42,
    "end_token": 55,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      6376,
      1438,
      19575,
      6060,
      19778,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Explicitly setting index name improves DataFrame readability"
  },
  {
    "line": 13,
    "text": "from qlib.constant import float_or_ndarray",
    "annotation": "\u2705 Best Practice: Using pd.concat for appending DataFrames is efficient and clear",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      9979,
      415,
      1330,
      12178,
      62,
      273,
      62,
      358,
      18747
    ],
    "start_token": 55,
    "end_token": 68,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      1102,
      9246,
      329,
      598,
      1571,
      6060,
      35439,
      318,
      6942,
      290,
      1598
    ],
    "label": "best_practice",
    "reason": "Using pd.concat for appending DataFrames is efficient and clear"
  },
  {
    "line": 18,
    "text": "    other_df = pd.DataFrame(other).set_index(\"datetime\")",
    "annotation": "\u2705 Best Practice: Check for division by zero to prevent runtime errors.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      584,
      62,
      7568,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      847,
      737,
      2617,
      62,
      9630,
      7203,
      19608,
      8079,
      4943
    ],
    "start_token": 68,
    "end_token": 90,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      7297,
      416,
      6632,
      284,
      2948,
      19124,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Check for division by zero to prevent runtime errors."
  },
  {
    "line": 20,
    "text": "",
    "annotation": "\u2705 Best Practice: Handle different types of exec_price for consistent return types.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 90,
    "end_token": 90,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      33141,
      1180,
      3858,
      286,
      2452,
      62,
      20888,
      329,
      6414,
      1441,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Handle different types of exec_price for consistent return types."
  },
  {
    "line": 25,
    "text": "def price_advantage(",
    "annotation": "\ud83e\udde0 ML Signal: Different behavior based on the direction of the order.",
    "confidence": 1.0,
    "tokens": [
      4299,
      2756,
      62,
      13461,
      496,
      7
    ],
    "start_token": 90,
    "end_token": 96,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20615,
      4069,
      1912,
      319,
      262,
      4571,
      286,
      262,
      1502,
      13
    ],
    "label": "ml_signal",
    "reason": "Different behavior based on the direction of the order."
  },
  {
    "line": 31,
    "text": "        if isinstance(exec_price, float):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for uncaught exceptions if direction is invalid.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      18558,
      62,
      20888,
      11,
      12178,
      2599
    ],
    "start_token": 96,
    "end_token": 113,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      4591,
      3413,
      13269,
      611,
      4571,
      318,
      12515,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for uncaught exceptions if direction is invalid."
  },
  {
    "line": 33,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Use np.nan_to_num to handle NaN values in calculations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 113,
    "end_token": 122,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      45941,
      13,
      12647,
      62,
      1462,
      62,
      22510,
      284,
      5412,
      11013,
      45,
      3815,
      287,
      16765,
      13
    ],
    "label": "best_practice",
    "reason": "Use np.nan_to_num to handle NaN values in calculations."
  },
  {
    "line": 35,
    "text": "    if direction == OrderDir.BUY:",
    "annotation": "\u2705 Best Practice: Check the size of the result to return the appropriate type.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      4571,
      6624,
      8284,
      35277,
      13,
      19499,
      56,
      25
    ],
    "start_token": 122,
    "end_token": 134,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      262,
      2546,
      286,
      262,
      1255,
      284,
      1441,
      262,
      5035,
      2099,
      13
    ],
    "label": "best_practice",
    "reason": "Check the size of the result to return the appropriate type."
  },
  {
    "line": 38,
    "text": "        res = (exec_price / baseline_price - 1) * 10000",
    "annotation": "\u2705 Best Practice: Use cast to ensure the return type matches the function signature.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      18558,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      532,
      352,
      8,
      1635,
      33028
    ],
    "start_token": 134,
    "end_token": 156,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      3350,
      284,
      4155,
      262,
      1441,
      2099,
      7466,
      262,
      2163,
      9877,
      13
    ],
    "label": "best_practice",
    "reason": "Use cast to ensure the return type matches the function signature."
  },
  {
    "line": 34,
    "text": "            return np.zeros_like(exec_price)",
    "annotation": "\ud83e\udde0 ML Signal: Function uses type checking and casting patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      45941,
      13,
      9107,
      418,
      62,
      2339,
      7,
      18558,
      62,
      20888,
      8
    ],
    "start_token": 156,
    "end_token": 179,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3544,
      2099,
      10627,
      290,
      13092,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function uses type checking and casting patterns"
  },
  {
    "line": 36,
    "text": "        res = (1 - exec_price / baseline_price) * 10000",
    "annotation": "\ud83e\udde0 ML Signal: Loop with type checking to unwrap nested structures",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      16,
      532,
      2452,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      8,
      1635,
      33028
    ],
    "start_token": 179,
    "end_token": 201,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26304,
      351,
      2099,
      10627,
      284,
      7379,
      2416,
      28376,
      8573
    ],
    "label": "ml_signal",
    "reason": "Loop with type checking to unwrap nested structures"
  },
  {
    "line": 38,
    "text": "        res = (exec_price / baseline_price - 1) * 10000",
    "annotation": "\ud83e\udde0 ML Signal: Accessing attribute of a specific type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      18558,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      532,
      352,
      8,
      1635,
      33028
    ],
    "start_token": 201,
    "end_token": 223,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      11688,
      286,
      257,
      2176,
      2099
    ],
    "label": "ml_signal",
    "reason": "Accessing attribute of a specific type"
  },
  {
    "line": 38,
    "text": "        res = (exec_price / baseline_price - 1) * 10000",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for type checking can be bypassed if Python is run with optimizations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      18558,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      532,
      352,
      8,
      1635,
      33028
    ],
    "start_token": 223,
    "end_token": 245,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      2099,
      10627,
      460,
      307,
      17286,
      276,
      611,
      11361,
      318,
      1057,
      351,
      41446
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for type checking can be bypassed if Python is run with optimizations"
  },
  {
    "line": 38,
    "text": "        res = (exec_price / baseline_price - 1) * 10000",
    "annotation": "\ud83e\udde0 ML Signal: Type assertion to ensure correct type before returning",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      18558,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      532,
      352,
      8,
      1635,
      33028
    ],
    "start_token": 245,
    "end_token": 267,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      19190,
      284,
      4155,
      3376,
      2099,
      878,
      8024
    ],
    "label": "ml_signal",
    "reason": "Type assertion to ensure correct type before returning"
  },
  {
    "line": 38,
    "text": "        res = (exec_price / baseline_price - 1) * 10000",
    "annotation": "\ud83e\udde0 ML Signal: Returning a specific type after unwrapping and checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      796,
      357,
      18558,
      62,
      20888,
      1220,
      14805,
      62,
      20888,
      532,
      352,
      8,
      1635,
      33028
    ],
    "start_token": 267,
    "end_token": 289,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      2176,
      2099,
      706,
      7379,
      430,
      2105,
      290,
      10627
    ],
    "label": "ml_signal",
    "reason": "Returning a specific type after unwrapping and checking"
  }
]