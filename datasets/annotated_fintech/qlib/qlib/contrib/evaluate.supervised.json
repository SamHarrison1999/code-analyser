[
  {
    "line": 7,
    "text": "import numpy as np",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [
      11748,
      299,
      32152,
      355,
      45941
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 9,
    "text": "import warnings",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [
      11748,
      14601
    ],
    "start_token": 5,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 11,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 7,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 13,
    "text": "from ..utils import get_date_range",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [
      6738,
      11485,
      26791,
      1330,
      651,
      62,
      4475,
      62,
      9521
    ],
    "start_token": 7,
    "end_token": 16,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 15,
    "text": "from ..strategy.base import BaseStrategy",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [
      6738,
      11485,
      2536,
      4338,
      13,
      8692,
      1330,
      7308,
      13290,
      4338
    ],
    "start_token": 16,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 26,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 26,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules helps maintain package structure.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 26,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103,
      5419,
      5529,
      5301,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules helps maintain package structure."
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging setup indicates potential for tracking and monitoring execution.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 26,
    "end_token": 26,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      9058,
      9217,
      2785,
      329,
      9646,
      290,
      9904,
      9706,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging setup indicates potential for tracking and monitoring execution."
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\u2705 Best Practice: Provide a clear and concise docstring explaining the function's purpose and parameters.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 26,
    "end_token": 26,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      1598,
      290,
      35327,
      2205,
      8841,
      11170,
      262,
      2163,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a clear and concise docstring explaining the function's purpose and parameters."
  },
  {
    "line": 37,
    "text": "    r : pandas.Series",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameters and type hints can be used to infer function usage patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      374,
      1058,
      19798,
      292,
      13,
      27996
    ],
    "start_token": 26,
    "end_token": 35,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      10007,
      290,
      2099,
      20269,
      460,
      307,
      973,
      284,
      13249,
      2163,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of default parameters and type hints can be used to infer function usage patterns."
  },
  {
    "line": 38,
    "text": "        daily return series.",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4445,
      1441,
      2168,
      13
    ],
    "start_token": 35,
    "end_token": 46,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability."
  },
  {
    "line": 38,
    "text": "        daily return series.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The function does not validate the input types or values, which could lead to runtime errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4445,
      1441,
      2168,
      13
    ],
    "start_token": 46,
    "end_token": 57,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      2163,
      857,
      407,
      26571,
      262,
      5128,
      3858,
      393,
      3815,
      11,
      543,
      714,
      1085,
      284,
      19124,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The function does not validate the input types or values, which could lead to runtime errors."
  },
  {
    "line": 37,
    "text": "    r : pandas.Series",
    "annotation": "\ud83e\udde0 ML Signal: Use of a dictionary to map frequency to scaler values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      374,
      1058,
      19798,
      292,
      13,
      27996
    ],
    "start_token": 57,
    "end_token": 66,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      22155,
      284,
      3975,
      8373,
      284,
      16578,
      263,
      3815
    ],
    "label": "ml_signal",
    "reason": "Use of a dictionary to map frequency to scaler values"
  },
  {
    "line": 45,
    "text": "        - \"sum\": Arithmetic accumulation (linear returns).",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if _freq is not in _freq_scaler",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      366,
      16345,
      1298,
      943,
      29848,
      24106,
      357,
      29127,
      5860,
      737
    ],
    "start_token": 66,
    "end_token": 84,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      4808,
      19503,
      80,
      318,
      407,
      287,
      4808,
      19503,
      80,
      62,
      1416,
      36213
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if _freq is not in _freq_scaler"
  },
  {
    "line": 47,
    "text": "    \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): N and freq are used without initial validation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 84,
    "end_token": 88,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      399,
      290,
      2030,
      80,
      389,
      973,
      1231,
      4238,
      21201
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "N and freq are used without initial validation"
  },
  {
    "line": 50,
    "text": "        _count, _freq = Freq.parse(freq)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Warnings are not always handled by users",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9127,
      11,
      4808,
      19503,
      80,
      796,
      4848,
      80,
      13,
      29572,
      7,
      19503,
      80,
      8
    ],
    "start_token": 88,
    "end_token": 110,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      39567,
      654,
      389,
      407,
      1464,
      12118,
      416,
      2985
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Warnings are not always handled by users"
  },
  {
    "line": 56,
    "text": "        }",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of mean and standard deviation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 110,
    "end_token": 118,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      1612,
      290,
      3210,
      28833
    ],
    "label": "ml_signal",
    "reason": "Calculation of mean and standard deviation"
  },
  {
    "line": 59,
    "text": "    if N is None and freq is None:",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of annualized return",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      399,
      318,
      6045,
      290,
      2030,
      80,
      318,
      6045,
      25
    ],
    "start_token": 118,
    "end_token": 131,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      5079,
      1143,
      1441
    ],
    "label": "ml_signal",
    "reason": "Calculation of annualized return"
  },
  {
    "line": 61,
    "text": "    if N is not None and freq is not None:",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of max drawdown",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      399,
      318,
      407,
      6045,
      290,
      2030,
      80,
      318,
      407,
      6045,
      25
    ],
    "start_token": 131,
    "end_token": 146,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      3509,
      3197,
      2902
    ],
    "label": "ml_signal",
    "reason": "Calculation of max drawdown"
  },
  {
    "line": 64,
    "text": "        N = cal_risk_analysis_scaler(freq)",
    "annotation": "\ud83e\udde0 ML Signal: Use of cumulative product for return calculation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      399,
      796,
      2386,
      62,
      19121,
      62,
      20930,
      62,
      1416,
      36213,
      7,
      19503,
      80,
      8
    ],
    "start_token": 146,
    "end_token": 167,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      23818,
      1720,
      329,
      1441,
      17952
    ],
    "label": "ml_signal",
    "reason": "Use of cumulative product for return calculation"
  },
  {
    "line": 73,
    "text": "        # geometric mean (compound annual growth rate)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for unsupported mode values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      38445,
      1612,
      357,
      5589,
      633,
      5079,
      3349,
      2494,
      8
    ],
    "start_token": 167,
    "end_token": 184,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      24222,
      4235,
      3815
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for unsupported mode values"
  },
  {
    "line": 74,
    "text": "        mean = cumulative_curve.iloc[-1] ** (1 / len(r)) - 1",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of information ratio",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1612,
      796,
      23818,
      62,
      22019,
      303,
      13,
      346,
      420,
      58,
      12,
      16,
      60,
      12429,
      357,
      16,
      1220,
      18896,
      7,
      81,
      4008,
      532,
      352
    ],
    "start_token": 184,
    "end_token": 214,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      1321,
      8064
    ],
    "label": "ml_signal",
    "reason": "Calculation of information ratio"
  },
  {
    "line": 76,
    "text": "        std = np.log(1 + r).std(ddof=1)",
    "annotation": "\u2705 Best Practice: Use of pd.Series for structured data representation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14367,
      796,
      45941,
      13,
      6404,
      7,
      16,
      1343,
      374,
      737,
      19282,
      7,
      1860,
      1659,
      28,
      16,
      8
    ],
    "start_token": 214,
    "end_token": 238,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      27996,
      329,
      20793,
      1366,
      10552
    ],
    "label": "best_practice",
    "reason": "Use of pd.Series for structured data representation"
  },
  {
    "line": 75,
    "text": "        # volatility of log returns",
    "annotation": "\u2705 Best Practice: Consider adding type hints for function parameters and return type for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      30772,
      286,
      2604,
      5860
    ],
    "start_token": 238,
    "end_token": 250,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for function parameters and return type for better readability and maintainability."
  },
  {
    "line": 100,
    "text": "    Parameters",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential KeyError if 'count' column is missing in the DataFrame.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      40117
    ],
    "start_token": 250,
    "end_token": 254,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      9127,
      6,
      5721,
      318,
      4814,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential KeyError if 'count' column is missing in the DataFrame."
  },
  {
    "line": 105,
    "text": "                - 'pa' is the price advantage in trade indicators",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential KeyError if 'deal_amount' column is missing in the DataFrame.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      705,
      8957,
      6,
      318,
      262,
      2756,
      4621,
      287,
      3292,
      21337
    ],
    "start_token": 254,
    "end_token": 280,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      31769,
      62,
      17287,
      6,
      5721,
      318,
      4814,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential KeyError if 'deal_amount' column is missing in the DataFrame."
  },
  {
    "line": 106,
    "text": "                - 'pos' is the positive rate in trade indicators",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential KeyError if 'value' column is missing in the DataFrame.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      705,
      1930,
      6,
      318,
      262,
      3967,
      2494,
      287,
      3292,
      21337
    ],
    "start_token": 280,
    "end_token": 306,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      8367,
      6,
      5721,
      318,
      4814,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential KeyError if 'value' column is missing in the DataFrame."
  },
  {
    "line": 109,
    "text": "                - 'deal_amount' is the total deal deal_amount, only necessary when method is 'amount_weighted'",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The method parameter is not validated against a predefined list of allowed values.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      705,
      31769,
      62,
      17287,
      6,
      318,
      262,
      2472,
      1730,
      1730,
      62,
      17287,
      11,
      691,
      3306,
      618,
      2446,
      318,
      705,
      17287,
      62,
      6551,
      276,
      6
    ],
    "start_token": 306,
    "end_token": 346,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      2446,
      11507,
      318,
      407,
      31031,
      1028,
      257,
      2747,
      18156,
      1351,
      286,
      3142,
      3815,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The method parameter is not validated against a predefined list of allowed values."
  },
  {
    "line": 112,
    "text": "        index: Index(datetime)",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential KeyError if 'ffr' or 'pa' columns are missing in the DataFrame.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      25,
      12901,
      7,
      19608,
      8079,
      8
    ],
    "start_token": 346,
    "end_token": 360,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      487,
      81,
      6,
      393,
      705,
      8957,
      6,
      15180,
      389,
      4814,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential KeyError if 'ffr' or 'pa' columns are missing in the DataFrame."
  },
  {
    "line": 114,
    "text": "        statistics method of pa/ffr, by default \"mean\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Division by zero risk if weights.sum() is zero.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7869,
      2446,
      286,
      14187,
      14,
      487,
      81,
      11,
      416,
      4277,
      366,
      32604,
      1
    ],
    "start_token": 360,
    "end_token": 380,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7458,
      416,
      6632,
      2526,
      611,
      19590,
      13,
      16345,
      3419,
      318,
      6632,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Division by zero risk if weights.sum() is zero."
  },
  {
    "line": 114,
    "text": "        statistics method of pa/ffr, by default \"mean\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential KeyError if 'pos' column is missing in the DataFrame.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7869,
      2446,
      286,
      14187,
      14,
      487,
      81,
      11,
      416,
      4277,
      366,
      32604,
      1
    ],
    "start_token": 380,
    "end_token": 400,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      1930,
      6,
      5721,
      318,
      4814,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential KeyError if 'pos' column is missing in the DataFrame."
  },
  {
    "line": 114,
    "text": "        statistics method of pa/ffr, by default \"mean\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Division by zero risk if weights.sum() is zero.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7869,
      2446,
      286,
      14187,
      14,
      487,
      81,
      11,
      416,
      4277,
      366,
      32604,
      1
    ],
    "start_token": 400,
    "end_token": 420,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7458,
      416,
      6632,
      2526,
      611,
      19590,
      13,
      16345,
      3419,
      318,
      6632,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Division by zero risk if weights.sum() is zero."
  },
  {
    "line": 187,
    "text": "            pred_score = pd.read_pickle(\"score.pkl\")[\"score\"]",
    "annotation": "\u2705 Best Practice: Use of default configuration for executor when none is provided",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2747,
      62,
      26675,
      796,
      279,
      67,
      13,
      961,
      62,
      27729,
      293,
      7203,
      26675,
      13,
      79,
      41582,
      4943,
      14692,
      26675,
      8973
    ],
    "start_token": 420,
    "end_token": 451,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      8398,
      329,
      3121,
      273,
      618,
      4844,
      318,
      2810
    ],
    "label": "best_practice",
    "reason": "Use of default configuration for executor when none is provided"
  },
  {
    "line": 192,
    "text": "            }",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic initialization of executor based on configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 451,
    "end_token": 463,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      37588,
      286,
      3121,
      273,
      1912,
      319,
      8398
    ],
    "label": "ml_signal",
    "reason": "Dynamic initialization of executor based on configuration"
  },
  {
    "line": 202,
    "text": "    executor : Union[str, dict, BaseExecutor]",
    "annotation": "\u2705 Best Practice: Updating default exchange_kwargs with user-provided values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      3121,
      273,
      1058,
      4479,
      58,
      2536,
      11,
      8633,
      11,
      7308,
      23002,
      38409,
      60
    ],
    "start_token": 463,
    "end_token": 479,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3205,
      38734,
      4277,
      5163,
      62,
      46265,
      22046,
      351,
      2836,
      12,
      41279,
      3815
    ],
    "label": "best_practice",
    "reason": "Updating default exchange_kwargs with user-provided values"
  },
  {
    "line": 202,
    "text": "    executor : Union[str, dict, BaseExecutor]",
    "annotation": "\ud83e\udde0 ML Signal: Use of backtest function with multiple parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3121,
      273,
      1058,
      4479,
      58,
      2536,
      11,
      8633,
      11,
      7308,
      23002,
      38409,
      60
    ],
    "start_token": 479,
    "end_token": 495,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      736,
      9288,
      2163,
      351,
      3294,
      10007
    ],
    "label": "ml_signal",
    "reason": "Use of backtest function with multiple parameters"
  },
  {
    "line": 215,
    "text": "            Using Account with a Position",
    "annotation": "\ud83e\udde0 ML Signal: Analysis frequency derived from frequency string",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8554,
      10781,
      351,
      257,
      23158
    ],
    "start_token": 495,
    "end_token": 511,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      14691,
      8373,
      10944,
      422,
      8373,
      4731
    ],
    "label": "ml_signal",
    "reason": "Analysis frequency derived from frequency string"
  },
  {
    "line": 215,
    "text": "            Using Account with a Position",
    "annotation": "\ud83e\udde0 ML Signal: Extraction of report and positions from portfolio metrics",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      8554,
      10781,
      351,
      257,
      23158
    ],
    "start_token": 511,
    "end_token": 527,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5683,
      7861,
      286,
      989,
      290,
      6116,
      422,
      15320,
      20731
    ],
    "label": "ml_signal",
    "reason": "Extraction of report and positions from portfolio metrics"
  },
  {
    "line": 248,
    "text": "        executor = _executor.SimulatorExecutor(**executor_config)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential issue with level index check, ensure `get_level_index` is defined and used correctly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3121,
      273,
      796,
      4808,
      18558,
      38409,
      13,
      8890,
      8927,
      23002,
      38409,
      7,
      1174,
      18558,
      38409,
      62,
      11250,
      8
    ],
    "start_token": 527,
    "end_token": 552,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2071,
      351,
      1241,
      6376,
      2198,
      11,
      4155,
      4600,
      1136,
      62,
      5715,
      62,
      9630,
      63,
      318,
      5447,
      290,
      973,
      9380,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential issue with level index check, ensure `get_level_index` is defined and used correctly."
  },
  {
    "line": 257,
    "text": "    if exchange_kwargs is not None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure `deal_price` is a string before checking its first character.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      5163,
      62,
      46265,
      22046,
      318,
      407,
      6045,
      25
    ],
    "start_token": 552,
    "end_token": 564,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      4600,
      31769,
      62,
      20888,
      63,
      318,
      257,
      4731,
      878,
      10627,
      663,
      717,
      2095,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure `deal_price` is a string before checking its first character."
  },
  {
    "line": 260,
    "text": "    portfolio_metric_dict, indicator_dict = backtest_func(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using mutable default argument `subscribe_fields`, which can lead to unexpected behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15320,
      62,
      4164,
      1173,
      62,
      11600,
      11,
      16916,
      62,
      11600,
      796,
      736,
      9288,
      62,
      20786,
      7
    ],
    "start_token": 564,
    "end_token": 583,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      4517,
      540,
      4277,
      4578,
      4600,
      7266,
      12522,
      62,
      25747,
      47671,
      543,
      460,
      1085,
      284,
      10059,
      4069,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using mutable default argument `subscribe_fields`, which can lead to unexpected behavior."
  },
  {
    "line": 321,
    "text": "        deal_price = \"$\" + deal_price",
    "annotation": "\u2705 Best Practice: Import statements for required modules should be included at the top of the file.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1730,
      62,
      20888,
      796,
      17971,
      1,
      1343,
      1730,
      62,
      20888
    ],
    "start_token": 583,
    "end_token": 600,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      6299,
      329,
      2672,
      13103,
      815,
      307,
      3017,
      379,
      262,
      1353,
      286,
      262,
      2393,
      13
    ],
    "label": "best_practice",
    "reason": "Import statements for required modules should be included at the top of the file."
  },
  {
    "line": 324,
    "text": "    profit_str = f\"Ref({deal_price}, -1)/{deal_price} - 1\"",
    "annotation": "\ud83e\udde0 ML Signal: Reading a CSV file into a DataFrame is a common pattern in data processing tasks.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      7630,
      62,
      2536,
      796,
      277,
      1,
      8134,
      15090,
      31769,
      62,
      20888,
      5512,
      532,
      16,
      20679,
      90,
      31769,
      62,
      20888,
      92,
      532,
      352,
      1
    ],
    "start_token": 600,
    "end_token": 626,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      257,
      44189,
      2393,
      656,
      257,
      6060,
      19778,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      8861,
      13
    ],
    "label": "ml_signal",
    "reason": "Reading a CSV file into a DataFrame is a common pattern in data processing tasks."
  },
  {
    "line": 325,
    "text": "    subscribe_fields.append(profit_str)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): File path is hardcoded, which may lead to issues if the file location changes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      12383,
      62,
      25747,
      13,
      33295,
      7,
      9183,
      62,
      2536,
      8
    ],
    "start_token": 626,
    "end_token": 639,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      9220,
      3108,
      318,
      1327,
      40976,
      11,
      543,
      743,
      1085,
      284,
      2428,
      611,
      262,
      2393,
      4067,
      2458,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "File path is hardcoded, which may lead to issues if the file location changes."
  },
  {
    "line": 327,
    "text": "    trade_exchange = get_exchange(",
    "annotation": "\ud83e\udde0 ML Signal: Converting a column to datetime is a common preprocessing step in time series analysis.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      3292,
      62,
      1069,
      3803,
      796,
      651,
      62,
      1069,
      3803,
      7
    ],
    "start_token": 639,
    "end_token": 652,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      257,
      5721,
      284,
      4818,
      8079,
      318,
      257,
      2219,
      662,
      36948,
      2239,
      287,
      640,
      2168,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Converting a column to datetime is a common preprocessing step in time series analysis."
  },
  {
    "line": 327,
    "text": "    trade_exchange = get_exchange(",
    "annotation": "\ud83e\udde0 ML Signal: Setting a DataFrame index using multiple columns is a common pattern in data manipulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3292,
      62,
      1069,
      3803,
      796,
      651,
      62,
      1069,
      3803,
      7
    ],
    "start_token": 652,
    "end_token": 665,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      257,
      6060,
      19778,
      6376,
      1262,
      3294,
      15180,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      17512,
      13
    ],
    "label": "ml_signal",
    "reason": "Setting a DataFrame index using multiple columns is a common pattern in data manipulation."
  },
  {
    "line": 332,
    "text": "        open_cost=open_cost,",
    "annotation": "\ud83e\udde0 ML Signal: Slicing a DataFrame to limit the number of rows is a common data preparation step.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1280,
      62,
      15805,
      28,
      9654,
      62,
      15805,
      11
    ],
    "start_token": 665,
    "end_token": 680,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      677,
      278,
      257,
      6060,
      19778,
      284,
      4179,
      262,
      1271,
      286,
      15274,
      318,
      257,
      2219,
      1366,
      11824,
      2239,
      13
    ],
    "label": "ml_signal",
    "reason": "Slicing a DataFrame to limit the number of rows is a common data preparation step."
  },
  {
    "line": 338,
    "text": "    )",
    "annotation": "\ud83e\udde0 ML Signal: Backtesting is a common practice in financial modeling and strategy evaluation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 680,
    "end_token": 684,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5157,
      33407,
      318,
      257,
      2219,
      3357,
      287,
      3176,
      21128,
      290,
      4811,
      12660,
      13
    ],
    "label": "ml_signal",
    "reason": "Backtesting is a common practice in financial modeling and strategy evaluation."
  },
  {
    "line": 338,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Printing the head of a DataFrame is useful for quick inspection of data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 684,
    "end_token": 688,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44118,
      262,
      1182,
      286,
      257,
      6060,
      19778,
      318,
      4465,
      329,
      2068,
      15210,
      286,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Printing the head of a DataFrame is useful for quick inspection of data."
  },
  {
    "line": 338,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Printing keys of a dictionary helps in understanding the structure of the data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 688,
    "end_token": 692,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44118,
      8251,
      286,
      257,
      22155,
      5419,
      287,
      4547,
      262,
      4645,
      286,
      262,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Printing keys of a dictionary helps in understanding the structure of the data."
  },
  {
    "line": 338,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Accessing and printing a specific element in a dictionary for inspection.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 692,
    "end_token": 696,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8798,
      278,
      290,
      13570,
      257,
      2176,
      5002,
      287,
      257,
      22155,
      329,
      15210,
      13
    ],
    "label": "best_practice",
    "reason": "Accessing and printing a specific element in a dictionary for inspection."
  },
  {
    "line": 338,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Using the main guard to ensure the script runs only when executed directly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 696,
    "end_token": 700,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      262,
      1388,
      4860,
      284,
      4155,
      262,
      4226,
      4539,
      691,
      618,
      10945,
      3264,
      13
    ],
    "label": "best_practice",
    "reason": "Using the main guard to ensure the script runs only when executed directly."
  }
]