[
  {
    "line": 4,
    "text": "from typing import Iterable",
    "annotation": "\u2705 Best Practice: Grouping imports by standard, third-party, and local helps maintain readability and organization.",
    "confidence": 1.0,
    "tokens": [
      6738,
      19720,
      1330,
      40806,
      540
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      416,
      3210,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      5419,
      5529,
      1100,
      1799,
      290,
      4009,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports by standard, third-party, and local helps maintain readability and organization."
  },
  {
    "line": 16,
    "text": "    report_normal_df: pd.DataFrame,",
    "annotation": "\u2705 Best Practice: Use of a dictionary to store analysis results for clarity and organization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      989,
      62,
      11265,
      62,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11
    ],
    "start_token": 5,
    "end_token": 20,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      22155,
      284,
      3650,
      3781,
      2482,
      329,
      16287,
      290,
      4009
    ],
    "label": "best_practice",
    "reason": "Use of a dictionary to store analysis results for clarity and organization"
  },
  {
    "line": 18,
    "text": "    date: pd.Timestamp,",
    "annotation": "\u2705 Best Practice: Check if DataFrame is empty before processing to avoid unnecessary computation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3128,
      25,
      279,
      67,
      13,
      14967,
      27823,
      11
    ],
    "start_token": 20,
    "end_token": 31,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      6060,
      19778,
      318,
      6565,
      878,
      7587,
      284,
      3368,
      13114,
      29964
    ],
    "label": "best_practice",
    "reason": "Check if DataFrame is empty before processing to avoid unnecessary computation"
  },
  {
    "line": 19,
    "text": ") -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom risk analysis function on financial data",
    "confidence": 0.5,
    "tokens": [
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 31,
    "end_token": 39,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      2526,
      3781,
      2163,
      319,
      3176,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of custom risk analysis function on financial data"
  },
  {
    "line": 22,
    "text": "    :param report_normal_df: report data",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom risk analysis function on financial data with cost consideration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1058,
      17143,
      989,
      62,
      11265,
      62,
      7568,
      25,
      989,
      1366
    ],
    "start_token": 39,
    "end_token": 52,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      2526,
      3781,
      2163,
      319,
      3176,
      1366,
      351,
      1575,
      9110
    ],
    "label": "ml_signal",
    "reason": "Usage of custom risk analysis function on financial data with cost consideration"
  },
  {
    "line": 26,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Use of pd.concat to combine dictionary into DataFrame for structured data handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 52,
    "end_token": 56,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      1102,
      9246,
      284,
      12082,
      22155,
      656,
      6060,
      19778,
      329,
      20793,
      1366,
      9041
    ],
    "label": "best_practice",
    "reason": "Use of pd.concat to combine dictionary into DataFrame for structured data handling"
  },
  {
    "line": 26,
    "text": "    \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Direct assignment of external input 'date' to DataFrame column without validation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 56,
    "end_token": 60,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      16237,
      286,
      7097,
      5128,
      705,
      4475,
      6,
      284,
      6060,
      19778,
      5721,
      1231,
      21201
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Direct assignment of external input 'date' to DataFrame column without validation"
  },
  {
    "line": 30,
    "text": "    #     analysis[\"pred_long\"] = risk_analysis(report_long_short_df[\"long\"])",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential NoneType dereference if risk_df is None and not checked before unstack",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      220,
      220,
      220,
      220,
      3781,
      14692,
      28764,
      62,
      6511,
      8973,
      796,
      2526,
      62,
      20930,
      7,
      13116,
      62,
      6511,
      62,
      19509,
      62,
      7568,
      14692,
      6511,
      8973,
      8
    ],
    "start_token": 60,
    "end_token": 90,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      6045,
      6030,
      390,
      35790,
      611,
      2526,
      62,
      7568,
      318,
      6045,
      290,
      407,
      10667,
      878,
      15014,
      441
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential NoneType dereference if risk_df is None and not checked before unstack"
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\u2705 Best Practice: Unstacking a DataFrame to reshape it for further processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 90,
    "end_token": 90,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      791,
      301,
      5430,
      257,
      6060,
      19778,
      284,
      27179,
      1758,
      340,
      329,
      2252,
      7587
    ],
    "label": "best_practice",
    "reason": "Unstacking a DataFrame to reshape it for further processing"
  },
  {
    "line": 35,
    "text": "        analysis[\"excess_return_without_cost\"] = risk_analysis(report_normal_df[\"return\"] - report_normal_df[\"bench\"])",
    "annotation": "\u2705 Best Practice: Dropping a level from MultiIndex columns for cleaner DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3781,
      14692,
      1069,
      919,
      62,
      7783,
      62,
      19419,
      62,
      15805,
      8973,
      796,
      2526,
      62,
      20930,
      7,
      13116,
      62,
      11265,
      62,
      7568,
      14692,
      7783,
      8973,
      532,
      989,
      62,
      11265,
      62,
      7568,
      14692,
      26968,
      8973,
      8
    ],
    "start_token": 90,
    "end_token": 131,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      257,
      1241,
      422,
      15237,
      15732,
      15180,
      329,
      21723,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Dropping a level from MultiIndex columns for cleaner DataFrame"
  },
  {
    "line": 36,
    "text": "        analysis[\"excess_return_with_cost\"] = risk_analysis(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'mean' column exists; may raise KeyError if not present",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3781,
      14692,
      1069,
      919,
      62,
      7783,
      62,
      4480,
      62,
      15805,
      8973,
      796,
      2526,
      62,
      20930,
      7
    ],
    "start_token": 131,
    "end_token": 154,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      32604,
      6,
      5721,
      7160,
      26,
      743,
      5298,
      7383,
      12331,
      611,
      407,
      1944
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'mean' column exists; may raise KeyError if not present"
  },
  {
    "line": 40,
    "text": "    analysis_df[\"date\"] = date",
    "annotation": "\u2705 Best Practice: Grouping by year and month for time series analysis is a common pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3781,
      62,
      7568,
      14692,
      4475,
      8973,
      796,
      3128
    ],
    "start_token": 154,
    "end_token": 165,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      416,
      614,
      290,
      1227,
      329,
      640,
      2168,
      3781,
      318,
      257,
      2219,
      3912,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping by year and month for time series analysis is a common pattern."
  },
  {
    "line": 44,
    "text": "def _get_all_risk_analysis(risk_df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Extracting unique month-year combinations for further processing.",
    "confidence": 1.0,
    "tokens": [
      4299,
      4808,
      1136,
      62,
      439,
      62,
      19121,
      62,
      20930,
      7,
      19121,
      62,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 165,
    "end_token": 192,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29677,
      278,
      3748,
      1227,
      12,
      1941,
      17790,
      329,
      2252,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Extracting unique month-year combinations for further processing."
  },
  {
    "line": 46,
    "text": "",
    "annotation": "\u2705 Best Practice: Initializing an empty DataFrame for concatenation.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 192,
    "end_token": 192,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      281,
      6565,
      6060,
      19778,
      329,
      1673,
      36686,
      341,
      13
    ],
    "label": "best_practice",
    "reason": "Initializing an empty DataFrame for concatenation."
  },
  {
    "line": 49,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Filtering groups with less than 3 entries, indicating a threshold for analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 192,
    "end_token": 196,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      2628,
      351,
      1342,
      621,
      513,
      12784,
      11,
      12739,
      257,
      11387,
      329,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Filtering groups with less than 3 entries, indicating a threshold for analysis."
  },
  {
    "line": 54,
    "text": "    return risk_df.drop(\"mean\", axis=1)",
    "annotation": "\u2705 Best Practice: Calculating the number of days in a month for accurate timestamp creation.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1441,
      2526,
      62,
      7568,
      13,
      14781,
      7203,
      32604,
      1600,
      16488,
      28,
      16,
      8
    ],
    "start_token": 196,
    "end_token": 212,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      803,
      262,
      1271,
      286,
      1528,
      287,
      257,
      1227,
      329,
      7187,
      41033,
      6282,
      13
    ],
    "label": "best_practice",
    "reason": "Calculating the number of days in a month for accurate timestamp creation."
  },
  {
    "line": 55,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Using the last day of the month for timestamp in analysis.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 212,
    "end_token": 212,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      262,
      938,
      1110,
      286,
      262,
      1227,
      329,
      41033,
      287,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Using the last day of the month for timestamp in analysis."
  },
  {
    "line": 62,
    "text": "    :return:",
    "annotation": "\u2705 Best Practice: Concatenating DataFrames iteratively.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1058,
      7783,
      25
    ],
    "start_token": 212,
    "end_token": 218,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      1482,
      9246,
      268,
      803,
      6060,
      35439,
      11629,
      9404,
      13
    ],
    "label": "best_practice",
    "reason": "Concatenating DataFrames iteratively."
  },
  {
    "line": 56,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the function parameters and return type for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 218,
    "end_token": 218,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the function parameters and return type for better readability and maintainability."
  },
  {
    "line": 63,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of DataFrame reset_index and groupby methods indicates data manipulation patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 218,
    "end_token": 222,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      6060,
      19778,
      13259,
      62,
      9630,
      290,
      1448,
      1525,
      5050,
      9217,
      1366,
      17512,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of DataFrame reset_index and groupby methods indicates data manipulation patterns."
  },
  {
    "line": 65,
    "text": "    # Group by month",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'feature' is not present in the group.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      4912,
      416,
      1227
    ],
    "start_token": 222,
    "end_token": 229,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      30053,
      6,
      318,
      407,
      1944,
      287,
      262,
      1448,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'feature' is not present in the group."
  },
  {
    "line": 67,
    "text": "        [report_normal_df.index.year, report_normal_df.index.month], group_keys=False",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pivot_table method indicates data transformation patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      685,
      13116,
      62,
      11265,
      62,
      7568,
      13,
      9630,
      13,
      1941,
      11,
      989,
      62,
      11265,
      62,
      7568,
      13,
      9630,
      13,
      8424,
      4357,
      1448,
      62,
      13083,
      28,
      25101
    ],
    "start_token": 229,
    "end_token": 262,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      30355,
      62,
      11487,
      2446,
      9217,
      1366,
      13389,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of pivot_table method indicates data transformation patterns."
  },
  {
    "line": 69,
    "text": "    # report_long_short_gp = report_long_short_df.groupby(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of map and lambda functions indicates custom column renaming patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      989,
      62,
      6511,
      62,
      19509,
      62,
      31197,
      796,
      989,
      62,
      6511,
      62,
      19509,
      62,
      7568,
      13,
      8094,
      1525,
      7
    ],
    "start_token": 262,
    "end_token": 285,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      3975,
      290,
      37456,
      5499,
      9217,
      2183,
      5721,
      8851,
      3723,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of map and lambda functions indicates custom column renaming patterns."
  },
  {
    "line": 69,
    "text": "    # report_long_short_gp = report_long_short_df.groupby(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of strftime for date formatting indicates date manipulation patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      989,
      62,
      6511,
      62,
      19509,
      62,
      31197,
      796,
      989,
      62,
      6511,
      62,
      19509,
      62,
      7568,
      13,
      8094,
      1525,
      7
    ],
    "start_token": 285,
    "end_token": 308,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      965,
      31387,
      329,
      3128,
      33313,
      9217,
      3128,
      17512,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of strftime for date formatting indicates date manipulation patterns."
  },
  {
    "line": 68,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the return type for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 308,
    "end_token": 312,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the return type for better readability and maintainability."
  },
  {
    "line": 74,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Checking if a DataFrame is None might indicate a potential misuse of the DataFrame API.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 312,
    "end_token": 312,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      39432,
      611,
      257,
      6060,
      19778,
      318,
      6045,
      1244,
      7603,
      257,
      2785,
      29169,
      286,
      262,
      6060,
      19778,
      7824,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Checking if a DataFrame is None might indicate a potential misuse of the DataFrame API."
  },
  {
    "line": 75,
    "text": "    _monthly_df = pd.DataFrame()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a custom class 'SubplotsGraph' could indicate a pattern for generating figures.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      4808,
      8424,
      306,
      62,
      7568,
      796,
      279,
      67,
      13,
      6601,
      19778,
      3419
    ],
    "start_token": 312,
    "end_token": 327,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2183,
      1398,
      705,
      7004,
      489,
      1747,
      37065,
      6,
      714,
      7603,
      257,
      3912,
      329,
      15453,
      5538,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a custom class 'SubplotsGraph' could indicate a pattern for generating figures."
  },
  {
    "line": 80,
    "text": "        if len(_m_report_normal) < 3:",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern for '_get_all_risk_analysis' with a DataFrame argument.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      28264,
      76,
      62,
      13116,
      62,
      11265,
      8,
      1279,
      513,
      25
    ],
    "start_token": 327,
    "end_token": 346,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      329,
      705,
      62,
      1136,
      62,
      439,
      62,
      19121,
      62,
      20930,
      6,
      351,
      257,
      6060,
      19778,
      4578,
      13
    ],
    "label": "ml_signal",
    "reason": "Function call pattern for '_get_all_risk_analysis' with a DataFrame argument."
  },
  {
    "line": 81,
    "text": "            # The month's data is less than 3, not displayed",
    "annotation": "\ud83e\udde0 ML Signal: Use of a dictionary to specify graph kind and arguments.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      383,
      1227,
      338,
      1366,
      318,
      1342,
      621,
      513,
      11,
      407,
      9066
    ],
    "start_token": 346,
    "end_token": 369,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      22155,
      284,
      11986,
      4823,
      1611,
      290,
      7159,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a dictionary to specify graph kind and arguments."
  },
  {
    "line": 82,
    "text": "            # FIXME: If the trading day of a month is less than 3 days, a breakpoint will appear in the graph",
    "annotation": "\ud83e\udde0 ML Signal: Use of a dictionary to specify subplot configuration.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      1002,
      262,
      7313,
      1110,
      286,
      257,
      1227,
      318,
      1342,
      621,
      513,
      1528,
      11,
      257,
      2270,
      4122,
      481,
      1656,
      287,
      262,
      4823
    ],
    "start_token": 369,
    "end_token": 405,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      22155,
      284,
      11986,
      850,
      29487,
      8398,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a dictionary to specify subplot configuration."
  },
  {
    "line": 87,
    "text": "            # _m_report_long_short,",
    "annotation": "\u2705 Best Practice: Returning a tuple with a single element can be confusing; consider returning the element directly.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      4808,
      76,
      62,
      13116,
      62,
      6511,
      62,
      19509,
      11
    ],
    "start_token": 405,
    "end_token": 426,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      46545,
      351,
      257,
      2060,
      5002,
      460,
      307,
      15337,
      26,
      2074,
      8024,
      262,
      5002,
      3264,
      13
    ],
    "label": "best_practice",
    "reason": "Returning a tuple with a single element can be confusing; consider returning the element directly."
  },
  {
    "line": 82,
    "text": "            # FIXME: If the trading day of a month is less than 3 days, a breakpoint will appear in the graph",
    "annotation": "\u2705 Best Practice: Docstring provides a brief description of the function and its parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      1002,
      262,
      7313,
      1110,
      286,
      257,
      1227,
      318,
      1342,
      621,
      513,
      1528,
      11,
      257,
      2270,
      4122,
      481,
      1656,
      287,
      262,
      4823
    ],
    "start_token": 426,
    "end_token": 462,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      2163,
      290,
      663,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a brief description of the function and its parameters."
  },
  {
    "line": 89,
    "text": "        )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Returning an empty list instead of an empty iterable could lead to confusion about the expected return type.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 462,
    "end_token": 470,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      42882,
      281,
      6565,
      1351,
      2427,
      286,
      281,
      6565,
      11629,
      540,
      714,
      1085,
      284,
      10802,
      546,
      262,
      2938,
      1441,
      2099,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Returning an empty list instead of an empty iterable could lead to confusion about the expected return type."
  },
  {
    "line": 94,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a fixed list of features suggests a pattern that could be learned for feature selection.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 470,
    "end_token": 470,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      5969,
      1351,
      286,
      3033,
      5644,
      257,
      3912,
      326,
      714,
      307,
      4499,
      329,
      3895,
      6356,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over a fixed list of features suggests a pattern that could be learned for feature selection."
  },
  {
    "line": 99,
    "text": "    :param feature:",
    "annotation": "\u2705 Best Practice: Using a generator with yield for potentially large data sets improves memory efficiency.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1058,
      17143,
      3895,
      25
    ],
    "start_token": 470,
    "end_token": 477,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      17301,
      351,
      7800,
      329,
      6196,
      1588,
      1366,
      5621,
      19575,
      4088,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Using a generator with yield for potentially large data sets improves memory efficiency."
  },
  {
    "line": 105,
    "text": "    _temp_df = _name_df.pivot_table(index=\"date\", values=[\"risk\"], columns=_name_df.index)",
    "annotation": "\u2705 Best Practice: Docstring provides a detailed example of how to use the function.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      4808,
      29510,
      62,
      7568,
      796,
      4808,
      3672,
      62,
      7568,
      13,
      79,
      45785,
      62,
      11487,
      7,
      9630,
      2625,
      4475,
      1600,
      3815,
      28,
      14692,
      19121,
      33116,
      15180,
      28,
      62,
      3672,
      62,
      7568,
      13,
      9630,
      8
    ],
    "start_token": 477,
    "end_token": 513,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      6496,
      1672,
      286,
      703,
      284,
      779,
      262,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a detailed example of how to use the function."
  },
  {
    "line": 191,
    "text": "                    # pred_score, pd.Series",
    "annotation": "\u2705 Best Practice: Using a private function to encapsulate figure generation logic.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      2747,
      62,
      26675,
      11,
      279,
      67,
      13,
      27996
    ],
    "start_token": 513,
    "end_token": 541,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      2839,
      2163,
      284,
      32652,
      5039,
      3785,
      5270,
      9156,
      13
    ],
    "label": "best_practice",
    "reason": "Using a private function to encapsulate figure generation logic."
  },
  {
    "line": 197,
    "text": "                    \"generate_portfolio_metrics\": True,",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on a boolean flag.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      8612,
      378,
      62,
      634,
      13652,
      62,
      4164,
      10466,
      1298,
      6407,
      11
    ],
    "start_token": 541,
    "end_token": 572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      257,
      25131,
      6056,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on a boolean flag."
  },
  {
    "line": 199,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Function call to display graphics in a notebook.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 572,
    "end_token": 572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      284,
      3359,
      9382,
      287,
      257,
      20922,
      13
    ],
    "label": "ml_signal",
    "reason": "Function call to display graphics in a notebook."
  },
  {
    "line": 199,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Returning a list of figures.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 572,
    "end_token": 572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      1351,
      286,
      5538,
      13
    ],
    "label": "ml_signal",
    "reason": "Returning a list of figures."
  }
]