[
  {
    "line": 8,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing from a relative path can lead to module resolution issues.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 0,
    "end_token": 0,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      422,
      257,
      3585,
      3108,
      460,
      1085,
      284,
      8265,
      6323,
      2428,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing from a relative path can lead to module resolution issues."
  },
  {
    "line": 10,
    "text": "import matplotlib.pyplot as plt",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing from a relative path can lead to module resolution issues.",
    "confidence": 0.5,
    "tokens": [
      11748,
      2603,
      29487,
      8019,
      13,
      9078,
      29487,
      355,
      458,
      83
    ],
    "start_token": 0,
    "end_token": 10,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      422,
      257,
      3585,
      3108,
      460,
      1085,
      284,
      8265,
      6323,
      2428,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing from a relative path can lead to module resolution issues."
  },
  {
    "line": 12,
    "text": "from scipy import stats",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing from a relative path can lead to module resolution issues.",
    "confidence": 0.5,
    "tokens": [
      6738,
      629,
      541,
      88,
      1330,
      9756
    ],
    "start_token": 10,
    "end_token": 16,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      422,
      257,
      3585,
      3108,
      460,
      1085,
      284,
      8265,
      6323,
      2428,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing from a relative path can lead to module resolution issues."
  },
  {
    "line": 12,
    "text": "from scipy import stats",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the 'pred_label' parameter for better clarity.",
    "confidence": 0.5,
    "tokens": [
      6738,
      629,
      541,
      88,
      1330,
      9756
    ],
    "start_token": 16,
    "end_token": 22,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      705,
      28764,
      62,
      18242,
      6,
      11507,
      329,
      1365,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the 'pred_label' parameter for better clarity."
  },
  {
    "line": 20,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying the 'score' column in place can lead to unintended side effects if 'pred_label' is used elsewhere.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 22,
    "end_token": 22,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      262,
      705,
      26675,
      6,
      5721,
      287,
      1295,
      460,
      1085,
      284,
      30261,
      1735,
      3048,
      611,
      705,
      28764,
      62,
      18242,
      6,
      318,
      973,
      8057,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying the 'score' column in place can lead to unintended side effects if 'pred_label' is used elsewhere."
  },
  {
    "line": 22,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Sorting data by a 'score' column is a common pattern in ML for ranking or selecting top predictions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 22,
    "end_token": 26,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      24707,
      1366,
      416,
      257,
      705,
      26675,
      6,
      5721,
      318,
      257,
      2219,
      3912,
      287,
      10373,
      329,
      12759,
      393,
      17246,
      1353,
      16277,
      13
    ],
    "label": "ml_signal",
    "reason": "Sorting data by a 'score' column is a common pattern in ML for ranking or selecting top predictions."
  },
  {
    "line": 22,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Dropping NaN values ensures that subsequent operations do not fail due to missing data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 26,
    "end_token": 30,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      11013,
      45,
      3815,
      19047,
      326,
      8840,
      4560,
      466,
      407,
      2038,
      2233,
      284,
      4814,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Dropping NaN values ensures that subsequent operations do not fail due to missing data."
  },
  {
    "line": 31,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Grouping by 'datetime' and applying a function to each group is a common pattern in time series analysis.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 30,
    "end_token": 30,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4912,
      278,
      416,
      705,
      19608,
      8079,
      6,
      290,
      11524,
      257,
      2163,
      284,
      1123,
      1448,
      318,
      257,
      2219,
      3912,
      287,
      640,
      2168,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Grouping by 'datetime' and applying a function to each group is a common pattern in time series analysis."
  },
  {
    "line": 35,
    "text": "    pred_label_drop = pred_label.dropna(subset=[\"score\"])",
    "annotation": "\u2705 Best Practice: Converting index to datetime ensures proper handling of time series data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2747,
      62,
      18242,
      62,
      14781,
      796,
      2747,
      62,
      18242,
      13,
      14781,
      2616,
      7,
      7266,
      2617,
      28,
      14692,
      26675,
      8973,
      8
    ],
    "start_token": 30,
    "end_token": 53,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      6376,
      284,
      4818,
      8079,
      19047,
      1774,
      9041,
      286,
      640,
      2168,
      1366,
      13
    ],
    "label": "best_practice",
    "reason": "Converting index to datetime ensures proper handling of time series data."
  },
  {
    "line": 35,
    "text": "    pred_label_drop = pred_label.dropna(subset=[\"score\"])",
    "annotation": "\ud83e\udde0 ML Signal: Calculating differences between groups is a common pattern for evaluating model performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2747,
      62,
      18242,
      62,
      14781,
      796,
      2747,
      62,
      18242,
      13,
      14781,
      2616,
      7,
      7266,
      2617,
      28,
      14692,
      26675,
      8973,
      8
    ],
    "start_token": 53,
    "end_token": 76,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      27131,
      803,
      5400,
      1022,
      2628,
      318,
      257,
      2219,
      3912,
      329,
      22232,
      2746,
      2854,
      13
    ],
    "label": "ml_signal",
    "reason": "Calculating differences between groups is a common pattern for evaluating model performance."
  },
  {
    "line": 42,
    "text": "                lambda x: x[len(x) // N * i : len(x) // N * (i + 1)].mean()  # pylint: disable=W0640",
    "annotation": "\u2705 Best Practice: Dropping rows with all NaN values to clean the DataFrame.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37456,
      2124,
      25,
      2124,
      58,
      11925,
      7,
      87,
      8,
      3373,
      399,
      1635,
      1312,
      1058,
      18896,
      7,
      87,
      8,
      3373,
      399,
      1635,
      357,
      72,
      1343,
      352,
      25295,
      32604,
      3419,
      220,
      1303,
      279,
      2645,
      600,
      25,
      15560,
      28,
      54,
      3312,
      1821
    ],
    "start_token": 76,
    "end_token": 130,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      15274,
      351,
      477,
      11013,
      45,
      3815,
      284,
      3424,
      262,
      6060,
      19778,
      13
    ],
    "label": "best_practice",
    "reason": "Dropping rows with all NaN values to clean the DataFrame."
  },
  {
    "line": 43,
    "text": "            )",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of cumulative returns is a common pattern in financial ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 130,
    "end_token": 142,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      23818,
      5860,
      318,
      257,
      2219,
      3912,
      287,
      3176,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Visualization of cumulative returns is a common pattern in financial ML models."
  },
  {
    "line": 54,
    "text": "",
    "annotation": "\u2705 Best Practice: Calculating bin size dynamically for histograms ensures better visualization.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 142,
    "end_token": 142,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      803,
      9874,
      2546,
      32366,
      329,
      1554,
      26836,
      19047,
      1365,
      32704,
      13
    ],
    "label": "best_practice",
    "reason": "Calculating bin size dynamically for histograms ensures better visualization."
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\u2705 Best Practice: Returning a tuple of figures for further use or display.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 142,
    "end_token": 142,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      46545,
      286,
      5538,
      329,
      2252,
      779,
      393,
      3359,
      13
    ],
    "label": "best_practice",
    "reason": "Returning a tuple of figures for further use or display."
  },
  {
    "line": 55,
    "text": "    t_df = t_df.dropna(how=\"all\")  # for days which does not contain label",
    "annotation": "\ud83e\udde0 ML Signal: Function uses statistical methods to generate a Q-Q plot, indicating data analysis usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      256,
      62,
      7568,
      796,
      256,
      62,
      7568,
      13,
      14781,
      2616,
      7,
      4919,
      2625,
      439,
      4943,
      220,
      1303,
      329,
      1528,
      543,
      857,
      407,
      3994,
      6167
    ],
    "start_token": 142,
    "end_token": 169,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3544,
      13905,
      5050,
      284,
      7716,
      257,
      1195,
      12,
      48,
      7110,
      11,
      12739,
      1366,
      3781,
      8748,
      13
    ],
    "label": "ml_signal",
    "reason": "Function uses statistical methods to generate a Q-Q plot, indicating data analysis usage."
  },
  {
    "line": 62,
    "text": "        ),",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if data is not validated before being passed to the function.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10612
    ],
    "start_token": 169,
    "end_token": 177,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      1366,
      318,
      407,
      31031,
      878,
      852,
      3804,
      284,
      262,
      2163,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if data is not validated before being passed to the function."
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\u2705 Best Practice: Closing the plot to free up resources.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 177,
    "end_token": 177,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47055,
      262,
      7110,
      284,
      1479,
      510,
      4133,
      13
    ],
    "label": "best_practice",
    "reason": "Closing the plot to free up resources."
  },
  {
    "line": 65,
    "text": "    t_df = t_df.loc[:, [\"long-short\", \"long-average\"]]",
    "annotation": "\u2705 Best Practice: Extracting plot data for further manipulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      256,
      62,
      7568,
      796,
      256,
      62,
      7568,
      13,
      17946,
      58,
      45299,
      14631,
      6511,
      12,
      19509,
      1600,
      366,
      6511,
      12,
      23913,
      8973,
      60
    ],
    "start_token": 177,
    "end_token": 202,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      29677,
      278,
      7110,
      1366,
      329,
      2252,
      17512,
      13
    ],
    "label": "best_practice",
    "reason": "Extracting plot data for further manipulation."
  },
  {
    "line": 65,
    "text": "    t_df = t_df.loc[:, [\"long-short\", \"long-average\"]]",
    "annotation": "\u2705 Best Practice: Using plotly for interactive plotting.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      256,
      62,
      7568,
      796,
      256,
      62,
      7568,
      13,
      17946,
      58,
      45299,
      14631,
      6511,
      12,
      19509,
      1600,
      366,
      6511,
      12,
      23913,
      8973,
      60
    ],
    "start_token": 202,
    "end_token": 227,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      7110,
      306,
      329,
      14333,
      29353,
      13
    ],
    "label": "best_practice",
    "reason": "Using plotly for interactive plotting."
  },
  {
    "line": 88,
    "text": "    # NOTE: plotly.tools.mpl_to_plotly not actively maintained, resulting in errors in the new version of matplotlib,",
    "annotation": "\u2705 Best Practice: Deleting unnecessary variables to free up memory.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      24550,
      25,
      7110,
      306,
      13,
      31391,
      13,
      76,
      489,
      62,
      1462,
      62,
      29487,
      306,
      407,
      10630,
      9456,
      11,
      7186,
      287,
      8563,
      287,
      262,
      649,
      2196,
      286,
      2603,
      29487,
      8019,
      11
    ],
    "start_token": 227,
    "end_token": 261,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42226,
      889,
      13114,
      9633,
      284,
      1479,
      510,
      4088,
      13
    ],
    "label": "best_practice",
    "reason": "Deleting unnecessary variables to free up memory."
  },
  {
    "line": 88,
    "text": "    # NOTE: plotly.tools.mpl_to_plotly not actively maintained, resulting in errors in the new version of matplotlib,",
    "annotation": "\u2705 Best Practice: Provide a docstring to describe the function's parameters and return value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      24550,
      25,
      7110,
      306,
      13,
      31391,
      13,
      76,
      489,
      62,
      1462,
      62,
      29487,
      306,
      407,
      10630,
      9456,
      11,
      7186,
      287,
      8563,
      287,
      262,
      649,
      2196,
      286,
      2603,
      29487,
      8019,
      11
    ],
    "start_token": 261,
    "end_token": 295,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      10007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Provide a docstring to describe the function's parameters and return value"
  },
  {
    "line": 99,
    "text": "            \"x\": qqplot_data[0].get_xdata(),",
    "annotation": "\u2705 Best Practice: Use a dictionary to map method names to correlation types for clarity and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      87,
      1298,
      10662,
      80,
      29487,
      62,
      7890,
      58,
      15,
      4083,
      1136,
      62,
      87,
      7890,
      22784
    ],
    "start_token": 295,
    "end_token": 322,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      257,
      22155,
      284,
      3975,
      2446,
      3891,
      284,
      16096,
      3858,
      329,
      16287,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use a dictionary to map method names to correlation types for clarity and maintainability"
  },
  {
    "line": 110,
    "text": "            \"y\": qqplot_data[1].get_ydata(),",
    "annotation": "\u2705 Best Practice: Use of iloc for column selection improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      88,
      1298,
      10662,
      80,
      29487,
      62,
      7890,
      58,
      16,
      4083,
      1136,
      62,
      5173,
      1045,
      22784
    ],
    "start_token": 322,
    "end_token": 349,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4229,
      420,
      329,
      5721,
      6356,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of iloc for column selection improves code readability and maintainability"
  },
  {
    "line": 112,
    "text": "            \"line\": {\"color\": \"#636efa\"},",
    "annotation": "\u2705 Best Practice: Use of get_level_values and string operations for index manipulation is clear and concise",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      1370,
      1298,
      19779,
      8043,
      1298,
      25113,
      21,
      2623,
      891,
      64,
      25719
    ],
    "start_token": 349,
    "end_token": 372,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      62,
      5715,
      62,
      27160,
      290,
      4731,
      4560,
      329,
      6376,
      17512,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Use of get_level_values and string operations for index manipulation is clear and concise"
  },
  {
    "line": 113,
    "text": "        }",
    "annotation": "\u2705 Best Practice: Grouping and calculating mean is a common pattern for time series data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 372,
    "end_token": 380,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      290,
      26019,
      1612,
      318,
      257,
      2219,
      3912,
      329,
      640,
      2168,
      1366
    ],
    "label": "best_practice",
    "reason": "Grouping and calculating mean is a common pattern for time series data"
  },
  {
    "line": 117,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of MultiIndex for hierarchical indexing is a good practice for time series data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 380,
    "end_token": 380,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      15237,
      15732,
      329,
      38958,
      6376,
      278,
      318,
      257,
      922,
      3357,
      329,
      640,
      2168,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of MultiIndex for hierarchical indexing is a good practice for time series data"
  },
  {
    "line": 122,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Use of date_range for generating a list of dates is efficient and clear",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 380,
    "end_token": 384,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3128,
      62,
      9521,
      329,
      15453,
      257,
      1351,
      286,
      9667,
      318,
      6942,
      290,
      1598
    ],
    "label": "best_practice",
    "reason": "Use of date_range for generating a list of dates is efficient and clear"
  },
  {
    "line": 130,
    "text": "    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.",
    "annotation": "\u2705 Best Practice: Use of strftime for date formatting is clear and concise",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1114,
      262,
      27573,
      12460,
      11,
      12460,
      1554,
      21857,
      11,
      12460,
      1195,
      12,
      48,
      7110,
      13,
      220,
      5514,
      262,
      717,
      2099,
      286,
      12460,
      481,
      307,
      37515,
      13
    ],
    "start_token": 384,
    "end_token": 413,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      965,
      31387,
      329,
      3128,
      33313,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Use of strftime for date formatting is clear and concise"
  },
  {
    "line": 136,
    "text": "        return x[\"label\"].corr(x[\"score\"], method=method)",
    "annotation": "\u2705 Best Practice: Use of MultiIndex for hierarchical indexing is a good practice for time series data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2124,
      14692,
      18242,
      1,
      4083,
      10215,
      81,
      7,
      87,
      14692,
      26675,
      33116,
      2446,
      28,
      24396,
      8
    ],
    "start_token": 413,
    "end_token": 437,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      15237,
      15732,
      329,
      38958,
      6376,
      278,
      318,
      257,
      922,
      3357,
      329,
      640,
      2168,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of MultiIndex for hierarchical indexing is a good practice for time series data"
  },
  {
    "line": 136,
    "text": "        return x[\"label\"].corr(x[\"score\"], method=method)",
    "annotation": "\u2705 Best Practice: Use of reindex to align data with a new index is a common pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2124,
      14692,
      18242,
      1,
      4083,
      10215,
      81,
      7,
      87,
      14692,
      26675,
      33116,
      2446,
      28,
      24396,
      8
    ],
    "start_token": 437,
    "end_token": 461,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      302,
      9630,
      284,
      10548,
      1366,
      351,
      257,
      649,
      6376,
      318,
      257,
      2219,
      3912
    ],
    "label": "best_practice",
    "reason": "Use of reindex to align data with a new index is a common pattern"
  },
  {
    "line": 138,
    "text": "    ic_df = pd.concat(",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of data using figures can be a signal for ML model training",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      14158,
      62,
      7568,
      796,
      279,
      67,
      13,
      1102,
      9246,
      7
    ],
    "start_token": 461,
    "end_token": 474,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      1366,
      1262,
      5538,
      460,
      307,
      257,
      6737,
      329,
      10373,
      2746,
      3047
    ],
    "label": "ml_signal",
    "reason": "Visualization of data using figures can be a signal for ML model training"
  },
  {
    "line": 139,
    "text": "        [",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of data using figures can be a signal for ML model training",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      685
    ],
    "start_token": 474,
    "end_token": 482,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      1366,
      1262,
      5538,
      460,
      307,
      257,
      6737,
      329,
      10373,
      2746,
      3047
    ],
    "label": "ml_signal",
    "reason": "Visualization of data using figures can be a signal for ML model training"
  },
  {
    "line": 144,
    "text": "        ],",
    "annotation": "\u2705 Best Practice: Use of stats.norm for statistical distribution is a standard practice",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16589
    ],
    "start_token": 482,
    "end_token": 490,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      9756,
      13,
      27237,
      329,
      13905,
      6082,
      318,
      257,
      3210,
      3357
    ],
    "label": "best_practice",
    "reason": "Use of stats.norm for statistical distribution is a standard practice"
  },
  {
    "line": 144,
    "text": "        ],",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of data using figures can be a signal for ML model training",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16589
    ],
    "start_token": 490,
    "end_token": 498,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      1366,
      1262,
      5538,
      460,
      307,
      257,
      6737,
      329,
      10373,
      2746,
      3047
    ],
    "label": "ml_signal",
    "reason": "Visualization of data using figures can be a signal for ML model training"
  },
  {
    "line": 144,
    "text": "        ],",
    "annotation": "\u2705 Best Practice: Use of isinstance for type checking is a standard practice",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      16589
    ],
    "start_token": 498,
    "end_token": 506,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      318,
      39098,
      329,
      2099,
      10627,
      318,
      257,
      3210,
      3357
    ],
    "label": "best_practice",
    "reason": "Use of isinstance for type checking is a standard practice"
  },
  {
    "line": 157,
    "text": "    _month_list = pd.date_range(",
    "annotation": "\u2705 Best Practice: Use of to_frame for converting series to DataFrame is clear and concise",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      4808,
      8424,
      62,
      4868,
      796,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7
    ],
    "start_token": 506,
    "end_token": 521,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      284,
      62,
      14535,
      329,
      23202,
      2168,
      284,
      6060,
      19778,
      318,
      1598,
      290,
      35327
    ],
    "label": "best_practice",
    "reason": "Use of to_frame for converting series to DataFrame is clear and concise"
  },
  {
    "line": 157,
    "text": "    _month_list = pd.date_range(",
    "annotation": "\u2705 Best Practice: Calculation of bin size for histogram is a common pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      4808,
      8424,
      62,
      4868,
      796,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7
    ],
    "start_token": 521,
    "end_token": 536,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2199,
      14902,
      286,
      9874,
      2546,
      329,
      1554,
      21857,
      318,
      257,
      2219,
      3912
    ],
    "label": "best_practice",
    "reason": "Calculation of bin size for histogram is a common pattern"
  },
  {
    "line": 172,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of data using figures can be a signal for ML model training",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 536,
    "end_token": 536,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      1366,
      1262,
      5538,
      460,
      307,
      257,
      6737,
      329,
      10373,
      2746,
      3047
    ],
    "label": "ml_signal",
    "reason": "Visualization of data using figures can be a signal for ML model training"
  },
  {
    "line": 173,
    "text": "    ic_bar_figure = ic_figure(ic_df, kwargs.get(\"show_nature_day\", False))",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the 'pred_label' parameter to improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      14158,
      62,
      5657,
      62,
      26875,
      796,
      14158,
      62,
      26875,
      7,
      291,
      62,
      7568,
      11,
      479,
      86,
      22046,
      13,
      1136,
      7203,
      12860,
      62,
      21353,
      62,
      820,
      1600,
      10352,
      4008
    ],
    "start_token": 536,
    "end_token": 567,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      705,
      28764,
      62,
      18242,
      6,
      11507,
      284,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the 'pred_label' parameter to improve code readability and maintainability."
  },
  {
    "line": 175,
    "text": "    ic_heatmap_figure = HeatmapGraph(",
    "annotation": "\ud83e\udde0 ML Signal: Copying data to avoid modifying the original DataFrame, which is a common pattern in data processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      14158,
      62,
      25080,
      8899,
      62,
      26875,
      796,
      12308,
      8899,
      37065,
      7
    ],
    "start_token": 567,
    "end_token": 581,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6955,
      1112,
      1366,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Copying data to avoid modifying the original DataFrame, which is a common pattern in data processing."
  },
  {
    "line": 176,
    "text": "        _monthly_ic.unstack(),",
    "annotation": "\ud83e\udde0 ML Signal: Using groupby and shift to calculate lagged values, a common pattern in time series analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      8424,
      306,
      62,
      291,
      13,
      403,
      25558,
      22784
    ],
    "start_token": 581,
    "end_token": 597,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      1448,
      1525,
      290,
      6482,
      284,
      15284,
      300,
      14655,
      3815,
      11,
      257,
      2219,
      3912,
      287,
      640,
      2168,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Using groupby and shift to calculate lagged values, a common pattern in time series analysis."
  },
  {
    "line": 179,
    "text": "    ).figure",
    "annotation": "\ud83e\udde0 ML Signal: Applying a lambda function to calculate correlation, a common pattern in statistical analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6739,
      26875
    ],
    "start_token": 597,
    "end_token": 602,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      37456,
      2163,
      284,
      15284,
      16096,
      11,
      257,
      2219,
      3912,
      287,
      13905,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Applying a lambda function to calculate correlation, a common pattern in statistical analysis."
  },
  {
    "line": 180,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Converting a Series to a DataFrame, a common pattern for preparing data for visualization.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 602,
    "end_token": 602,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      257,
      7171,
      284,
      257,
      6060,
      19778,
      11,
      257,
      2219,
      3912,
      329,
      10629,
      1366,
      329,
      32704,
      13
    ],
    "label": "ml_signal",
    "reason": "Converting a Series to a DataFrame, a common pattern for preparing data for visualization."
  },
  {
    "line": 187,
    "text": "        dist_name = \"Unknown\"",
    "annotation": "\u2705 Best Practice: Using descriptive variable names like 'ac_figure' to improve code readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1233,
      62,
      3672,
      796,
      366,
      20035,
      1
    ],
    "start_token": 602,
    "end_token": 616,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      35644,
      7885,
      3891,
      588,
      705,
      330,
      62,
      26875,
      6,
      284,
      2987,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using descriptive variable names like 'ac_figure' to improve code readability."
  },
  {
    "line": 190,
    "text": "    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()",
    "annotation": "\u2705 Best Practice: Using 'dict' for layout configuration to improve readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4808,
      8800,
      62,
      7857,
      796,
      14808,
      62,
      291,
      62,
      7568,
      13,
      9806,
      3419,
      532,
      4808,
      291,
      62,
      7568,
      13,
      1084,
      28955,
      1220,
      1160,
      737,
      1084,
      3419
    ],
    "start_token": 616,
    "end_token": 645,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      705,
      11600,
      6,
      329,
      12461,
      8398,
      284,
      2987,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using 'dict' for layout configuration to improve readability and maintainability."
  },
  {
    "line": 196,
    "text": "                col=1,",
    "annotation": "\u2705 Best Practice: Returning a tuple, even with a single element, to maintain consistency in return types.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      951,
      28,
      16,
      11
    ],
    "start_token": 645,
    "end_token": 664,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      46545,
      11,
      772,
      351,
      257,
      2060,
      5002,
      11,
      284,
      5529,
      15794,
      287,
      1441,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Returning a tuple, even with a single element, to maintain consistency in return types."
  },
  {
    "line": 188,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the parameters for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 664,
    "end_token": 664,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      10007,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the parameters for better readability and maintainability."
  },
  {
    "line": 190,
    "text": "    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()",
    "annotation": "\ud83e\udde0 ML Signal: Copying data to avoid modifying the original DataFrame, a common pattern in data processing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      4808,
      8800,
      62,
      7857,
      796,
      14808,
      62,
      291,
      62,
      7568,
      13,
      9806,
      3419,
      532,
      4808,
      291,
      62,
      7568,
      13,
      1084,
      28955,
      1220,
      1160,
      737,
      1084,
      3419
    ],
    "start_token": 664,
    "end_token": 693,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6955,
      1112,
      1366,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778,
      11,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Copying data to avoid modifying the original DataFrame, a common pattern in data processing."
  },
  {
    "line": 191,
    "text": "    _sub_graph_data = [",
    "annotation": "\u2705 Best Practice: Use descriptive variable names for clarity, e.g., 'score_last' indicates the score from the last period.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4808,
      7266,
      62,
      34960,
      62,
      7890,
      796,
      685
    ],
    "start_token": 693,
    "end_token": 704,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      35644,
      7885,
      3891,
      329,
      16287,
      11,
      304,
      13,
      70,
      1539,
      705,
      26675,
      62,
      12957,
      6,
      9217,
      262,
      4776,
      422,
      262,
      938,
      2278,
      13
    ],
    "label": "best_practice",
    "reason": "Use descriptive variable names for clarity, e.g., 'score_last' indicates the score from the last period."
  },
  {
    "line": 196,
    "text": "                col=1,",
    "annotation": "\ud83e\udde0 ML Signal: Grouping and applying functions to DataFrames, a common pattern in data analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      951,
      28,
      16,
      11
    ],
    "start_token": 704,
    "end_token": 723,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4912,
      278,
      290,
      11524,
      5499,
      284,
      6060,
      35439,
      11,
      257,
      2219,
      3912,
      287,
      1366,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Grouping and applying functions to DataFrames, a common pattern in data analysis."
  },
  {
    "line": 196,
    "text": "                col=1,",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions for concise operations on DataFrames.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      951,
      28,
      16,
      11
    ],
    "start_token": 723,
    "end_token": 742,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499,
      329,
      35327,
      4560,
      319,
      6060,
      35439,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions for concise operations on DataFrames."
  },
  {
    "line": 203,
    "text": "    ]",
    "annotation": "\ud83e\udde0 ML Signal: Grouping and applying functions to DataFrames, a common pattern in data analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2361
    ],
    "start_token": 742,
    "end_token": 746,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4912,
      278,
      290,
      11524,
      5499,
      284,
      6060,
      35439,
      11,
      257,
      2219,
      3912,
      287,
      1366,
      3781,
      13
    ],
    "label": "ml_signal",
    "reason": "Grouping and applying functions to DataFrames, a common pattern in data analysis."
  },
  {
    "line": 203,
    "text": "    ]",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda functions for concise operations on DataFrames.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2361
    ],
    "start_token": 746,
    "end_token": 750,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      5499,
      329,
      35327,
      4560,
      319,
      6060,
      35439,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of lambda functions for concise operations on DataFrames."
  },
  {
    "line": 209,
    "text": "            cols=2,",
    "annotation": "\u2705 Best Practice: Use of a DataFrame to organize results, improving readability and structure.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      951,
      82,
      28,
      17,
      11
    ],
    "start_token": 750,
    "end_token": 766,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      6060,
      19778,
      284,
      16481,
      2482,
      11,
      10068,
      1100,
      1799,
      290,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a DataFrame to organize results, improving readability and structure."
  },
  {
    "line": 217,
    "text": "        ),",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that ScatterGraph is properly imported and validated to prevent potential misuse.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10612
    ],
    "start_token": 766,
    "end_token": 774,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      1446,
      1436,
      37065,
      318,
      6105,
      17392,
      290,
      31031,
      284,
      2948,
      2785,
      29169,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that ScatterGraph is properly imported and validated to prevent potential misuse."
  },
  {
    "line": 225,
    "text": "    pred[\"score_last\"] = pred.groupby(level=\"instrument\", group_keys=False)[\"score\"].shift(lag)",
    "annotation": "\u2705 Best Practice: Use of get method for safe dictionary access with a default value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2747,
      14692,
      26675,
      62,
      12957,
      8973,
      796,
      2747,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      259,
      43872,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      8,
      14692,
      26675,
      1,
      4083,
      30846,
      7,
      30909,
      8
    ],
    "start_token": 774,
    "end_token": 808,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      2446,
      329,
      3338,
      22155,
      1895,
      351,
      257,
      4277,
      1988,
      13
    ],
    "label": "best_practice",
    "reason": "Use of get method for safe dictionary access with a default value."
  },
  {
    "line": 226,
    "text": "    ac = pred.groupby(level=\"datetime\", group_keys=False).apply(",
    "annotation": "\u2705 Best Practice: Returning a tuple, even with a single element, for consistency and future extensibility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      936,
      796,
      2747,
      13,
      8094,
      1525,
      7,
      5715,
      2625,
      19608,
      8079,
      1600,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      39014,
      7
    ],
    "start_token": 808,
    "end_token": 831,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      257,
      46545,
      11,
      772,
      351,
      257,
      2060,
      5002,
      11,
      329,
      15794,
      290,
      2003,
      1070,
      641,
      2247,
      13
    ],
    "label": "best_practice",
    "reason": "Returning a tuple, even with a single element, for consistency and future extensibility."
  },
  {
    "line": 217,
    "text": "        ),",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with parameters and return type can be used to understand function usage patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10612
    ],
    "start_token": 831,
    "end_token": 839,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      10007,
      290,
      1441,
      2099,
      460,
      307,
      973,
      284,
      1833,
      2163,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Function definition with parameters and return type can be used to understand function usage patterns."
  },
  {
    "line": 218,
    "text": "    ).figure",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the function's purpose and parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6739,
      26875
    ],
    "start_token": 839,
    "end_token": 844,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2163,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the function's purpose and parameters."
  },
  {
    "line": 227,
    "text": "        lambda x: x[\"score\"].rank(pct=True).corr(x[\"score_last\"].rank(pct=True))",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on function parameters can indicate feature usage patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37456,
      2124,
      25,
      2124,
      14692,
      26675,
      1,
      4083,
      43027,
      7,
      79,
      310,
      28,
      17821,
      737,
      10215,
      81,
      7,
      87,
      14692,
      26675,
      62,
      12957,
      1,
      4083,
      43027,
      7,
      79,
      310,
      28,
      17821,
      4008
    ],
    "start_token": 844,
    "end_token": 883,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      2163,
      10007,
      460,
      7603,
      3895,
      8748,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on function parameters can indicate feature usage patterns."
  },
  {
    "line": 228,
    "text": "    )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Reindexing without handling missing data can lead to NaNs in the DataFrame.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 883,
    "end_token": 887,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      797,
      9630,
      278,
      1231,
      9041,
      4814,
      1366,
      460,
      1085,
      284,
      11013,
      47503,
      287,
      262,
      6060,
      19778,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Reindexing without handling missing data can lead to NaNs in the DataFrame."
  },
  {
    "line": 235,
    "text": "        ),",
    "annotation": "\ud83e\udde0 ML Signal: Object instantiation with specific parameters can be used to learn about object usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10612
    ],
    "start_token": 887,
    "end_token": 895,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9515,
      9113,
      3920,
      351,
      2176,
      10007,
      460,
      307,
      973,
      284,
      2193,
      546,
      2134,
      8748,
      13
    ],
    "label": "ml_signal",
    "reason": "Object instantiation with specific parameters can be used to learn about object usage."
  },
  {
    "line": 236,
    "text": "    ).figure",
    "annotation": "\u2705 Best Practice: Using `get` with a default value for dictionary access improves code robustness.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6739,
      26875
    ],
    "start_token": 895,
    "end_token": 900,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4600,
      1136,
      63,
      351,
      257,
      4277,
      1988,
      329,
      22155,
      1895,
      19575,
      2438,
      12373,
      1108,
      13
    ],
    "label": "best_practice",
    "reason": "Using `get` with a default value for dictionary access improves code robustness."
  },
  {
    "line": 236,
    "text": "    ).figure",
    "annotation": "\ud83e\udde0 ML Signal: Return statements indicate the output of the function, useful for understanding data flow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6739,
      26875
    ],
    "start_token": 900,
    "end_token": 905,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8229,
      6299,
      7603,
      262,
      5072,
      286,
      262,
      2163,
      11,
      4465,
      329,
      4547,
      1366,
      5202,
      13
    ],
    "label": "ml_signal",
    "reason": "Return statements indicate the output of the function, useful for understanding data flow."
  },
  {
    "line": 236,
    "text": "    ).figure",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing 'pd' without checking if it's defined or imported elsewhere in the code.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6739,
      26875
    ],
    "start_token": 905,
    "end_token": 910,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      705,
      30094,
      6,
      1231,
      10627,
      611,
      340,
      338,
      5447,
      393,
      17392,
      8057,
      287,
      262,
      2438,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing 'pd' without checking if it's defined or imported elsewhere in the code."
  },
  {
    "line": 247,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Provide a clear and concise docstring for function documentation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 910,
    "end_token": 914,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      1598,
      290,
      35327,
      2205,
      8841,
      329,
      2163,
      10314,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a clear and concise docstring for function documentation."
  },
  {
    "line": 270,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a list of graph names to dynamically call functions.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 914,
    "end_token": 914,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      1351,
      286,
      4823,
      3891,
      284,
      32366,
      869,
      5499,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over a list of graph names to dynamically call functions."
  },
  {
    "line": 273,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Using eval() can lead to code injection if graph_name is not controlled.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 914,
    "end_token": 914,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8554,
      5418,
      3419,
      460,
      1085,
      284,
      2438,
      16954,
      611,
      4823,
      62,
      3672,
      318,
      407,
      6856,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Using eval() can lead to code injection if graph_name is not controlled."
  },
  {
    "line": 277,
    "text": "       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic to determine output based on a boolean flag.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      4600,
      9521,
      30058,
      63,
      25,
      3740,
      1378,
      29487,
      306,
      13,
      785,
      14,
      29412,
      14,
      2435,
      12,
      25076,
      31113,
      39,
      2530,
      12,
      20916,
      2412,
      12,
      392,
      12,
      39,
      10180,
      592
    ],
    "start_token": 914,
    "end_token": 950,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      284,
      5004,
      5072,
      1912,
      319,
      257,
      25131,
      6056,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic to determine output based on a boolean flag."
  }
]