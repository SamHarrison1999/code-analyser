[
  {
    "line": 3,
    "text": "import matplotlib.pyplot as plt",
    "annotation": "\u2705 Best Practice: Consider adding type hints for function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      11748,
      2603,
      29487,
      8019,
      13,
      9078,
      29487,
      355,
      458,
      83
    ],
    "start_token": 0,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for function parameters and return type for better readability and maintainability."
  },
  {
    "line": 26,
    "text": "        You can try 0.3 if you feel it is too crowded",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The use of assert for input validation can be bypassed if Python is run with optimizations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      921,
      460,
      1949,
      657,
      13,
      18,
      611,
      345,
      1254,
      340,
      318,
      1165,
      18012
    ],
    "start_token": 10,
    "end_token": 30,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      779,
      286,
      6818,
      329,
      5128,
      21201,
      460,
      307,
      17286,
      276,
      611,
      11361,
      318,
      1057,
      351,
      41446,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The use of assert for input validation can be bypassed if Python is run with optimizations."
  },
  {
    "line": 30,
    "text": "    It will return graphs with the shape of <col_n> each iter (it is squeezed).",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for infinite loop if not handled properly outside the function.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      632,
      481,
      1441,
      28770,
      351,
      262,
      5485,
      286,
      1279,
      4033,
      62,
      77,
      29,
      1123,
      11629,
      357,
      270,
      318,
      29650,
      737
    ],
    "start_token": 30,
    "end_token": 53,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      15541,
      9052,
      611,
      407,
      12118,
      6105,
      2354,
      262,
      2163,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for infinite loop if not handled properly outside the function."
  },
  {
    "line": 39,
    "text": "        axes = axes.reshape(row_n, col_n)",
    "annotation": "\ud83e\udde0 ML Signal: Use of generator pattern, which can be a signal for learning code behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      34197,
      796,
      34197,
      13,
      3447,
      1758,
      7,
      808,
      62,
      77,
      11,
      951,
      62,
      77,
      8
    ],
    "start_token": 53,
    "end_token": 75,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      17301,
      3912,
      11,
      543,
      460,
      307,
      257,
      6737,
      329,
      4673,
      2438,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of generator pattern, which can be a signal for learning code behavior."
  },
  {
    "line": 52,
    "text": "    It basically calculates the difference between a `continuous` datetime index and index given.",
    "annotation": "\u2705 Best Practice: Sorting the datetime index ensures that the gaps are calculated correctly.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      632,
      6209,
      43707,
      262,
      3580,
      1022,
      257,
      4600,
      18487,
      5623,
      63,
      4818,
      8079,
      6376,
      290,
      6376,
      1813,
      13
    ],
    "start_token": 75,
    "end_token": 96,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      262,
      4818,
      8079,
      6376,
      19047,
      326,
      262,
      17332,
      389,
      10488,
      9380,
      13
    ],
    "label": "best_practice",
    "reason": "Sorting the datetime index ensures that the gaps are calculated correctly."
  },
  {
    "line": 54,
    "text": "    For more details on `rangebreaks` params in plotly, see",
    "annotation": "\u2705 Best Practice: Calculating gaps between consecutive datetime entries.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1114,
      517,
      3307,
      319,
      4600,
      9521,
      30058,
      63,
      42287,
      287,
      7110,
      306,
      11,
      766
    ],
    "start_token": 96,
    "end_token": 113,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      803,
      17332,
      1022,
      12785,
      4818,
      8079,
      12784,
      13
    ],
    "label": "best_practice",
    "reason": "Calculating gaps between consecutive datetime entries."
  },
  {
    "line": 56,
    "text": "",
    "annotation": "\u2705 Best Practice: Finding the minimum gap to identify the smallest interval.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 113,
    "end_token": 113,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27063,
      262,
      5288,
      7625,
      284,
      5911,
      262,
      18197,
      16654,
      13
    ],
    "label": "best_practice",
    "reason": "Finding the minimum gap to identify the smallest interval."
  },
  {
    "line": 58,
    "text": "    ----------",
    "annotation": "\u2705 Best Practice: Using a dictionary to store gaps that need to be broken.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 113,
    "end_token": 118,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      22155,
      284,
      3650,
      17332,
      326,
      761,
      284,
      307,
      5445,
      13
    ],
    "label": "best_practice",
    "reason": "Using a dictionary to store gaps that need to be broken."
  },
  {
    "line": 59,
    "text": "    dt_index: pd.DatetimeIndex",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over gaps and datetimes to identify significant gaps.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      288,
      83,
      62,
      9630,
      25,
      279,
      67,
      13,
      27354,
      8079,
      15732
    ],
    "start_token": 118,
    "end_token": 132,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      17332,
      290,
      4818,
      46874,
      284,
      5911,
      2383,
      17332,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over gaps and datetimes to identify significant gaps."
  },
  {
    "line": 59,
    "text": "    dt_index: pd.DatetimeIndex",
    "annotation": "\u2705 Best Practice: Checking if the gap is larger than the minimum gap.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      288,
      83,
      62,
      9630,
      25,
      279,
      67,
      13,
      27354,
      8079,
      15732
    ],
    "start_token": 132,
    "end_token": 146,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      611,
      262,
      7625,
      318,
      4025,
      621,
      262,
      5288,
      7625,
      13
    ],
    "label": "best_practice",
    "reason": "Checking if the gap is larger than the minimum gap."
  },
  {
    "line": 59,
    "text": "    dt_index: pd.DatetimeIndex",
    "annotation": "\u2705 Best Practice: Using setdefault to append dates to the list for each gap.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      288,
      83,
      62,
      9630,
      25,
      279,
      67,
      13,
      27354,
      8079,
      15732
    ],
    "start_token": 146,
    "end_token": 160,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      900,
      12286,
      284,
      24443,
      9667,
      284,
      262,
      1351,
      329,
      1123,
      7625,
      13
    ],
    "label": "best_practice",
    "reason": "Using setdefault to append dates to the list for each gap."
  },
  {
    "line": 59,
    "text": "    dt_index: pd.DatetimeIndex",
    "annotation": "\u2705 Best Practice: Constructing the rangebreaks list for plotly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      288,
      83,
      62,
      9630,
      25,
      279,
      67,
      13,
      27354,
      8079,
      15732
    ],
    "start_token": 160,
    "end_token": 174,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      28407,
      278,
      262,
      2837,
      30058,
      1351,
      329,
      7110,
      306,
      13
    ],
    "label": "best_practice",
    "reason": "Constructing the rangebreaks list for plotly."
  }
]