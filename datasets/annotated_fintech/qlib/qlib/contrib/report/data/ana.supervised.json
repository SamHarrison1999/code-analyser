[
  {
    "line": 9,
    "text": "",
    "annotation": "\u2705 Best Practice: Grouping imports from the same module together improves readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 0,
    "end_token": 0,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      422,
      262,
      976,
      8265,
      1978,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports from the same module together improves readability."
  },
  {
    "line": 17,
    "text": "from qlib.contrib.report.data.base import FeaAnalyser",
    "annotation": "\u2705 Best Practice: Constants should be in uppercase to distinguish them from variables.",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      3642,
      822,
      13,
      13116,
      13,
      7890,
      13,
      8692,
      1330,
      5452,
      64,
      2025,
      26266,
      263
    ],
    "start_token": 0,
    "end_token": 18,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      287,
      334,
      39921,
      589,
      284,
      15714,
      606,
      422,
      9633,
      13
    ],
    "label": "best_practice",
    "reason": "Constants should be in uppercase to distinguish them from variables."
  },
  {
    "line": 22,
    "text": "import seaborn as sns",
    "annotation": "\u2705 Best Practice: Class docstring provides a brief description of the class purpose",
    "confidence": 1.0,
    "tokens": [
      11748,
      384,
      397,
      1211,
      355,
      3013,
      82
    ],
    "start_token": 18,
    "end_token": 25,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      1398,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a brief description of the class purpose"
  },
  {
    "line": 23,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): No validation on dataset type, could lead to runtime errors if not a DataFrame",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 25,
    "end_token": 25,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1400,
      21201,
      319,
      27039,
      2099,
      11,
      714,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      257,
      6060,
      19778
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "No validation on dataset type, could lead to runtime errors if not a DataFrame"
  },
  {
    "line": 25,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError might not be the most appropriate exception type",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 25,
    "end_token": 25,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      1244,
      407,
      307,
      262,
      749,
      5035,
      6631,
      2099
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError might not be the most appropriate exception type"
  },
  {
    "line": 27,
    "text": "class CombFeaAna(FeaAnalyser):",
    "annotation": "\ud83e\udde0 ML Signal: Use of list comprehension to apply classes to a dataset",
    "confidence": 0.5,
    "tokens": [
      4871,
      14336,
      14304,
      64,
      2025,
      64,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 25,
    "end_token": 38,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1351,
      35915,
      284,
      4174,
      6097,
      284,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Use of list comprehension to apply classes to a dataset"
  },
  {
    "line": 29,
    "text": "    Combine the sub feature analysers and plot then in a single graph",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      29176,
      262,
      850,
      3895,
      11090,
      364,
      290,
      7110,
      788,
      287,
      257,
      2060,
      4823
    ],
    "start_token": 38,
    "end_token": 54,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method"
  },
  {
    "line": 27,
    "text": "class CombFeaAna(FeaAnalyser):",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function.",
    "confidence": 1.0,
    "tokens": [
      4871,
      14336,
      14304,
      64,
      2025,
      64,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 54,
    "end_token": 67,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function."
  },
  {
    "line": 29,
    "text": "    Combine the sub feature analysers and plot then in a single graph",
    "annotation": "\ud83e\udde0 ML Signal: Usage of numpy's all function to check conditions across a list.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      29176,
      262,
      850,
      3895,
      11090,
      364,
      290,
      7110,
      788,
      287,
      257,
      2060,
      4823
    ],
    "start_token": 67,
    "end_token": 83,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      299,
      32152,
      338,
      477,
      2163,
      284,
      2198,
      3403,
      1973,
      257,
      1351,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of numpy's all function to check conditions across a list."
  },
  {
    "line": 30,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Using list comprehension instead of map and lambda for better readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 83,
    "end_token": 87,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      1351,
      35915,
      2427,
      286,
      3975,
      290,
      37456,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using list comprehension instead of map and lambda for better readability."
  },
  {
    "line": 30,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 87,
    "end_token": 91,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose"
  },
  {
    "line": 32,
    "text": "    def __init__(self, dataset: pd.DataFrame, *fea_ana_cls):",
    "annotation": "\u2705 Best Practice: Use of iter() to create an iterator for sub_fig_generator",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      27039,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11,
      1635,
      5036,
      64,
      62,
      2271,
      62,
      565,
      82,
      2599
    ],
    "start_token": 91,
    "end_token": 118,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11629,
      3419,
      284,
      2251,
      281,
      41313,
      329,
      850,
      62,
      5647,
      62,
      8612,
      1352
    ],
    "label": "best_practice",
    "reason": "Use of iter() to create an iterator for sub_fig_generator"
  },
  {
    "line": 34,
    "text": "            raise NotImplementedError(f\"This type of input is not supported\")",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over dataset columns for plotting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7,
      69,
      1,
      1212,
      2099,
      286,
      5128,
      318,
      407,
      4855,
      4943
    ],
    "start_token": 118,
    "end_token": 146,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      27039,
      15180,
      329,
      29353
    ],
    "label": "ml_signal",
    "reason": "Iterating over dataset columns for plotting"
  },
  {
    "line": 36,
    "text": "        super().__init__(dataset=dataset)",
    "annotation": "\u2705 Best Practice: Check if a column should be skipped",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      7,
      19608,
      292,
      316,
      28,
      19608,
      292,
      316,
      8
    ],
    "start_token": 146,
    "end_token": 167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      257,
      5721,
      815,
      307,
      26684
    ],
    "label": "best_practice",
    "reason": "Check if a column should be skipped"
  },
  {
    "line": 38,
    "text": "    def skip(self, col):",
    "annotation": "\u2705 Best Practice: Use of next() to get the next item from the iterator",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      14267,
      7,
      944,
      11,
      951,
      2599
    ],
    "start_token": 167,
    "end_token": 177,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1306,
      3419,
      284,
      651,
      262,
      1306,
      2378,
      422,
      262,
      41313
    ],
    "label": "best_practice",
    "reason": "Use of next() to get the next item from the iterator"
  },
  {
    "line": 40,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over feature analysis list for plotting",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 177,
    "end_token": 177,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      3895,
      3781,
      1351,
      329,
      29353
    ],
    "label": "ml_signal",
    "reason": "Iterating over feature analysis list for plotting"
  },
  {
    "line": 42,
    "text": "        \"\"\"The statistics of features are finished in the underlying analysers\"\"\"",
    "annotation": "\u2705 Best Practice: Check if a feature analysis should be skipped",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      464,
      7869,
      286,
      3033,
      389,
      5201,
      287,
      262,
      10238,
      11090,
      364,
      37811
    ],
    "start_token": 177,
    "end_token": 197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      257,
      3895,
      3781,
      815,
      307,
      26684
    ],
    "label": "best_practice",
    "reason": "Check if a feature analysis should be skipped"
  },
  {
    "line": 44,
    "text": "    def plot_all(self, *args, **kwargs):",
    "annotation": "\ud83e\udde0 ML Signal: Plotting a single feature analysis",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      439,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 197,
    "end_token": 214,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28114,
      889,
      257,
      2060,
      3895,
      3781
    ],
    "label": "ml_signal",
    "reason": "Plotting a single feature analysis"
  },
  {
    "line": 46,
    "text": "",
    "annotation": "\u2705 Best Practice: Clearing axis labels and titles for cleaner plots",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 214,
    "end_token": 214,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3779,
      1723,
      16488,
      14722,
      290,
      8714,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Clearing axis labels and titles for cleaner plots"
  },
  {
    "line": 49,
    "text": "                axes = next(ax_gen)",
    "annotation": "\u2705 Best Practice: Setting the title for the first axis in the group",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      34197,
      796,
      1306,
      7,
      897,
      62,
      5235,
      8
    ],
    "start_token": 214,
    "end_token": 237,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      3670,
      329,
      262,
      717,
      16488,
      287,
      262,
      1448
    ],
    "label": "best_practice",
    "reason": "Setting the title for the first axis in the group"
  },
  {
    "line": 43,
    "text": "",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 237,
    "end_token": 237,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 44,
    "text": "    def plot_all(self, *args, **kwargs):",
    "annotation": "\ud83e\udde0 ML Signal: Checking if a column is of object type to decide processing steps",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      439,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 237,
    "end_token": 254,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      257,
      5721,
      318,
      286,
      2134,
      2099,
      284,
      5409,
      7587,
      4831
    ],
    "label": "ml_signal",
    "reason": "Checking if a column is of object type to decide processing steps"
  },
  {
    "line": 46,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information exposure through logging",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 254,
    "end_token": 254,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      7111,
      832,
      18931
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information exposure through logging"
  },
  {
    "line": 48,
    "text": "            if not self.skip(col):",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from a class, indicating a potential pattern of class extension",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13,
      48267,
      7,
      4033,
      2599
    ],
    "start_token": 254,
    "end_token": 273,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      257,
      1398,
      11,
      12739,
      257,
      2785,
      3912,
      286,
      1398,
      7552
    ],
    "label": "ml_signal",
    "reason": "Inheritance from a class, indicating a potential pattern of class extension"
  },
  {
    "line": 50,
    "text": "                for fa, ax in zip(self._fea_ana_l, axes):",
    "annotation": "\u2705 Best Practice: Use type hints for function parameters to improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      24685,
      11,
      7877,
      287,
      19974,
      7,
      944,
      13557,
      5036,
      64,
      62,
      2271,
      62,
      75,
      11,
      34197,
      2599
    ],
    "start_token": 273,
    "end_token": 306,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      2099,
      20269,
      329,
      2163,
      10007,
      284,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use type hints for function parameters to improve code readability and maintainability."
  },
  {
    "line": 52,
    "text": "                        fa.plot_single(col, ax)",
    "annotation": "\u2705 Best Practice: Explicitly call the superclass's __init__ method to ensure proper initialization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24685,
      13,
      29487,
      62,
      29762,
      7,
      4033,
      11,
      7877,
      8
    ],
    "start_token": 306,
    "end_token": 339,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      869,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      284,
      4155,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly call the superclass's __init__ method to ensure proper initialization."
  },
  {
    "line": 55,
    "text": "                axes[0].set_title(col)",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over dataset columns to calculate statistics",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      34197,
      58,
      15,
      4083,
      2617,
      62,
      7839,
      7,
      4033,
      8
    ],
    "start_token": 339,
    "end_token": 364,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      27039,
      15180,
      284,
      15284,
      7869
    ],
    "label": "ml_signal",
    "reason": "Iterating over dataset columns to calculate statistics"
  },
  {
    "line": 57,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic to skip certain columns",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 364,
    "end_token": 364,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      284,
      14267,
      1728,
      15180
    ],
    "label": "ml_signal",
    "reason": "Conditional logic to skip certain columns"
  },
  {
    "line": 59,
    "text": "    def skip(self, col):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if DT_COL_NAME is user-controlled and not validated",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      14267,
      7,
      944,
      11,
      951,
      2599
    ],
    "start_token": 364,
    "end_token": 374,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      24311,
      62,
      25154,
      62,
      20608,
      318,
      2836,
      12,
      14401,
      290,
      407,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if DT_COL_NAME is user-controlled and not validated"
  },
  {
    "line": 61,
    "text": "        if is_obj:",
    "annotation": "\u2705 Best Practice: Convert dictionary to DataFrame for better data manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      62,
      26801,
      25
    ],
    "start_token": 374,
    "end_token": 386,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      22155,
      284,
      6060,
      19778,
      329,
      1365,
      1366,
      17512
    ],
    "label": "best_practice",
    "reason": "Convert dictionary to DataFrame for better data manipulation"
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Division by zero risk if group size is zero",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 386,
    "end_token": 386,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7458,
      416,
      6632,
      2526,
      611,
      1448,
      2546,
      318,
      6632
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Division by zero risk if group size is zero"
  },
  {
    "line": 66,
    "text": "class ValueCNT(FeaAnalyser):",
    "annotation": "\u2705 Best Practice: Calculate min and max for setting plot limits",
    "confidence": 1.0,
    "tokens": [
      4871,
      11052,
      34,
      11251,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 386,
    "end_token": 397,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      378,
      949,
      290,
      3509,
      329,
      4634,
      7110,
      7095
    ],
    "label": "best_practice",
    "reason": "Calculate min and max for setting plot limits"
  },
  {
    "line": 68,
    "text": "        self.ratio = ratio",
    "annotation": "\u2705 Best Practice: Extend plot limits slightly for better visualization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      10366,
      952,
      796,
      8064
    ],
    "start_token": 397,
    "end_token": 410,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      46228,
      7110,
      7095,
      4622,
      329,
      1365,
      32704
    ],
    "label": "best_practice",
    "reason": "Extend plot limits slightly for better visualization"
  },
  {
    "line": 63,
    "text": "        return is_obj",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, indicating usage of visualization libraries",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      318,
      62,
      26801
    ],
    "start_token": 410,
    "end_token": 421,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      12739,
      8748,
      286,
      32704,
      12782
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, indicating usage of visualization libraries"
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of instance variable self._val_cnt suggests encapsulation and object-oriented design",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 421,
    "end_token": 421,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4554,
      7885,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      5644,
      32652,
      1741,
      290,
      2134,
      12,
      17107,
      1486
    ],
    "label": "best_practice",
    "reason": "Use of instance variable self._val_cnt suggests encapsulation and object-oriented design"
  },
  {
    "line": 66,
    "text": "class ValueCNT(FeaAnalyser):",
    "annotation": "\u2705 Best Practice: Setting the x-label to an empty string for cleaner plots",
    "confidence": 1.0,
    "tokens": [
      4871,
      11052,
      34,
      11251,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 421,
    "end_token": 432,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      2124,
      12,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Setting the x-label to an empty string for cleaner plots"
  },
  {
    "line": 66,
    "text": "class ValueCNT(FeaAnalyser):",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from a base class, indicating a pattern of extending functionality",
    "confidence": 0.5,
    "tokens": [
      4871,
      11052,
      34,
      11251,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 432,
    "end_token": 443,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      257,
      2779,
      1398,
      11,
      12739,
      257,
      3912,
      286,
      16610,
      11244
    ],
    "label": "ml_signal",
    "reason": "Inheritance from a base class, indicating a pattern of extending functionality"
  },
  {
    "line": 66,
    "text": "class ValueCNT(FeaAnalyser):",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting a single column from a dataset",
    "confidence": 0.5,
    "tokens": [
      4871,
      11052,
      34,
      11251,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 443,
    "end_token": 454,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      257,
      2060,
      5721,
      422,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Method for plotting a single column from a dataset"
  },
  {
    "line": 68,
    "text": "        self.ratio = ratio",
    "annotation": "\ud83e\udde0 ML Signal: Use of seaborn for histogram plotting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      10366,
      952,
      796,
      8064
    ],
    "start_token": 454,
    "end_token": 467,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      384,
      397,
      1211,
      329,
      1554,
      21857,
      29353
    ],
    "label": "ml_signal",
    "reason": "Use of seaborn for histogram plotting"
  },
  {
    "line": 70,
    "text": "",
    "annotation": "\u2705 Best Practice: Clear x-label for cleaner plot presentation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 467,
    "end_token": 467,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      2124,
      12,
      18242,
      329,
      21723,
      7110,
      10470
    ],
    "label": "best_practice",
    "reason": "Clear x-label for cleaner plot presentation"
  },
  {
    "line": 72,
    "text": "        self._val_cnt = {}",
    "annotation": "\u2705 Best Practice: Set title to the column name for context",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      796,
      23884
    ],
    "start_token": 467,
    "end_token": 482,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5345,
      3670,
      284,
      262,
      5721,
      1438,
      329,
      4732
    ],
    "label": "best_practice",
    "reason": "Set title to the column name for context"
  },
  {
    "line": 74,
    "text": "            if not super().skip(col):",
    "annotation": "\u2705 Best Practice: Use of 'super()' to call a method from the parent class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2208,
      22446,
      48267,
      7,
      4033,
      2599
    ],
    "start_token": 482,
    "end_token": 501,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      16668,
      3419,
      6,
      284,
      869,
      257,
      2446,
      422,
      262,
      2560,
      1398
    ],
    "label": "best_practice",
    "reason": "Use of 'super()' to call a method from the parent class"
  },
  {
    "line": 76,
    "text": "        self._val_cnt = pd.DataFrame(self._val_cnt)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of deprecated 'np.int', consider using 'int' or 'np.int64'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      796,
      279,
      67,
      13,
      6601,
      19778,
      7,
      944,
      13557,
      2100,
      62,
      66,
      429,
      8
    ],
    "start_token": 501,
    "end_token": 528,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      39224,
      705,
      37659,
      13,
      600,
      3256,
      2074,
      1262,
      705,
      600,
      6,
      393,
      705,
      37659,
      13,
      600,
      2414,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of deprecated 'np.int', consider using 'int' or 'np.int64'"
  },
  {
    "line": 78,
    "text": "            self._val_cnt = self._val_cnt.div(self._dataset.groupby(DT_COL_NAME, group_keys=False).size(), axis=0)",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of dictionary to DataFrame, indicating data transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      796,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      13,
      7146,
      7,
      944,
      13557,
      19608,
      292,
      316,
      13,
      8094,
      1525,
      7,
      24544,
      62,
      25154,
      62,
      20608,
      11,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      7857,
      22784,
      16488,
      28,
      15,
      8
    ],
    "start_token": 528,
    "end_token": 582,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      22155,
      284,
      6060,
      19778,
      11,
      12739,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Conversion of dictionary to DataFrame, indicating data transformation"
  },
  {
    "line": 77,
    "text": "        if self.ratio:",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      10366,
      952,
      25
    ],
    "start_token": 582,
    "end_token": 595,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose and parameters"
  },
  {
    "line": 79,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of 'not in' to check for key existence in a dictionary",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 595,
    "end_token": 595,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      705,
      1662,
      287,
      6,
      284,
      2198,
      329,
      1994,
      6224,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Usage of 'not in' to check for key existence in a dictionary"
  },
  {
    "line": 80,
    "text": "        # TODO: transfer this feature to other analysers",
    "annotation": "\ud83e\udde0 ML Signal: Use of logical operators to combine conditions",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      4351,
      428,
      3895,
      284,
      584,
      11090,
      364
    ],
    "start_token": 595,
    "end_token": 613,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      12219,
      12879,
      284,
      12082,
      3403
    ],
    "label": "ml_signal",
    "reason": "Use of logical operators to combine conditions"
  },
  {
    "line": 80,
    "text": "        # TODO: transfer this feature to other analysers",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, indicating usage of visualization libraries",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16926,
      46,
      25,
      4351,
      428,
      3895,
      284,
      584,
      11090,
      364
    ],
    "start_token": 613,
    "end_token": 631,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      12739,
      8748,
      286,
      32704,
      12782
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, indicating usage of visualization libraries"
  },
  {
    "line": 82,
    "text": "        self.ylim = (ymin - 0.05 * (ymax - ymin), ymax + 0.05 * (ymax - ymin))",
    "annotation": "\u2705 Best Practice: Setting the x-label to an empty string for cleaner plots",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      88,
      2475,
      796,
      357,
      88,
      1084,
      532,
      657,
      13,
      2713,
      1635,
      357,
      4948,
      897,
      532,
      331,
      1084,
      828,
      331,
      9806,
      1343,
      657,
      13,
      2713,
      1635,
      357,
      4948,
      897,
      532,
      331,
      1084,
      4008
    ],
    "start_token": 631,
    "end_token": 672,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      2124,
      12,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Setting the x-label to an empty string for cleaner plots"
  },
  {
    "line": 82,
    "text": "        self.ylim = (ymin - 0.05 * (ymax - ymin), ymax + 0.05 * (ymax - ymin))",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      88,
      2475,
      796,
      357,
      88,
      1084,
      532,
      657,
      13,
      2713,
      1635,
      357,
      4948,
      897,
      532,
      331,
      1084,
      828,
      331,
      9806,
      1343,
      657,
      13,
      2713,
      1635,
      357,
      4948,
      897,
      532,
      331,
      1084,
      4008
    ],
    "start_token": 672,
    "end_token": 713,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 83,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests statistical calculation, indicating a pattern of data analysis",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 713,
    "end_token": 713,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      13905,
      17952,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      3781
    ],
    "label": "ml_signal",
    "reason": "Method name suggests statistical calculation, indicating a pattern of data analysis"
  },
  {
    "line": 85,
    "text": "        self._val_cnt[col].plot(ax=ax, title=col, ylim=self.ylim)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large data processing without error handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      58,
      4033,
      4083,
      29487,
      7,
      897,
      28,
      897,
      11,
      3670,
      28,
      4033,
      11,
      331,
      2475,
      28,
      944,
      13,
      88,
      2475,
      8
    ],
    "start_token": 713,
    "end_token": 747,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      1366,
      7587,
      1231,
      4049,
      9041
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large data processing without error handling"
  },
  {
    "line": 86,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of isna() and groupby() indicates data cleaning and aggregation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 747,
    "end_token": 762,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2125,
      64,
      3419,
      290,
      1448,
      1525,
      3419,
      9217,
      1366,
      12724,
      290,
      46500
    ],
    "label": "ml_signal",
    "reason": "Use of isna() and groupby() indicates data cleaning and aggregation"
  },
  {
    "line": 87,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding error handling for dataset operations",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 762,
    "end_token": 762,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      4049,
      9041,
      329,
      27039,
      4560
    ],
    "label": "best_practice",
    "reason": "Consider adding error handling for dataset operations"
  },
  {
    "line": 85,
    "text": "        self._val_cnt[col].plot(ax=ax, title=col, ylim=self.ylim)",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      2100,
      62,
      66,
      429,
      58,
      4033,
      4083,
      29487,
      7,
      897,
      28,
      897,
      11,
      3670,
      28,
      4033,
      11,
      331,
      2475,
      28,
      944,
      13,
      88,
      2475,
      8
    ],
    "start_token": 762,
    "end_token": 796,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function"
  },
  {
    "line": 87,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of 'not in' to check for key existence in a dictionary",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 796,
    "end_token": 796,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      705,
      1662,
      287,
      6,
      284,
      2198,
      329,
      1994,
      6224,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Usage of 'not in' to check for key existence in a dictionary"
  },
  {
    "line": 88,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logical OR operation to combine conditions",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 796,
    "end_token": 796,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      605,
      6375,
      4905,
      284,
      12082,
      3403
    ],
    "label": "ml_signal",
    "reason": "Logical OR operation to combine conditions"
  },
  {
    "line": 89,
    "text": "class FeaDistAna(NumFeaAnalyser):",
    "annotation": "\u2705 Best Practice: Use parentheses for clarity in complex logical expressions",
    "confidence": 0.5,
    "tokens": [
      4871,
      5452,
      64,
      20344,
      2025,
      64,
      7,
      33111,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 796,
    "end_token": 810,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46672,
      329,
      16287,
      287,
      3716,
      12219,
      14700
    ],
    "label": "best_practice",
    "reason": "Use parentheses for clarity in complex logical expressions"
  },
  {
    "line": 88,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, indicating usage of visualization libraries",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 810,
    "end_token": 810,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      12739,
      8748,
      286,
      32704,
      12782
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, indicating usage of visualization libraries"
  },
  {
    "line": 89,
    "text": "class FeaDistAna(NumFeaAnalyser):",
    "annotation": "\u2705 Best Practice: Accessing instance variable _nan_cnt suggests encapsulation of data",
    "confidence": 1.0,
    "tokens": [
      4871,
      5452,
      64,
      20344,
      2025,
      64,
      7,
      33111,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 810,
    "end_token": 824,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8798,
      278,
      4554,
      7885,
      4808,
      12647,
      62,
      66,
      429,
      5644,
      32652,
      1741,
      286,
      1366
    ],
    "label": "best_practice",
    "reason": "Accessing instance variable _nan_cnt suggests encapsulation of data"
  },
  {
    "line": 91,
    "text": "        sns.histplot(self._dataset[col], ax=ax, kde=False, bins=100)",
    "annotation": "\u2705 Best Practice: Setting the x-label to an empty string for cleaner plots",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3013,
      82,
      13,
      10034,
      29487,
      7,
      944,
      13557,
      19608,
      292,
      316,
      58,
      4033,
      4357,
      7877,
      28,
      897,
      11,
      479,
      2934,
      28,
      25101,
      11,
      41701,
      28,
      3064,
      8
    ],
    "start_token": 824,
    "end_token": 858,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      262,
      2124,
      12,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Setting the x-label to an empty string for cleaner plots"
  },
  {
    "line": 91,
    "text": "        sns.histplot(self._dataset[col], ax=ax, kde=False, bins=100)",
    "annotation": "\ud83e\udde0 ML Signal: Method for calculating statistics on a dataset",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3013,
      82,
      13,
      10034,
      29487,
      7,
      944,
      13557,
      19608,
      292,
      316,
      58,
      4033,
      4357,
      7877,
      28,
      897,
      11,
      479,
      2934,
      28,
      25101,
      11,
      41701,
      28,
      3064,
      8
    ],
    "start_token": 858,
    "end_token": 892,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      26019,
      7869,
      319,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Method for calculating statistics on a dataset"
  },
  {
    "line": 93,
    "text": "        ax.set_title(col)",
    "annotation": "\ud83e\udde0 ML Signal: Counting NaN values in the dataset",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      7839,
      7,
      4033,
      8
    ],
    "start_token": 892,
    "end_token": 907,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2764,
      278,
      11013,
      45,
      3815,
      287,
      262,
      27039
    ],
    "label": "ml_signal",
    "reason": "Counting NaN values in the dataset"
  },
  {
    "line": 94,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large memory usage with large datasets",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 907,
    "end_token": 907,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      4088,
      8748,
      351,
      1588,
      40522
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large memory usage with large datasets"
  },
  {
    "line": 96,
    "text": "class FeaInfAna(NumFeaAnalyser):",
    "annotation": "\ud83e\udde0 ML Signal: Counting total entries in the dataset",
    "confidence": 1.0,
    "tokens": [
      4871,
      5452,
      64,
      18943,
      2025,
      64,
      7,
      33111,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 907,
    "end_token": 921,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2764,
      278,
      2472,
      12784,
      287,
      262,
      27039
    ],
    "label": "ml_signal",
    "reason": "Counting total entries in the dataset"
  },
  {
    "line": 97,
    "text": "    def calc_stat_values(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large memory usage with large datasets",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      42302,
      62,
      14269,
      62,
      27160,
      7,
      944,
      2599
    ],
    "start_token": 921,
    "end_token": 933,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      4088,
      8748,
      351,
      1588,
      40522
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large memory usage with large datasets"
  },
  {
    "line": 94,
    "text": "",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose and parameters",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 933,
    "end_token": 933,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose and parameters"
  },
  {
    "line": 96,
    "text": "class FeaInfAna(NumFeaAnalyser):",
    "annotation": "\ud83e\udde0 ML Signal: Checking if a column is in a dictionary",
    "confidence": 0.5,
    "tokens": [
      4871,
      5452,
      64,
      18943,
      2025,
      64,
      7,
      33111,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 933,
    "end_token": 947,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      257,
      5721,
      318,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Checking if a column is in a dictionary"
  },
  {
    "line": 97,
    "text": "    def calc_stat_values(self):",
    "annotation": "\ud83e\udde0 ML Signal: Using logical operators to combine conditions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      42302,
      62,
      14269,
      62,
      27160,
      7,
      944,
      2599
    ],
    "start_token": 947,
    "end_token": 959,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      12219,
      12879,
      284,
      12082,
      3403
    ],
    "label": "ml_signal",
    "reason": "Using logical operators to combine conditions"
  },
  {
    "line": 97,
    "text": "    def calc_stat_values(self):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of plotting function indicates data visualization behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      42302,
      62,
      14269,
      62,
      27160,
      7,
      944,
      2599
    ],
    "start_token": 959,
    "end_token": 971,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      29353,
      2163,
      9217,
      1366,
      32704,
      4069
    ],
    "label": "ml_signal",
    "reason": "Usage of plotting function indicates data visualization behavior"
  },
  {
    "line": 98,
    "text": "        self._inf_cnt = {}",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for division by zero if self._total_cnt is zero",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      10745,
      62,
      66,
      429,
      796,
      23884
    ],
    "start_token": 971,
    "end_token": 986,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      7297,
      416,
      6632,
      611,
      2116,
      13557,
      23350,
      62,
      66,
      429,
      318,
      6632
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for division by zero if self._total_cnt is zero"
  },
  {
    "line": 100,
    "text": "            if not super().skip(col):",
    "annotation": "\u2705 Best Practice: Setting xlabel to an empty string for cleaner plot presentation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2208,
      22446,
      48267,
      7,
      4033,
      2599
    ],
    "start_token": 986,
    "end_token": 1005,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      2124,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      7110,
      10470
    ],
    "label": "best_practice",
    "reason": "Setting xlabel to an empty string for cleaner plot presentation"
  },
  {
    "line": 101,
    "text": "                self._inf_cnt[col] = item.apply(np.isinf).astype(np.int).groupby(DT_COL_NAME, group_keys=False).sum()",
    "annotation": "\u2705 Best Practice: Class docstring provides a brief description of the class purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      10745,
      62,
      66,
      429,
      58,
      4033,
      60,
      796,
      2378,
      13,
      39014,
      7,
      37659,
      13,
      271,
      10745,
      737,
      459,
      2981,
      7,
      37659,
      13,
      600,
      737,
      8094,
      1525,
      7,
      24544,
      62,
      25154,
      62,
      20608,
      11,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      16345,
      3419
    ],
    "start_token": 1005,
    "end_token": 1063,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      1398,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a brief description of the class purpose"
  },
  {
    "line": 101,
    "text": "                self._inf_cnt[col] = item.apply(np.isinf).astype(np.int).groupby(DT_COL_NAME, group_keys=False).sum()",
    "annotation": "\ud83e\udde0 ML Signal: Method calculating statistical values from dataset",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      10745,
      62,
      66,
      429,
      58,
      4033,
      60,
      796,
      2378,
      13,
      39014,
      7,
      37659,
      13,
      271,
      10745,
      737,
      459,
      2981,
      7,
      37659,
      13,
      600,
      737,
      8094,
      1525,
      7,
      24544,
      62,
      25154,
      62,
      20608,
      11,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      16345,
      3419
    ],
    "start_token": 1063,
    "end_token": 1121,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      26019,
      13905,
      3815,
      422,
      27039
    ],
    "label": "ml_signal",
    "reason": "Method calculating statistical values from dataset"
  },
  {
    "line": 103,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a method to calculate autocorrelation",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1121,
    "end_token": 1121,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2446,
      284,
      15284,
      1960,
      420,
      273,
      49501
    ],
    "label": "ml_signal",
    "reason": "Usage of a method to calculate autocorrelation"
  },
  {
    "line": 105,
    "text": "        return (col not in self._inf_cnt) or (self._inf_cnt[col].sum() == 0)",
    "annotation": "\u2705 Best Practice: Converting correlation results to a DataFrame for easier manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      357,
      4033,
      407,
      287,
      2116,
      13557,
      10745,
      62,
      66,
      429,
      8,
      393,
      357,
      944,
      13557,
      10745,
      62,
      66,
      429,
      58,
      4033,
      4083,
      16345,
      3419,
      6624,
      657,
      8
    ],
    "start_token": 1121,
    "end_token": 1156,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      16096,
      2482,
      284,
      257,
      6060,
      19778,
      329,
      4577,
      17512
    ],
    "label": "best_practice",
    "reason": "Converting correlation results to a DataFrame for easier manipulation"
  },
  {
    "line": 107,
    "text": "    def plot_single(self, col, ax):",
    "annotation": "\u2705 Best Practice: Calculating min and max values for setting plot limits",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      29762,
      7,
      944,
      11,
      951,
      11,
      7877,
      2599
    ],
    "start_token": 1156,
    "end_token": 1170,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      803,
      949,
      290,
      3509,
      3815,
      329,
      4634,
      7110,
      7095
    ],
    "label": "best_practice",
    "reason": "Calculating min and max values for setting plot limits"
  },
  {
    "line": 109,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\u2705 Best Practice: Setting y-axis limits with a margin for better visualization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1170,
    "end_token": 1185,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      331,
      12,
      22704,
      7095,
      351,
      257,
      10330,
      329,
      1365,
      32704
    ],
    "label": "best_practice",
    "reason": "Setting y-axis limits with a margin for better visualization"
  },
  {
    "line": 106,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, useful for understanding data visualization patterns",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1185,
    "end_token": 1185,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      4465,
      329,
      4547,
      1366,
      32704,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, useful for understanding data visualization patterns"
  },
  {
    "line": 108,
    "text": "        self._inf_cnt[col].plot(ax=ax, title=col)",
    "annotation": "\ud83e\udde0 ML Signal: Accessing a specific column for plotting, indicating feature importance",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      10745,
      62,
      66,
      429,
      58,
      4033,
      4083,
      29487,
      7,
      897,
      28,
      897,
      11,
      3670,
      28,
      4033,
      8
    ],
    "start_token": 1185,
    "end_token": 1211,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      257,
      2176,
      5721,
      329,
      29353,
      11,
      12739,
      3895,
      6817
    ],
    "label": "ml_signal",
    "reason": "Accessing a specific column for plotting, indicating feature importance"
  },
  {
    "line": 110,
    "text": "",
    "annotation": "\u2705 Best Practice: Setting x-label to an empty string for cleaner plots",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1211,
    "end_token": 1211,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      2124,
      12,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Setting x-label to an empty string for cleaner plots"
  },
  {
    "line": 110,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from NumFeaAnalyser indicates a pattern of extending functionality",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1211,
    "end_token": 1211,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      31835,
      14304,
      64,
      2025,
      26266,
      263,
      9217,
      257,
      3912,
      286,
      16610,
      11244
    ],
    "label": "ml_signal",
    "reason": "Inheritance from NumFeaAnalyser indicates a pattern of extending functionality"
  },
  {
    "line": 111,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method usage pattern for calculating skewness",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1211,
    "end_token": 1211,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8748,
      3912,
      329,
      26019,
      6146,
      675,
      408
    ],
    "label": "ml_signal",
    "reason": "Method usage pattern for calculating skewness"
  },
  {
    "line": 113,
    "text": "    def calc_stat_values(self):",
    "annotation": "\ud83e\udde0 ML Signal: Method usage pattern for calculating kurtosis",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      42302,
      62,
      14269,
      62,
      27160,
      7,
      944,
      2599
    ],
    "start_token": 1211,
    "end_token": 1223,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8748,
      3912,
      329,
      26019,
      479,
      3325,
      5958
    ],
    "label": "ml_signal",
    "reason": "Method usage pattern for calculating kurtosis"
  },
  {
    "line": 114,
    "text": "        self._nan_cnt = self._dataset.isna().groupby(DT_COL_NAME, group_keys=False).sum()",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, useful for understanding data visualization patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      12647,
      62,
      66,
      429,
      796,
      2116,
      13557,
      19608,
      292,
      316,
      13,
      271,
      2616,
      22446,
      8094,
      1525,
      7,
      24544,
      62,
      25154,
      62,
      20608,
      11,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      16345,
      3419
    ],
    "start_token": 1223,
    "end_token": 1263,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      4465,
      329,
      4547,
      1366,
      32704,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, useful for understanding data visualization patterns"
  },
  {
    "line": 116,
    "text": "    def skip(self, col):",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      14267,
      7,
      944,
      11,
      951,
      2599
    ],
    "start_token": 1263,
    "end_token": 1273,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 118,
    "text": "",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1273,
    "end_token": 1273,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 121,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\u2705 Best Practice: Use of twin axes for different data series",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1273,
    "end_token": 1288,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      15203,
      34197,
      329,
      1180,
      1366,
      2168
    ],
    "label": "best_practice",
    "reason": "Use of twin axes for different data series"
  },
  {
    "line": 124,
    "text": "class FeaNanAnaRatio(FeaAnalyser):",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [
      4871,
      5452,
      64,
      45,
      272,
      2025,
      64,
      29665,
      952,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 1288,
    "end_token": 1304,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 126,
    "text": "        self._nan_cnt = self._dataset.isna().groupby(DT_COL_NAME, group_keys=False).sum()",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      12647,
      62,
      66,
      429,
      796,
      2116,
      13557,
      19608,
      292,
      316,
      13,
      271,
      2616,
      22446,
      8094,
      1525,
      7,
      24544,
      62,
      25154,
      62,
      20608,
      11,
      1448,
      62,
      13083,
      28,
      25101,
      737,
      16345,
      3419
    ],
    "start_token": 1304,
    "end_token": 1344,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 128,
    "text": "",
    "annotation": "\u2705 Best Practice: Disabling grid for secondary axis to reduce clutter",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1344,
    "end_token": 1344,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3167,
      11716,
      10706,
      329,
      9233,
      16488,
      284,
      4646,
      45343
    ],
    "label": "best_practice",
    "reason": "Disabling grid for secondary axis to reduce clutter"
  },
  {
    "line": 132,
    "text": "    def plot_single(self, col, ax):",
    "annotation": "\u2705 Best Practice: Hiding the first legend to combine legends later",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      29762,
      7,
      944,
      11,
      951,
      11,
      7877,
      2599
    ],
    "start_token": 1344,
    "end_token": 1358,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      367,
      2530,
      262,
      717,
      8177,
      284,
      12082,
      24901,
      1568
    ],
    "label": "best_practice",
    "reason": "Hiding the first legend to combine legends later"
  },
  {
    "line": 134,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\u2705 Best Practice: Combining legends from both axes for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1358,
    "end_token": 1373,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14336,
      3191,
      24901,
      422,
      1111,
      34197,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Combining legends from both axes for clarity"
  },
  {
    "line": 136,
    "text": "",
    "annotation": "\u2705 Best Practice: Setting a title for the plot for context",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1373,
    "end_token": 1373,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      257,
      3670,
      329,
      262,
      7110,
      329,
      4732
    ],
    "label": "best_practice",
    "reason": "Setting a title for the plot for context"
  },
  {
    "line": 129,
    "text": "    def skip(self, col):",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its functionality",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      14267,
      7,
      944,
      11,
      951,
      2599
    ],
    "start_token": 1373,
    "end_token": 1383,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      11244
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its functionality"
  },
  {
    "line": 131,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of groupby operation on a dataset",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1383,
    "end_token": 1383,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1448,
      1525,
      4905,
      319,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Use of groupby operation on a dataset"
  },
  {
    "line": 132,
    "text": "    def plot_single(self, col, ax):",
    "annotation": "\u2705 Best Practice: Use of group_keys=False for efficiency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      29762,
      7,
      944,
      11,
      951,
      11,
      7877,
      2599
    ],
    "start_token": 1383,
    "end_token": 1397,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1448,
      62,
      13083,
      28,
      25101,
      329,
      9332
    ],
    "label": "best_practice",
    "reason": "Use of group_keys=False for efficiency"
  },
  {
    "line": 134,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of groupby operation on a dataset",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1397,
    "end_token": 1412,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1448,
      1525,
      4905,
      319,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Use of groupby operation on a dataset"
  },
  {
    "line": 135,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of group_keys=False for efficiency",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1412,
    "end_token": 1412,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1448,
      62,
      13083,
      28,
      25101,
      329,
      9332
    ],
    "label": "best_practice",
    "reason": "Use of group_keys=False for efficiency"
  },
  {
    "line": 133,
    "text": "        (self._nan_cnt[col] / self._total_cnt).plot(ax=ax, title=col)",
    "annotation": "\ud83e\udde0 ML Signal: Usage of plotting functions indicates data visualization patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      357,
      944,
      13557,
      12647,
      62,
      66,
      429,
      58,
      4033,
      60,
      1220,
      2116,
      13557,
      23350,
      62,
      66,
      429,
      737,
      29487,
      7,
      897,
      28,
      897,
      11,
      3670,
      28,
      4033,
      8
    ],
    "start_token": 1412,
    "end_token": 1447,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      29353,
      5499,
      9217,
      1366,
      32704,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of plotting functions indicates data visualization patterns"
  },
  {
    "line": 135,
    "text": "",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1447,
    "end_token": 1447,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 137,
    "text": "class FeaACAna(FeaAnalyser):",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [
      4871,
      5452,
      64,
      2246,
      2025,
      64,
      7,
      14304,
      64,
      2025,
      26266,
      263,
      2599
    ],
    "start_token": 1447,
    "end_token": 1460,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 139,
    "text": "",
    "annotation": "\u2705 Best Practice: Adding a legend improves plot interpretability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1460,
    "end_token": 1460,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18247,
      257,
      8177,
      19575,
      7110,
      6179,
      1799
    ],
    "label": "best_practice",
    "reason": "Adding a legend improves plot interpretability"
  },
  {
    "line": 141,
    "text": "        self._fea_corr = pred_autocorr_all(self._dataset.to_dict(\"series\"))",
    "annotation": "\u2705 Best Practice: Rotating x-axis labels improves readability for dense data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      5036,
      64,
      62,
      10215,
      81,
      796,
      2747,
      62,
      2306,
      420,
      38890,
      62,
      439,
      7,
      944,
      13557,
      19608,
      292,
      316,
      13,
      1462,
      62,
      11600,
      7203,
      25076,
      48774
    ],
    "start_token": 1460,
    "end_token": 1495,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18481,
      803,
      2124,
      12,
      22704,
      14722,
      19575,
      1100,
      1799,
      329,
      15715,
      1366
    ],
    "label": "best_practice",
    "reason": "Rotating x-axis labels improves readability for dense data"
  },
  {
    "line": 143,
    "text": "        ymin, ymax = df.min().min(), df.max().max()",
    "annotation": "\ud83e\udde0 ML Signal: Usage of twin axes indicates advanced plotting techniques",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      331,
      1084,
      11,
      331,
      9806,
      796,
      47764,
      13,
      1084,
      22446,
      1084,
      22784,
      47764,
      13,
      9806,
      22446,
      9806,
      3419
    ],
    "start_token": 1495,
    "end_token": 1520,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      15203,
      34197,
      9217,
      6190,
      29353,
      7605
    ],
    "label": "ml_signal",
    "reason": "Usage of twin axes indicates advanced plotting techniques"
  },
  {
    "line": 145,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of plotting functions indicates data visualization patterns",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1520,
    "end_token": 1520,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      29353,
      5499,
      9217,
      1366,
      32704,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of plotting functions indicates data visualization patterns"
  },
  {
    "line": 147,
    "text": "        self._fea_corr[col].plot(ax=ax, title=col, ylim=self.ylim)",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      5036,
      64,
      62,
      10215,
      81,
      58,
      4033,
      4083,
      29487,
      7,
      897,
      28,
      897,
      11,
      3670,
      28,
      4033,
      11,
      331,
      2475,
      28,
      944,
      13,
      88,
      2475,
      8
    ],
    "start_token": 1520,
    "end_token": 1555,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 149,
    "text": "",
    "annotation": "\u2705 Best Practice: Clear axis labels improve plot readability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1555,
    "end_token": 1555,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      16488,
      14722,
      2987,
      7110,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear axis labels improve plot readability"
  },
  {
    "line": 150,
    "text": "",
    "annotation": "\u2705 Best Practice: Rotating x-axis labels improves readability for dense data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1555,
    "end_token": 1555,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18481,
      803,
      2124,
      12,
      22704,
      14722,
      19575,
      1100,
      1799,
      329,
      15715,
      1366
    ],
    "label": "best_practice",
    "reason": "Rotating x-axis labels improves readability for dense data"
  },
  {
    "line": 154,
    "text": "        self._kurt = datetime_groupby_apply(self._dataset, pd.DataFrame.kurt)",
    "annotation": "\u2705 Best Practice: Disabling grid can improve plot clarity when not needed",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      74,
      3325,
      796,
      4818,
      8079,
      62,
      8094,
      1525,
      62,
      39014,
      7,
      944,
      13557,
      19608,
      292,
      316,
      11,
      279,
      67,
      13,
      6601,
      19778,
      13,
      74,
      3325,
      8
    ],
    "start_token": 1555,
    "end_token": 1590,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3167,
      11716,
      10706,
      460,
      2987,
      7110,
      16287,
      618,
      407,
      2622
    ],
    "label": "best_practice",
    "reason": "Disabling grid can improve plot clarity when not needed"
  },
  {
    "line": 155,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Handling of legend objects indicates customization of plot appearance",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1590,
    "end_token": 1590,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      286,
      8177,
      5563,
      9217,
      31344,
      286,
      7110,
      5585
    ],
    "label": "ml_signal",
    "reason": "Handling of legend objects indicates customization of plot appearance"
  },
  {
    "line": 158,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\u2705 Best Practice: Hiding redundant legends can reduce visual clutter",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1590,
    "end_token": 1605,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      367,
      2530,
      30806,
      24901,
      460,
      4646,
      5874,
      45343
    ],
    "label": "best_practice",
    "reason": "Hiding redundant legends can reduce visual clutter"
  },
  {
    "line": 159,
    "text": "        ax.set_ylabel(\"skew\")",
    "annotation": "\u2705 Best Practice: Combining legends from multiple axes for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      2645,
      9608,
      7203,
      82,
      365,
      86,
      4943
    ],
    "start_token": 1605,
    "end_token": 1623,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14336,
      3191,
      24901,
      422,
      3294,
      34197,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Combining legends from multiple axes for clarity"
  },
  {
    "line": 159,
    "text": "        ax.set_ylabel(\"skew\")",
    "annotation": "\u2705 Best Practice: Setting a title improves plot context and understanding",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      2645,
      9608,
      7203,
      82,
      365,
      86,
      4943
    ],
    "start_token": 1623,
    "end_token": 1641,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      257,
      3670,
      19575,
      7110,
      4732,
      290,
      4547
    ],
    "label": "best_practice",
    "reason": "Setting a title improves plot context and understanding"
  },
  {
    "line": 154,
    "text": "        self._kurt = datetime_groupby_apply(self._dataset, pd.DataFrame.kurt)",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear explanation of the class purpose",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      74,
      3325,
      796,
      4818,
      8079,
      62,
      8094,
      1525,
      62,
      39014,
      7,
      944,
      13557,
      19608,
      292,
      316,
      11,
      279,
      67,
      13,
      6601,
      19778,
      13,
      74,
      3325,
      8
    ],
    "start_token": 1641,
    "end_token": 1676,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear explanation of the class purpose"
  },
  {
    "line": 154,
    "text": "        self._kurt = datetime_groupby_apply(self._dataset, pd.DataFrame.kurt)",
    "annotation": "\ud83e\udde0 ML Signal: Method for calculating statistical values from a dataset",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      74,
      3325,
      796,
      4818,
      8079,
      62,
      8094,
      1525,
      62,
      39014,
      7,
      944,
      13557,
      19608,
      292,
      316,
      11,
      279,
      67,
      13,
      6601,
      19778,
      13,
      74,
      3325,
      8
    ],
    "start_token": 1676,
    "end_token": 1711,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      26019,
      13905,
      3815,
      422,
      257,
      27039
    ],
    "label": "ml_signal",
    "reason": "Method for calculating statistical values from a dataset"
  },
  {
    "line": 156,
    "text": "    def plot_single(self, col, ax):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of min and max functions to determine dataset range",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      7110,
      62,
      29762,
      7,
      944,
      11,
      951,
      11,
      7877,
      2599
    ],
    "start_token": 1711,
    "end_token": 1725,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      949,
      290,
      3509,
      5499,
      284,
      5004,
      27039,
      2837
    ],
    "label": "ml_signal",
    "reason": "Usage of min and max functions to determine dataset range"
  },
  {
    "line": 158,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\u2705 Best Practice: Store calculated limits in a tuple for clarity and immutability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1725,
    "end_token": 1740,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      9363,
      10488,
      7095,
      287,
      257,
      46545,
      329,
      16287,
      290,
      2296,
      315,
      1799
    ],
    "label": "best_practice",
    "reason": "Store calculated limits in a tuple for clarity and immutability"
  },
  {
    "line": 158,
    "text": "        ax.set_xlabel(\"\")",
    "annotation": "\ud83e\udde0 ML Signal: Method for plotting data, indicating usage of visualization libraries",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      87,
      18242,
      7203,
      4943
    ],
    "start_token": 1740,
    "end_token": 1755,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      29353,
      1366,
      11,
      12739,
      8748,
      286,
      32704,
      12782
    ],
    "label": "ml_signal",
    "reason": "Method for plotting data, indicating usage of visualization libraries"
  },
  {
    "line": 159,
    "text": "        ax.set_ylabel(\"skew\")",
    "annotation": "\u2705 Best Practice: Accessing class attribute self._dataset for data encapsulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      2645,
      9608,
      7203,
      82,
      365,
      86,
      4943
    ],
    "start_token": 1755,
    "end_token": 1773,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8798,
      278,
      1398,
      11688,
      2116,
      13557,
      19608,
      292,
      316,
      329,
      1366,
      32652,
      1741
    ],
    "label": "best_practice",
    "reason": "Accessing class attribute self._dataset for data encapsulation"
  },
  {
    "line": 159,
    "text": "        ax.set_ylabel(\"skew\")",
    "annotation": "\u2705 Best Practice: Setting x-label to an empty string for cleaner plots",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7877,
      13,
      2617,
      62,
      2645,
      9608,
      7203,
      82,
      365,
      86,
      4943
    ],
    "start_token": 1773,
    "end_token": 1791,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      25700,
      2124,
      12,
      18242,
      284,
      281,
      6565,
      4731,
      329,
      21723,
      21528
    ],
    "label": "best_practice",
    "reason": "Setting x-label to an empty string for cleaner plots"
  }
]