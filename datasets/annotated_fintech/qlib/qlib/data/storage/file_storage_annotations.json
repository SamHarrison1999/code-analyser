[
  {
    "line": 11,
    "text": "from qlib.utils.time import Freq",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern can be used to train models to identify logging practices",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      26791,
      13,
      2435,
      1330,
      4848,
      80
    ],
    "start_token": 0,
    "end_token": 10,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      460,
      307,
      973,
      284,
      4512,
      4981,
      284,
      5911,
      18931,
      6593
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern can be used to train models to identify logging practices"
  },
  {
    "line": 12,
    "text": "from qlib.utils.resam import resam_calendar",
    "annotation": "\u2705 Best Practice: Using a logger instead of print statements for logging is a best practice",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      26791,
      13,
      411,
      321,
      1330,
      581,
      321,
      62,
      9948,
      9239
    ],
    "start_token": 10,
    "end_token": 24,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      49706,
      2427,
      286,
      3601,
      6299,
      329,
      18931,
      318,
      257,
      1266,
      3357
    ],
    "label": "best_practice",
    "reason": "Using a logger instead of print statements for logging is a best practice"
  },
  {
    "line": 14,
    "text": "from qlib.data.cache import H",
    "annotation": "\ud83e\udde0 ML Signal: Importing specific classes and functions can indicate usage patterns for ML models",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      7890,
      13,
      23870,
      1330,
      367
    ],
    "start_token": 24,
    "end_token": 33,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17267,
      278,
      2176,
      6097,
      290,
      5499,
      460,
      7603,
      8748,
      7572,
      329,
      10373,
      4981
    ],
    "label": "ml_signal",
    "reason": "Importing specific classes and functions can indicate usage patterns for ML models"
  },
  {
    "line": 14,
    "text": "from qlib.data.cache import H",
    "annotation": "\u2705 Best Practice: Use of @property decorator for getter method",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      7890,
      13,
      23870,
      1330,
      367
    ],
    "start_token": 33,
    "end_token": 42,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      651,
      353,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for getter method"
  },
  {
    "line": 14,
    "text": "from qlib.data.cache import H",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      7890,
      13,
      23870,
      1330,
      367
    ],
    "start_token": 42,
    "end_token": 51,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting"
  },
  {
    "line": 19,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential file path manipulation vulnerability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 51,
    "end_token": 51,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      2393,
      3108,
      17512,
      15131
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential file path manipulation vulnerability"
  },
  {
    "line": 22,
    "text": "    \"\"\"FileStorageMixin, applicable to FileXXXStorage",
    "annotation": "\u2705 Best Practice: Use of 'with' statement for file operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227,
      8979,
      31425,
      35608,
      259,
      11,
      9723,
      284,
      9220,
      43145,
      31425
    ],
    "start_token": 51,
    "end_token": 65,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      4480,
      6,
      2643,
      329,
      2393,
      4560
    ],
    "label": "best_practice",
    "reason": "Use of 'with' statement for file operations"
  },
  {
    "line": 26,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential file path manipulation vulnerability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 65,
    "end_token": 65,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      2393,
      3108,
      17512,
      15131
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential file path manipulation vulnerability"
  },
  {
    "line": 28,
    "text": "    #   1. self._provider_uri : if provider_uri is provided.",
    "annotation": "\u2705 Best Practice: Use of 'with' statement for file operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      220,
      220,
      352,
      13,
      2116,
      13557,
      15234,
      1304,
      62,
      9900,
      1058,
      611,
      10131,
      62,
      9900,
      318,
      2810,
      13
    ],
    "start_token": 65,
    "end_token": 87,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      4480,
      6,
      2643,
      329,
      2393,
      4560
    ],
    "label": "best_practice",
    "reason": "Use of 'with' statement for file operations"
  },
  {
    "line": 33,
    "text": "        return C[\"provider_uri\"] if getattr(self, \"_provider_uri\", None) is None else self._provider_uri",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential file path manipulation vulnerability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      327,
      14692,
      15234,
      1304,
      62,
      9900,
      8973,
      611,
      651,
      35226,
      7,
      944,
      11,
      45434,
      15234,
      1304,
      62,
      9900,
      1600,
      6045,
      8,
      318,
      6045,
      2073,
      2116,
      13557,
      15234,
      1304,
      62,
      9900
    ],
    "start_token": 87,
    "end_token": 125,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      2393,
      3108,
      17512,
      15131
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential file path manipulation vulnerability"
  },
  {
    "line": 38,
    "text": "            C.dpm",
    "annotation": "\u2705 Best Practice: Informative logging for non-existent file",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      327,
      13,
      67,
      4426
    ],
    "start_token": 125,
    "end_token": 140,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      45255,
      876,
      18931,
      329,
      1729,
      12,
      32786,
      2393
    ],
    "label": "best_practice",
    "reason": "Informative logging for non-existent file"
  },
  {
    "line": 18,
    "text": "logger = get_module_logger(\"file_storage\")",
    "annotation": "\u2705 Best Practice: Use of a property method to encapsulate access to the provider_uri attribute",
    "confidence": 0.5,
    "tokens": [
      6404,
      1362,
      796,
      651,
      62,
      21412,
      62,
      6404,
      1362,
      7203,
      7753,
      62,
      35350,
      4943
    ],
    "start_token": 140,
    "end_token": 154,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      3119,
      2446,
      284,
      32652,
      5039,
      1895,
      284,
      262,
      10131,
      62,
      9900,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of a property method to encapsulate access to the provider_uri attribute"
  },
  {
    "line": 19,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of a conditional expression for concise logic",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 154,
    "end_token": 154,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      26340,
      5408,
      329,
      35327,
      9156
    ],
    "label": "best_practice",
    "reason": "Use of a conditional expression for concise logic"
  },
  {
    "line": 22,
    "text": "    \"\"\"FileStorageMixin, applicable to FileXXXStorage",
    "annotation": "\u2705 Best Practice: Use of getattr with a default value to avoid AttributeError",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227,
      8979,
      31425,
      35608,
      259,
      11,
      9723,
      284,
      9220,
      43145,
      31425
    ],
    "start_token": 154,
    "end_token": 168,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      35226,
      351,
      257,
      4277,
      1988,
      284,
      3368,
      3460,
      4163,
      12331
    ],
    "label": "best_practice",
    "reason": "Use of getattr with a default value to avoid AttributeError"
  },
  {
    "line": 29,
    "text": "    #   2. provider_uri in qlib.config.C",
    "annotation": "\u2705 Best Practice: Use of a descriptive variable name for caching attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      220,
      220,
      362,
      13,
      10131,
      62,
      9900,
      287,
      10662,
      8019,
      13,
      11250,
      13,
      34
    ],
    "start_token": 168,
    "end_token": 186,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      35644,
      7885,
      1438,
      329,
      40918,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of a descriptive variable name for caching attribute"
  },
  {
    "line": 31,
    "text": "    @property",
    "annotation": "\u2705 Best Practice: Check if an attribute exists before accessing it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 186,
    "end_token": 191,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      281,
      11688,
      7160,
      878,
      22534,
      340
    ],
    "label": "best_practice",
    "reason": "Check if an attribute exists before accessing it"
  },
  {
    "line": 33,
    "text": "        return C[\"provider_uri\"] if getattr(self, \"_provider_uri\", None) is None else self._provider_uri",
    "annotation": "\u2705 Best Practice: Use of getattr to access an attribute dynamically",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      327,
      14692,
      15234,
      1304,
      62,
      9900,
      8973,
      611,
      651,
      35226,
      7,
      944,
      11,
      45434,
      15234,
      1304,
      62,
      9900,
      1600,
      6045,
      8,
      318,
      6045,
      2073,
      2116,
      13557,
      15234,
      1304,
      62,
      9900
    ],
    "start_token": 191,
    "end_token": 229,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      35226,
      284,
      1895,
      281,
      11688,
      32366
    ],
    "label": "best_practice",
    "reason": "Use of getattr to access an attribute dynamically"
  },
  {
    "line": 33,
    "text": "        return C[\"provider_uri\"] if getattr(self, \"_provider_uri\", None) is None else self._provider_uri",
    "annotation": "\u2705 Best Practice: Use of constants for configuration values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      327,
      14692,
      15234,
      1304,
      62,
      9900,
      8973,
      611,
      651,
      35226,
      7,
      944,
      11,
      45434,
      15234,
      1304,
      62,
      9900,
      1600,
      6045,
      8,
      318,
      6045,
      2073,
      2116,
      13557,
      15234,
      1304,
      62,
      9900
    ],
    "start_token": 229,
    "end_token": 267,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      38491,
      329,
      8398,
      3815
    ],
    "label": "best_practice",
    "reason": "Use of constants for configuration values"
  },
  {
    "line": 38,
    "text": "            C.dpm",
    "annotation": "\u2705 Best Practice: Use of filter and map for functional programming",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      327,
      13,
      67,
      4426
    ],
    "start_token": 267,
    "end_token": 282,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      8106,
      290,
      3975,
      329,
      10345,
      8300
    ],
    "label": "best_practice",
    "reason": "Use of filter and map for functional programming"
  },
  {
    "line": 39,
    "text": "            if getattr(self, \"_provider_uri\", None) is None",
    "annotation": "\u2705 Best Practice: Use of lambda for inline function definition",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      651,
      35226,
      7,
      944,
      11,
      45434,
      15234,
      1304,
      62,
      9900,
      1600,
      6045,
      8,
      318,
      6045
    ],
    "start_token": 282,
    "end_token": 309,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      37456,
      329,
      26098,
      2163,
      6770
    ],
    "label": "best_practice",
    "reason": "Use of lambda for inline function definition"
  },
  {
    "line": 41,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Use of map for transforming data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 309,
    "end_token": 317,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3975,
      329,
      25449,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of map for transforming data"
  },
  {
    "line": 45,
    "text": "        _v = \"_support_freq\"",
    "annotation": "\u2705 Best Practice: Directly using keys from a dictionary",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      85,
      796,
      45434,
      11284,
      62,
      19503,
      80,
      1
    ],
    "start_token": 317,
    "end_token": 333,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4128,
      306,
      1262,
      8251,
      422,
      257,
      22155
    ],
    "label": "best_practice",
    "reason": "Directly using keys from a dictionary"
  },
  {
    "line": 47,
    "text": "            return getattr(self, _v)",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of items to a specific class (Freq) indicates a pattern of data transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      651,
      35226,
      7,
      944,
      11,
      4808,
      85,
      8
    ],
    "start_token": 333,
    "end_token": 353,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      3709,
      284,
      257,
      2176,
      1398,
      357,
      20366,
      80,
      8,
      9217,
      257,
      3912,
      286,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Conversion of items to a specific class (Freq) indicates a pattern of data transformation"
  },
  {
    "line": 48,
    "text": "        if len(self.provider_uri) == 1 and C.DEFAULT_FREQ in self.provider_uri:",
    "annotation": "\u2705 Best Practice: Caching the result in an instance attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      944,
      13,
      15234,
      1304,
      62,
      9900,
      8,
      6624,
      352,
      290,
      327,
      13,
      7206,
      38865,
      62,
      37,
      2200,
      48,
      287,
      2116,
      13,
      15234,
      1304,
      62,
      9900,
      25
    ],
    "start_token": 353,
    "end_token": 389,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      327,
      8103,
      262,
      1255,
      287,
      281,
      4554,
      11688
    ],
    "label": "best_practice",
    "reason": "Caching the result in an instance attribute"
  },
  {
    "line": 44,
    "text": "    def support_freq(self) -> List[str]:",
    "annotation": "\ud83e\udde0 ML Signal: Method returns a Path object, indicating file or directory path handling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1104,
      62,
      19503,
      80,
      7,
      944,
      8,
      4613,
      7343,
      58,
      2536,
      5974
    ],
    "start_token": 389,
    "end_token": 405,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      5860,
      257,
      10644,
      2134,
      11,
      12739,
      2393,
      393,
      8619,
      3108,
      9041
    ],
    "label": "ml_signal",
    "reason": "Method returns a Path object, indicating file or directory path handling"
  },
  {
    "line": 46,
    "text": "        if hasattr(self, _v):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for ValueError to be raised, ensure proper handling where this method is called",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      468,
      35226,
      7,
      944,
      11,
      4808,
      85,
      2599
    ],
    "start_token": 405,
    "end_token": 421,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11052,
      12331,
      284,
      307,
      4376,
      11,
      4155,
      1774,
      9041,
      810,
      428,
      2446,
      318,
      1444
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for ValueError to be raised, ensure proper handling where this method is called"
  },
  {
    "line": 48,
    "text": "        if len(self.provider_uri) == 1 and C.DEFAULT_FREQ in self.provider_uri:",
    "annotation": "\u2705 Best Practice: Use of joinpath for constructing file paths is preferred for readability and OS compatibility",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      944,
      13,
      15234,
      1304,
      62,
      9900,
      8,
      6624,
      352,
      290,
      327,
      13,
      7206,
      38865,
      62,
      37,
      2200,
      48,
      287,
      2116,
      13,
      15234,
      1304,
      62,
      9900,
      25
    ],
    "start_token": 421,
    "end_token": 457,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4654,
      6978,
      329,
      30580,
      2393,
      13532,
      318,
      9871,
      329,
      1100,
      1799,
      290,
      7294,
      17764
    ],
    "label": "best_practice",
    "reason": "Use of joinpath for constructing file paths is preferred for readability and OS compatibility"
  },
  {
    "line": 53,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure in error message",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 457,
    "end_token": 466,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      287,
      4049,
      3275
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure in error message"
  },
  {
    "line": 55,
    "text": "        freq_l = [Freq(freq) for freq in freq_l]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure in error message",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      62,
      75,
      796,
      685,
      20366,
      80,
      7,
      19503,
      80,
      8,
      329,
      2030,
      80,
      287,
      2030,
      80,
      62,
      75,
      60
    ],
    "start_token": 466,
    "end_token": 494,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      287,
      4049,
      3275
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure in error message"
  },
  {
    "line": 56,
    "text": "        setattr(self, _v, freq_l)",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      900,
      35226,
      7,
      944,
      11,
      4808,
      85,
      11,
      2030,
      80,
      62,
      75,
      8
    ],
    "start_token": 494,
    "end_token": 514,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage"
  },
  {
    "line": 57,
    "text": "        return freq_l",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2030,
      80,
      62,
      75
    ],
    "start_token": 514,
    "end_token": 526,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization."
  },
  {
    "line": 59,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Storing a boolean value that might affect behavior or decision-making.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 526,
    "end_token": 531,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      25131,
      1988,
      326,
      1244,
      2689,
      4069,
      393,
      2551,
      12,
      8601,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing a boolean value that might affect behavior or decision-making."
  },
  {
    "line": 61,
    "text": "        if self.freq not in self.support_freq:",
    "annotation": "\ud83e\udde0 ML Signal: Conditional assignment based on input, indicating a potential configuration pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      19503,
      80,
      407,
      287,
      2116,
      13,
      11284,
      62,
      19503,
      80,
      25
    ],
    "start_token": 531,
    "end_token": 552,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      16237,
      1912,
      319,
      5128,
      11,
      12739,
      257,
      2785,
      8398,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional assignment based on input, indicating a potential configuration pattern."
  },
  {
    "line": 63,
    "text": "        return self.dpm.get_data_uri(self.freq).joinpath(f\"{self.storage_name}s\", self.file_name)",
    "annotation": "\ud83e\udde0 ML Signal: Boolean flag that might be used to toggle functionality.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      67,
      4426,
      13,
      1136,
      62,
      7890,
      62,
      9900,
      7,
      944,
      13,
      19503,
      80,
      737,
      22179,
      6978,
      7,
      69,
      1,
      90,
      944,
      13,
      35350,
      62,
      3672,
      92,
      82,
      1600,
      2116,
      13,
      7753,
      62,
      3672,
      8
    ],
    "start_token": 552,
    "end_token": 596,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      41146,
      6056,
      326,
      1244,
      307,
      973,
      284,
      19846,
      11244,
      13
    ],
    "label": "ml_signal",
    "reason": "Boolean flag that might be used to toggle functionality."
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Accessing a global configuration object, which might be modified elsewhere.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 596,
    "end_token": 596,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8798,
      278,
      257,
      3298,
      8398,
      2134,
      11,
      543,
      1244,
      307,
      9518,
      8057,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Accessing a global configuration object, which might be modified elsewhere."
  },
  {
    "line": 63,
    "text": "        return self.dpm.get_data_uri(self.freq).joinpath(f\"{self.storage_name}s\", self.file_name)",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      67,
      4426,
      13,
      1136,
      62,
      7890,
      62,
      9900,
      7,
      944,
      13,
      19503,
      80,
      737,
      22179,
      6978,
      7,
      69,
      1,
      90,
      944,
      13,
      35350,
      62,
      3672,
      92,
      82,
      1600,
      2116,
      13,
      7753,
      62,
      3672,
      8
    ],
    "start_token": 596,
    "end_token": 640,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting"
  },
  {
    "line": 64,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic in return statement",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 640,
    "end_token": 640,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      287,
      1441,
      2643
    ],
    "label": "ml_signal",
    "reason": "Conditional logic in return statement"
  },
  {
    "line": 68,
    "text": "        Raises",
    "annotation": "\u2705 Best Practice: Check for attribute existence before using it to avoid AttributeError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7567,
      2696
    ],
    "start_token": 640,
    "end_token": 649,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      11688,
      6224,
      878,
      1262,
      340,
      284,
      3368,
      3460,
      4163,
      12331,
      13
    ],
    "label": "best_practice",
    "reason": "Check for attribute existence before using it to avoid AttributeError."
  },
  {
    "line": 70,
    "text": "        ValueError",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a custom class 'Freq' to handle frequency-related operations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11052,
      12331
    ],
    "start_token": 649,
    "end_token": 658,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2183,
      1398,
      705,
      20366,
      80,
      6,
      284,
      5412,
      8373,
      12,
      5363,
      4560,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a custom class 'Freq' to handle frequency-related operations."
  },
  {
    "line": 72,
    "text": "        if not self.uri.exists():",
    "annotation": "\ud83e\udde0 ML Signal: Checking membership in a list or set, indicating validation of input against allowed values.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13,
      9900,
      13,
      1069,
      1023,
      33529
    ],
    "start_token": 658,
    "end_token": 674,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      9931,
      287,
      257,
      1351,
      393,
      900,
      11,
      12739,
      21201,
      286,
      5128,
      1028,
      3142,
      3815,
      13
    ],
    "label": "ml_signal",
    "reason": "Checking membership in a list or set, indicating validation of input against allowed values."
  },
  {
    "line": 74,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a method to get a recent frequency, indicating a fallback mechanism.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 674,
    "end_token": 674,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2446,
      284,
      651,
      257,
      2274,
      8373,
      11,
      12739,
      257,
      2121,
      1891,
      9030,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a method to get a recent frequency, indicating a fallback mechanism."
  },
  {
    "line": 76,
    "text": "class FileCalendarStorage(FileStorageMixin, CalendarStorage):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a ValueError with potentially sensitive information about internal state.",
    "confidence": 1.0,
    "tokens": [
      4871,
      9220,
      9771,
      9239,
      31425,
      7,
      8979,
      31425,
      35608,
      259,
      11,
      26506,
      31425,
      2599
    ],
    "start_token": 674,
    "end_token": 688,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      11052,
      12331,
      351,
      6196,
      8564,
      1321,
      546,
      5387,
      1181,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a ValueError with potentially sensitive information about internal state."
  },
  {
    "line": 79,
    "text": "        self.future = future",
    "annotation": "\u2705 Best Practice: Caching the result to avoid redundant calculations and improve performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      37443,
      796,
      2003
    ],
    "start_token": 688,
    "end_token": 700,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      327,
      8103,
      262,
      1255,
      284,
      3368,
      30806,
      16765,
      290,
      2987,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Caching the result to avoid redundant calculations and improve performance."
  },
  {
    "line": 76,
    "text": "class FileCalendarStorage(FileStorageMixin, CalendarStorage):",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      4871,
      9220,
      9771,
      9239,
      31425,
      7,
      8979,
      31425,
      35608,
      259,
      11,
      26506,
      31425,
      2599
    ],
    "start_token": 700,
    "end_token": 714,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 78,
    "text": "        super(FileCalendarStorage, self).__init__(freq, future, **kwargs)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential issue if self.uri is user-controlled, leading to path traversal or file access vulnerabilities",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      8979,
      9771,
      9239,
      31425,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7,
      19503,
      80,
      11,
      2003,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 714,
    "end_token": 743,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2071,
      611,
      2116,
      13,
      9900,
      318,
      2836,
      12,
      14401,
      11,
      3756,
      284,
      3108,
      33038,
      282,
      393,
      2393,
      1895,
      23805
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential issue if self.uri is user-controlled, leading to path traversal or file access vulnerabilities"
  },
  {
    "line": 80,
    "text": "        self._provider_uri = None if provider_uri is None else C.DataPathManager.format_provider_uri(provider_uri)",
    "annotation": "\ud83e\udde0 ML Signal: Checking for file existence before attempting to read or write",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      15234,
      1304,
      62,
      9900,
      796,
      6045,
      611,
      10131,
      62,
      9900,
      318,
      6045,
      2073,
      327,
      13,
      6601,
      15235,
      13511,
      13,
      18982,
      62,
      15234,
      1304,
      62,
      9900,
      7,
      15234,
      1304,
      62,
      9900,
      8
    ],
    "start_token": 743,
    "end_token": 783,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      329,
      2393,
      6224,
      878,
      9361,
      284,
      1100,
      393,
      3551
    ],
    "label": "ml_signal",
    "reason": "Checking for file existence before attempting to read or write"
  },
  {
    "line": 82,
    "text": "        self.region = C[\"region\"]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Opening files without specifying encoding can lead to issues on different systems",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      36996,
      796,
      327,
      14692,
      36996,
      8973
    ],
    "start_token": 783,
    "end_token": 798,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      25522,
      3696,
      1231,
      31577,
      21004,
      460,
      1085,
      284,
      2428,
      319,
      1180,
      3341
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Opening files without specifying encoding can lead to issues on different systems"
  },
  {
    "line": 85,
    "text": "    def file_name(self) -> str:",
    "annotation": "\ud83e\udde0 ML Signal: Reading lines from a file and processing them",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      2393,
      62,
      3672,
      7,
      944,
      8,
      4613,
      965,
      25
    ],
    "start_token": 798,
    "end_token": 811,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      3951,
      422,
      257,
      2393,
      290,
      7587,
      606
    ],
    "label": "ml_signal",
    "reason": "Reading lines from a file and processing them"
  },
  {
    "line": 87,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Stripping whitespace from lines before processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 811,
    "end_token": 811,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26137,
      2105,
      13216,
      10223,
      422,
      3951,
      878,
      7587
    ],
    "label": "ml_signal",
    "reason": "Stripping whitespace from lines before processing"
  },
  {
    "line": 90,
    "text": "        \"\"\"the freq to read from file\"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Filtering out empty lines from the result",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      1169,
      2030,
      80,
      284,
      1100,
      422,
      2393,
      37811
    ],
    "start_token": 811,
    "end_token": 827,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      503,
      6565,
      3951,
      422,
      262,
      1255
    ],
    "label": "ml_signal",
    "reason": "Filtering out empty lines from the result"
  },
  {
    "line": 86,
    "text": "        return f\"{self._freq_file}_future.txt\" if self.future else f\"{self._freq_file}.txt\".lower()",
    "annotation": "\u2705 Best Practice: Type hint for 'values' parameter improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      277,
      1,
      90,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      92,
      62,
      37443,
      13,
      14116,
      1,
      611,
      2116,
      13,
      37443,
      2073,
      277,
      1,
      90,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      27422,
      14116,
      1911,
      21037,
      3419
    ],
    "start_token": 827,
    "end_token": 869,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      329,
      705,
      27160,
      6,
      11507,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hint for 'values' parameter improves code readability and maintainability"
  },
  {
    "line": 87,
    "text": "",
    "annotation": "\u2705 Best Practice: Default parameter 'mode' allows flexibility in file operation",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 869,
    "end_token": 869,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      11507,
      705,
      14171,
      6,
      3578,
      13688,
      287,
      2393,
      4905
    ],
    "label": "best_practice",
    "reason": "Default parameter 'mode' allows flexibility in file operation"
  },
  {
    "line": 88,
    "text": "    @property",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure 'self.uri' is a trusted source to prevent path traversal vulnerabilities",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 869,
    "end_token": 874,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      705,
      944,
      13,
      9900,
      6,
      318,
      257,
      13467,
      2723,
      284,
      2948,
      3108,
      33038,
      282,
      23805
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure 'self.uri' is a trusted source to prevent path traversal vulnerabilities"
  },
  {
    "line": 91,
    "text": "        if not hasattr(self, \"_freq_file_cache\"):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure 'values' is sanitized to prevent injection attacks in file writing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      468,
      35226,
      7,
      944,
      11,
      45434,
      19503,
      80,
      62,
      7753,
      62,
      23870,
      1,
      2599
    ],
    "start_token": 874,
    "end_token": 897,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      705,
      27160,
      6,
      318,
      5336,
      36951,
      284,
      2948,
      16954,
      3434,
      287,
      2393,
      3597
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure 'values' is sanitized to prevent injection attacks in file writing"
  },
  {
    "line": 91,
    "text": "        if not hasattr(self, \"_freq_file_cache\"):",
    "annotation": "\u2705 Best Practice: Specifying 'fmt' and 'encoding' ensures consistent data formatting and encoding",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      468,
      35226,
      7,
      944,
      11,
      45434,
      19503,
      80,
      62,
      7753,
      62,
      23870,
      1,
      2599
    ],
    "start_token": 897,
    "end_token": 920,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      4035,
      705,
      69,
      16762,
      6,
      290,
      705,
      12685,
      7656,
      6,
      19047,
      6414,
      1366,
      33313,
      290,
      21004
    ],
    "label": "best_practice",
    "reason": "Specifying 'fmt' and 'encoding' ensures consistent data formatting and encoding"
  },
  {
    "line": 90,
    "text": "        \"\"\"the freq to read from file\"\"\"",
    "annotation": "\u2705 Best Practice: Type hinting for the return value improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      1169,
      2030,
      80,
      284,
      1100,
      422,
      2393,
      37811
    ],
    "start_token": 920,
    "end_token": 936,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      1988,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return value improves code readability and maintainability"
  },
  {
    "line": 91,
    "text": "        if not hasattr(self, \"_freq_file_cache\"):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of method chaining pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      468,
      35226,
      7,
      944,
      11,
      45434,
      19503,
      80,
      62,
      7753,
      62,
      23870,
      1,
      2599
    ],
    "start_token": 936,
    "end_token": 959,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2446,
      442,
      1397,
      3912
    ],
    "label": "ml_signal",
    "reason": "Usage of method chaining pattern"
  },
  {
    "line": 93,
    "text": "            if freq not in self.support_freq:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `get_data_uri` returns an unexpected type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2030,
      80,
      407,
      287,
      2116,
      13,
      11284,
      62,
      19503,
      80,
      25
    ],
    "start_token": 959,
    "end_token": 982,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      1136,
      62,
      7890,
      62,
      9900,
      63,
      5860,
      281,
      10059,
      2099
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `get_data_uri` returns an unexpected type"
  },
  {
    "line": 94,
    "text": "                # NOTE: uri",
    "annotation": "\u2705 Best Practice: Ensure that the method name is descriptive and follows naming conventions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      2956,
      72
    ],
    "start_token": 982,
    "end_token": 1002,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      262,
      2446,
      1438,
      318,
      35644,
      290,
      5679,
      19264,
      21396,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure that the method name is descriptive and follows naming conventions."
  },
  {
    "line": 96,
    "text": "                #       - Get the `min_uri` of the closest `freq` under the same \"directory\" as the `uri`",
    "annotation": "\ud83e\udde0 ML Signal: Usage of caching mechanism with a conditional check.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      3497,
      262,
      4600,
      1084,
      62,
      9900,
      63,
      286,
      262,
      11706,
      4600,
      19503,
      80,
      63,
      739,
      262,
      976,
      366,
      34945,
      1,
      355,
      262,
      4600,
      9900,
      63
    ],
    "start_token": 1002,
    "end_token": 1050,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      40918,
      9030,
      351,
      257,
      26340,
      2198,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of caching mechanism with a conditional check."
  },
  {
    "line": 98,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Concatenation of strings to form a cache key.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1050,
    "end_token": 1050,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1482,
      9246,
      268,
      341,
      286,
      13042,
      284,
      1296,
      257,
      12940,
      1994,
      13
    ],
    "label": "ml_signal",
    "reason": "Concatenation of strings to form a cache key."
  },
  {
    "line": 99,
    "text": "                freq = Freq.get_recent_freq(freq, self.support_freq)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of key collision in the cache dictionary.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      796,
      4848,
      80,
      13,
      1136,
      62,
      49921,
      62,
      19503,
      80,
      7,
      19503,
      80,
      11,
      2116,
      13,
      11284,
      62,
      19503,
      80,
      8
    ],
    "start_token": 1050,
    "end_token": 1088,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      1994,
      17661,
      287,
      262,
      12940,
      22155,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of key collision in the cache dictionary."
  },
  {
    "line": 102,
    "text": "            self._freq_file_cache = freq",
    "annotation": "\ud83e\udde0 ML Signal: Caching the result of a function call.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      19503,
      80,
      62,
      7753,
      62,
      23870,
      796,
      2030,
      80
    ],
    "start_token": 1088,
    "end_token": 1110,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      8103,
      262,
      1255,
      286,
      257,
      2163,
      869,
      13
    ],
    "label": "ml_signal",
    "reason": "Caching the result of a function call."
  },
  {
    "line": 107,
    "text": "        # if we want to accelerate partial reading calendar",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on frequency comparison.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      611,
      356,
      765,
      284,
      22636,
      13027,
      3555,
      11845
    ],
    "start_token": 1110,
    "end_token": 1126,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      8373,
      7208,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on frequency comparison."
  },
  {
    "line": 109,
    "text": "        # Currently, it is not supported for the txt-based calendar",
    "annotation": "\ud83e\udde0 ML Signal: Use of resampling function with multiple parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16888,
      11,
      340,
      318,
      407,
      4855,
      329,
      262,
      256,
      742,
      12,
      3106,
      11845
    ],
    "start_token": 1126,
    "end_token": 1147,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      581,
      321,
      11347,
      2163,
      351,
      3294,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of resampling function with multiple parameters."
  },
  {
    "line": 107,
    "text": "        # if we want to accelerate partial reading calendar",
    "annotation": "\u2705 Best Practice: Use of type hinting for the return type improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      611,
      356,
      765,
      284,
      22636,
      13027,
      3555,
      11845
    ],
    "start_token": 1147,
    "end_token": 1163,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for the return type improves code readability and maintainability."
  },
  {
    "line": 109,
    "text": "        # Currently, it is not supported for the txt-based calendar",
    "annotation": "\ud83e\udde0 ML Signal: Use of sorted and set indicates a pattern of deduplication and ordering.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16888,
      11,
      340,
      318,
      407,
      4855,
      329,
      262,
      256,
      742,
      12,
      3106,
      11845
    ],
    "start_token": 1163,
    "end_token": 1184,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      23243,
      290,
      900,
      9217,
      257,
      3912,
      286,
      4648,
      84,
      489,
      3299,
      290,
      16216,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of sorted and set indicates a pattern of deduplication and ordering."
  },
  {
    "line": 110,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda function for inline operations.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1184,
    "end_token": 1184,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      2163,
      329,
      26098,
      4560,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of lambda function for inline operations."
  },
  {
    "line": 111,
    "text": "        if not self.uri.exists():",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for large memory usage if the directory contains many files.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13,
      9900,
      13,
      1069,
      1023,
      33529
    ],
    "start_token": 1184,
    "end_token": 1200,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      1588,
      4088,
      8748,
      611,
      262,
      8619,
      4909,
      867,
      3696,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for large memory usage if the directory contains many files."
  },
  {
    "line": 109,
    "text": "        # Currently, it is not supported for the txt-based calendar",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      16888,
      11,
      340,
      318,
      407,
      4855,
      329,
      262,
      256,
      742,
      12,
      3106,
      11845
    ],
    "start_token": 1200,
    "end_token": 1221,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 111,
    "text": "        if not self.uri.exists():",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a private method indicates encapsulation and abstraction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13,
      9900,
      13,
      1069,
      1023,
      33529
    ],
    "start_token": 1221,
    "end_token": 1237,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2839,
      2446,
      9217,
      32652,
      1741,
      290,
      34651,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of a private method indicates encapsulation and abstraction patterns"
  },
  {
    "line": 112,
    "text": "            self._write_calendar(values=[])",
    "annotation": "\u2705 Best Practice: Using a private method suggests that _write_calendar is intended for internal use only",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      9948,
      9239,
      7,
      27160,
      41888,
      12962
    ],
    "start_token": 1237,
    "end_token": 1258,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      2839,
      2446,
      5644,
      326,
      4808,
      13564,
      62,
      9948,
      9239,
      318,
      5292,
      329,
      5387,
      779,
      691
    ],
    "label": "best_practice",
    "reason": "Using a private method suggests that _write_calendar is intended for internal use only"
  },
  {
    "line": 112,
    "text": "            self._write_calendar(values=[])",
    "annotation": "\u2705 Best Practice: Use of type hint for return value improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      9948,
      9239,
      7,
      27160,
      41888,
      12962
    ],
    "start_token": 1258,
    "end_token": 1279,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      329,
      1441,
      1988,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hint for return value improves code readability and maintainability"
  },
  {
    "line": 114,
    "text": "        with self.uri.open(\"r\") as fp:",
    "annotation": "\ud83e\udde0 ML Signal: Method call with specific argument pattern (empty list) could indicate a reset or clear operation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      2116,
      13,
      9900,
      13,
      9654,
      7203,
      81,
      4943,
      355,
      277,
      79,
      25
    ],
    "start_token": 1279,
    "end_token": 1299,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      2176,
      4578,
      3912,
      357,
      28920,
      1351,
      8,
      714,
      7603,
      257,
      13259,
      393,
      1598,
      4905
    ],
    "label": "ml_signal",
    "reason": "Method call with specific argument pattern (empty list) could indicate a reset or clear operation"
  },
  {
    "line": 114,
    "text": "        with self.uri.open(\"r\") as fp:",
    "annotation": "\u2705 Best Practice: Ensure the method is checking preconditions before proceeding with main logic",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      2116,
      13,
      9900,
      13,
      9654,
      7203,
      81,
      4943,
      355,
      277,
      79,
      25
    ],
    "start_token": 1299,
    "end_token": 1319,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2446,
      318,
      10627,
      3718,
      623,
      1756,
      878,
      18788,
      351,
      1388,
      9156
    ],
    "label": "best_practice",
    "reason": "Ensure the method is checking preconditions before proceeding with main logic"
  },
  {
    "line": 116,
    "text": "            for line in fp.readlines():",
    "annotation": "\u2705 Best Practice: Reading from a calendar source, consider caching if this is a frequent operation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1627,
      287,
      277,
      79,
      13,
      961,
      6615,
      33529
    ],
    "start_token": 1319,
    "end_token": 1339,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11725,
      422,
      257,
      11845,
      2723,
      11,
      2074,
      40918,
      611,
      428,
      318,
      257,
      10792,
      4905
    ],
    "label": "best_practice",
    "reason": "Reading from a calendar source, consider caching if this is a frequent operation"
  },
  {
    "line": 118,
    "text": "                if len(line) > 0:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes that np.argwhere will always find the value, which may lead to IndexError",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      1370,
      8,
      1875,
      657,
      25
    ],
    "start_token": 1339,
    "end_token": 1362,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      326,
      45941,
      13,
      853,
      3003,
      481,
      1464,
      1064,
      262,
      1988,
      11,
      543,
      743,
      1085,
      284,
      12901,
      12331
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes that np.argwhere will always find the value, which may lead to IndexError"
  },
  {
    "line": 119,
    "text": "                    res.append(line)",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for array operations, indicating numerical or data processing tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      13,
      33295,
      7,
      1370,
      8
    ],
    "start_token": 1362,
    "end_token": 1387,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      7177,
      4560,
      11,
      12739,
      29052,
      393,
      1366,
      7587,
      8861
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for array operations, indicating numerical or data processing tasks"
  },
  {
    "line": 117,
    "text": "                line = line.strip()",
    "annotation": "\u2705 Best Practice: Type hinting for parameters improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1627,
      796,
      1627,
      13,
      36311,
      3419
    ],
    "start_token": 1387,
    "end_token": 1408,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for parameters improves code readability and maintainability"
  },
  {
    "line": 119,
    "text": "                    res.append(line)",
    "annotation": "\ud83e\udde0 ML Signal: Reading from a data source before modification is a common pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      13,
      33295,
      7,
      1370,
      8
    ],
    "start_token": 1408,
    "end_token": 1433,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      422,
      257,
      1366,
      2723,
      878,
      17613,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Reading from a data source before modification is a common pattern"
  },
  {
    "line": 121,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for array manipulation is a common pattern",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1433,
    "end_token": 1433,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      7177,
      17512,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for array manipulation is a common pattern"
  },
  {
    "line": 123,
    "text": "        with self.uri.open(mode=mode) as fp:",
    "annotation": "\ud83e\udde0 ML Signal: Writing back to a data source after modification is a common pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      2116,
      13,
      9900,
      13,
      9654,
      7,
      14171,
      28,
      14171,
      8,
      355,
      277,
      79,
      25
    ],
    "start_token": 1433,
    "end_token": 1455,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      736,
      284,
      257,
      1366,
      2723,
      706,
      17613,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Writing back to a data source after modification is a common pattern"
  },
  {
    "line": 122,
    "text": "    def _write_calendar(self, values: Iterable[CalVT], mode: str = \"wb\"):",
    "annotation": "\ud83e\udde0 ML Signal: Method for removing an item from a collection",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      13564,
      62,
      9948,
      9239,
      7,
      944,
      11,
      3815,
      25,
      40806,
      540,
      58,
      9771,
      36392,
      4357,
      4235,
      25,
      965,
      796,
      366,
      39346,
      1,
      2599
    ],
    "start_token": 1455,
    "end_token": 1483,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      10829,
      281,
      2378,
      422,
      257,
      4947
    ],
    "label": "ml_signal",
    "reason": "Method for removing an item from a collection"
  },
  {
    "line": 124,
    "text": "            np.savetxt(fp, values, fmt=\"%s\", encoding=\"utf-8\")",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking preconditions before performing operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      45941,
      13,
      21928,
      14116,
      7,
      46428,
      11,
      3815,
      11,
      46996,
      2625,
      4,
      82,
      1600,
      21004,
      2625,
      40477,
      12,
      23,
      4943
    ],
    "start_token": 1483,
    "end_token": 1514,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      3718,
      623,
      1756,
      878,
      9489,
      4560
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking preconditions before performing operations"
  },
  {
    "line": 126,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Usage of index finding in a collection",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1514,
    "end_token": 1519,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      6376,
      4917,
      287,
      257,
      4947
    ],
    "label": "ml_signal",
    "reason": "Usage of index finding in a collection"
  },
  {
    "line": 128,
    "text": "        return self.dpm.get_data_uri(self._freq_file).joinpath(f\"{self.storage_name}s\", self.file_name)",
    "annotation": "\ud83e\udde0 ML Signal: Reading data from a source before modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      67,
      4426,
      13,
      1136,
      62,
      7890,
      62,
      9900,
      7,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      737,
      22179,
      6978,
      7,
      69,
      1,
      90,
      944,
      13,
      35350,
      62,
      3672,
      92,
      82,
      1600,
      2116,
      13,
      7753,
      62,
      3672,
      8
    ],
    "start_token": 1519,
    "end_token": 1565,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      1366,
      422,
      257,
      2723,
      878,
      17613
    ],
    "label": "ml_signal",
    "reason": "Reading data from a source before modification"
  },
  {
    "line": 130,
    "text": "    @property",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for IndexError if index is out of bounds",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1565,
    "end_token": 1570,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      12901,
      12331,
      611,
      6376,
      318,
      503,
      286,
      22303
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for IndexError if index is out of bounds"
  },
  {
    "line": 131,
    "text": "    def data(self) -> List[CalVT]:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of numpy for array manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1366,
      7,
      944,
      8,
      4613,
      7343,
      58,
      9771,
      36392,
      5974
    ],
    "start_token": 1570,
    "end_token": 1584,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      299,
      32152,
      329,
      7177,
      17512
    ],
    "label": "ml_signal",
    "reason": "Usage of numpy for array manipulation"
  },
  {
    "line": 133,
    "text": "        # If cache is enabled, then return cache directly",
    "annotation": "\ud83e\udde0 ML Signal: Writing data back to a source after modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1002,
      12940,
      318,
      9343,
      11,
      788,
      1441,
      12940,
      3264
    ],
    "start_token": 1584,
    "end_token": 1601,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      1366,
      736,
      284,
      257,
      2723,
      706,
      17613
    ],
    "label": "ml_signal",
    "reason": "Writing data back to a source after modification"
  },
  {
    "line": 127,
    "text": "    def uri(self) -> Path:",
    "annotation": "\u2705 Best Practice: Type hints are used for function parameters and return type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      2956,
      72,
      7,
      944,
      8,
      4613,
      10644,
      25
    ],
    "start_token": 1601,
    "end_token": 1613,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      389,
      973,
      329,
      2163,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Type hints are used for function parameters and return type"
  },
  {
    "line": 129,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method name suggests this is a special method for item assignment",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1613,
    "end_token": 1613,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      1438,
      5644,
      428,
      318,
      257,
      2041,
      2446,
      329,
      2378,
      16237
    ],
    "label": "ml_signal",
    "reason": "Method name suggests this is a special method for item assignment"
  },
  {
    "line": 130,
    "text": "    @property",
    "annotation": "\ud83e\udde0 ML Signal: Use of Union type hint indicates handling of multiple input types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      26745
    ],
    "start_token": 1613,
    "end_token": 1618,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4479,
      2099,
      9254,
      9217,
      9041,
      286,
      3294,
      5128,
      3858
    ],
    "label": "ml_signal",
    "reason": "Use of Union type hint indicates handling of multiple input types"
  },
  {
    "line": 132,
    "text": "        self.check()",
    "annotation": "\ud83e\udde0 ML Signal: Direct assignment to a data structure, indicating in-place modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9122,
      3419
    ],
    "start_token": 1618,
    "end_token": 1629,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4128,
      16237,
      284,
      257,
      1366,
      4645,
      11,
      12739,
      287,
      12,
      5372,
      17613
    ],
    "label": "ml_signal",
    "reason": "Direct assignment to a data structure, indicating in-place modification"
  },
  {
    "line": 134,
    "text": "        if self.enable_read_cache:",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern for persisting changes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      21633,
      62,
      961,
      62,
      23870,
      25
    ],
    "start_token": 1629,
    "end_token": 1645,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      329,
      2774,
      9665,
      2458
    ],
    "label": "ml_signal",
    "reason": "Method call pattern for persisting changes"
  },
  {
    "line": 132,
    "text": "        self.check()",
    "annotation": "\u2705 Best Practice: Ensure the object is in a valid state before performing operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9122,
      3419
    ],
    "start_token": 1645,
    "end_token": 1656,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2134,
      318,
      287,
      257,
      4938,
      1181,
      878,
      9489,
      4560
    ],
    "label": "best_practice",
    "reason": "Ensure the object is in a valid state before performing operations"
  },
  {
    "line": 134,
    "text": "        if self.enable_read_cache:",
    "annotation": "\ud83e\udde0 ML Signal: Reading data from a source before modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      21633,
      62,
      961,
      62,
      23870,
      25
    ],
    "start_token": 1656,
    "end_token": 1672,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      1366,
      422,
      257,
      2723,
      878,
      17613
    ],
    "label": "ml_signal",
    "reason": "Reading data from a source before modification"
  },
  {
    "line": 136,
    "text": "            if key not in H[\"c\"]:",
    "annotation": "\ud83e\udde0 ML Signal: Using numpy to delete elements from an array",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1994,
      407,
      287,
      367,
      14692,
      66,
      1,
      5974
    ],
    "start_token": 1672,
    "end_token": 1692,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      299,
      32152,
      284,
      12233,
      4847,
      422,
      281,
      7177
    ],
    "label": "ml_signal",
    "reason": "Using numpy to delete elements from an array"
  },
  {
    "line": 138,
    "text": "            _calendar = H[\"c\"][key]",
    "annotation": "\ud83e\udde0 ML Signal: Writing data back to a source after modification",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      9948,
      9239,
      796,
      367,
      14692,
      66,
      1,
      7131,
      2539,
      60
    ],
    "start_token": 1692,
    "end_token": 1714,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      1366,
      736,
      284,
      257,
      2723,
      706,
      17613
    ],
    "label": "ml_signal",
    "reason": "Writing data back to a source after modification"
  },
  {
    "line": 137,
    "text": "                H[\"c\"][key] = self._read_calendar()",
    "annotation": "\u2705 Best Practice: Ensure the method is type hinted for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      367,
      14692,
      66,
      1,
      7131,
      2539,
      60,
      796,
      2116,
      13557,
      961,
      62,
      9948,
      9239,
      3419
    ],
    "start_token": 1714,
    "end_token": 1744,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2446,
      318,
      2099,
      27388,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure the method is type hinted for better readability and maintainability."
  },
  {
    "line": 139,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern before accessing an internal method.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1744,
    "end_token": 1753,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      878,
      22534,
      281,
      5387,
      2446,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call pattern before accessing an internal method."
  },
  {
    "line": 141,
    "text": "        if Freq(self._freq_file) != Freq(self.freq):",
    "annotation": "\ud83e\udde0 ML Signal: Access pattern using indexing or slicing on the result of a method call.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4848,
      80,
      7,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      8,
      14512,
      4848,
      80,
      7,
      944,
      13,
      19503,
      80,
      2599
    ],
    "start_token": 1753,
    "end_token": 1780,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      3912,
      1262,
      6376,
      278,
      393,
      49289,
      319,
      262,
      1255,
      286,
      257,
      2446,
      869,
      13
    ],
    "label": "ml_signal",
    "reason": "Access pattern using indexing or slicing on the result of a method call."
  },
  {
    "line": 139,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Use of __len__ method to define object length",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1780,
    "end_token": 1789,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      11925,
      834,
      2446,
      284,
      8160,
      2134,
      4129
    ],
    "label": "best_practice",
    "reason": "Use of __len__ method to define object length"
  },
  {
    "line": 141,
    "text": "        if Freq(self._freq_file) != Freq(self.freq):",
    "annotation": "\ud83e\udde0 ML Signal: Accessing an attribute of the object",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4848,
      80,
      7,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      8,
      14512,
      4848,
      80,
      7,
      944,
      13,
      19503,
      80,
      2599
    ],
    "start_token": 1789,
    "end_token": 1816,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      281,
      11688,
      286,
      262,
      2134
    ],
    "label": "ml_signal",
    "reason": "Accessing an attribute of the object"
  },
  {
    "line": 141,
    "text": "        if Freq(self._freq_file) != Freq(self.freq):",
    "annotation": "\u2705 Best Practice: Class definition with clear inheritance for code organization and reuse",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      4848,
      80,
      7,
      944,
      13557,
      19503,
      80,
      62,
      7753,
      8,
      14512,
      4848,
      80,
      7,
      944,
      13,
      19503,
      80,
      2599
    ],
    "start_token": 1816,
    "end_token": 1843,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      351,
      1598,
      24155,
      329,
      2438,
      4009,
      290,
      32349
    ],
    "label": "best_practice",
    "reason": "Class definition with clear inheritance for code organization and reuse"
  },
  {
    "line": 143,
    "text": "                np.array(list(map(pd.Timestamp, _calendar))), self._freq_file, self.freq, self.region",
    "annotation": "\u2705 Best Practice: Constants are defined for easy configuration and readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      45941,
      13,
      18747,
      7,
      4868,
      7,
      8899,
      7,
      30094,
      13,
      14967,
      27823,
      11,
      4808,
      9948,
      9239,
      4008,
      828,
      2116,
      13557,
      19503,
      80,
      62,
      7753,
      11,
      2116,
      13,
      19503,
      80,
      11,
      2116,
      13,
      36996
    ],
    "start_token": 1843,
    "end_token": 1891,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      389,
      5447,
      329,
      2562,
      8398,
      290,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Constants are defined for easy configuration and readability"
  },
  {
    "line": 147,
    "text": "    def _get_storage_freq(self) -> List[str]:",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      1136,
      62,
      35350,
      62,
      19503,
      80,
      7,
      944,
      8,
      4613,
      7343,
      58,
      2536,
      5974
    ],
    "start_token": 1891,
    "end_token": 1910,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability."
  },
  {
    "line": 148,
    "text": "        return sorted(set(map(lambda x: x.stem.split(\"_\")[0], self.uri.parent.glob(\"*.txt\"))))",
    "annotation": "\u2705 Best Practice: Default mutable arguments should be avoided; using None as a default value is a safer pattern.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      23243,
      7,
      2617,
      7,
      8899,
      7,
      50033,
      2124,
      25,
      2124,
      13,
      927,
      13,
      35312,
      7203,
      62,
      4943,
      58,
      15,
      4357,
      2116,
      13,
      9900,
      13,
      8000,
      13,
      4743,
      672,
      7203,
      24620,
      14116,
      1,
      35514
    ],
    "start_token": 1910,
    "end_token": 1951,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      4517,
      540,
      7159,
      815,
      307,
      13941,
      26,
      1262,
      6045,
      355,
      257,
      4277,
      1988,
      318,
      257,
      14178,
      3912,
      13
    ],
    "label": "best_practice",
    "reason": "Default mutable arguments should be avoided; using None as a default value is a safer pattern."
  },
  {
    "line": 150,
    "text": "    def extend(self, values: Iterable[CalVT]) -> None:",
    "annotation": "\u2705 Best Practice: Use of conditional expression for concise assignment.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      9117,
      7,
      944,
      11,
      3815,
      25,
      40806,
      540,
      58,
      9771,
      36392,
      12962,
      4613,
      6045,
      25
    ],
    "start_token": 1951,
    "end_token": 1970,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      26340,
      5408,
      329,
      35327,
      16237,
      13
    ],
    "label": "best_practice",
    "reason": "Use of conditional expression for concise assignment."
  },
  {
    "line": 152,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of string formatting to create file names based on input parameters.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1970,
    "end_token": 1970,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      33313,
      284,
      2251,
      2393,
      3891,
      1912,
      319,
      5128,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of string formatting to create file names based on input parameters."
  },
  {
    "line": 151,
    "text": "        self._write_calendar(values, mode=\"ab\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential issue if self.uri is user-controlled, leading to path traversal or file access vulnerabilities",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      9948,
      9239,
      7,
      27160,
      11,
      4235,
      2625,
      397,
      4943
    ],
    "start_token": 1970,
    "end_token": 1990,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2071,
      611,
      2116,
      13,
      9900,
      318,
      2836,
      12,
      14401,
      11,
      3756,
      284,
      3108,
      33038,
      282,
      393,
      2393,
      1895,
      23805
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential issue if self.uri is user-controlled, leading to path traversal or file access vulnerabilities"
  },
  {
    "line": 154,
    "text": "        self._write_calendar(values=[])",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pandas to read CSV files, indicating data processing patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      9948,
      9239,
      7,
      27160,
      41888,
      12962
    ],
    "start_token": 1990,
    "end_token": 2007,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      19798,
      292,
      284,
      1100,
      44189,
      3696,
      11,
      12739,
      1366,
      7587,
      7572
    ],
    "label": "ml_signal",
    "reason": "Usage of pandas to read CSV files, indicating data processing patterns"
  },
  {
    "line": 164,
    "text": "        self._write_calendar(values=calendar)",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over DataFrame rows, common pattern in data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      9948,
      9239,
      7,
      27160,
      28,
      9948,
      9239,
      8
    ],
    "start_token": 2007,
    "end_token": 2026,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      6060,
      19778,
      15274,
      11,
      2219,
      3912,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Iterating over DataFrame rows, common pattern in data processing"
  },
  {
    "line": 166,
    "text": "    def remove(self, value: CalVT) -> None:",
    "annotation": "\u2705 Best Practice: Using setdefault to handle dictionary entries efficiently",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4781,
      7,
      944,
      11,
      1988,
      25,
      2199,
      36392,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2026,
    "end_token": 2042,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      900,
      12286,
      284,
      5412,
      22155,
      12784,
      18306
    ],
    "label": "best_practice",
    "reason": "Using setdefault to handle dictionary entries efficiently"
  },
  {
    "line": 166,
    "text": "    def remove(self, value: CalVT) -> None:",
    "annotation": "\u2705 Best Practice: Check for empty data before proceeding with operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4781,
      7,
      944,
      11,
      1988,
      25,
      2199,
      36392,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2042,
    "end_token": 2058,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      1366,
      878,
      18788,
      351,
      4560
    ],
    "label": "best_practice",
    "reason": "Check for empty data before proceeding with operations"
  },
  {
    "line": 173,
    "text": "    def __setitem__(self, i: Union[int, slice], values: Union[CalVT, Iterable[CalVT]]) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pandas DataFrame for data manipulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      2617,
      9186,
      834,
      7,
      944,
      11,
      1312,
      25,
      4479,
      58,
      600,
      11,
      16416,
      4357,
      3815,
      25,
      4479,
      58,
      9771,
      36392,
      11,
      40806,
      540,
      58,
      9771,
      36392,
      11907,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2058,
    "end_token": 2094,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      19798,
      292,
      6060,
      19778,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Usage of pandas DataFrame for data manipulation"
  },
  {
    "line": 175,
    "text": "        calendar[i] = values",
    "annotation": "\ud83e\udde0 ML Signal: Assigning a constant value to a DataFrame column",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11845,
      58,
      72,
      60,
      796,
      3815
    ],
    "start_token": 2094,
    "end_token": 2107,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2195,
      38944,
      257,
      6937,
      1988,
      284,
      257,
      6060,
      19778,
      5721
    ],
    "label": "ml_signal",
    "reason": "Assigning a constant value to a DataFrame column"
  },
  {
    "line": 179,
    "text": "        self.check()",
    "annotation": "\ud83e\udde0 ML Signal: Concatenating multiple DataFrames",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9122,
      3419
    ],
    "start_token": 2107,
    "end_token": 2118,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1482,
      9246,
      268,
      803,
      3294,
      6060,
      35439
    ],
    "label": "ml_signal",
    "reason": "Concatenating multiple DataFrames"
  },
  {
    "line": 180,
    "text": "        calendar = self._read_calendar()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential data overwrite if self.uri is not handled properly",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11845,
      796,
      2116,
      13557,
      961,
      62,
      9948,
      9239,
      3419
    ],
    "start_token": 2118,
    "end_token": 2134,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1366,
      49312,
      611,
      2116,
      13,
      9900,
      318,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential data overwrite if self.uri is not handled properly"
  },
  {
    "line": 184,
    "text": "    def __getitem__(self, i: Union[int, slice]) -> Union[CalVT, List[CalVT]]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential data overwrite if self.uri is not handled properly",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      1136,
      9186,
      834,
      7,
      944,
      11,
      1312,
      25,
      4479,
      58,
      600,
      11,
      16416,
      12962,
      4613,
      4479,
      58,
      9771,
      36392,
      11,
      7343,
      58,
      9771,
      36392,
      60,
      5974
    ],
    "start_token": 2134,
    "end_token": 2165,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1366,
      49312,
      611,
      2116,
      13,
      9900,
      318,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential data overwrite if self.uri is not handled properly"
  },
  {
    "line": 181,
    "text": "        calendar = np.delete(calendar, i)",
    "annotation": "\u2705 Best Practice: Use of type hint for return value improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11845,
      796,
      45941,
      13,
      33678,
      7,
      9948,
      9239,
      11,
      1312,
      8
    ],
    "start_token": 2165,
    "end_token": 2183,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      329,
      1441,
      1988,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hint for return value improves code readability and maintainability"
  },
  {
    "line": 183,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method call with empty dictionary as argument, indicating a reset or clear operation",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2183,
    "end_token": 2183,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      6565,
      22155,
      355,
      4578,
      11,
      12739,
      257,
      13259,
      393,
      1598,
      4905
    ],
    "label": "ml_signal",
    "reason": "Method call with empty dictionary as argument, indicating a reset or clear operation"
  },
  {
    "line": 185,
    "text": "        self.check()",
    "annotation": "\u2705 Best Practice: Use of @property decorator for creating a read-only attribute",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      9122,
      3419
    ],
    "start_token": 2183,
    "end_token": 2194,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      26745,
      11705,
      1352,
      329,
      4441,
      257,
      1100,
      12,
      8807,
      11688
    ],
    "label": "best_practice",
    "reason": "Use of @property decorator for creating a read-only attribute"
  },
  {
    "line": 184,
    "text": "    def __getitem__(self, i: Union[int, slice]) -> Union[CalVT, List[CalVT]]:",
    "annotation": "\ud83e\udde0 ML Signal: Method signature with type hints indicating expected input and output types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      1136,
      9186,
      834,
      7,
      944,
      11,
      1312,
      25,
      4479,
      58,
      600,
      11,
      16416,
      12962,
      4613,
      4479,
      58,
      9771,
      36392,
      11,
      7343,
      58,
      9771,
      36392,
      60,
      5974
    ],
    "start_token": 2194,
    "end_token": 2225,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      351,
      2099,
      20269,
      12739,
      2938,
      5128,
      290,
      5072,
      3858
    ],
    "label": "ml_signal",
    "reason": "Method signature with type hints indicating expected input and output types"
  },
  {
    "line": 186,
    "text": "        return self._read_calendar()[i]",
    "annotation": "\u2705 Best Practice: Ensure that preconditions are met before proceeding with the main logic",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13557,
      961,
      62,
      9948,
      9239,
      3419,
      58,
      72,
      60
    ],
    "start_token": 2225,
    "end_token": 2243,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      326,
      3718,
      623,
      1756,
      389,
      1138,
      878,
      18788,
      351,
      262,
      1388,
      9156
    ],
    "label": "best_practice",
    "reason": "Ensure that preconditions are met before proceeding with the main logic"
  },
  {
    "line": 188,
    "text": "    def __len__(self) -> int:",
    "annotation": "\ud83e\udde0 ML Signal: Returning a method call result, indicating a pattern of delegation or encapsulation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      11925,
      834,
      7,
      944,
      8,
      4613,
      493,
      25
    ],
    "start_token": 2243,
    "end_token": 2256,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      2446,
      869,
      1255,
      11,
      12739,
      257,
      3912,
      286,
      22635,
      393,
      32652,
      1741
    ],
    "label": "ml_signal",
    "reason": "Returning a method call result, indicating a pattern of delegation or encapsulation"
  },
  {
    "line": 186,
    "text": "        return self._read_calendar()[i]",
    "annotation": "\u2705 Best Practice: Type hints for parameters and return value improve code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13557,
      961,
      62,
      9948,
      9239,
      3419,
      58,
      72,
      60
    ],
    "start_token": 2256,
    "end_token": 2274,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      329,
      10007,
      290,
      1441,
      1988,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hints for parameters and return value improve code readability and maintainability"
  },
  {
    "line": 188,
    "text": "    def __len__(self) -> int:",
    "annotation": "\ud83e\udde0 ML Signal: Reading from a private method, indicating encapsulation and internal state management",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      11925,
      834,
      7,
      944,
      8,
      4613,
      493,
      25
    ],
    "start_token": 2274,
    "end_token": 2287,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      422,
      257,
      2839,
      2446,
      11,
      12739,
      32652,
      1741,
      290,
      5387,
      1181,
      4542
    ],
    "label": "ml_signal",
    "reason": "Reading from a private method, indicating encapsulation and internal state management"
  },
  {
    "line": 190,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Dictionary-like item assignment pattern",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2287,
    "end_token": 2287,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28261,
      12,
      2339,
      2378,
      16237,
      3912
    ],
    "label": "ml_signal",
    "reason": "Dictionary-like item assignment pattern"
  },
  {
    "line": 192,
    "text": "class FileInstrumentStorage(FileStorageMixin, InstrumentStorage):",
    "annotation": "\ud83e\udde0 ML Signal: Writing to a private method, indicating encapsulation and internal state management",
    "confidence": 1.0,
    "tokens": [
      4871,
      9220,
      818,
      43872,
      31425,
      7,
      8979,
      31425,
      35608,
      259,
      11,
      42410,
      31425,
      2599
    ],
    "start_token": 2287,
    "end_token": 2301,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      284,
      257,
      2839,
      2446,
      11,
      12739,
      32652,
      1741,
      290,
      5387,
      1181,
      4542
    ],
    "label": "ml_signal",
    "reason": "Writing to a private method, indicating encapsulation and internal state management"
  },
  {
    "line": 191,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensure the object is in a valid state before performing operations",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2301,
    "end_token": 2301,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2134,
      318,
      287,
      257,
      4938,
      1181,
      878,
      9489,
      4560
    ],
    "label": "best_practice",
    "reason": "Ensure the object is in a valid state before performing operations"
  },
  {
    "line": 193,
    "text": "    INSTRUMENT_SEP = \"\\t\"",
    "annotation": "\ud83e\udde0 ML Signal: Reading an instrument before modifying it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      3268,
      18601,
      5883,
      3525,
      62,
      5188,
      47,
      796,
      37082,
      83,
      1
    ],
    "start_token": 2301,
    "end_token": 2315,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      281,
      8875,
      878,
      30620,
      340
    ],
    "label": "ml_signal",
    "reason": "Reading an instrument before modifying it"
  },
  {
    "line": 195,
    "text": "    INSTRUMENT_END_FIELD = \"end_datetime\"",
    "annotation": "\ud83e\udde0 ML Signal: Deleting an item from a dictionary-like structure",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3268,
      18601,
      5883,
      3525,
      62,
      10619,
      62,
      44603,
      796,
      366,
      437,
      62,
      19608,
      8079,
      1
    ],
    "start_token": 2315,
    "end_token": 2333,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42226,
      889,
      281,
      2378,
      422,
      257,
      22155,
      12,
      2339,
      4645
    ],
    "label": "ml_signal",
    "reason": "Deleting an item from a dictionary-like structure"
  },
  {
    "line": 197,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Writing back the modified instrument",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2333,
    "end_token": 2333,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      736,
      262,
      9518,
      8875
    ],
    "label": "ml_signal",
    "reason": "Writing back the modified instrument"
  },
  {
    "line": 196,
    "text": "    SYMBOL_FIELD_NAME = \"instrument\"",
    "annotation": "\u2705 Best Practice: Type hints for parameters and return values improve code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      19704,
      10744,
      3535,
      62,
      44603,
      62,
      20608,
      796,
      366,
      259,
      43872,
      1
    ],
    "start_token": 2333,
    "end_token": 2348,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      329,
      10007,
      290,
      1441,
      3815,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hints for parameters and return values improve code readability and maintainability."
  },
  {
    "line": 198,
    "text": "    def __init__(self, market: str, freq: str, provider_uri: dict = None, **kwargs):",
    "annotation": "\ud83e\udde0 ML Signal: Method call before accessing a dictionary, indicating a pattern of validation or pre-processing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      1910,
      25,
      965,
      11,
      2030,
      80,
      25,
      965,
      11,
      10131,
      62,
      9900,
      25,
      8633,
      796,
      6045,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 2348,
    "end_token": 2379,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      878,
      22534,
      257,
      22155,
      11,
      12739,
      257,
      3912,
      286,
      21201,
      393,
      662,
      12,
      36948,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call before accessing a dictionary, indicating a pattern of validation or pre-processing."
  },
  {
    "line": 200,
    "text": "        self._provider_uri = None if provider_uri is None else C.DataPathManager.format_provider_uri(provider_uri)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'k' is not present in the dictionary returned by _read_instrument().",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      15234,
      1304,
      62,
      9900,
      796,
      6045,
      611,
      10131,
      62,
      9900,
      318,
      6045,
      2073,
      327,
      13,
      6601,
      15235,
      13511,
      13,
      18982,
      62,
      15234,
      1304,
      62,
      9900,
      7,
      15234,
      1304,
      62,
      9900,
      8
    ],
    "start_token": 2379,
    "end_token": 2419,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      74,
      6,
      318,
      407,
      1944,
      287,
      262,
      22155,
      4504,
      416,
      4808,
      961,
      62,
      259,
      43872,
      22446
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'k' is not present in the dictionary returned by _read_instrument()."
  },
  {
    "line": 199,
    "text": "        super(FileInstrumentStorage, self).__init__(market, freq, **kwargs)",
    "annotation": "\u2705 Best Practice: Check for the number of arguments to prevent unexpected behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      8979,
      818,
      43872,
      31425,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7,
      10728,
      11,
      2030,
      80,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 2419,
    "end_token": 2448,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      262,
      1271,
      286,
      7159,
      284,
      2948,
      10059,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Check for the number of arguments to prevent unexpected behavior."
  },
  {
    "line": 201,
    "text": "        self.file_name = f\"{market.lower()}.txt\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message may expose internal logic details.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7753,
      62,
      3672,
      796,
      277,
      1,
      90,
      10728,
      13,
      21037,
      3419,
      27422,
      14116,
      1
    ],
    "start_token": 2448,
    "end_token": 2471,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      743,
      15651,
      5387,
      9156,
      3307,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message may expose internal logic details."
  },
  {
    "line": 203,
    "text": "    def _read_instrument(self) -> Dict[InstKT, InstVT]:",
    "annotation": "\ud83e\udde0 ML Signal: Reading from an instrument, indicating interaction with external systems.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      961,
      62,
      259,
      43872,
      7,
      944,
      8,
      4613,
      360,
      713,
      58,
      6310,
      42176,
      11,
      2262,
      36392,
      5974
    ],
    "start_token": 2471,
    "end_token": 2493,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11725,
      422,
      281,
      8875,
      11,
      12739,
      10375,
      351,
      7097,
      3341,
      13
    ],
    "label": "ml_signal",
    "reason": "Reading from an instrument, indicating interaction with external systems."
  },
  {
    "line": 207,
    "text": "        _instruments = dict()",
    "annotation": "\u2705 Best Practice: Check if 'other' is a Mapping for safe key-value access.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      259,
      2536,
      2886,
      796,
      8633,
      3419
    ],
    "start_token": 2493,
    "end_token": 2507,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      847,
      6,
      318,
      257,
      337,
      5912,
      329,
      3338,
      1994,
      12,
      8367,
      1895,
      13
    ],
    "label": "best_practice",
    "reason": "Check if 'other' is a Mapping for safe key-value access."
  },
  {
    "line": 211,
    "text": "            usecols=[0, 1, 2],",
    "annotation": "\u2705 Best Practice: Check for 'keys' attribute to handle dictionary-like objects.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      779,
      4033,
      82,
      41888,
      15,
      11,
      352,
      11,
      362,
      4357
    ],
    "start_token": 2507,
    "end_token": 2528,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      705,
      13083,
      6,
      11688,
      284,
      5412,
      22155,
      12,
      2339,
      5563,
      13
    ],
    "label": "best_practice",
    "reason": "Check for 'keys' attribute to handle dictionary-like objects."
  },
  {
    "line": 216,
    "text": "        for row in df.itertuples(index=False):",
    "annotation": "\u2705 Best Practice: Fallback to iterable unpacking for key-value pairs.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      5752,
      287,
      47764,
      13,
      270,
      861,
      84,
      2374,
      7,
      9630,
      28,
      25101,
      2599
    ],
    "start_token": 2528,
    "end_token": 2549,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7218,
      1891,
      284,
      11629,
      540,
      8593,
      5430,
      329,
      1994,
      12,
      8367,
      14729,
      13
    ],
    "label": "best_practice",
    "reason": "Fallback to iterable unpacking for key-value pairs."
  },
  {
    "line": 219,
    "text": "",
    "annotation": "\u2705 Best Practice: Use kwargs to update dictionary, allowing flexible key-value updates.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 2549,
    "end_token": 2549,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      479,
      86,
      22046,
      284,
      4296,
      22155,
      11,
      5086,
      12846,
      1994,
      12,
      8367,
      5992,
      13
    ],
    "label": "best_practice",
    "reason": "Use kwargs to update dictionary, allowing flexible key-value updates."
  },
  {
    "line": 222,
    "text": "            with self.uri.open(\"w\") as _:",
    "annotation": "\ud83e\udde0 ML Signal: Writing to an instrument, indicating interaction with external systems.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      2116,
      13,
      9900,
      13,
      9654,
      7203,
      86,
      4943,
      355,
      4808,
      25
    ],
    "start_token": 2549,
    "end_token": 2572,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      22183,
      284,
      281,
      8875,
      11,
      12739,
      10375,
      351,
      7097,
      3341,
      13
    ],
    "label": "ml_signal",
    "reason": "Writing to an instrument, indicating interaction with external systems."
  },
  {
    "line": 216,
    "text": "        for row in df.itertuples(index=False):",
    "annotation": "\u2705 Best Practice: Type hinting for return value improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      5752,
      287,
      47764,
      13,
      270,
      861,
      84,
      2374,
      7,
      9630,
      28,
      25101,
      2599
    ],
    "start_token": 2572,
    "end_token": 2593,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1441,
      1988,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for return value improves code readability and maintainability"
  },
  {
    "line": 218,
    "text": "        return _instruments",
    "annotation": "\ud83e\udde0 ML Signal: Usage of __len__ method indicates implementation of a container-like class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      259,
      2536,
      2886
    ],
    "start_token": 2593,
    "end_token": 2605,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      11593,
      11925,
      834,
      2446,
      9217,
      7822,
      286,
      257,
      9290,
      12,
      2339,
      1398
    ],
    "label": "ml_signal",
    "reason": "Usage of __len__ method indicates implementation of a container-like class"
  },
  {
    "line": 218,
    "text": "        return _instruments",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring to describe its purpose and usage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      4808,
      259,
      2536,
      2886
    ],
    "start_token": 2605,
    "end_token": 2617,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      284,
      6901,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring to describe its purpose and usage"
  },
  {
    "line": 220,
    "text": "    def _write_instrument(self, data: Dict[InstKT, InstVT] = None) -> None:",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      13564,
      62,
      259,
      43872,
      7,
      944,
      11,
      1366,
      25,
      360,
      713,
      58,
      6310,
      42176,
      11,
      2262,
      36392,
      60,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2617,
    "end_token": 2646,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization."
  },
  {
    "line": 222,
    "text": "            with self.uri.open(\"w\") as _:",
    "annotation": "\u2705 Best Practice: Using a conditional expression to handle None values improves code readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      351,
      2116,
      13,
      9900,
      13,
      9654,
      7203,
      86,
      4943,
      355,
      4808,
      25
    ],
    "start_token": 2646,
    "end_token": 2669,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      26340,
      5408,
      284,
      5412,
      6045,
      3815,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using a conditional expression to handle None values improves code readability."
  },
  {
    "line": 224,
    "text": "            return",
    "annotation": "\ud83e\udde0 ML Signal: Consistent file naming pattern based on input parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 2669,
    "end_token": 2681,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3515,
      7609,
      2393,
      19264,
      3912,
      1912,
      319,
      5128,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Consistent file naming pattern based on input parameters."
  },
  {
    "line": 224,
    "text": "            return",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Opening a file in write-binary mode without writing anything may lead to data loss.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441
    ],
    "start_token": 2681,
    "end_token": 2693,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      25522,
      257,
      2393,
      287,
      3551,
      12,
      39491,
      4235,
      1231,
      3597,
      1997,
      743,
      1085,
      284,
      1366,
      2994,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Opening a file in write-binary mode without writing anything may lead to data loss."
  },
  {
    "line": 227,
    "text": "        for inst, v_list in data.items():",
    "annotation": "\u2705 Best Practice: Use of type hinting for the return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      916,
      11,
      410,
      62,
      4868,
      287,
      1366,
      13,
      23814,
      33529
    ],
    "start_token": 2693,
    "end_token": 2711,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for the return type improves code readability and maintainability."
  },
  {
    "line": 229,
    "text": "            _df[self.SYMBOL_FIELD_NAME] = inst",
    "annotation": "\ud83e\udde0 ML Signal: Method returning a slice of the object, indicating potential use of custom data structures.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      7568,
      58,
      944,
      13,
      23060,
      10744,
      3535,
      62,
      44603,
      62,
      20608,
      60,
      796,
      916
    ],
    "start_token": 2711,
    "end_token": 2737,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8024,
      257,
      16416,
      286,
      262,
      2134,
      11,
      12739,
      2785,
      779,
      286,
      2183,
      1366,
      8573,
      13
    ],
    "label": "ml_signal",
    "reason": "Method returning a slice of the object, indicating potential use of custom data structures."
  },
  {
    "line": 230,
    "text": "            res.append(_df)",
    "annotation": "\u2705 Best Practice: Check for empty data_array to avoid unnecessary operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      581,
      13,
      33295,
      28264,
      7568,
      8
    ],
    "start_token": 2737,
    "end_token": 2754,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      1366,
      62,
      18747,
      284,
      3368,
      13114,
      4560
    ],
    "label": "best_practice",
    "reason": "Check for empty data_array to avoid unnecessary operations"
  },
  {
    "line": 237,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes self.uri is a valid path object with an exists method",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2754,
    "end_token": 2754,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      2116,
      13,
      9900,
      318,
      257,
      4938,
      3108,
      2134,
      351,
      281,
      7160,
      2446
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes self.uri is a valid path object with an exists method"
  },
  {
    "line": 239,
    "text": "        self._write_instrument(data={})",
    "annotation": "\u2705 Best Practice: Initialize index if not provided",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      259,
      43872,
      7,
      7890,
      34758,
      30072
    ],
    "start_token": 2754,
    "end_token": 2771,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      6376,
      611,
      407,
      2810
    ],
    "label": "best_practice",
    "reason": "Initialize index if not provided"
  },
  {
    "line": 242,
    "text": "    def data(self) -> Dict[InstKT, InstVT]:",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1366,
      7,
      944,
      8,
      4613,
      360,
      713,
      58,
      6310,
      42176,
      11,
      2262,
      36392,
      5974
    ],
    "start_token": 2771,
    "end_token": 2789,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for data manipulation"
  },
  {
    "line": 244,
    "text": "        return self._read_instrument()",
    "annotation": "\u2705 Best Practice: Handle case where index is None or greater than end_index",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13557,
      961,
      62,
      259,
      43872,
      3419
    ],
    "start_token": 2789,
    "end_token": 2804,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      33141,
      1339,
      810,
      6376,
      318,
      6045,
      393,
      3744,
      621,
      886,
      62,
      9630
    ],
    "label": "best_practice",
    "reason": "Handle case where index is None or greater than end_index"
  },
  {
    "line": 249,
    "text": "        self._write_instrument(inst)",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      259,
      43872,
      7,
      8625,
      8
    ],
    "start_token": 2804,
    "end_token": 2820,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for data manipulation"
  },
  {
    "line": 253,
    "text": "        inst = self._read_instrument()",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      916,
      796,
      2116,
      13557,
      961,
      62,
      259,
      43872,
      3419
    ],
    "start_token": 2820,
    "end_token": 2836,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for data manipulation"
  },
  {
    "line": 256,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 2836,
    "end_token": 2836,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 261,
    "text": "    def update(self, *args, **kwargs) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4296,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 2836,
    "end_token": 2854,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 263,
    "text": "            raise TypeError(f\"update expected at most 1 arguments, got {len(args)}\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      5994,
      12331,
      7,
      69,
      1,
      19119,
      2938,
      379,
      749,
      352,
      7159,
      11,
      1392,
      1391,
      11925,
      7,
      22046,
      38165,
      4943
    ],
    "start_token": 2854,
    "end_token": 2885,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 266,
    "text": "            other = args[0]  # type: dict",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas for data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      584,
      796,
      26498,
      58,
      15,
      60,
      220,
      1303,
      2099,
      25,
      8633
    ],
    "start_token": 2885,
    "end_token": 2907,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      329,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas for data manipulation"
  },
  {
    "line": 259,
    "text": "        return self._read_instrument()[k]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential file handling issue if self.uri is not a valid file path or if file access is restricted.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13557,
      961,
      62,
      259,
      43872,
      3419,
      58,
      74,
      60
    ],
    "start_token": 2907,
    "end_token": 2925,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2393,
      9041,
      2071,
      611,
      2116,
      13,
      9900,
      318,
      407,
      257,
      4938,
      2393,
      3108,
      393,
      611,
      2393,
      1895,
      318,
      10770,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential file handling issue if self.uri is not a valid file path or if file access is restricted."
  },
  {
    "line": 262,
    "text": "        if len(args) > 1:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Opening a file without exception handling can lead to unhandled exceptions if the file cannot be opened.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      22046,
      8,
      1875,
      352,
      25
    ],
    "start_token": 2925,
    "end_token": 2940,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      25522,
      257,
      2393,
      1231,
      6631,
      9041,
      460,
      1085,
      284,
      555,
      38788,
      13269,
      611,
      262,
      2393,
      2314,
      307,
      4721,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Opening a file without exception handling can lead to unhandled exceptions if the file cannot be opened."
  },
  {
    "line": 263,
    "text": "            raise TypeError(f\"update expected at most 1 arguments, got {len(args)}\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes the file contains at least 4 bytes; otherwise, this could raise an error.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      5994,
      12331,
      7,
      69,
      1,
      19119,
      2938,
      379,
      749,
      352,
      7159,
      11,
      1392,
      1391,
      11925,
      7,
      22046,
      38165,
      4943
    ],
    "start_token": 2940,
    "end_token": 2971,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      262,
      2393,
      4909,
      379,
      1551,
      604,
      9881,
      26,
      4306,
      11,
      428,
      714,
      5298,
      281,
      4049,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes the file contains at least 4 bytes; otherwise, this could raise an error."
  },
  {
    "line": 265,
    "text": "        if args:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes the file content can be interpreted as a float, which might not always be the case.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      26498,
      25
    ],
    "start_token": 2971,
    "end_token": 2981,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      262,
      2393,
      2695,
      460,
      307,
      16173,
      355,
      257,
      12178,
      11,
      543,
      1244,
      407,
      1464,
      307,
      262,
      1339,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes the file content can be interpreted as a float, which might not always be the case."
  },
  {
    "line": 268,
    "text": "                for key in other:",
    "annotation": "\u2705 Best Practice: Use @property decorator to define a method as a property, improving code readability and usability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1994,
      287,
      584,
      25
    ],
    "start_token": 2981,
    "end_token": 3001,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      2488,
      26745,
      11705,
      1352,
      284,
      8160,
      257,
      2446,
      355,
      257,
      3119,
      11,
      10068,
      2438,
      1100,
      1799,
      290,
      42863,
      13
    ],
    "label": "best_practice",
    "reason": "Use @property decorator to define a method as a property, improving code readability and usability."
  },
  {
    "line": 265,
    "text": "        if args:",
    "annotation": "\u2705 Best Practice: Specify the return type using Union for clarity and type checking",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      26498,
      25
    ],
    "start_token": 3001,
    "end_token": 3011,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      1958,
      262,
      1441,
      2099,
      1262,
      4479,
      329,
      16287,
      290,
      2099,
      10627
    ],
    "label": "best_practice",
    "reason": "Specify the return type using Union for clarity and type checking"
  },
  {
    "line": 267,
    "text": "            if isinstance(other, Mapping):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for NoneType attribute access if self.uri is None",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      847,
      11,
      337,
      5912,
      2599
    ],
    "start_token": 3011,
    "end_token": 3031,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      6045,
      6030,
      11688,
      1895,
      611,
      2116,
      13,
      9900,
      318,
      6045
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for NoneType attribute access if self.uri is None"
  },
  {
    "line": 270,
    "text": "            elif hasattr(other, \"keys\"):",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of calculating an end index from a start index and length",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      468,
      35226,
      7,
      847,
      11,
      366,
      13083,
      1,
      2599
    ],
    "start_token": 3031,
    "end_token": 3053,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      26019,
      281,
      886,
      6376,
      422,
      257,
      923,
      6376,
      290,
      4129
    ],
    "label": "ml_signal",
    "reason": "Pattern of calculating an end index from a start index and length"
  },
  {
    "line": 269,
    "text": "                    inst[key] = other[key]",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and helps with static analysis.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      916,
      58,
      2539,
      60,
      796,
      584,
      58,
      2539,
      60
    ],
    "start_token": 3053,
    "end_token": 3081,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5419,
      351,
      9037,
      3781,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and helps with static analysis."
  },
  {
    "line": 271,
    "text": "                for key in other.keys():",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential file existence check race condition.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1994,
      287,
      584,
      13,
      13083,
      33529
    ],
    "start_token": 3081,
    "end_token": 3103,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2393,
      6224,
      2198,
      3234,
      4006,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential file existence check race condition."
  },
  {
    "line": 276,
    "text": "        for key, value in kwargs.items():",
    "annotation": "\u2705 Best Practice: Returning an empty Series with specified dtype is clear and explicit.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1994,
      11,
      1988,
      287,
      479,
      86,
      22046,
      13,
      23814,
      33529
    ],
    "start_token": 3103,
    "end_token": 3121,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      281,
      6565,
      7171,
      351,
      7368,
      288,
      4906,
      318,
      1598,
      290,
      7952,
      13
    ],
    "label": "best_practice",
    "reason": "Returning an empty Series with specified dtype is clear and explicit."
  },
  {
    "line": 279,
    "text": "        self._write_instrument(inst)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message may expose internal type information.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      13564,
      62,
      259,
      43872,
      7,
      8625,
      8
    ],
    "start_token": 3121,
    "end_token": 3137,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      743,
      15651,
      5387,
      2099,
      1321,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message may expose internal type information."
  },
  {
    "line": 283,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): File is opened without exception handling, which may lead to resource leaks.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3137,
    "end_token": 3137,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      9220,
      318,
      4721,
      1231,
      6631,
      9041,
      11,
      543,
      743,
      1085,
      284,
      8271,
      17316,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "File is opened without exception handling, which may lead to resource leaks."
  },
  {
    "line": 287,
    "text": "        super(FileFeatureStorage, self).__init__(instrument, field, freq, **kwargs)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message may expose internal index information.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      7,
      8979,
      38816,
      31425,
      11,
      2116,
      737,
      834,
      15003,
      834,
      7,
      259,
      43872,
      11,
      2214,
      11,
      2030,
      80,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 3137,
    "end_token": 3168,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      743,
      15651,
      5387,
      6376,
      1321,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message may expose internal index information."
  },
  {
    "line": 289,
    "text": "        self.file_name = f\"{instrument.lower()}/{field.lower()}.{freq.lower()}.bin\"",
    "annotation": "\u2705 Best Practice: Calculating seek position based on index is efficient for file access.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7753,
      62,
      3672,
      796,
      277,
      1,
      90,
      259,
      43872,
      13,
      21037,
      3419,
      92,
      14,
      90,
      3245,
      13,
      21037,
      3419,
      27422,
      90,
      19503,
      80,
      13,
      21037,
      3419,
      27422,
      8800,
      1
    ],
    "start_token": 3168,
    "end_token": 3206,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      803,
      5380,
      2292,
      1912,
      319,
      6376,
      318,
      6942,
      329,
      2393,
      1895,
      13
    ],
    "label": "best_practice",
    "reason": "Calculating seek position based on index is efficient for file access."
  },
  {
    "line": 291,
    "text": "    def clear(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Unpacking without validation may lead to unexpected exceptions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1598,
      7,
      944,
      2599
    ],
    "start_token": 3206,
    "end_token": 3214,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      791,
      41291,
      1231,
      21201,
      743,
      1085,
      284,
      10059,
      13269,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Unpacking without validation may lead to unexpected exceptions."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy for efficient data handling and processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3214,
    "end_token": 3244,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      329,
      6942,
      1366,
      9041,
      290,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of numpy for efficient data handling and processing."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\u2705 Best Practice: Using pd.Series with index improves data handling and access.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3244,
    "end_token": 3274,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      27996,
      351,
      6376,
      19575,
      1366,
      9041,
      290,
      1895,
      13
    ],
    "label": "best_practice",
    "reason": "Using pd.Series with index improves data handling and access."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message may expose internal type information.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3274,
    "end_token": 3304,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      743,
      15651,
      5387,
      2099,
      1321,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message may expose internal type information."
  },
  {
    "line": 298,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensure the method is type hinted for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 3304,
    "end_token": 3304,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      262,
      2446,
      318,
      2099,
      27388,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure the method is type hinted for better readability and maintainability."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern can be used to understand object behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3304,
    "end_token": 3334,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      460,
      307,
      973,
      284,
      1833,
      2134,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call pattern can be used to understand object behavior."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential integer division and subtraction could lead to unexpected results if not handled properly.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3334,
    "end_token": 3364,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      18253,
      7297,
      290,
      13284,
      7861,
      714,
      1085,
      284,
      10059,
      2482,
      611,
      407,
      12118,
      6105,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential integer division and subtraction could lead to unexpected results if not handled properly."
  },
  {
    "line": 299,
    "text": "    def write(self, data_array: Union[List, np.ndarray], index: int = None) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of file size and arithmetic operations can indicate data processing patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      3551,
      7,
      944,
      11,
      1366,
      62,
      18747,
      25,
      4479,
      58,
      8053,
      11,
      45941,
      13,
      358,
      18747,
      4357,
      6376,
      25,
      493,
      796,
      6045,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 3364,
    "end_token": 3394,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2393,
      2546,
      290,
      34768,
      4560,
      460,
      7603,
      1366,
      7587,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of file size and arithmetic operations can indicate data processing patterns."
  }
]