[
  {
    "line": 14,
    "text": "from ...utils.serial import Serializable",
    "annotation": "\u2705 Best Practice: Use of Literal for type hinting ensures that only specific string values are allowed, improving code reliability and readability.",
    "confidence": 0.5,
    "tokens": [
      6738,
      2644,
      26791,
      13,
      46911,
      1330,
      23283,
      13821
    ],
    "start_token": 0,
    "end_token": 8,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      25659,
      1691,
      329,
      2099,
      9254,
      278,
      19047,
      326,
      691,
      2176,
      4731,
      3815,
      389,
      3142,
      11,
      10068,
      2438,
      17843,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of Literal for type hinting ensures that only specific string values are allowed, improving code reliability and readability."
  },
  {
    "line": 27,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Consider using an abstract base class to enforce implementation of required methods in subclasses.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 8,
    "end_token": 12,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      281,
      12531,
      2779,
      1398,
      284,
      4605,
      7822,
      286,
      2672,
      5050,
      287,
      850,
      37724,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using an abstract base class to enforce implementation of required methods in subclasses."
  },
  {
    "line": 32,
    "text": "",
    "annotation": "\u2705 Best Practice: Constants should be defined at the top of the class for better readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 12,
    "end_token": 12,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      5447,
      379,
      262,
      1353,
      286,
      262,
      1398,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Constants should be defined at the top of the class for better readability."
  },
  {
    "line": 38,
    "text": "    - The workflow to combine them all:",
    "annotation": "\u2705 Best Practice: Use of @abstractmethod indicates this method must be implemented by subclasses.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      383,
      30798,
      284,
      12082,
      606,
      477,
      25
    ],
    "start_token": 12,
    "end_token": 23,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      397,
      8709,
      24396,
      9217,
      428,
      2446,
      1276,
      307,
      9177,
      416,
      850,
      37724,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @abstractmethod indicates this method must be implemented by subclasses."
  },
  {
    "line": 38,
    "text": "    - The workflow to combine them all:",
    "annotation": "\u2705 Best Practice: Type hints improve code readability and maintainability by specifying expected argument types.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      383,
      30798,
      284,
      12082,
      606,
      477,
      25
    ],
    "start_token": 23,
    "end_token": 34,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      416,
      31577,
      2938,
      4578,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Type hints improve code readability and maintainability by specifying expected argument types."
  },
  {
    "line": 38,
    "text": "    - The workflow to combine them all:",
    "annotation": "\u2705 Best Practice: Default values for function parameters enhance usability by providing fallback options.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      383,
      30798,
      284,
      12082,
      606,
      477,
      25
    ],
    "start_token": 34,
    "end_token": 45,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      3815,
      329,
      2163,
      10007,
      9494,
      42863,
      416,
      4955,
      2121,
      1891,
      3689,
      13
    ],
    "label": "best_practice",
    "reason": "Default values for function parameters enhance usability by providing fallback options."
  },
  {
    "line": 38,
    "text": "    - The workflow to combine them all:",
    "annotation": "\u2705 Best Practice: Using Union for type hints allows for flexible input types, improving function versatility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      383,
      30798,
      284,
      12082,
      606,
      477,
      25
    ],
    "start_token": 45,
    "end_token": 56,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4479,
      329,
      2099,
      20269,
      3578,
      329,
      12846,
      5128,
      3858,
      11,
      10068,
      2163,
      31689,
      13
    ],
    "label": "best_practice",
    "reason": "Using Union for type hints allows for flexible input types, improving function versatility."
  },
  {
    "line": 43,
    "text": "    def __init__(self, *args, **kwargs):  # pylint: disable=W0246",
    "annotation": "\u2705 Best Practice: Providing a default value for 'level' enhances function usability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599,
      220,
      1303,
      279,
      2645,
      600,
      25,
      15560,
      28,
      54,
      15,
      26912
    ],
    "start_token": 56,
    "end_token": 84,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7518,
      2530,
      257,
      4277,
      1988,
      329,
      705,
      5715,
      6,
      32479,
      2163,
      42863,
      13
    ],
    "label": "best_practice",
    "reason": "Providing a default value for 'level' enhances function usability."
  },
  {
    "line": 45,
    "text": "        We should define how to get ready for the fetching.",
    "annotation": "\u2705 Best Practice: Using Union for type hints allows for flexible input types, improving function versatility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      775,
      815,
      8160,
      703,
      284,
      651,
      3492,
      329,
      262,
      21207,
      278,
      13
    ],
    "start_token": 84,
    "end_token": 103,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4479,
      329,
      2099,
      20269,
      3578,
      329,
      12846,
      5128,
      3858,
      11,
      10068,
      2163,
      31689,
      13
    ],
    "label": "best_practice",
    "reason": "Using Union for type hints allows for flexible input types, improving function versatility."
  },
  {
    "line": 47,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Type hints improve code readability and maintainability by specifying expected argument types.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 103,
    "end_token": 122,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      416,
      31577,
      2938,
      4578,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Type hints improve code readability and maintainability by specifying expected argument types."
  },
  {
    "line": 47,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Specifying the return type with type hints improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 122,
    "end_token": 141,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      4035,
      262,
      1441,
      2099,
      351,
      2099,
      20269,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Specifying the return type with type hints improves code readability and maintainability."
  },
  {
    "line": 46,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Class docstring provides a detailed explanation of the class's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 141,
    "end_token": 149,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      6496,
      7468,
      286,
      262,
      1398,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a detailed explanation of the class's purpose and usage."
  },
  {
    "line": 47,
    "text": "        super().__init__(*args, **kwargs)",
    "annotation": "\u2705 Best Practice: Type hinting for class attributes improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      46491,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 149,
    "end_token": 168,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1398,
      12608,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for class attributes improves code readability and maintainability."
  },
  {
    "line": 97,
    "text": "                   SH600005    37.796539  12231662.0       38.258602        37.919757    0.970325  0.0289",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Use of assert statement for runtime checks can be disabled with optimization flags",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6006,
      21,
      2388,
      20,
      220,
      220,
      220,
      5214,
      13,
      3720,
      2996,
      2670,
      220,
      1105,
      1954,
      1433,
      5237,
      13,
      15,
      220,
      220,
      220,
      220,
      220,
      220,
      4353,
      13,
      25600,
      31418,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5214,
      13,
      24,
      38449,
      22,
      220,
      220,
      220,
      657,
      13,
      43587,
      26582,
      220,
      657,
      13,
      15,
      27693
    ],
    "start_token": 168,
    "end_token": 239,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      5765,
      286,
      6818,
      2643,
      329,
      19124,
      8794,
      460,
      307,
      10058,
      351,
      23989,
      9701
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Use of assert statement for runtime checks can be disabled with optimization flags"
  },
  {
    "line": 98,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a factory method pattern for initializing instances",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 239,
    "end_token": 239,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      8860,
      2446,
      3912,
      329,
      4238,
      2890,
      10245
    ],
    "label": "ml_signal",
    "reason": "Use of a factory method pattern for initializing instances"
  },
  {
    "line": 105,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Tracking initialization of class attributes",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 239,
    "end_token": 239,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      37169,
      37588,
      286,
      1398,
      12608
    ],
    "label": "ml_signal",
    "reason": "Tracking initialization of class attributes"
  },
  {
    "line": 111,
    "text": "        data_loader: Union[dict, str, DataLoader] = None,",
    "annotation": "\ud83e\udde0 ML Signal: Use of context manager for logging or timing operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      29356,
      25,
      4479,
      58,
      11600,
      11,
      965,
      11,
      6060,
      17401,
      60,
      796,
      6045,
      11
    ],
    "start_token": 239,
    "end_token": 262,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4732,
      4706,
      329,
      18931,
      393,
      10576,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of context manager for logging or timing operations"
  },
  {
    "line": 112,
    "text": "        init_data=True,",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2315,
      62,
      7890,
      28,
      17821,
      11
    ],
    "start_token": 262,
    "end_token": 275,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      23772
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass constructor"
  },
  {
    "line": 117,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Use a set for `attr_list` for efficient membership testing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 275,
    "end_token": 284,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      257,
      900,
      329,
      4600,
      35226,
      62,
      4868,
      63,
      329,
      6942,
      9931,
      4856,
      13
    ],
    "label": "best_practice",
    "reason": "Use a set for `attr_list` for efficient membership testing."
  },
  {
    "line": 120,
    "text": "        start_time :",
    "annotation": "\u2705 Best Practice: Use `setattr` to dynamically set attributes.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      2435,
      1058
    ],
    "start_token": 284,
    "end_token": 295,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      4600,
      2617,
      35226,
      63,
      284,
      32366,
      900,
      12608,
      13
    ],
    "label": "best_practice",
    "reason": "Use `setattr` to dynamically set attributes."
  },
  {
    "line": 124,
    "text": "        data_loader : Union[dict, str, DataLoader]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Modifying the dictionary while iterating can lead to unexpected behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      29356,
      1058,
      4479,
      58,
      11600,
      11,
      965,
      11,
      6060,
      17401,
      60
    ],
    "start_token": 295,
    "end_token": 315,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3401,
      4035,
      262,
      22155,
      981,
      11629,
      803,
      460,
      1085,
      284,
      10059,
      4069,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Modifying the dictionary while iterating can lead to unexpected behavior."
  },
  {
    "line": 126,
    "text": "        init_data :",
    "annotation": "\ud83e\udde0 ML Signal: Use of `super()` indicates inheritance, which is common in ML model configurations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2315,
      62,
      7890,
      1058
    ],
    "start_token": 315,
    "end_token": 326,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4600,
      16668,
      3419,
      63,
      9217,
      24155,
      11,
      543,
      318,
      2219,
      287,
      10373,
      2746,
      25412,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of `super()` indicates inheritance, which is common in ML model configurations."
  },
  {
    "line": 138,
    "text": "            None if (isinstance(data_loader, dict) and \"module_path\" in data_loader) else data_loader_module,",
    "annotation": "\u2705 Best Practice: Using a context manager for timing operations improves readability and ensures proper resource management.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6045,
      611,
      357,
      271,
      39098,
      7,
      7890,
      62,
      29356,
      11,
      8633,
      8,
      290,
      366,
      21412,
      62,
      6978,
      1,
      287,
      1366,
      62,
      29356,
      8,
      2073,
      1366,
      62,
      29356,
      62,
      21412,
      11
    ],
    "start_token": 326,
    "end_token": 367,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      4732,
      4706,
      329,
      10576,
      4560,
      19575,
      1100,
      1799,
      290,
      19047,
      1774,
      8271,
      4542,
      13
    ],
    "label": "best_practice",
    "reason": "Using a context manager for timing operations improves readability and ensures proper resource management."
  },
  {
    "line": 140,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Usage of lazy loading pattern which can be a feature for optimizing data processing in ML models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 367,
    "end_token": 375,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      16931,
      11046,
      3912,
      543,
      460,
      307,
      257,
      3895,
      329,
      45780,
      1366,
      7587,
      287,
      10373,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of lazy loading pattern which can be a feature for optimizing data processing in ML models."
  },
  {
    "line": 149,
    "text": "        if init_data:",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the method's purpose and parameters.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2315,
      62,
      7890,
      25
    ],
    "start_token": 375,
    "end_token": 387,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2446,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the method's purpose and parameters."
  },
  {
    "line": 191,
    "text": "        # Setup data.",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a private method to fetch data indicates encapsulation and abstraction patterns.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      31122,
      1366,
      13
    ],
    "start_token": 387,
    "end_token": 398,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2839,
      2446,
      284,
      21207,
      1366,
      9217,
      32652,
      1741,
      290,
      34651,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a private method to fetch data indicates encapsulation and abstraction patterns."
  },
  {
    "line": 191,
    "text": "        # Setup data.",
    "annotation": "\ud83e\udde0 ML Signal: Passing multiple parameters to a method call can indicate complex data processing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      31122,
      1366,
      13
    ],
    "start_token": 398,
    "end_token": 409,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      46389,
      3294,
      10007,
      284,
      257,
      2446,
      869,
      460,
      7603,
      3716,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Passing multiple parameters to a method call can indicate complex data processing."
  },
  {
    "line": 209,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding type checks or assertions for input parameters for better error handling.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 409,
    "end_token": 409,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      8794,
      393,
      29965,
      329,
      5128,
      10007,
      329,
      1365,
      4049,
      9041,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type checks or assertions for input parameters for better error handling."
  },
  {
    "line": 214,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging sensitive data can lead to information leakage.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 409,
    "end_token": 409,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      8564,
      1366,
      460,
      1085,
      284,
      1321,
      47988,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging sensitive data can lead to information leakage."
  },
  {
    "line": 218,
    "text": "            describe how to select data by index",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom processing functions (proc_func) can indicate user-specific data transformations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6901,
      703,
      284,
      2922,
      1366,
      416,
      6376
    ],
    "start_token": 409,
    "end_token": 427,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      7587,
      5499,
      357,
      36942,
      62,
      20786,
      8,
      460,
      7603,
      2836,
      12,
      11423,
      1366,
      38226,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of custom processing functions (proc_func) can indicate user-specific data transformations."
  },
  {
    "line": 227,
    "text": "            Following conflicts may occur",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising exceptions with dynamic content can expose internal logic.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      14207,
      12333,
      743,
      3051
    ],
    "start_token": 427,
    "end_token": 442,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      13269,
      351,
      8925,
      2695,
      460,
      15651,
      5387,
      9156,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising exceptions with dynamic content can expose internal logic."
  },
  {
    "line": 231,
    "text": "                - slice have higher priorities",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising exceptions with dynamic content can expose internal logic.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      16416,
      423,
      2440,
      15369
    ],
    "start_token": 442,
    "end_token": 462,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      13269,
      351,
      8925,
      2695,
      460,
      15651,
      5387,
      9156,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising exceptions with dynamic content can expose internal logic."
  },
  {
    "line": 234,
    "text": "            which index level to select the data",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      6376,
      1241,
      284,
      2922,
      262,
      1366
    ],
    "start_token": 462,
    "end_token": 480,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return value"
  },
  {
    "line": 246,
    "text": "            - if isinstance(col_set, List[str]):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self indicates this is a method in a class, which can be useful for class-based pattern recognition",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      611,
      318,
      39098,
      7,
      4033,
      62,
      2617,
      11,
      7343,
      58,
      2536,
      60,
      2599
    ],
    "start_token": 480,
    "end_token": 505,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      9217,
      428,
      318,
      257,
      2446,
      287,
      257,
      1398,
      11,
      543,
      460,
      307,
      4465,
      329,
      1398,
      12,
      3106,
      3912,
      9465
    ],
    "label": "ml_signal",
    "reason": "Usage of self indicates this is a method in a class, which can be useful for class-based pattern recognition"
  },
  {
    "line": 248,
    "text": "                select several sets of meaningful columns, the returned data has multiple levels",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential data exposure if _data contains sensitive information",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2922,
      1811,
      5621,
      286,
      11570,
      15180,
      11,
      262,
      4504,
      1366,
      468,
      3294,
      2974
    ],
    "start_token": 505,
    "end_token": 533,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1366,
      7111,
      611,
      4808,
      7890,
      4909,
      8564,
      1321
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential data exposure if _data contains sensitive information"
  },
  {
    "line": 249,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of fetch_df_by_col function indicates a pattern of data filtering or transformation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 533,
    "end_token": 533,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      21207,
      62,
      7568,
      62,
      1525,
      62,
      4033,
      2163,
      9217,
      257,
      3912,
      286,
      1366,
      25431,
      393,
      13389
    ],
    "label": "ml_signal",
    "reason": "Use of fetch_df_by_col function indicates a pattern of data filtering or transformation"
  },
  {
    "line": 249,
    "text": "",
    "annotation": "\u2705 Best Practice: Converting columns to a list for a clear and consistent return type",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 533,
    "end_token": 533,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      15180,
      284,
      257,
      1351,
      329,
      257,
      1598,
      290,
      6414,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Converting columns to a list for a clear and consistent return type"
  },
  {
    "line": 255,
    "text": "                - A Dataset learned some processors to process data which is related to data segmentation",
    "annotation": "\ud83e\udde0 ML Signal: Usage of unique index levels to filter data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      317,
      16092,
      292,
      316,
      4499,
      617,
      20399,
      284,
      1429,
      1366,
      543,
      318,
      3519,
      284,
      1366,
      10618,
      341
    ],
    "start_token": 533,
    "end_token": 566,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      3748,
      6376,
      2974,
      284,
      8106,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of unique index levels to filter data"
  },
  {
    "line": 257,
    "text": "                - The learned processor require the dataframe remains the same format when fitting and applying",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of locating positions in a time series",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      383,
      4499,
      12649,
      2421,
      262,
      1366,
      14535,
      3793,
      262,
      976,
      5794,
      618,
      15830,
      290,
      11524
    ],
    "start_token": 566,
    "end_token": 597,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      42139,
      6116,
      287,
      257,
      640,
      2168
    ],
    "label": "ml_signal",
    "reason": "Pattern of locating positions in a time series"
  },
  {
    "line": 259,
    "text": "                - So the processors should be applied to the underlayer data.",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of a range based on a current location and periods",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      1406,
      262,
      20399,
      815,
      307,
      5625,
      284,
      262,
      739,
      29289,
      1366,
      13
    ],
    "start_token": 597,
    "end_token": 625,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      257,
      2837,
      1912,
      319,
      257,
      1459,
      4067,
      290,
      9574
    ],
    "label": "ml_signal",
    "reason": "Calculation of a range based on a current location and periods"
  },
  {
    "line": 261,
    "text": "        squeeze : bool",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential negative index access if `pre_loc` is not checked",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      21229,
      1058,
      20512
    ],
    "start_token": 625,
    "end_token": 635,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      4633,
      6376,
      1895,
      611,
      4600,
      3866,
      62,
      17946,
      63,
      318,
      407,
      10667
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential negative index access if `pre_loc` is not checked"
  },
  {
    "line": 263,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Warning message could be logged instead of using warnings.warn",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 635,
    "end_token": 635,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      15932,
      3275,
      714,
      307,
      18832,
      2427,
      286,
      1262,
      14601,
      13,
      40539
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Warning message could be logged instead of using warnings.warn"
  },
  {
    "line": 266,
    "text": "        pd.DataFrame.",
    "annotation": "\ud83e\udde0 ML Signal: Accessing elements in a time series by calculated index",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      13
    ],
    "start_token": 635,
    "end_token": 648,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      4847,
      287,
      257,
      640,
      2168,
      416,
      10488,
      6376
    ],
    "label": "ml_signal",
    "reason": "Accessing elements in a time series by calculated index"
  },
  {
    "line": 266,
    "text": "        pd.DataFrame.",
    "annotation": "\ud83e\udde0 ML Signal: Returning a slice object for data selection",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778,
      13
    ],
    "start_token": 648,
    "end_token": 661,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      16416,
      2134,
      329,
      1366,
      6356
    ],
    "label": "ml_signal",
    "reason": "Returning a slice object for data selection"
  },
  {
    "line": 273,
    "text": "            level=level,",
    "annotation": "\u2705 Best Practice: Use of unique() to ensure trading_dates are distinct",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      5715,
      11
    ],
    "start_token": 661,
    "end_token": 676,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3748,
      3419,
      284,
      4155,
      7313,
      62,
      19581,
      389,
      7310
    ],
    "label": "best_practice",
    "reason": "Use of unique() to ensure trading_dates are distinct"
  },
  {
    "line": 276,
    "text": "            proc_func=proc_func,",
    "annotation": "\u2705 Best Practice: Defaulting min_periods to periods if not provided",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      13834,
      62,
      20786,
      28,
      36942,
      62,
      20786,
      11
    ],
    "start_token": 676,
    "end_token": 695,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      278,
      949,
      62,
      41007,
      82,
      284,
      9574,
      611,
      407,
      2810
    ],
    "label": "best_practice",
    "reason": "Defaulting min_periods to periods if not provided"
  },
  {
    "line": 279,
    "text": "    def _fetch_data(",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over dates with a specific range",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      69,
      7569,
      62,
      7890,
      7
    ],
    "start_token": 695,
    "end_token": 705,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      9667,
      351,
      257,
      2176,
      2837
    ],
    "label": "ml_signal",
    "reason": "Iterating over dates with a specific range"
  },
  {
    "line": 280,
    "text": "        self,",
    "annotation": "\ud83e\udde0 ML Signal: Yielding tuples of date and DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 705,
    "end_token": 714,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      575,
      30449,
      12777,
      2374,
      286,
      3128,
      290,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Yielding tuples of date and DataFrame"
  },
  {
    "line": 301,
    "text": "                get_module_logger(\"DataHandlerLP\").info(f\"Fail to converting to query to slice. It will used directly\")",
    "annotation": "\u2705 Best Practice: Type annotations for class attributes improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      651,
      62,
      21412,
      62,
      6404,
      1362,
      7203,
      6601,
      25060,
      19930,
      11074,
      10951,
      7,
      69,
      1,
      39044,
      284,
      23202,
      284,
      12405,
      284,
      16416,
      13,
      632,
      481,
      973,
      3264,
      4943
    ],
    "start_token": 714,
    "end_token": 757,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      37647,
      329,
      1398,
      12608,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type annotations for class attributes improve code readability and maintainability."
  },
  {
    "line": 303,
    "text": "        if isinstance(data_storage, pd.DataFrame):",
    "annotation": "\u2705 Best Practice: Type annotations for class attributes improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      7890,
      62,
      35350,
      11,
      279,
      67,
      13,
      6601,
      19778,
      2599
    ],
    "start_token": 757,
    "end_token": 778,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      37647,
      329,
      1398,
      12608,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type annotations for class attributes improve code readability and maintainability."
  },
  {
    "line": 305,
    "text": "            if proc_func is not None:",
    "annotation": "\u2705 Best Practice: Using a dictionary for attribute mapping improves code organization and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      13834,
      62,
      20786,
      318,
      407,
      6045,
      25
    ],
    "start_token": 778,
    "end_token": 797,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      22155,
      329,
      11688,
      16855,
      19575,
      2438,
      4009,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using a dictionary for attribute mapping improves code organization and maintainability."
  },
  {
    "line": 306,
    "text": "                # FIXME: fetching by time first will be more friendly to `proc_func`",
    "annotation": "\ud83e\udde0 ML Signal: Constants like PTYPE_I can be used to identify processing types in ML workflows.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      21207,
      278,
      416,
      640,
      717,
      481,
      307,
      517,
      8030,
      284,
      4600,
      36942,
      62,
      20786,
      63
    ],
    "start_token": 797,
    "end_token": 831,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      588,
      350,
      25216,
      62,
      40,
      460,
      307,
      973,
      284,
      5911,
      7587,
      3858,
      287,
      10373,
      670,
      44041,
      13
    ],
    "label": "ml_signal",
    "reason": "Constants like PTYPE_I can be used to identify processing types in ML workflows."
  },
  {
    "line": 306,
    "text": "                # FIXME: fetching by time first will be more friendly to `proc_func`",
    "annotation": "\ud83e\udde0 ML Signal: Constants like PTYPE_A can be used to identify processing types in ML workflows.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      44855,
      11682,
      25,
      21207,
      278,
      416,
      640,
      717,
      481,
      307,
      517,
      8030,
      284,
      4600,
      36942,
      62,
      20786,
      63
    ],
    "start_token": 831,
    "end_token": 865,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      588,
      350,
      25216,
      62,
      32,
      460,
      307,
      973,
      284,
      5911,
      7587,
      3858,
      287,
      10373,
      670,
      44041,
      13
    ],
    "label": "ml_signal",
    "reason": "Constants like PTYPE_A can be used to identify processing types in ML workflows."
  },
  {
    "line": 319,
    "text": "            raise TypeError(f\"data_storage should be pd.DataFrame|HashingStockStorage, not {type(data_storage)}\")",
    "annotation": "\u2705 Best Practice: Docstring provides detailed parameter descriptions and usage examples",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      5994,
      12331,
      7,
      69,
      1,
      7890,
      62,
      35350,
      815,
      307,
      279,
      67,
      13,
      6601,
      19778,
      91,
      39,
      2140,
      26207,
      31425,
      11,
      407,
      1391,
      4906,
      7,
      7890,
      62,
      35350,
      38165,
      4943
    ],
    "start_token": 865,
    "end_token": 907,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      6496,
      11507,
      16969,
      290,
      8748,
      6096
    ],
    "label": "best_practice",
    "reason": "Docstring provides detailed parameter descriptions and usage examples"
  },
  {
    "line": 351,
    "text": "        Args:",
    "annotation": "\u2705 Best Practice: Initialize lists to avoid shared mutable default arguments",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      943,
      14542,
      25
    ],
    "start_token": 907,
    "end_token": 917,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      8341,
      284,
      3368,
      4888,
      4517,
      540,
      4277,
      7159
    ],
    "label": "best_practice",
    "reason": "Initialize lists to avoid shared mutable default arguments"
  },
  {
    "line": 355,
    "text": "        trading_dates = self._data.index.unique(level=\"datetime\")",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over processor lists to initialize them",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7313,
      62,
      19581,
      796,
      2116,
      13557,
      7890,
      13,
      9630,
      13,
      34642,
      7,
      5715,
      2625,
      19608,
      8079,
      4943
    ],
    "start_token": 917,
    "end_token": 941,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      12649,
      8341,
      284,
      41216,
      606
    ],
    "label": "ml_signal",
    "reason": "Iterating over processor lists to initialize them"
  },
  {
    "line": 355,
    "text": "        trading_dates = self._data.index.unique(level=\"datetime\")",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic attribute access and initialization",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7313,
      62,
      19581,
      796,
      2116,
      13557,
      7890,
      13,
      9630,
      13,
      34642,
      7,
      5715,
      2625,
      19608,
      8079,
      4943
    ],
    "start_token": 941,
    "end_token": 965,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      11688,
      1895,
      290,
      37588
    ],
    "label": "ml_signal",
    "reason": "Dynamic attribute access and initialization"
  },
  {
    "line": 362,
    "text": "        return slice(ref_date, cur_date)",
    "annotation": "\ud83e\udde0 ML Signal: Use of getattr for dynamic method invocation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      16416,
      7,
      5420,
      62,
      4475,
      11,
      1090,
      62,
      4475,
      8
    ],
    "start_token": 965,
    "end_token": 983,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      651,
      35226,
      329,
      8925,
      2446,
      43219
    ],
    "label": "ml_signal",
    "reason": "Use of getattr for dynamic method invocation"
  },
  {
    "line": 362,
    "text": "        return slice(ref_date, cur_date)",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of instances by configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      16416,
      7,
      5420,
      62,
      4475,
      11,
      1090,
      62,
      4475,
      8
    ],
    "start_token": 983,
    "end_token": 1001,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      10245,
      416,
      8398
    ],
    "label": "ml_signal",
    "reason": "Initialization of instances by configuration"
  },
  {
    "line": 371,
    "text": "            periods (int): number of periods.",
    "annotation": "\u2705 Best Practice: Call to superclass initializer",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9574,
      357,
      600,
      2599,
      1271,
      286,
      9574,
      13
    ],
    "start_token": 1001,
    "end_token": 1020,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      4871,
      4238,
      7509
    ],
    "label": "best_practice",
    "reason": "Call to superclass initializer"
  },
  {
    "line": 365,
    "text": "        self, periods: int, min_periods: Optional[int] = None, **kwargs",
    "annotation": "\u2705 Best Practice: Method name should be descriptive of its action",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11,
      9574,
      25,
      493,
      11,
      949,
      62,
      41007,
      82,
      25,
      32233,
      58,
      600,
      60,
      796,
      6045,
      11,
      12429,
      46265,
      22046
    ],
    "start_token": 1020,
    "end_token": 1048,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      1438,
      815,
      307,
      35644,
      286,
      663,
      2223
    ],
    "label": "best_practice",
    "reason": "Method name should be descriptive of its action"
  },
  {
    "line": 367,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Using list concatenation to combine multiple lists",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1048,
    "end_token": 1056,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      1351,
      1673,
      36686,
      341,
      284,
      12082,
      3294,
      8341
    ],
    "label": "best_practice",
    "reason": "Using list concatenation to combine multiple lists"
  },
  {
    "line": 371,
    "text": "            periods (int): number of periods.",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the return type and parameters for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9574,
      357,
      600,
      2599,
      1271,
      286,
      9574,
      13
    ],
    "start_token": 1056,
    "end_token": 1075,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      1441,
      2099,
      290,
      10007,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the return type and parameters for better readability and maintainability."
  },
  {
    "line": 373,
    "text": "            kwargs (dict): will be passed to `self.fetch`.",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over processors to fit data indicates a pattern of applying multiple transformations or models.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      479,
      86,
      22046,
      357,
      11600,
      2599,
      481,
      307,
      3804,
      284,
      4600,
      944,
      13,
      69,
      7569,
      44646
    ],
    "start_token": 1075,
    "end_token": 1102,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      20399,
      284,
      4197,
      1366,
      9217,
      257,
      3912,
      286,
      11524,
      3294,
      38226,
      393,
      4981,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over processors to fit data indicates a pattern of applying multiple transformations or models."
  },
  {
    "line": 374,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Consider handling exceptions within the loop to prevent one processor failure from stopping the entire fitting process.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1102,
    "end_token": 1110,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      9041,
      13269,
      1626,
      262,
      9052,
      284,
      2948,
      530,
      12649,
      5287,
      422,
      12225,
      262,
      2104,
      15830,
      1429,
      13
    ],
    "label": "best_practice",
    "reason": "Consider handling exceptions within the loop to prevent one processor failure from stopping the entire fitting process."
  },
  {
    "line": 375,
    "text": "        trading_dates = self._data.index.unique(level=\"datetime\")",
    "annotation": "\ud83e\udde0 ML Signal: Logging the time taken for each processor can be useful for performance monitoring and optimization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7313,
      62,
      19581,
      796,
      2116,
      13557,
      7890,
      13,
      9630,
      13,
      34642,
      7,
      5715,
      2625,
      19608,
      8079,
      4943
    ],
    "start_token": 1110,
    "end_token": 1134,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      262,
      640,
      2077,
      329,
      1123,
      12649,
      460,
      307,
      4465,
      329,
      2854,
      9904,
      290,
      23989,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging the time taken for each processor can be useful for performance monitoring and optimization."
  },
  {
    "line": 379,
    "text": "            selector = self.get_range_selector(cur_date, periods)",
    "annotation": "\ud83e\udde0 ML Signal: Calling fit on each processor suggests a training or preparation step in a machine learning pipeline.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      31870,
      796,
      2116,
      13,
      1136,
      62,
      9521,
      62,
      19738,
      273,
      7,
      22019,
      62,
      4475,
      11,
      9574,
      8
    ],
    "start_token": 1134,
    "end_token": 1162,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      32677,
      4197,
      319,
      1123,
      12649,
      5644,
      257,
      3047,
      393,
      11824,
      2239,
      287,
      257,
      4572,
      4673,
      11523,
      13
    ],
    "label": "ml_signal",
    "reason": "Calling fit on each processor suggests a training or preparation step in a machine learning pipeline."
  },
  {
    "line": 379,
    "text": "            selector = self.get_range_selector(cur_date, periods)",
    "annotation": "\ud83e\udde0 ML Signal: Method indicating a data processing step in a machine learning pipeline",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      31870,
      796,
      2116,
      13,
      1136,
      62,
      9521,
      62,
      19738,
      273,
      7,
      22019,
      62,
      4475,
      11,
      9574,
      8
    ],
    "start_token": 1162,
    "end_token": 1190,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      12739,
      257,
      1366,
      7587,
      2239,
      287,
      257,
      4572,
      4673,
      11523
    ],
    "label": "ml_signal",
    "reason": "Method indicating a data processing step in a machine learning pipeline"
  },
  {
    "line": 384,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a list of processor objects to apply transformations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 1190,
    "end_token": 1194,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      1351,
      286,
      12649,
      5563,
      284,
      4174,
      38226
    ],
    "label": "ml_signal",
    "reason": "Iterating over a list of processor objects to apply transformations"
  },
  {
    "line": 386,
    "text": "    - For the case that we hope using different processor workflows for learning and inference;",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for TypeError if proc.is_for_infer() is not implemented correctly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      1114,
      262,
      1339,
      326,
      356,
      2911,
      1262,
      1180,
      12649,
      670,
      44041,
      329,
      4673,
      290,
      32278,
      26
    ],
    "start_token": 1194,
    "end_token": 1214,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      5994,
      12331,
      611,
      13834,
      13,
      271,
      62,
      1640,
      62,
      259,
      2232,
      3419,
      318,
      407,
      9177,
      9380
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for TypeError if proc.is_for_infer() is not implemented correctly"
  },
  {
    "line": 389,
    "text": "    DataHandler with **(L)earnable (P)rocessor**",
    "annotation": "\u2705 Best Practice: Using a context manager for timing operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      6060,
      25060,
      351,
      12429,
      7,
      43,
      8,
      451,
      77,
      540,
      357,
      47,
      8,
      305,
      919,
      273,
      1174
    ],
    "start_token": 1214,
    "end_token": 1234,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      4732,
      4706,
      329,
      10576,
      4560
    ],
    "label": "best_practice",
    "reason": "Using a context manager for timing operations"
  },
  {
    "line": 391,
    "text": "    This handler will produce three pieces of data in pd.DataFrame format.",
    "annotation": "\ud83e\udde0 ML Signal: Conditional fitting of processors based on a flag",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      770,
      21360,
      481,
      4439,
      1115,
      5207,
      286,
      1366,
      287,
      279,
      67,
      13,
      6601,
      19778,
      5794,
      13
    ],
    "start_token": 1234,
    "end_token": 1253,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      15830,
      286,
      20399,
      1912,
      319,
      257,
      6056
    ],
    "label": "ml_signal",
    "reason": "Conditional fitting of processors based on a flag"
  },
  {
    "line": 394,
    "text": "    - DK_I / self._infer: the data processed for inference",
    "annotation": "\ud83e\udde0 ML Signal: Applying a transformation to the DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      532,
      32975,
      62,
      40,
      1220,
      2116,
      13557,
      259,
      2232,
      25,
      262,
      1366,
      13686,
      329,
      32278
    ],
    "start_token": 1253,
    "end_token": 1271,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      13389,
      284,
      262,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Applying a transformation to the DataFrame"
  },
  {
    "line": 394,
    "text": "    - DK_I / self._infer: the data processed for inference",
    "annotation": "\u2705 Best Practice: Add a docstring to explain the function's behavior and edge cases",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      32975,
      62,
      40,
      1220,
      2116,
      13557,
      259,
      2232,
      25,
      262,
      1366,
      13686,
      329,
      32278
    ],
    "start_token": 1271,
    "end_token": 1289,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      257,
      2205,
      8841,
      284,
      4727,
      262,
      2163,
      338,
      4069,
      290,
      5743,
      2663
    ],
    "label": "best_practice",
    "reason": "Add a docstring to explain the function's behavior and edge cases"
  },
  {
    "line": 399,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a list to check a condition on each element",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1289,
    "end_token": 1289,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      1351,
      284,
      2198,
      257,
      4006,
      319,
      1123,
      5002
    ],
    "label": "ml_signal",
    "reason": "Iterating over a list to check a condition on each element"
  },
  {
    "line": 401,
    "text": "    - The processing of some samples may rely on label (for example, some samples hit the limit may need extra processing or be dropped).",
    "annotation": "\ud83e\udde0 ML Signal: Checking a boolean condition on an object method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      532,
      383,
      7587,
      286,
      617,
      8405,
      743,
      8814,
      319,
      6167,
      357,
      1640,
      1672,
      11,
      617,
      8405,
      2277,
      262,
      4179,
      743,
      761,
      3131,
      7587,
      393,
      307,
      5710,
      737
    ],
    "start_token": 1289,
    "end_token": 1319,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      257,
      25131,
      4006,
      319,
      281,
      2134,
      2446
    ],
    "label": "ml_signal",
    "reason": "Checking a boolean condition on an object method"
  },
  {
    "line": 402,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Returning a boolean value based on a condition",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1319,
    "end_token": 1319,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      25131,
      1988,
      1912,
      319,
      257,
      4006
    ],
    "label": "ml_signal",
    "reason": "Returning a boolean value based on a condition"
  },
  {
    "line": 417,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Checks if processors are read-only, indicating conditional logic based on processor state",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1319,
    "end_token": 1319,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      611,
      20399,
      389,
      1100,
      12,
      8807,
      11,
      12739,
      26340,
      9156,
      1912,
      319,
      12649,
      1181
    ],
    "label": "ml_signal",
    "reason": "Checks if processors are read-only, indicating conditional logic based on processor state"
  },
  {
    "line": 420,
    "text": "    _learn: pd.DataFrame  # data for learning models",
    "annotation": "\ud83e\udde0 ML Signal: Executes a list of processors, indicating a pattern of sequential data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4808,
      35720,
      25,
      279,
      67,
      13,
      6601,
      19778,
      220,
      1303,
      1366,
      329,
      4673,
      4981
    ],
    "start_token": 1319,
    "end_token": 1336,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8393,
      1769,
      257,
      1351,
      286,
      20399,
      11,
      12739,
      257,
      3912,
      286,
      35582,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Executes a list of processors, indicating a pattern of sequential data processing"
  },
  {
    "line": 423,
    "text": "    ATTR_MAP = {DataHandler.DK_R: \"_data\", DataHandler.DK_I: \"_infer\", DataHandler.DK_L: \"_learn\"}",
    "annotation": "\ud83e\udde0 ML Signal: Checks if processors are read-only, indicating conditional logic based on processor state",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      5161,
      5446,
      62,
      33767,
      796,
      1391,
      6601,
      25060,
      13,
      48510,
      62,
      49,
      25,
      45434,
      7890,
      1600,
      6060,
      25060,
      13,
      48510,
      62,
      40,
      25,
      45434,
      259,
      2232,
      1600,
      6060,
      25060,
      13,
      48510,
      62,
      43,
      25,
      45434,
      35720,
      20662
    ],
    "start_token": 1336,
    "end_token": 1376,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      611,
      20399,
      389,
      1100,
      12,
      8807,
      11,
      12739,
      26340,
      9156,
      1912,
      319,
      12649,
      1181
    ],
    "label": "ml_signal",
    "reason": "Checks if processors are read-only, indicating conditional logic based on processor state"
  },
  {
    "line": 426,
    "text": "    PTYPE_I = \"independent\"",
    "annotation": "\ud83e\udde0 ML Signal: Executes a list of processors, indicating a pattern of sequential data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      350,
      25216,
      62,
      40,
      796,
      366,
      34750,
      1
    ],
    "start_token": 1376,
    "end_token": 1387,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8393,
      1769,
      257,
      1351,
      286,
      20399,
      11,
      12739,
      257,
      3912,
      286,
      35582,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Executes a list of processors, indicating a pattern of sequential data processing"
  },
  {
    "line": 428,
    "text": "    # - self._learn will be processed by shared_processors + learn_processors",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on process type, indicating different processing paths",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      532,
      2116,
      13557,
      35720,
      481,
      307,
      13686,
      416,
      4888,
      62,
      14681,
      669,
      1343,
      2193,
      62,
      14681,
      669
    ],
    "start_token": 1387,
    "end_token": 1408,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      1429,
      2099,
      11,
      12739,
      1180,
      7587,
      13532
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on process type, indicating different processing paths"
  },
  {
    "line": 435,
    "text": "    #   - (e.g. self._infer processed by learn_processors )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raises a generic exception, which could be improved for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      220,
      220,
      532,
      357,
      68,
      13,
      70,
      13,
      2116,
      13557,
      259,
      2232,
      13686,
      416,
      2193,
      62,
      14681,
      669,
      1267
    ],
    "start_token": 1408,
    "end_token": 1431,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      2696,
      257,
      14276,
      6631,
      11,
      543,
      714,
      307,
      6596,
      329,
      16287
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raises a generic exception, which could be improved for clarity"
  },
  {
    "line": 437,
    "text": "    def __init__(",
    "annotation": "\ud83e\udde0 ML Signal: Checks if processors are read-only, indicating conditional logic based on processor state",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 1431,
    "end_token": 1439,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      611,
      20399,
      389,
      1100,
      12,
      8807,
      11,
      12739,
      26340,
      9156,
      1912,
      319,
      12649,
      1181
    ],
    "label": "ml_signal",
    "reason": "Checks if processors are read-only, indicating conditional logic based on processor state"
  },
  {
    "line": 438,
    "text": "        self,",
    "annotation": "\ud83e\udde0 ML Signal: Executes a list of processors, indicating a pattern of sequential data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 1439,
    "end_token": 1448,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8393,
      1769,
      257,
      1351,
      286,
      20399,
      11,
      12739,
      257,
      3912,
      286,
      35582,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Executes a list of processors, indicating a pattern of sequential data processing"
  },
  {
    "line": 443,
    "text": "        infer_processors: List = [],",
    "annotation": "\u2705 Best Practice: Deletes raw data if not needed, indicating resource management",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      13249,
      62,
      14681,
      669,
      25,
      7343,
      796,
      685,
      4357
    ],
    "start_token": 1448,
    "end_token": 1464,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      1024,
      40676,
      8246,
      1366,
      611,
      407,
      2622,
      11,
      12739,
      8271,
      4542
    ],
    "label": "best_practice",
    "reason": "Deletes raw data if not needed, indicating resource management"
  },
  {
    "line": 438,
    "text": "        self,",
    "annotation": "\u2705 Best Practice: Provide a default value for mutable arguments to avoid unexpected behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 1464,
    "end_token": 1473,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      4277,
      1988,
      329,
      4517,
      540,
      7159,
      284,
      3368,
      10059,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a default value for mutable arguments to avoid unexpected behavior."
  },
  {
    "line": 445,
    "text": "        shared_processors: List = [],",
    "annotation": "\u2705 Best Practice: Check for None before iterating to prevent runtime errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4888,
      62,
      14681,
      669,
      25,
      7343,
      796,
      685,
      4357
    ],
    "start_token": 1473,
    "end_token": 1489,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6045,
      878,
      11629,
      803,
      284,
      2948,
      19124,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Check for None before iterating to prevent runtime errors."
  },
  {
    "line": 448,
    "text": "        **kwargs,",
    "annotation": "\ud83e\udde0 ML Signal: Configuring processors with specific arguments can indicate customization patterns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12429,
      46265,
      22046,
      11
    ],
    "start_token": 1489,
    "end_token": 1500,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17056,
      870,
      20399,
      351,
      2176,
      7159,
      460,
      7603,
      31344,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Configuring processors with specific arguments can indicate customization patterns."
  },
  {
    "line": 451,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Constants like these can indicate specific modes or states in a process.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 1500,
    "end_token": 1508,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4757,
      1187,
      588,
      777,
      460,
      7603,
      2176,
      12881,
      393,
      2585,
      287,
      257,
      1429,
      13
    ],
    "label": "ml_signal",
    "reason": "Constants like these can indicate specific modes or states in a process."
  },
  {
    "line": 451,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of parameters and functionality",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 1508,
    "end_token": 1516,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      10007,
      290,
      11244
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of parameters and functionality"
  },
  {
    "line": 464,
    "text": "                            \"fit_start_time\": \"20080101\",",
    "annotation": "\ud83e\udde0 ML Signal: Use of super() indicates inheritance, which is common in ML model setups",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      11147,
      62,
      9688,
      62,
      2435,
      1298,
      366,
      11528,
      486,
      486,
      1600
    ],
    "start_token": 1516,
    "end_token": 1555,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2208,
      3419,
      9217,
      24155,
      11,
      543,
      318,
      2219,
      287,
      10373,
      2746,
      44266
    ],
    "label": "ml_signal",
    "reason": "Use of super() indicates inheritance, which is common in ML model setups"
  },
  {
    "line": 466,
    "text": "                        }",
    "annotation": "\ud83e\udde0 ML Signal: Use of TimeInspector suggests performance monitoring, common in ML workflows",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1782
    ],
    "start_token": 1555,
    "end_token": 1579,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3862,
      818,
      4443,
      273,
      5644,
      2854,
      9904,
      11,
      2219,
      287,
      10373,
      670,
      44041
    ],
    "label": "ml_signal",
    "reason": "Use of TimeInspector suggests performance monitoring, common in ML workflows"
  },
  {
    "line": 468,
    "text": "                2) Only classname:",
    "annotation": "\ud83e\udde0 ML Signal: Different initialization types suggest flexibility in data handling, relevant for ML",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      362,
      8,
      5514,
      1398,
      3672,
      25
    ],
    "start_token": 1579,
    "end_token": 1600,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20615,
      37588,
      3858,
      1950,
      13688,
      287,
      1366,
      9041,
      11,
      5981,
      329,
      10373
    ],
    "label": "ml_signal",
    "reason": "Different initialization types suggest flexibility in data handling, relevant for ML"
  },
  {
    "line": 470,
    "text": "                3) object instance of Processor",
    "annotation": "\ud83e\udde0 ML Signal: Method calls like fit() are indicative of ML model training",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      513,
      8,
      2134,
      4554,
      286,
      32893
    ],
    "start_token": 1600,
    "end_token": 1621,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      3848,
      588,
      4197,
      3419,
      389,
      29105,
      286,
      10373,
      2746,
      3047
    ],
    "label": "ml_signal",
    "reason": "Method calls like fit() are indicative of ML model training"
  },
  {
    "line": 471,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method calls like process_data() are indicative of data preprocessing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1621,
    "end_token": 1621,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      3848,
      588,
      1429,
      62,
      7890,
      3419,
      389,
      29105,
      286,
      1366,
      662,
      36948
    ],
    "label": "ml_signal",
    "reason": "Method calls like process_data() are indicative of data preprocessing"
  },
  {
    "line": 476,
    "text": "            PTYPE_I = 'independent'",
    "annotation": "\ud83e\udde0 ML Signal: Method calls like fit_process_data() are indicative of combined training and preprocessing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      350,
      25216,
      62,
      40,
      796,
      705,
      34750,
      6
    ],
    "start_token": 1621,
    "end_token": 1640,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      3848,
      588,
      4197,
      62,
      14681,
      62,
      7890,
      3419,
      389,
      29105,
      286,
      5929,
      3047,
      290,
      662,
      36948
    ],
    "label": "ml_signal",
    "reason": "Method calls like fit_process_data() are indicative of combined training and preprocessing"
  },
  {
    "line": 480,
    "text": "            - self._learn will be processed by learn_processors",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): NotImplementedError could expose internal logic if not handled properly",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      2116,
      13557,
      35720,
      481,
      307,
      13686,
      416,
      2193,
      62,
      14681,
      669
    ],
    "start_token": 1640,
    "end_token": 1663,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1892,
      3546,
      1154,
      12061,
      12331,
      714,
      15651,
      5387,
      9156,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "NotImplementedError could expose internal logic if not handled properly"
  },
  {
    "line": 474,
    "text": "",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1663,
    "end_token": 1663,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 476,
    "text": "            PTYPE_I = 'independent'",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different data keys",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      350,
      25216,
      62,
      40,
      796,
      705,
      34750,
      6
    ],
    "start_token": 1663,
    "end_token": 1682,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      1366,
      8251
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different data keys"
  },
  {
    "line": 479,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic AttributeError might not provide enough context for debugging",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1682,
    "end_token": 1682,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      3460,
      4163,
      12331,
      1244,
      407,
      2148,
      1576,
      4732,
      329,
      28769
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic AttributeError might not provide enough context for debugging"
  },
  {
    "line": 481,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic attribute access pattern using getattr",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1682,
    "end_token": 1682,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      11688,
      1895,
      3912,
      1262,
      651,
      35226
    ],
    "label": "ml_signal",
    "reason": "Dynamic attribute access pattern using getattr"
  },
  {
    "line": 490,
    "text": "            Whether to drop the raw data",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10127,
      284,
      4268,
      262,
      8246,
      1366
    ],
    "start_token": 1682,
    "end_token": 1699,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return type"
  },
  {
    "line": 508,
    "text": "        self.drop_raw = drop_raw",
    "annotation": "\ud83e\udde0 ML Signal: Method signature and parameters can be used to understand data access patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      14781,
      62,
      1831,
      796,
      4268,
      62,
      1831
    ],
    "start_token": 1699,
    "end_token": 1715,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      9877,
      290,
      10007,
      460,
      307,
      973,
      284,
      1833,
      1366,
      1895,
      7572
    ],
    "label": "ml_signal",
    "reason": "Method signature and parameters can be used to understand data access patterns"
  },
  {
    "line": 508,
    "text": "        self.drop_raw = drop_raw",
    "annotation": "\u2705 Best Practice: Using a private method for data fetching encapsulates functionality",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      14781,
      62,
      1831,
      796,
      4268,
      62,
      1831
    ],
    "start_token": 1715,
    "end_token": 1731,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      2839,
      2446,
      329,
      1366,
      21207,
      278,
      32652,
      15968,
      11244
    ],
    "label": "best_practice",
    "reason": "Using a private method for data fetching encapsulates functionality"
  },
  {
    "line": 508,
    "text": "        self.drop_raw = drop_raw",
    "annotation": "\ud83e\udde0 ML Signal: Accessing data storage by key indicates data retrieval patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      14781,
      62,
      1831,
      796,
      4268,
      62,
      1831
    ],
    "start_token": 1731,
    "end_token": 1747,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      1366,
      6143,
      416,
      1994,
      9217,
      1366,
      45069,
      7572
    ],
    "label": "ml_signal",
    "reason": "Accessing data storage by key indicates data retrieval patterns"
  },
  {
    "line": 517,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1747,
    "end_token": 1755,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return value"
  },
  {
    "line": 531,
    "text": "    def _run_proc_l(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self indicates this is an instance method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4808,
      5143,
      62,
      36942,
      62,
      75,
      7
    ],
    "start_token": 1755,
    "end_token": 1766,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      9217,
      428,
      318,
      281,
      4554,
      2446
    ],
    "label": "ml_signal",
    "reason": "Usage of self indicates this is an instance method"
  },
  {
    "line": 532,
    "text": "        df: pd.DataFrame, proc_l: List[processor_module.Processor], with_fit: bool, check_for_infer: bool",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern with specific parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      25,
      279,
      67,
      13,
      6601,
      19778,
      11,
      13834,
      62,
      75,
      25,
      7343,
      58,
      41341,
      62,
      21412,
      13,
      18709,
      273,
      4357,
      351,
      62,
      11147,
      25,
      20512,
      11,
      2198,
      62,
      1640,
      62,
      259,
      2232,
      25,
      20512
    ],
    "start_token": 1766,
    "end_token": 1808,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      351,
      2176,
      10007
    ],
    "label": "ml_signal",
    "reason": "Function call pattern with specific parameters"
  },
  {
    "line": 535,
    "text": "            if check_for_infer and not proc.is_for_infer():",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of DataFrame columns to list",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2198,
      62,
      1640,
      62,
      259,
      2232,
      290,
      407,
      13834,
      13,
      271,
      62,
      1640,
      62,
      259,
      2232,
      33529
    ],
    "start_token": 1808,
    "end_token": 1837,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      6060,
      19778,
      15180,
      284,
      1351
    ],
    "label": "ml_signal",
    "reason": "Conversion of DataFrame columns to list"
  },
  {
    "line": 549,
    "text": "            if not p.readonly():",
    "annotation": "\u2705 Best Practice: Use of type hinting for variable 'new_hd' improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      279,
      13,
      961,
      8807,
      33529
    ],
    "start_token": 1837,
    "end_token": 1855,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      7885,
      705,
      3605,
      62,
      31298,
      6,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for variable 'new_hd' improves code readability and maintainability."
  },
  {
    "line": 551,
    "text": "        return True",
    "annotation": "\ud83e\udde0 ML Signal: Setting an attribute to a constant value can indicate a flag or state change.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6407
    ],
    "start_token": 1855,
    "end_token": 1864,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      25700,
      281,
      11688,
      284,
      257,
      6937,
      1988,
      460,
      7603,
      257,
      6056,
      393,
      1181,
      1487,
      13
    ],
    "label": "ml_signal",
    "reason": "Setting an attribute to a constant value can indicate a flag or state change."
  },
  {
    "line": 559,
    "text": "        # data processing flow of self.process_type == DataHandlerLP.PTYPE_I",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): getattr with a default value of None can mask attribute errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1366,
      7587,
      5202,
      286,
      2116,
      13,
      14681,
      62,
      4906,
      6624,
      6060,
      25060,
      19930,
      13,
      47,
      25216,
      62,
      40
    ],
    "start_token": 1864,
    "end_token": 1890,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      651,
      35226,
      351,
      257,
      4277,
      1988,
      286,
      6045,
      460,
      9335,
      11688,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "getattr with a default value of None can mask attribute errors."
  },
  {
    "line": 562,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of @classmethod decorator indicates a method that operates on the class rather than instance.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1890,
    "end_token": 1890,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      11705,
      1352,
      9217,
      257,
      2446,
      326,
      14051,
      319,
      262,
      1398,
      2138,
      621,
      4554,
      13
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod decorator indicates a method that operates on the class rather than instance."
  },
  {
    "line": 562,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for creating an object from a DataFrame, common in data processing libraries",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1890,
    "end_token": 1890,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      4441,
      281,
      2134,
      422,
      257,
      6060,
      19778,
      11,
      2219,
      287,
      1366,
      7587,
      12782
    ],
    "label": "ml_signal",
    "reason": "Method for creating an object from a DataFrame, common in data processing libraries"
  },
  {
    "line": 562,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides motivation and usage example, aiding understanding and maintainability",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1890,
    "end_token": 1890,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      14052,
      290,
      8748,
      1672,
      11,
      37221,
      4547,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Docstring provides motivation and usage example, aiding understanding and maintainability"
  },
  {
    "line": 576,
    "text": "            The input of the `fit` will be the output of the previous processor",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential performance issue with StaticDataLoader being slow",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      5128,
      286,
      262,
      4600,
      11147,
      63,
      481,
      307,
      262,
      5072,
      286,
      262,
      2180,
      12649
    ],
    "start_token": 1890,
    "end_token": 1916,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2854,
      2071,
      351,
      36125,
      6601,
      17401,
      852,
      3105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential performance issue with StaticDataLoader being slow"
  },
  {
    "line": 576,
    "text": "            The input of the `fit` will be the output of the previous processor",
    "annotation": "\u2705 Best Practice: Returning an instance of the class using a class method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      5128,
      286,
      262,
      4600,
      11147,
      63,
      481,
      307,
      262,
      5072,
      286,
      262,
      2180,
      12649
    ],
    "start_token": 1916,
    "end_token": 1942,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      42882,
      281,
      4554,
      286,
      262,
      1398,
      1262,
      257,
      1398,
      2446
    ],
    "label": "best_practice",
    "reason": "Returning an instance of the class using a class method"
  }
]