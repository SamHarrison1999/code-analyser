[
  {
    "line": 4,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Conditional imports with TYPE_CHECKING to avoid circular dependencies and reduce runtime overhead",
    "confidence": 0.5,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 0,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      9724,
      1859,
      17944,
      351,
      41876,
      62,
      50084,
      2751,
      284,
      3368,
      18620,
      20086,
      290,
      4646,
      19124,
      16965
    ],
    "label": "best_practice",
    "reason": "Conditional imports with TYPE_CHECKING to avoid circular dependencies and reduce runtime overhead"
  },
  {
    "line": 7,
    "text": "",
    "annotation": "\u2705 Best Practice: TYPE_CHECKING import to prevent runtime import and improve performance",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 6,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      41876,
      62,
      50084,
      2751,
      1330,
      284,
      2948,
      19124,
      1330,
      290,
      2987,
      2854
    ],
    "label": "best_practice",
    "reason": "TYPE_CHECKING import to prevent runtime import and improve performance"
  },
  {
    "line": 7,
    "text": "",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 6,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 22,
    "text": "        index level",
    "annotation": "\ud83e\udde0 ML Signal: Checking the type of a variable to determine the code path",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      1241
    ],
    "start_token": 6,
    "end_token": 15,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      262,
      2099,
      286,
      257,
      7885,
      284,
      5004,
      262,
      2438,
      3108
    ],
    "label": "ml_signal",
    "reason": "Checking the type of a variable to determine the code path"
  },
  {
    "line": 25,
    "text": "    -------",
    "annotation": "\ud83e\udde0 ML Signal: Using DataFrame index names to find the index of a level",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      35656
    ],
    "start_token": 15,
    "end_token": 19,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      6060,
      19778,
      6376,
      3891,
      284,
      1064,
      262,
      6376,
      286,
      257,
      1241
    ],
    "label": "ml_signal",
    "reason": "Using DataFrame index names to find the index of a level"
  },
  {
    "line": 27,
    "text": "        The level index in the multiple index",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if the level is not found in the tuple, could raise a ValueError",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      1241,
      6376,
      287,
      262,
      3294,
      6376
    ],
    "start_token": 19,
    "end_token": 33,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      262,
      1241,
      318,
      407,
      1043,
      287,
      262,
      46545,
      11,
      714,
      5298,
      257,
      11052,
      12331
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if the level is not found in the tuple, could raise a ValueError"
  },
  {
    "line": 30,
    "text": "        try:",
    "annotation": "\ud83e\udde0 ML Signal: Checking the type of a variable to determine the code path",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 33,
    "end_token": 42,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      262,
      2099,
      286,
      257,
      7885,
      284,
      5004,
      262,
      2438,
      3108
    ],
    "label": "ml_signal",
    "reason": "Checking the type of a variable to determine the code path"
  },
  {
    "line": 34,
    "text": "            return (\"datetime\", \"instrument\").index(level)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError for unsupported input types",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      5855,
      19608,
      8079,
      1600,
      366,
      259,
      43872,
      11074,
      9630,
      7,
      5715,
      8
    ],
    "start_token": 42,
    "end_token": 66,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      329,
      24222,
      5128,
      3858
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError for unsupported input types"
  },
  {
    "line": 30,
    "text": "        try:",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 66,
    "end_token": 75,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the function parameters and return type for better readability and maintainability."
  },
  {
    "line": 51,
    "text": "    `fetch_df_by_index` is only responsible for get the right level",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): If `level` is None, it might lead to unexpected behavior. Consider validating input parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4600,
      69,
      7569,
      62,
      7568,
      62,
      1525,
      62,
      9630,
      63,
      318,
      691,
      4497,
      329,
      651,
      262,
      826,
      1241
    ],
    "start_token": 75,
    "end_token": 96,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1002,
      4600,
      5715,
      63,
      318,
      6045,
      11,
      340,
      1244,
      1085,
      284,
      10059,
      4069,
      13,
      12642,
      4938,
      803,
      5128,
      10007,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "If `level` is None, it might lead to unexpected behavior. Consider validating input parameters."
  },
  {
    "line": 55,
    "text": "    selector : Union[pd.Timestamp, slice, str, list]",
    "annotation": "\u2705 Best Practice: Use descriptive variable names for better readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      31870,
      1058,
      4479,
      58,
      30094,
      13,
      14967,
      27823,
      11,
      16416,
      11,
      965,
      11,
      1351,
      60
    ],
    "start_token": 96,
    "end_token": 114,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      35644,
      7885,
      3891,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use descriptive variable names for better readability."
  },
  {
    "line": 63,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Import statements should be at the top of the file for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 114,
    "end_token": 118,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      6299,
      815,
      307,
      379,
      262,
      1353,
      286,
      262,
      2393,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Import statements should be at the top of the file for better readability and maintainability."
  },
  {
    "line": 65,
    "text": "    if level is None or isinstance(selector, pd.MultiIndex):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Dynamic attribute access on DataFrame columns can lead to KeyError if col_set is not present.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      1241,
      318,
      6045,
      393,
      318,
      39098,
      7,
      19738,
      273,
      11,
      279,
      67,
      13,
      29800,
      15732,
      2599
    ],
    "start_token": 118,
    "end_token": 138,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      26977,
      11688,
      1895,
      319,
      6060,
      19778,
      15180,
      460,
      1085,
      284,
      7383,
      12331,
      611,
      951,
      62,
      2617,
      318,
      407,
      1944,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Dynamic attribute access on DataFrame columns can lead to KeyError if col_set is not present."
  },
  {
    "line": 68,
    "text": "    idx_slc = (selector, slice(None, None))",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Dropping levels in a MultiIndex DataFrame can lead to data misinterpretation if not handled carefully.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4686,
      87,
      62,
      6649,
      66,
      796,
      357,
      19738,
      273,
      11,
      16416,
      7,
      14202,
      11,
      6045,
      4008
    ],
    "start_token": 138,
    "end_token": 157,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      21045,
      2105,
      2974,
      287,
      257,
      15237,
      15732,
      6060,
      19778,
      460,
      1085,
      284,
      1366,
      40882,
      341,
      611,
      407,
      12118,
      7773,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Dropping levels in a MultiIndex DataFrame can lead to data misinterpretation if not handled carefully."
  },
  {
    "line": 71,
    "text": "    if fetch_orig:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using loc with dynamic column selection can lead to KeyError if col_set is not present.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      21207,
      62,
      11612,
      25
    ],
    "start_token": 157,
    "end_token": 165,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1179,
      351,
      8925,
      5721,
      6356,
      460,
      1085,
      284,
      7383,
      12331,
      611,
      951,
      62,
      2617,
      318,
      407,
      1944,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using loc with dynamic column selection can lead to KeyError if col_set is not present."
  },
  {
    "line": 71,
    "text": "    if fetch_orig:",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      21207,
      62,
      11612,
      25
    ],
    "start_token": 165,
    "end_token": 173,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability."
  },
  {
    "line": 90,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes that the MultiIndex has exactly two levels without validation.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 173,
    "end_token": 173,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      326,
      262,
      15237,
      15732,
      468,
      3446,
      734,
      2974,
      1231,
      21201,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes that the MultiIndex has exactly two levels without validation."
  },
  {
    "line": 92,
    "text": "def convert_index_format(df: Union[pd.DataFrame, pd.Series], level: str = \"datetime\") -> Union[pd.DataFrame, pd.Series]:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of swaplevel and sort_index indicates data manipulation patterns.",
    "confidence": 0.5,
    "tokens": [
      4299,
      10385,
      62,
      9630,
      62,
      18982,
      7,
      7568,
      25,
      4479,
      58,
      30094,
      13,
      6601,
      19778,
      11,
      279,
      67,
      13,
      27996,
      4357,
      1241,
      25,
      965,
      796,
      366,
      19608,
      8079,
      4943,
      4613,
      4479,
      58,
      30094,
      13,
      6601,
      19778,
      11,
      279,
      67,
      13,
      27996,
      5974
    ],
    "start_token": 173,
    "end_token": 215,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      16075,
      5715,
      290,
      3297,
      62,
      9630,
      9217,
      1366,
      17512,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of swaplevel and sort_index indicates data manipulation patterns."
  },
  {
    "line": 92,
    "text": "def convert_index_format(df: Union[pd.DataFrame, pd.Series], level: str = \"datetime\") -> Union[pd.DataFrame, pd.Series]:",
    "annotation": "\u2705 Best Practice: Add type hint for the return type in the function signature",
    "confidence": 0.5,
    "tokens": [
      4299,
      10385,
      62,
      9630,
      62,
      18982,
      7,
      7568,
      25,
      4479,
      58,
      30094,
      13,
      6601,
      19778,
      11,
      279,
      67,
      13,
      27996,
      4357,
      1241,
      25,
      965,
      796,
      366,
      19608,
      8079,
      4943,
      4613,
      4479,
      58,
      30094,
      13,
      6601,
      19778,
      11,
      279,
      67,
      13,
      27996,
      5974
    ],
    "start_token": 215,
    "end_token": 257,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      2099,
      9254,
      329,
      262,
      1441,
      2099,
      287,
      262,
      2163,
      9877
    ],
    "label": "best_practice",
    "reason": "Add type hint for the return type in the function signature"
  },
  {
    "line": 105,
    "text": "    level : str, optional",
    "annotation": "\u2705 Best Practice: Import statements should be at the top of the file",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1241,
      1058,
      965,
      11,
      11902
    ],
    "start_token": 257,
    "end_token": 265,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      6299,
      815,
      307,
      379,
      262,
      1353,
      286,
      262,
      2393
    ],
    "label": "best_practice",
    "reason": "Import statements should be at the top of the file"
  },
  {
    "line": 107,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Accessing nested dictionary keys",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 265,
    "end_token": 265,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      28376,
      22155,
      8251
    ],
    "label": "ml_signal",
    "reason": "Accessing nested dictionary keys"
  },
  {
    "line": 109,
    "text": "    -------",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on configuration presence",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      35656
    ],
    "start_token": 265,
    "end_token": 269,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      8398,
      4931
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on configuration presence"
  },
  {
    "line": 111,
    "text": "        converted DataFrame/Series",
    "annotation": "\ud83e\udde0 ML Signal: Function call with specific argument types",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11513,
      6060,
      19778,
      14,
      27996
    ],
    "start_token": 269,
    "end_token": 281,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      351,
      2176,
      4578,
      3858
    ],
    "label": "ml_signal",
    "reason": "Function call with specific argument types"
  },
  {
    "line": 111,
    "text": "        converted DataFrame/Series",
    "annotation": "\ud83e\udde0 ML Signal: Modifying a dictionary in place",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11513,
      6060,
      19778,
      14,
      27996
    ],
    "start_token": 281,
    "end_token": 293,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3401,
      4035,
      257,
      22155,
      287,
      1295
    ],
    "label": "ml_signal",
    "reason": "Modifying a dictionary in place"
  },
  {
    "line": 111,
    "text": "        converted DataFrame/Series",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic exception without additional context",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      11513,
      6060,
      19778,
      14,
      27996
    ],
    "start_token": 293,
    "end_token": 305,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      6631,
      1231,
      3224,
      4732
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic exception without additional context"
  }
]