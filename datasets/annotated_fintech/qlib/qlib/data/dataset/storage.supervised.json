[
  {
    "line": 4,
    "text": "",
    "annotation": "\u2705 Best Practice: Grouping imports by standard, third-party, and local can improve readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 0,
    "end_token": 0,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      416,
      3210,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      460,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports by standard, third-party, and local can improve readability."
  },
  {
    "line": 7,
    "text": "from qlib.log import get_module_logger",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and reduce memory usage.",
    "confidence": 0.5,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      6404,
      1330,
      651,
      62,
      21412,
      62,
      6404,
      1362
    ],
    "start_token": 0,
    "end_token": 12,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      4646,
      4088,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and reduce memory usage."
  },
  {
    "line": 8,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the class purpose and usage",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 12,
    "end_token": 12,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1398,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the class purpose and usage"
  },
  {
    "line": 15,
    "text": "    - pd.DataFrame is the default data storage format in Qlib datahandler",
    "annotation": "\u2705 Best Practice: Use of abstractmethod indicates this method must be implemented by subclasses",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      532,
      279,
      67,
      13,
      6601,
      19778,
      318,
      262,
      4277,
      1366,
      6143,
      5794,
      287,
      1195,
      8019,
      4818,
      993,
      392,
      1754
    ],
    "start_token": 12,
    "end_token": 34,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      12531,
      24396,
      9217,
      428,
      2446,
      1276,
      307,
      9177,
      416,
      850,
      37724
    ],
    "label": "best_practice",
    "reason": "Use of abstractmethod indicates this method must be implemented by subclasses"
  },
  {
    "line": 22,
    "text": "        selector: Union[pd.Timestamp, slice, str, pd.Index] = slice(None, None),",
    "annotation": "\u2705 Best Practice: Docstring provides a clear description of parameters and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      31870,
      25,
      4479,
      58,
      30094,
      13,
      14967,
      27823,
      11,
      16416,
      11,
      965,
      11,
      279,
      67,
      13,
      15732,
      60,
      796,
      16416,
      7,
      14202,
      11,
      6045,
      828
    ],
    "start_token": 34,
    "end_token": 66,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear description of parameters and return type"
  },
  {
    "line": 45,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Method is not implemented, which may lead to runtime errors if called",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 66,
    "end_token": 66,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11789,
      318,
      407,
      9177,
      11,
      543,
      743,
      1085,
      284,
      19124,
      8563,
      611,
      1444
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Method is not implemented, which may lead to runtime errors if called"
  },
  {
    "line": 45,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the class and its purpose",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 66,
    "end_token": 66,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1398,
      290,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the class and its purpose"
  },
  {
    "line": 51,
    "text": "        raise NotImplementedError(\"fetch is method not implemented!\")",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pandas DataFrame as a parameter",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      1892,
      3546,
      1154,
      12061,
      12331,
      7203,
      69,
      7569,
      318,
      2446,
      407,
      9177,
      2474,
      8
    ],
    "start_token": 66,
    "end_token": 88,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      19798,
      292,
      6060,
      19778,
      355,
      257,
      11507
    ],
    "label": "ml_signal",
    "reason": "Usage of pandas DataFrame as a parameter"
  },
  {
    "line": 59,
    "text": "",
    "annotation": "\u2705 Best Practice: Check if selector is a tuple or list before attempting to convert to a slice",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 88,
    "end_token": 88,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      31870,
      318,
      257,
      46545,
      393,
      1351,
      878,
      9361,
      284,
      10385,
      284,
      257,
      16416
    ],
    "label": "best_practice",
    "reason": "Check if selector is a tuple or list before attempting to convert to a slice"
  },
  {
    "line": 61,
    "text": "        self.df = df",
    "annotation": "\u2705 Best Practice: Use slice unpacking to convert tuple/list to slice",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7568,
      796,
      47764
    ],
    "start_token": 88,
    "end_token": 100,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      16416,
      8593,
      5430,
      284,
      10385,
      46545,
      14,
      4868,
      284,
      16416
    ],
    "label": "best_practice",
    "reason": "Use slice unpacking to convert tuple/list to slice"
  },
  {
    "line": 65,
    "text": "        selector: Union[pd.Timestamp, slice, str, pd.Index] = slice(None, None),",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Logging without exception details may hide the root cause of the error",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      31870,
      25,
      4479,
      58,
      30094,
      13,
      14967,
      27823,
      11,
      16416,
      11,
      965,
      11,
      279,
      67,
      13,
      15732,
      60,
      796,
      16416,
      7,
      14202,
      11,
      6045,
      828
    ],
    "start_token": 100,
    "end_token": 132,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5972,
      2667,
      1231,
      6631,
      3307,
      743,
      7808,
      262,
      6808,
      2728,
      286,
      262,
      4049
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Logging without exception details may hide the root cause of the error"
  },
  {
    "line": 67,
    "text": "        col_set: Union[str, List[str]] = DataHandler.CS_ALL,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of self.df indicates a class instance with a DataFrame attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      951,
      62,
      2617,
      25,
      4479,
      58,
      2536,
      11,
      7343,
      58,
      2536,
      11907,
      796,
      6060,
      25060,
      13,
      7902,
      62,
      7036,
      11
    ],
    "start_token": 132,
    "end_token": 159,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2116,
      13,
      7568,
      9217,
      257,
      1398,
      4554,
      351,
      257,
      6060,
      19778,
      11688
    ],
    "label": "ml_signal",
    "reason": "Usage of self.df indicates a class instance with a DataFrame attribute"
  },
  {
    "line": 69,
    "text": "    ) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Function call to fetch_df_by_col suggests column-based data filtering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 159,
    "end_token": 170,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      284,
      21207,
      62,
      7568,
      62,
      1525,
      62,
      4033,
      5644,
      5721,
      12,
      3106,
      1366,
      25431
    ],
    "label": "ml_signal",
    "reason": "Function call to fetch_df_by_col suggests column-based data filtering"
  },
  {
    "line": 69,
    "text": "    ) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Function call to fetch_df_by_index suggests index-based data filtering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 170,
    "end_token": 181,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      284,
      21207,
      62,
      7568,
      62,
      1525,
      62,
      9630,
      5644,
      6376,
      12,
      3106,
      1366,
      25431
    ],
    "label": "ml_signal",
    "reason": "Function call to fetch_df_by_index suggests index-based data filtering"
  },
  {
    "line": 69,
    "text": "    ) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Returning a DataFrame indicates data processing or transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 181,
    "end_token": 192,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      257,
      6060,
      19778,
      9217,
      1366,
      7587,
      393,
      13389
    ],
    "label": "ml_signal",
    "reason": "Returning a DataFrame indicates data processing or transformation"
  },
  {
    "line": 81,
    "text": "                get_module_logger(\"DataHandlerLP\").info(f\"Fail to converting to query to slice. It will used directly\")",
    "annotation": "\u2705 Best Practice: Consider adding a constructor to initialize the storage dictionary and any other necessary attributes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      651,
      62,
      21412,
      62,
      6404,
      1362,
      7203,
      6601,
      25060,
      19930,
      11074,
      10951,
      7,
      69,
      1,
      39044,
      284,
      23202,
      284,
      12405,
      284,
      16416,
      13,
      632,
      481,
      973,
      3264,
      4943
    ],
    "start_token": 192,
    "end_token": 235,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      23772,
      284,
      41216,
      262,
      6143,
      22155,
      290,
      597,
      584,
      3306,
      12608,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a constructor to initialize the storage dictionary and any other necessary attributes."
  },
  {
    "line": 82,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of dictionary to store grouped data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 235,
    "end_token": 235,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      22155,
      284,
      3650,
      32824,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of dictionary to store grouped data"
  },
  {
    "line": 84,
    "text": "        data_df = fetch_df_by_col(data_df, col_set)",
    "annotation": "\ud83e\udde0 ML Signal: Use of custom function to get index level",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      7568,
      796,
      21207,
      62,
      7568,
      62,
      1525,
      62,
      4033,
      7,
      7890,
      62,
      7568,
      11,
      951,
      62,
      2617,
      8
    ],
    "start_token": 235,
    "end_token": 262,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2183,
      2163,
      284,
      651,
      6376,
      1241
    ],
    "label": "ml_signal",
    "reason": "Use of custom function to get index level"
  },
  {
    "line": 86,
    "text": "        return data_df",
    "annotation": "\ud83e\udde0 ML Signal: Grouping data by a specific level",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1366,
      62,
      7568
    ],
    "start_token": 262,
    "end_token": 273,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4912,
      278,
      1366,
      416,
      257,
      2176,
      1241
    ],
    "label": "ml_signal",
    "reason": "Grouping data by a specific level"
  },
  {
    "line": 88,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Storing grouped data in a dictionary",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 273,
    "end_token": 273,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      32824,
      1366,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Storing grouped data in a dictionary"
  },
  {
    "line": 90,
    "text": "    \"\"\"Hashing data storage for datahanlder",
    "annotation": "\ud83e\udde0 ML Signal: Storing DataFrame columns for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227,
      39,
      2140,
      1366,
      6143,
      329,
      4818,
      19210,
      6499
    ],
    "start_token": 273,
    "end_token": 285,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      6060,
      19778,
      15180,
      329,
      1568,
      779
    ],
    "label": "ml_signal",
    "reason": "Storing DataFrame columns for later use"
  },
  {
    "line": 88,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with a single parameter, indicating a common pattern for data processing functions",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 285,
    "end_token": 285,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      257,
      2060,
      11507,
      11,
      12739,
      257,
      2219,
      3912,
      329,
      1366,
      7587,
      5499
    ],
    "label": "ml_signal",
    "reason": "Function definition with a single parameter, indicating a common pattern for data processing functions"
  },
  {
    "line": 90,
    "text": "    \"\"\"Hashing data storage for datahanlder",
    "annotation": "\ud83e\udde0 ML Signal: Returning an instance of a class, indicating object-oriented design pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227,
      39,
      2140,
      1366,
      6143,
      329,
      4818,
      19210,
      6499
    ],
    "start_token": 285,
    "end_token": 297,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      281,
      4554,
      286,
      257,
      1398,
      11,
      12739,
      2134,
      12,
      17107,
      1486,
      3912
    ],
    "label": "ml_signal",
    "reason": "Returning an instance of a class, indicating object-oriented design pattern"
  },
  {
    "line": 116,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a generic TypeError without a clear message can make debugging difficult.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 297,
    "end_token": 297,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      14276,
      5994,
      12331,
      1231,
      257,
      1598,
      3275,
      460,
      787,
      28769,
      2408,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a generic TypeError without a clear message can make debugging difficult."
  },
  {
    "line": 122,
    "text": "            which index level to select the data",
    "annotation": "\u2705 Best Practice: Validate input types to ensure they match expected types.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      6376,
      1241,
      284,
      2922,
      262,
      1366
    ],
    "start_token": 297,
    "end_token": 315,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3254,
      20540,
      5128,
      3858,
      284,
      4155,
      484,
      2872,
      2938,
      3858,
      13
    ],
    "label": "best_practice",
    "reason": "Validate input types to ensure they match expected types."
  },
  {
    "line": 130,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over sorted data can indicate a need for ordered processing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 315,
    "end_token": 323,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      23243,
      1366,
      460,
      7603,
      257,
      761,
      329,
      6149,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over sorted data can indicate a need for ordered processing."
  },
  {
    "line": 139,
    "text": "                stock_selector = selector[self.stock_level]",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the return value of _fetch_hash_df_by_stock for better readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      19738,
      273,
      796,
      31870,
      58,
      944,
      13,
      13578,
      62,
      5715,
      60
    ],
    "start_token": 323,
    "end_token": 351,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      1441,
      1988,
      286,
      4808,
      69,
      7569,
      62,
      17831,
      62,
      7568,
      62,
      1525,
      62,
      13578,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the return value of _fetch_hash_df_by_stock for better readability."
  },
  {
    "line": 141,
    "text": "            elif isinstance(selector, (list, str)) and self.stock_level == 0:",
    "annotation": "\u2705 Best Practice: Converting values to a list for consistent data structure handling.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1288,
      361,
      318,
      39098,
      7,
      19738,
      273,
      11,
      357,
      4868,
      11,
      965,
      4008,
      290,
      2116,
      13,
      13578,
      62,
      5715,
      6624,
      657,
      25
    ],
    "start_token": 351,
    "end_token": 384,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      3815,
      284,
      257,
      1351,
      329,
      6414,
      1366,
      4645,
      9041,
      13
    ],
    "label": "best_practice",
    "reason": "Converting values to a list for consistent data structure handling."
  },
  {
    "line": 143,
    "text": "                stock_selector = selector",
    "annotation": "\u2705 Best Practice: Using a separate function to fetch columns improves modularity and readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      19738,
      273,
      796,
      31870
    ],
    "start_token": 384,
    "end_token": 405,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      4553,
      2163,
      284,
      21207,
      15180,
      19575,
      26507,
      414,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using a separate function to fetch columns improves modularity and readability."
  },
  {
    "line": 146,
    "text": "                # NOTE: How could the stock level selector be a tuple?",
    "annotation": "\u2705 Best Practice: Using a separate function to fetch index improves modularity and readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      1374,
      714,
      262,
      4283,
      1241,
      31870,
      307,
      257,
      46545,
      30
    ],
    "start_token": 405,
    "end_token": 433,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      4553,
      2163,
      284,
      21207,
      6376,
      19575,
      26507,
      414,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Using a separate function to fetch index improves modularity and readability."
  },
  {
    "line": 152,
    "text": "                stock_selector = selector",
    "annotation": "\u2705 Best Practice: Using pd.MultiIndex for creating an empty DataFrame with specific index names.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4283,
      62,
      19738,
      273,
      796,
      31870
    ],
    "start_token": 433,
    "end_token": 454,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      279,
      67,
      13,
      29800,
      15732,
      329,
      4441,
      281,
      6565,
      6060,
      19778,
      351,
      2176,
      6376,
      3891,
      13
    ],
    "label": "best_practice",
    "reason": "Using pd.MultiIndex for creating an empty DataFrame with specific index names."
  },
  {
    "line": 155,
    "text": "            raise TypeError(f\"stock selector must be type str|list, or slice(None), rather than {stock_selector}\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using pd.concat with user-controlled data could lead to memory issues if not properly managed.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5298,
      5994,
      12331,
      7,
      69,
      1,
      13578,
      31870,
      1276,
      307,
      2099,
      965,
      91,
      4868,
      11,
      393,
      16416,
      7,
      14202,
      828,
      2138,
      621,
      1391,
      13578,
      62,
      19738,
      273,
      92,
      4943
    ],
    "start_token": 454,
    "end_token": 494,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      279,
      67,
      13,
      1102,
      9246,
      351,
      2836,
      12,
      14401,
      1366,
      714,
      1085,
      284,
      4088,
      2428,
      611,
      407,
      6105,
      5257,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using pd.concat with user-controlled data could lead to memory issues if not properly managed."
  }
]