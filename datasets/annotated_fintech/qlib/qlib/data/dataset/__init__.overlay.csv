annotation,annotation_tokens,confidence,end_token,label,line,reason,severity,start_token,text,tokens
"‚úÖ Best Practice: Grouping imports into standard library, third-party, and local can improve readability.","[26486, 227, 6705, 19939, 25, 4912, 278, 17944, 656, 3210, 5888, 11, 2368, 12, 10608, 11, 290, 1957, 460, 2987, 1100, 1799, 13]",1.0,25,best_practice,3,"Grouping imports into standard library, third-party, and local can improve readability.",,0,"from ...utils import init_instance_by_config, np_ffill, time_to_slc_point","[6738, 2644, 26791, 1330, 2315, 62, 39098, 62, 1525, 62, 11250, 11, 45941, 62, 487, 359, 11, 640, 62, 1462, 62, 6649, 66, 62, 4122]"
‚úÖ Best Practice: Class docstring provides a clear description of the class purpose.,"[26486, 227, 6705, 19939, 25, 5016, 2205, 8841, 3769, 257, 1598, 6764, 286, 262, 1398, 4007, 13]",1.0,25,best_practice,14,Class docstring provides a clear description of the class purpose.,,25,,[]
‚úÖ Best Practice: Docstring provides a clear explanation of the method's purpose and behavior.,"[26486, 227, 6705, 19939, 25, 14432, 8841, 3769, 257, 1598, 7468, 286, 262, 2446, 338, 4007, 290, 4069, 13]",0.5,29,best_practice,18,Docstring provides a clear explanation of the method's purpose and behavior.,,25,"    """"""","[220, 220, 220, 37227]"
üß† ML Signal: Usage of **kwargs indicates flexibility in handling various input parameters.,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 12429, 46265, 22046, 9217, 13688, 287, 9041, 2972, 5128, 10007, 13]",0.5,39,ml_signal,27,Usage of **kwargs indicates flexibility in handling various input parameters.,,29,        - setup data,"[220, 220, 220, 220, 220, 220, 220, 532, 9058, 1366]"
‚úÖ Best Practice: Calling the superclass's __init__ method ensures proper initialization of the base class.,"[26486, 227, 6705, 19939, 25, 32677, 262, 2208, 4871, 338, 11593, 15003, 834, 2446, 19047, 1774, 37588, 286, 262, 2779, 1398, 13]",1.0,39,best_practice,29,Calling the superclass's __init__ method ensures proper initialization of the base class.,,39,,[]
‚úÖ Best Practice: Use of **kwargs allows for flexible function arguments,"[26486, 227, 6705, 19939, 25, 5765, 286, 12429, 46265, 22046, 3578, 329, 12846, 2163, 7159]",1.0,39,best_practice,29,Use of **kwargs allows for flexible function arguments,,39,,[]
‚úÖ Best Practice: Calling the superclass method ensures proper inheritance behavior,"[26486, 227, 6705, 19939, 25, 32677, 262, 2208, 4871, 2446, 19047, 1774, 24155, 4069]",0.5,52,best_practice,33,Calling the superclass method ensures proper inheritance behavior,,39,        super().__init__(),"[220, 220, 220, 220, 220, 220, 220, 2208, 22446, 834, 15003, 834, 3419]"
"üß† ML Signal: Function designed to handle data setup, indicating a pattern for data preprocessing in ML workflows","[8582, 100, 254, 10373, 26484, 25, 15553, 3562, 284, 5412, 1366, 9058, 11, 12739, 257, 3912, 329, 1366, 662, 36948, 287, 10373, 670, 44041]",1.0,52,ml_signal,34,"Function designed to handle data setup, indicating a pattern for data preprocessing in ML workflows",,52,,[]
"‚úÖ Best Practice: Use of docstring to describe the method's purpose, parameters, and return type","[26486, 227, 6705, 19939, 25, 5765, 286, 2205, 8841, 284, 6901, 262, 2446, 338, 4007, 11, 10007, 11, 290, 1441, 2099]",1.0,60,best_practice,42,"Use of docstring to describe the method's purpose, parameters, and return type",,52,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
‚úÖ Best Practice: Clear and concise docstring explaining the method's functionality,"[26486, 227, 6705, 19939, 25, 11459, 290, 35327, 2205, 8841, 11170, 262, 2446, 338, 11244]",0.5,71,best_practice,43,Clear and concise docstring explaining the method's functionality,,60,        Setup the data.,"[220, 220, 220, 220, 220, 220, 220, 31122, 262, 1366, 13]"
‚úÖ Best Practice: Class docstring provides clear guidance on intended usage and responsibilities.,"[26486, 227, 6705, 19939, 25, 5016, 2205, 8841, 3769, 1598, 11154, 319, 5292, 8748, 290, 15171, 13]",0.5,71,best_practice,62,Class docstring provides clear guidance on intended usage and responsibilities.,,71,,[]
‚ö†Ô∏è SAST Risk (Low): Potential type confusion if `handler` is not properly validated before use.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 2099, 10802, 611, 4600, 30281, 63, 318, 407, 6105, 31031, 878, 779, 13]",1.0,79,sast_risk,91,Potential type confusion if `handler` is not properly validated before use.,Low,71,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
‚úÖ Best Practice: Use type hints to clarify expected types for better readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5765, 2099, 20269, 284, 18282, 2938, 3858, 329, 1365, 1100, 1799, 290, 5529, 1799, 13]",0.5,91,best_practice,92,Use type hints to clarify expected types for better readability and maintainability.,,79,        Setup the underlying data.,"[220, 220, 220, 220, 220, 220, 220, 31122, 262, 10238, 1366, 13]"
‚úÖ Best Practice: Use `.copy()` to avoid unintended side effects from mutable default arguments.,"[26486, 227, 6705, 19939, 25, 5765, 4600, 13, 30073, 3419, 63, 284, 3368, 30261, 1735, 3048, 422, 4517, 540, 4277, 7159, 13]",0.5,99,best_practice,94,Use `.copy()` to avoid unintended side effects from mutable default arguments.,,91,        Parameters,"[220, 220, 220, 220, 220, 220, 220, 40117]"
‚ö†Ô∏è SAST Risk (Low): Using `copy` without import statement; ensure `copy` is imported from `copy` module.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 8554, 4600, 30073, 63, 1231, 1330, 2643, 26, 4155, 4600, 30073, 63, 318, 17392, 422, 4600, 30073, 63, 8265, 13]",0.5,115,sast_risk,96,Using `copy` without import statement; ensure `copy` is imported from `copy` module.,Low,99,"        handler : Union[dict, DataHandler]","[220, 220, 220, 220, 220, 220, 220, 21360, 1058, 4479, 58, 11600, 11, 6060, 25060, 60]"
‚úÖ Best Practice: Call the superclass's `__init__` to ensure proper initialization of inherited attributes.,"[26486, 227, 6705, 19939, 25, 4889, 262, 2208, 4871, 338, 4600, 834, 15003, 834, 63, 284, 4155, 1774, 37588, 286, 19552, 12608, 13]",1.0,131,best_practice,96,Call the superclass's `__init__` to ensure proper initialization of inherited attributes.,,115,"        handler : Union[dict, DataHandler]","[220, 220, 220, 220, 220, 220, 220, 21360, 1058, 4479, 58, 11600, 11, 6060, 25060, 60]"
‚úÖ Best Practice: Use of default mutable arguments (like dict) is avoided by setting default to None,"[26486, 227, 6705, 19939, 25, 5765, 286, 4277, 4517, 540, 7159, 357, 2339, 8633, 8, 318, 13941, 416, 4634, 4277, 284, 6045]",0.5,147,best_practice,96,Use of default mutable arguments (like dict) is avoided by setting default to None,,131,"        handler : Union[dict, DataHandler]","[220, 220, 220, 220, 220, 220, 220, 21360, 1058, 4479, 58, 11600, 11, 6060, 25060, 60]"
üß† ML Signal: Conditional configuration based on presence of handler_kwargs,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 8398, 1912, 319, 4931, 286, 21360, 62, 46265, 22046]",0.5,187,ml_signal,110,Conditional configuration based on presence of handler_kwargs,,147,"                        'train': (""2008-01-01"", ""2014-12-31""),","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 705, 27432, 10354, 5855, 11528, 12, 486, 12, 486, 1600, 366, 4967, 12, 1065, 12, 3132, 12340]"
üß† ML Signal: Conditional logic based on presence of specific key in kwargs,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 4931, 286, 2176, 1994, 287, 479, 86, 22046]",0.5,207,ml_signal,113,Conditional logic based on presence of specific key in kwargs,,187,                    },"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1782]"
‚úÖ Best Practice: Use of deepcopy to avoid unintended side-effects from mutable objects,"[26486, 227, 6705, 19939, 25, 5765, 286, 2769, 30073, 284, 3368, 30261, 1735, 12, 34435, 422, 4517, 540, 5563]",1.0,229,best_practice,114,Use of deepcopy to avoid unintended side-effects from mutable objects,,207,                2) 'segments': {,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 362, 8, 705, 325, 11726, 10354, 1391]"
üß† ML Signal: Use of super() to call parent class method,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 2208, 3419, 284, 869, 2560, 1398, 2446]",1.0,251,ml_signal,114,Use of super() to call parent class method,,229,                2) 'segments': {,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 362, 8, 705, 325, 11726, 10354, 1391]"
‚úÖ Best Practice: Use of default mutable arguments (like dict) should be avoided; use None instead,"[26486, 227, 6705, 19939, 25, 5765, 286, 4277, 4517, 540, 7159, 357, 2339, 8633, 8, 815, 307, 13941, 26, 779, 6045, 2427]",0.5,273,best_practice,114,Use of default mutable arguments (like dict) should be avoided; use None instead,,251,                2) 'segments': {,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 362, 8, 705, 325, 11726, 10354, 1391]"
"üß† ML Signal: Use of super() indicates inheritance, which is common in ML model setups","[8582, 100, 254, 10373, 26484, 25, 5765, 286, 2208, 3419, 9217, 24155, 11, 543, 318, 2219, 287, 10373, 2746, 44266]",0.5,281,ml_signal,125,"Use of super() indicates inheritance, which is common in ML model setups",,273,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
üß† ML Signal: Conditional logic based on handler_kwargs can indicate dynamic data handling,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 21360, 62, 46265, 22046, 460, 7603, 8925, 1366, 9041]",0.5,281,ml_signal,127,Conditional logic based on handler_kwargs can indicate dynamic data handling,,281,,[]
üß† ML Signal: Dynamic method calls on self.handler suggest flexible data processing,"[8582, 100, 254, 10373, 26484, 25, 26977, 2446, 3848, 319, 2116, 13, 30281, 1950, 12846, 1366, 7587]",0.5,290,ml_signal,129,Dynamic method calls on self.handler suggest flexible data processing,,281,        ----------,"[220, 220, 220, 220, 220, 220, 220, 24200, 438]"
‚úÖ Best Practice: Use of __repr__ for unambiguous object representation,"[26486, 227, 6705, 19939, 25, 5765, 286, 11593, 260, 1050, 834, 329, 42053, 29709, 2134, 10552]",0.5,304,best_practice,126,Use of __repr__ for unambiguous object representation,,290,        Initialize the DatasetH,"[220, 220, 220, 220, 220, 220, 220, 20768, 1096, 262, 16092, 292, 316, 39]"
‚úÖ Best Practice: Using format method for string formatting,"[26486, 227, 6705, 19939, 25, 8554, 5794, 2446, 329, 4731, 33313]",1.0,304,best_practice,127,Using format method for string formatting,,304,,[]
üß† ML Signal: Accessing class name dynamically,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 1398, 1438, 32366]",0.5,317,ml_signal,130,Accessing class name dynamically,,304,        handler_kwargs : dict,"[220, 220, 220, 220, 220, 220, 220, 21360, 62, 46265, 22046, 1058, 8633]"
üß† ML Signal: Accessing instance attributes,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 4554, 12608]",0.5,340,ml_signal,131,Accessing instance attributes,,317,"            Config of DataHandler, which could include the following arguments:","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 17056, 286, 6060, 25060, 11, 543, 714, 2291, 262, 1708, 7159, 25]"
üß† ML Signal: Accessing instance attributes,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 4554, 12608]",0.5,363,ml_signal,131,Accessing instance attributes,,340,"            Config of DataHandler, which could include the following arguments:","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 17056, 286, 6060, 25060, 11, 543, 714, 2291, 262, 1708, 7159, 25]"
‚úÖ Best Practice: Docstring provides a clear explanation of the method's purpose and parameters,"[26486, 227, 6705, 19939, 25, 14432, 8841, 3769, 257, 1598, 7468, 286, 262, 2446, 338, 4007, 290, 10007]",1.0,386,best_practice,131,Docstring provides a clear explanation of the method's purpose and parameters,,363,"            Config of DataHandler, which could include the following arguments:","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 17056, 286, 6060, 25060, 11, 543, 714, 2291, 262, 1708, 7159, 25]"
‚úÖ Best Practice: Checking for attribute existence with hasattr is a safe way to handle optional attributes,"[26486, 227, 6705, 19939, 25, 39432, 329, 11688, 6224, 351, 468, 35226, 318, 257, 3338, 835, 284, 5412, 11902, 12608]",0.5,418,best_practice,139,Checking for attribute existence with hasattr is a safe way to handle optional attributes,,386,                Config of segments which is same as 'segments' in self.__init__,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 17056, 286, 17894, 543, 318, 976, 355, 705, 325, 11726, 6, 287, 2116, 13, 834, 15003, 834]"
üß† ML Signal: Usage of dynamic keyword arguments with **kwargs,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 8925, 21179, 7159, 351, 12429, 46265, 22046]",0.5,426,ml_signal,141,Usage of dynamic keyword arguments with **kwargs,,418,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
üß† ML Signal: Usage of dynamic keyword arguments with **kwargs,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 8925, 21179, 7159, 351, 12429, 46265, 22046]",0.5,442,ml_signal,142,Usage of dynamic keyword arguments with **kwargs,,426,        if handler_kwargs is not None:,"[220, 220, 220, 220, 220, 220, 220, 611, 21360, 62, 46265, 22046, 318, 407, 6045, 25]"
‚úÖ Best Practice: Docstring provides clear explanation of parameters and return types,"[26486, 227, 6705, 19939, 25, 14432, 8841, 3769, 1598, 7468, 286, 10007, 290, 1441, 3858]",1.0,450,best_practice,149,Docstring provides clear explanation of parameters and return types,,442,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
üß† ML Signal: Usage of isinstance to handle different types of 'segments',"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 318, 39098, 284, 5412, 1180, 3858, 286, 705, 325, 11726, 6]",0.5,485,ml_signal,181,Usage of isinstance to handle different types of 'segments',,450,"            return self.handler.fetch(slc, **kwargs, **self.fetch_kwargs)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1441, 2116, 13, 30281, 13, 69, 7569, 7, 6649, 66, 11, 12429, 46265, 22046, 11, 12429, 944, 13, 69, 7569, 62, 46265, 22046, 8]"
üß† ML Signal: Handling of list or tuple types for 'segments',"[8582, 100, 254, 10373, 26484, 25, 49500, 286, 1351, 393, 46545, 3858, 329, 705, 325, 11726, 6]",0.5,485,ml_signal,184,Handling of list or tuple types for 'segments',,485,,[]
üß† ML Signal: Function usage pattern for calculating minimum time,"[8582, 100, 254, 10373, 26484, 25, 15553, 8748, 3912, 329, 26019, 5288, 640]",0.5,514,ml_signal,187,Function usage pattern for calculating minimum time,,485,"        segments: Union[List[Text], Tuple[Text], Text, slice, pd.Index],","[220, 220, 220, 220, 220, 220, 220, 17894, 25, 4479, 58, 8053, 58, 8206, 4357, 309, 29291, 58, 8206, 4357, 8255, 11, 16416, 11, 279, 67, 13, 15732, 4357]"
"üß† ML Signal: Function uses a lambda for comparison, indicating custom behavior","[8582, 100, 254, 10373, 26484, 25, 15553, 3544, 257, 37456, 329, 7208, 11, 12739, 2183, 4069]",0.5,525,ml_signal,190,"Function uses a lambda for comparison, indicating custom behavior",,514,"        **kwargs,","[220, 220, 220, 220, 220, 220, 220, 12429, 46265, 22046, 11]"
‚úÖ Best Practice: Use of type hints for function parameters and return type can improve code readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5765, 286, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 460, 2987, 2438, 1100, 1799, 290, 5529, 1799, 13]",1.0,533,best_practice,192,Use of type hints for function parameters and return type can improve code readability and maintainability.,,525,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
‚úÖ Best Practice: Initializing candidate to None is a clear way to handle the absence of a valid candidate initially.,"[26486, 227, 6705, 19939, 25, 20768, 2890, 4540, 284, 6045, 318, 257, 1598, 835, 284, 5412, 262, 8889, 286, 257, 4938, 4540, 7317, 13]",1.0,541,best_practice,195,Initializing candidate to None is a clear way to handle the absence of a valid candidate initially.,,533,        Parameters,"[220, 220, 220, 220, 220, 220, 220, 40117]"
üß† ML Signal: Iterating over dictionary items is a common pattern that can be used to train models on dictionary usage.,"[8582, 100, 254, 10373, 26484, 25, 40806, 803, 625, 22155, 3709, 318, 257, 2219, 3912, 326, 460, 307, 973, 284, 4512, 4981, 319, 22155, 8748, 13]",1.0,565,ml_signal,197,Iterating over dictionary items is a common pattern that can be used to train models on dictionary usage.,,541,"        segments : Union[List[Text], Tuple[Text], Text, slice]","[220, 220, 220, 220, 220, 220, 220, 17894, 1058, 4479, 58, 8053, 58, 8206, 4357, 309, 29291, 58, 8206, 4357, 8255, 11, 16416, 60]"
üß† ML Signal: Accessing list elements by index is a common pattern that can be used to train models on list usage.,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 1351, 4847, 416, 6376, 318, 257, 2219, 3912, 326, 460, 307, 973, 284, 4512, 4981, 319, 1351, 8748, 13]",1.0,581,ml_signal,199,Accessing list elements by index is a common pattern that can be used to train models on list usage.,,565,            Here are some examples:,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 3423, 389, 617, 6096, 25]"
‚ö†Ô∏è SAST Risk (Low): Returning None immediately if point is None might lead to unexpected behavior if not handled by the caller.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 42882, 6045, 3393, 611, 966, 318, 6045, 1244, 1085, 284, 10059, 4069, 611, 407, 12118, 416, 262, 24955, 13]",1.0,596,sast_risk,201,Returning None immediately if point is None might lead to unexpected behavior if not handled by the caller.,Low,581,            - 'train',"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 532, 705, 27432, 6]"
‚úÖ Best Practice: Using elif after an if return statement improves readability by clearly separating different conditions.,"[26486, 227, 6705, 19939, 25, 8554, 1288, 361, 706, 281, 611, 1441, 2643, 19575, 1100, 1799, 416, 4084, 27259, 1180, 3403, 13]",1.0,614,best_practice,203,Using elif after an if return statement improves readability by clearly separating different conditions.,,596,"            - ['train', 'valid']","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 532, 37250, 27432, 3256, 705, 12102, 20520]"
"üß† ML Signal: Use of numpy and pandas for data manipulation, common in data science and ML workflows","[8582, 100, 254, 10373, 26484, 25, 5765, 286, 299, 32152, 290, 19798, 292, 329, 1366, 17512, 11, 2219, 287, 1366, 3783, 290, 10373, 670, 44041]",0.5,648,ml_signal,252,"Use of numpy and pandas for data manipulation, common in data science and ML workflows",,614,"        return DatasetH._get_extrema(segments, 0, (lambda a, b: a > b))","[220, 220, 220, 220, 220, 220, 220, 1441, 16092, 292, 316, 39, 13557, 1136, 62, 2302, 260, 2611, 7, 325, 11726, 11, 657, 11, 357, 50033, 257, 11, 275, 25, 257, 1875, 275, 4008]"
‚úÖ Best Practice: Type annotations for class attributes improve code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 37647, 329, 1398, 12608, 2987, 2438, 1100, 1799, 290, 5529, 1799]",1.0,648,best_practice,253,Type annotations for class attributes improve code readability and maintainability,,648,,[]
"üß† ML Signal: Use of pandas MultiIndex, indicating hierarchical data structure, common in time-series analysis","[8582, 100, 254, 10373, 26484, 25, 5765, 286, 19798, 292, 15237, 15732, 11, 12739, 38958, 1366, 4645, 11, 2219, 287, 640, 12, 25076, 3781]",0.5,661,ml_signal,255,"Use of pandas MultiIndex, indicating hierarchical data structure, common in time-series analysis",,648,    def get_max_time(segments):,"[220, 220, 220, 825, 651, 62, 9806, 62, 2435, 7, 325, 11726, 2599]"
üß† ML Signal: Use of numpy arrays for efficient data indexing and manipulation,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 299, 32152, 26515, 329, 6942, 1366, 6376, 278, 290, 17512]",0.5,695,ml_signal,256,Use of numpy arrays for efficient data indexing and manipulation,,661,"        return DatasetH._get_extrema(segments, 1, (lambda a, b: a < b))","[220, 220, 220, 220, 220, 220, 220, 1441, 16092, 292, 316, 39, 13557, 1136, 62, 2302, 260, 2611, 7, 325, 11726, 11, 352, 11, 357, 50033, 257, 11, 275, 25, 257, 1279, 275, 4008]"
üß† ML Signal: Use of pandas DataFrame for structured data storage and manipulation,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 19798, 292, 6060, 19778, 329, 20793, 1366, 6143, 290, 17512]",0.5,729,ml_signal,256,Use of pandas DataFrame for structured data storage and manipulation,,695,"        return DatasetH._get_extrema(segments, 1, (lambda a, b: a < b))","[220, 220, 220, 220, 220, 220, 220, 1441, 16092, 292, 316, 39, 13557, 1136, 62, 2302, 260, 2611, 7, 325, 11726, 11, 352, 11, 357, 50033, 257, 11, 275, 25, 257, 1279, 275, 4008]"
‚ö†Ô∏è SAST Risk (Low): Lack of error handling for get_level_index function,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 38289, 286, 4049, 9041, 329, 651, 62, 5715, 62, 9630, 2163]",0.5,777,sast_risk,297,Lack of error handling for get_level_index function,Low,729,"                By leveraging this data charactoristics to speed up querying, the multi-index of data_arr is rearranged in (instrument, datetime) order","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2750, 42389, 428, 1366, 1543, 273, 3969, 284, 2866, 510, 42517, 1112, 11, 262, 5021, 12, 9630, 286, 1366, 62, 3258, 318, 37825, 5102, 287, 357, 259, 43872, 11, 4818, 8079, 8, 1502]"
‚úÖ Best Practice: Use of swaplevel and sort_index for data organization,"[26486, 227, 6705, 19939, 25, 5765, 286, 16075, 5715, 290, 3297, 62, 9630, 329, 1366, 4009]",0.5,807,best_practice,299,Use of swaplevel and sort_index for data organization,,777,"            data_index: pd.MultiIndex with index order <instrument, datetime>","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1366, 62, 9630, 25, 279, 67, 13, 29800, 15732, 351, 6376, 1502, 1279, 259, 43872, 11, 4818, 8079, 29]"
‚ö†Ô∏è SAST Risk (Low): Inplace operation on data may lead to unexpected side effects,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 554, 5372, 4905, 319, 1366, 743, 1085, 284, 10059, 1735, 3048]",1.0,827,sast_risk,302,Inplace operation on data may lead to unexpected side effects,Low,807,            idx_map: np.ndarray,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 8899, 25, 45941, 13, 358, 18747]"
üß† ML Signal: Conversion of DataFrame to numpy array,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 6060, 19778, 284, 299, 32152, 7177]",1.0,887,ml_signal,306,Conversion of DataFrame to numpy array,,827,"                    2) some data are excluded by `flt_data` (e.g. no <X, y> sample pair for that index). but they are still used in time-series in X","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 362, 8, 617, 1366, 389, 15009, 416, 4600, 69, 2528, 62, 7890, 63, 357, 68, 13, 70, 13, 645, 1279, 55, 11, 331, 29, 6291, 5166, 329, 326, 6376, 737, 475, 484, 389, 991, 973, 287, 640, 12, 25076, 287, 1395]"
‚úÖ Best Practice: Use of np.append to add a row of NaNs,"[26486, 227, 6705, 19939, 25, 5765, 286, 45941, 13, 33295, 284, 751, 257, 5752, 286, 11013, 47503]",0.5,917,best_practice,311,Use of np.append to add a row of NaNs,,887,"                       [  1,   0],","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 685, 220, 352, 11, 220, 220, 657, 4357]"
üß† ML Signal: Building index for data,"[8582, 100, 254, 10373, 26484, 25, 11819, 6376, 329, 1366]",1.0,917,ml_signal,317,Building index for data,,917,,[]
‚úÖ Best Practice: Use of deepcopy to avoid modifying original data,"[26486, 227, 6705, 19939, 25, 5765, 286, 2769, 30073, 284, 3368, 30620, 2656, 1366]",0.5,938,best_practice,319,Use of deepcopy to avoid modifying original data,,917,            idx_df: pd.DataFrame,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 7568, 25, 279, 67, 13, 6601, 19778]"
‚ö†Ô∏è SAST Risk (Low): Lack of error handling for DataFrame column length check,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 38289, 286, 4049, 9041, 329, 6060, 19778, 5721, 4129, 2198]",0.5,938,sast_risk,323,Lack of error handling for DataFrame column length check,Low,938,,[]
‚úÖ Best Practice: Use of swaplevel and reindex for data alignment,"[26486, 227, 6705, 19939, 25, 5765, 286, 16075, 5715, 290, 302, 9630, 329, 1366, 19114]",0.5,1006,best_practice,327,Use of swaplevel and reindex for data alignment,,938,                    2017-01-04        1      243      474      718      NaN      975  ...,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3023, 220, 220, 220, 220, 220, 220, 220, 352, 220, 220, 220, 220, 220, 35989, 220, 220, 220, 220, 220, 604, 4524, 220, 220, 220, 220, 220, 767, 1507, 220, 220, 220, 220, 220, 11013, 45, 220, 220, 220, 220, 220, 860, 2425, 220, 2644]"
üß† ML Signal: Filtering index map based on flt_data,"[8582, 100, 254, 10373, 26484, 25, 7066, 20212, 6376, 3975, 1912, 319, 781, 83, 62, 7890]",1.0,1006,ml_signal,330,Filtering index map based on flt_data,,1006,,[]
üß† ML Signal: Conversion of index map to array,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 6376, 3975, 284, 7177]",1.0,1006,ml_signal,330,Conversion of index map to array,,1006,,[]
üß† ML Signal: Slicing index map and data index based on start and end,"[8582, 100, 254, 10373, 26484, 25, 311, 677, 278, 6376, 3975, 290, 1366, 6376, 1912, 319, 923, 290, 886]",1.0,1010,ml_signal,335,Slicing index map and data index based on start and end,,1006,"    """"""","[220, 220, 220, 37227]"
‚úÖ Best Practice: Use of np.array with dtype for consistent data type,"[26486, 227, 6705, 19939, 25, 5765, 286, 45941, 13, 18747, 351, 288, 4906, 329, 6414, 1366, 2099]",0.5,1022,best_practice,340,Use of np.array with dtype for consistent data type,,1010,    idx_map: np.ndarray,"[220, 220, 220, 4686, 87, 62, 8899, 25, 45941, 13, 358, 18747]"
‚úÖ Best Practice: Deleting unused data to free memory,"[26486, 227, 6705, 19939, 25, 42226, 889, 21958, 1366, 284, 1479, 4088]",0.5,1035,best_practice,341,Deleting unused data to free memory,,1022,    idx_df: pd.DataFrame,"[220, 220, 220, 4686, 87, 62, 7568, 25, 279, 67, 13, 6601, 19778]"
‚ö†Ô∏è SAST Risk (Low): Use of assert for input validation can be disabled with optimization flags,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 5765, 286, 6818, 329, 5128, 21201, 460, 307, 10058, 351, 23989, 9701]",1.0,1056,sast_risk,337,Use of assert for input validation can be disabled with optimization flags,Low,1035,    # Please refer to the docstring of TSDataSampler for the definition of following attributes,"[220, 220, 220, 1303, 4222, 3522, 284, 262, 2205, 8841, 286, 26136, 6601, 16305, 20053, 329, 262, 6770, 286, 1708, 12608]"
‚úÖ Best Practice: Consider adding error handling for potential exceptions in slice_locs,"[26486, 227, 6705, 19939, 25, 12642, 4375, 4049, 9041, 329, 2785, 13269, 287, 16416, 62, 17946, 82]",1.0,1069,best_practice,341,Consider adding error handling for potential exceptions in slice_locs,,1056,    idx_df: pd.DataFrame,"[220, 220, 220, 4686, 87, 62, 7568, 25, 279, 67, 13, 6601, 19778]"
‚úÖ Best Practice: Use descriptive variable names for better readability,"[26486, 227, 6705, 19939, 25, 5765, 35644, 7885, 3891, 329, 1365, 1100, 1799]",1.0,1069,best_practice,342,Use descriptive variable names for better readability,,1069,,[]
"üß† ML Signal: Returns a filtered subset of data, indicating a pattern of data slicing","[8582, 100, 254, 10373, 26484, 25, 16409, 257, 29083, 24637, 286, 1366, 11, 12739, 257, 3912, 286, 1366, 49289]",0.5,1084,ml_signal,345,"Returns a filtered subset of data, indicating a pattern of data slicing",,1069,"        data: pd.DataFrame,","[220, 220, 220, 220, 220, 220, 220, 1366, 25, 279, 67, 13, 6601, 19778, 11]"
üß† ML Signal: Use of numpy data types and functions,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 299, 32152, 1366, 3858, 290, 5499]",1.0,1099,ml_signal,345,Use of numpy data types and functions,,1084,"        data: pd.DataFrame,","[220, 220, 220, 220, 220, 220, 220, 1366, 25, 279, 67, 13, 6601, 19778, 11]"
‚úÖ Best Practice: Use of numpy's iinfo to determine max value for dtype,"[26486, 227, 6705, 19939, 25, 5765, 286, 299, 32152, 338, 1312, 10951, 284, 5004, 3509, 1988, 329, 288, 4906]",1.0,1108,best_practice,347,Use of numpy's iinfo to determine max value for dtype,,1099,"        end,","[220, 220, 220, 220, 220, 220, 220, 886, 11]"
üß† ML Signal: Use of dictionary keys to determine range,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 22155, 8251, 284, 5004, 2837]",1.0,1125,ml_signal,349,Use of dictionary keys to determine range,,1108,"        fillna_type: str = ""none"",","[220, 220, 220, 220, 220, 220, 220, 6070, 2616, 62, 4906, 25, 965, 796, 366, 23108, 1600]"
üß† ML Signal: Use of dictionary get method with default value,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 22155, 651, 2446, 351, 4277, 1988]",1.0,1129,ml_signal,352,Use of dictionary get method with default value,,1125,    ):,"[220, 220, 220, 15179]"
üß† ML Signal: Conversion of list to numpy array,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 1351, 284, 299, 32152, 7177]",1.0,1129,ml_signal,355,Conversion of list to numpy array,,1129,,[]
‚úÖ Best Practice: Initialize variables at the start of the function for clarity.,"[26486, 227, 6705, 19939, 25, 20768, 1096, 9633, 379, 262, 923, 286, 262, 2163, 329, 16287, 13]",1.0,1129,best_practice,355,Initialize variables at the start of the function for clarity.,,1129,,[]
‚úÖ Best Practice: Use descriptive variable names for better readability.,"[26486, 227, 6705, 19939, 25, 5765, 35644, 7885, 3891, 329, 1365, 1100, 1799, 13]",0.5,1158,best_practice,359,Use descriptive variable names for better readability.,,1129,"            The raw tabular data whose index order is <""datetime"", ""instrument"">","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 383, 8246, 7400, 934, 1366, 3025, 6376, 1502, 318, 1279, 1, 19608, 8079, 1600, 366, 259, 43872, 5320]"
üß† ML Signal: Pattern of filtering and mapping data.,"[8582, 100, 254, 10373, 26484, 25, 23939, 286, 25431, 290, 16855, 1366, 13]",0.5,1174,ml_signal,361,Pattern of filtering and mapping data.,,1158,            The indexable start time,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 383, 6376, 540, 923, 640]"
"üß† ML Signal: Method that returns an index, indicating data manipulation or access pattern","[8582, 100, 254, 10373, 26484, 25, 11789, 326, 5860, 281, 6376, 11, 12739, 1366, 17512, 393, 1895, 3912]",0.5,1202,ml_signal,367,"Method that returns an index, indicating data manipulation or access pattern",,1174,            How will qlib handle the sample if there is on sample in a specific date.,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1374, 481, 10662, 8019, 5412, 262, 6291, 611, 612, 318, 319, 6291, 287, 257, 2176, 3128, 13]"
üß† ML Signal: Use of dynamic attribute setting,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 8925, 11688, 4634]",1.0,1222,ml_signal,369,Use of dynamic attribute setting,,1202,                fill with np.nan,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 6070, 351, 45941, 13, 12647]"
‚ö†Ô∏è SAST Risk (Medium): Potential for setting unexpected or unsafe attributes,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 31205, 2599, 32480, 329, 4634, 10059, 393, 21596, 12608]",1.0,1236,sast_risk,370,Potential for setting unexpected or unsafe attributes,Medium,1222,            ffill:,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 277, 20797, 25]"
‚úÖ Best Practice: Use of pd.Series with range and index for efficient index creation,"[26486, 227, 6705, 19939, 25, 5765, 286, 279, 67, 13, 27996, 351, 2837, 290, 6376, 329, 6942, 6376, 6282]",1.0,1262,best_practice,398,Use of pd.Series with range and index for efficient index creation,,1236,        # - append last line with full NaN for better performance in `__getitem__`,"[220, 220, 220, 220, 220, 220, 220, 1303, 532, 24443, 938, 1627, 351, 1336, 11013, 45, 329, 1365, 2854, 287, 4600, 834, 1136, 9186, 834, 63]"
üß† ML Signal: Use of lazy_sort_index indicates a custom sorting mechanism,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 16931, 62, 30619, 62, 9630, 9217, 257, 2183, 29407, 9030]",0.5,1279,ml_signal,400,Use of lazy_sort_index indicates a custom sorting mechanism,,1262,        self.data_arr = np.append(,"[220, 220, 220, 220, 220, 220, 220, 2116, 13, 7890, 62, 3258, 796, 45941, 13, 33295, 7]"
üß† ML Signal: Repeated use of lazy_sort_index suggests a pattern for data transformation,"[8582, 100, 254, 10373, 26484, 25, 30558, 515, 779, 286, 16931, 62, 30619, 62, 9630, 5644, 257, 3912, 329, 1366, 13389]",0.5,1322,ml_signal,402,Repeated use of lazy_sort_index suggests a pattern for data transformation,,1279,"            np.full((1, self.data_arr.shape[1]), np.nan, dtype=self.data_arr.dtype),","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 45941, 13, 12853, 19510, 16, 11, 2116, 13, 7890, 62, 3258, 13, 43358, 58, 16, 46570, 45941, 13, 12647, 11, 288, 4906, 28, 944, 13, 7890, 62, 3258, 13, 67, 4906, 828]"
"‚úÖ Best Practice: Enumerate is used for both index and value, improving readability","[26486, 227, 6705, 19939, 25, 2039, 6975, 378, 318, 973, 329, 1111, 6376, 290, 1988, 11, 10068, 1100, 1799]",0.5,1367,best_practice,405,"Enumerate is used for both index and value, improving readability",,1322,        self.nan_idx = len(self.data_arr) - 1  # The last line is all NaN; setting it to -1 can cause bug #1716,"[220, 220, 220, 220, 220, 220, 220, 2116, 13, 12647, 62, 312, 87, 796, 18896, 7, 944, 13, 7890, 62, 3258, 8, 532, 352, 220, 1303, 383, 938, 1627, 318, 477, 11013, 45, 26, 4634, 340, 284, 532, 16, 460, 2728, 5434, 1303, 1558, 1433]"
‚ö†Ô∏è SAST Risk (Low): Use of np.isnan without type checking could lead to unexpected behavior,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 5765, 286, 45941, 13, 271, 12647, 1231, 2099, 10627, 714, 1085, 284, 10059, 4069]",1.0,1391,sast_risk,408,Use of np.isnan without type checking could lead to unexpected behavior,Low,1367,        # The index of usable data is between start_idx and end_idx,"[220, 220, 220, 220, 220, 220, 220, 1303, 383, 6376, 286, 24284, 1366, 318, 1022, 923, 62, 312, 87, 290, 886, 62, 312, 87]"
‚úÖ Best Practice: Returning a tuple of DataFrame and dict for clear function output,"[26486, 227, 6705, 19939, 25, 42882, 257, 46545, 286, 6060, 19778, 290, 8633, 329, 1598, 2163, 5072]",1.0,1391,best_practice,411,Returning a tuple of DataFrame and dict for clear function output,,1391,,[]
"‚úÖ Best Practice: Method name 'empty' clearly indicates its purpose, improving readability.","[26486, 227, 6705, 19939, 25, 11789, 1438, 705, 28920, 6, 4084, 9217, 663, 4007, 11, 10068, 1100, 1799, 13]",1.0,1415,best_practice,408,"Method name 'empty' clearly indicates its purpose, improving readability.",,1391,        # The index of usable data is between start_idx and end_idx,"[220, 220, 220, 220, 220, 220, 220, 1303, 383, 6376, 286, 24284, 1366, 318, 1022, 923, 62, 312, 87, 290, 886, 62, 312, 87]"
‚úÖ Best Practice: Using 'len(self) == 0' is a clear and efficient way to check for emptiness.,"[26486, 227, 6705, 19939, 25, 8554, 705, 11925, 7, 944, 8, 6624, 657, 6, 318, 257, 1598, 290, 6942, 835, 284, 2198, 329, 49333, 13]",0.5,1437,best_practice,410,Using 'len(self) == 0' is a clear and efficient way to check for emptiness.,,1415,        self.data_index = deepcopy(self.data.index),"[220, 220, 220, 220, 220, 220, 220, 2116, 13, 7890, 62, 9630, 796, 2769, 30073, 7, 944, 13, 7890, 13, 9630, 8]"
‚úÖ Best Practice: Use of max function to ensure non-negative index,"[26486, 227, 6705, 19939, 25, 5765, 286, 3509, 2163, 284, 4155, 1729, 12, 31591, 6376]",1.0,1472,best_practice,424,Use of max function to ensure non-negative index,,1437,"        self.idx_map, self.data_index = self.slice_idx_map_and_data_index(","[220, 220, 220, 220, 220, 220, 220, 2116, 13, 312, 87, 62, 8899, 11, 2116, 13, 7890, 62, 9630, 796, 2116, 13, 48369, 62, 312, 87, 62, 8899, 62, 392, 62, 7890, 62, 9630, 7]"
‚úÖ Best Practice: Check and handle case where indices length is less than step_len,"[26486, 227, 6705, 19939, 25, 6822, 290, 5412, 1339, 810, 36525, 4129, 318, 1342, 621, 2239, 62, 11925]",1.0,1480,best_practice,426,Check and handle case where indices length is less than step_len,,1472,        ),"[220, 220, 220, 220, 220, 220, 220, 1267]"
‚úÖ Best Practice: Use of np.full to create an array of NaNs,"[26486, 227, 6705, 19939, 25, 5765, 286, 45941, 13, 12853, 284, 2251, 281, 7177, 286, 11013, 47503]",0.5,1520,best_practice,428,Use of np.full to create an array of NaNs,,1480,"        self.idx_arr = np.array(self.idx_df.values, dtype=np.float64)  # for better performance","[220, 220, 220, 220, 220, 220, 220, 2116, 13, 312, 87, 62, 3258, 796, 45941, 13, 18747, 7, 944, 13, 312, 87, 62, 7568, 13, 27160, 11, 288, 4906, 28, 37659, 13, 22468, 2414, 8, 220, 1303, 329, 1365, 2854]"
üß† ML Signal: Conditional logic based on self.fillna_type,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 2116, 13, 20797, 2616, 62, 4906]",0.5,1520,ml_signal,430,Conditional logic based on self.fillna_type,,1520,,[]
üß† ML Signal: Use of forward fill method,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 2651, 6070, 2446]",0.5,1537,ml_signal,432,Use of forward fill method,,1520,    def slice_idx_map_and_data_index(,"[220, 220, 220, 825, 16416, 62, 312, 87, 62, 8899, 62, 392, 62, 7890, 62, 9630, 7]"
üß† ML Signal: Use of forward and backward fill method,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 2651, 290, 19528, 6070, 2446]",0.5,1548,ml_signal,435,Use of forward and backward fill method,,1537,"        data_index,","[220, 220, 220, 220, 220, 220, 220, 1366, 62, 9630, 11]"
‚ö†Ô∏è SAST Risk (Low): Use of assert statement for runtime check,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 5765, 286, 6818, 2643, 329, 19124, 2198]",0.5,1559,sast_risk,435,Use of assert statement for runtime check,Low,1548,"        data_index,","[220, 220, 220, 220, 220, 220, 220, 1366, 62, 9630, 11]"
‚úÖ Best Practice: Docstring provides clear explanation of parameters and return values,"[26486, 227, 6705, 19939, 25, 14432, 8841, 3769, 1598, 7468, 286, 10007, 290, 1441, 3815]",1.0,1570,best_practice,435,Docstring provides clear explanation of parameters and return values,,1559,"        data_index,","[220, 220, 220, 220, 220, 220, 220, 1366, 62, 9630, 11]"
‚ö†Ô∏è SAST Risk (Low): Potential IndexError if self.idx_map is not properly validated,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 12901, 12331, 611, 2116, 13, 312, 87, 62, 8899, 318, 407, 6105, 31031]",1.0,1586,sast_risk,449,Potential IndexError if self.idx_map is not properly validated,Low,1570,    def idx_map2arr(idx_map):,"[220, 220, 220, 825, 4686, 87, 62, 8899, 17, 3258, 7, 312, 87, 62, 8899, 2599]"
‚ö†Ô∏è SAST Risk (Low): KeyError could expose internal state information,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 7383, 12331, 714, 15651, 5387, 1181, 1321]",1.0,1603,sast_risk,453,KeyError could expose internal state information,Low,1586,        # So we convert the dict into int array.,"[220, 220, 220, 220, 220, 220, 220, 1303, 1406, 356, 10385, 262, 8633, 656, 493, 7177, 13]"
üß† ML Signal: Use of pd.Timestamp indicates handling of date/time data,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 279, 67, 13, 14967, 27823, 9217, 9041, 286, 3128, 14, 2435, 1366]",1.0,1617,ml_signal,456,Use of pd.Timestamp indicates handling of date/time data,,1603,        dtype = np.int32,"[220, 220, 220, 220, 220, 220, 220, 288, 4906, 796, 45941, 13, 600, 2624]"
üß† ML Signal: Use of bisect methods indicates sorted data handling,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 47457, 478, 5050, 9217, 23243, 1366, 9041]",1.0,1617,ml_signal,459,Use of bisect methods indicates sorted data handling,,1617,,[]
‚ö†Ô∏è SAST Risk (Low): NotImplementedError could expose internal state information,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 1892, 3546, 1154, 12061, 12331, 714, 15651, 5387, 1181, 1321]",1.0,1629,sast_risk,461,NotImplementedError could expose internal state information,Low,1617,        arr_map = [],"[220, 220, 220, 220, 220, 220, 220, 5240, 62, 8899, 796, 17635]"
‚úÖ Best Practice: Docstring provides a clear explanation of the method's purpose and parameters.,"[26486, 227, 6705, 19939, 25, 14432, 8841, 3769, 257, 1598, 7468, 286, 262, 2446, 338, 4007, 290, 10007, 13]",1.0,1641,best_practice,461,Docstring provides a clear explanation of the method's purpose and parameters.,,1629,        arr_map = [],"[220, 220, 220, 220, 220, 220, 220, 5240, 62, 8899, 796, 17635]"
üß† ML Signal: Use of isinstance to check for multiple types.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 318, 39098, 284, 2198, 329, 3294, 3858, 13]",0.5,1655,ml_signal,472,Use of isinstance to check for multiple types.,,1641,            if exist:,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 611, 2152, 25]"
üß† ML Signal: Use of list comprehension for processing elements.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 1351, 35915, 329, 7587, 4847, 13]",0.5,1688,ml_signal,473,Use of list comprehension for processing elements.,,1655,                new_idx_map[idx] = idx_map[i],"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 649, 62, 312, 87, 62, 8899, 58, 312, 87, 60, 796, 4686, 87, 62, 8899, 58, 72, 60]"
üß† ML Signal: Use of numpy's concatenate function.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 299, 32152, 338, 1673, 36686, 378, 2163, 13]",0.5,1688,ml_signal,476,Use of numpy's concatenate function.,,1688,,[]
‚ö†Ô∏è SAST Risk (Low): Potential for data type conversion issues with nan_to_num and astype.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 1366, 2099, 11315, 2428, 351, 15709, 62, 1462, 62, 22510, 290, 6468, 2981, 13]",1.0,1715,sast_risk,480,Potential for data type conversion issues with nan_to_num and astype.,Low,1688,        - Special sampler will be used (e.g. user want to sample day by day),"[220, 220, 220, 220, 220, 220, 220, 532, 6093, 6072, 20053, 481, 307, 973, 357, 68, 13, 70, 13, 2836, 765, 284, 6291, 1110, 416, 1110, 8]"
üß† ML Signal: Use of numpy's diff and all functions for condition checking.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 299, 32152, 338, 814, 290, 477, 5499, 329, 4006, 10627, 13]",0.5,1750,ml_signal,482,Use of numpy's diff and all functions for condition checking.,,1715,        return self.data_index.swaplevel()  # to align the order of multiple index of original data received by __init__,"[220, 220, 220, 220, 220, 220, 220, 1441, 2116, 13, 7890, 62, 9630, 13, 2032, 499, 5715, 3419, 220, 1303, 284, 10548, 262, 1502, 286, 3294, 6376, 286, 2656, 1366, 2722, 416, 11593, 15003, 834]"
üß† ML Signal: Slicing numpy arrays.,"[8582, 100, 254, 10373, 26484, 25, 311, 677, 278, 299, 32152, 26515, 13]",0.5,1762,ml_signal,484,Slicing numpy arrays.,,1750,"    def config(self, **kwargs):","[220, 220, 220, 825, 4566, 7, 944, 11, 12429, 46265, 22046, 2599]"
üß† ML Signal: Reshaping numpy arrays.,"[8582, 100, 254, 10373, 26484, 25, 1874, 71, 9269, 299, 32152, 26515, 13]",0.5,1782,ml_signal,487,Reshaping numpy arrays.,,1762,"            setattr(self, k, v)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 900, 35226, 7, 944, 11, 479, 11, 410, 8]"
"‚úÖ Best Practice: Implementing __len__ allows the object to be used with len(), enhancing usability.","[26486, 227, 6705, 19939, 25, 48282, 278, 11593, 11925, 834, 3578, 262, 2134, 284, 307, 973, 351, 18896, 22784, 27496, 42863, 13]",1.0,1794,best_practice,484,"Implementing __len__ allows the object to be used with len(), enhancing usability.",,1782,"    def config(self, **kwargs):","[220, 220, 220, 825, 4566, 7, 944, 11, 12429, 46265, 22046, 2599]"
üß† ML Signal: Usage of len() on a custom object indicates the object is likely a collection or has a collection-like behavior.,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 18896, 3419, 319, 257, 2183, 2134, 9217, 262, 2134, 318, 1884, 257, 4947, 393, 468, 257, 4947, 12, 2339, 4069, 13]",1.0,1812,ml_signal,486,Usage of len() on a custom object indicates the object is likely a collection or has a collection-like behavior.,,1794,"        for k, v in kwargs.items():","[220, 220, 220, 220, 220, 220, 220, 329, 479, 11, 410, 287, 479, 86, 22046, 13, 23814, 33529]"
‚úÖ Best Practice: Use of a class attribute for default configuration,"[26486, 227, 6705, 19939, 25, 5765, 286, 257, 1398, 11688, 329, 4277, 8398]",1.0,1826,best_practice,500,Use of a class attribute for default configuration,,1812,            instrument datetime,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 8875, 4818, 8079]"
‚úÖ Best Practice: Use of default values for function parameters improves usability and reduces errors.,"[26486, 227, 6705, 19939, 25, 5765, 286, 4277, 3815, 329, 2163, 10007, 19575, 42863, 290, 12850, 8563, 13]",1.0,1875,best_practice,502,Use of default values for function parameters improves usability and reduces errors.,,1826,                       2017-01-04  0.884545 -0.110597 -1.059332 -0.030139,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3023, 220, 657, 13, 3459, 2231, 2231, 532, 15, 13, 11442, 43239, 532, 16, 13, 46712, 32148, 532, 15, 13, 3070, 486, 2670]"
‚úÖ Best Practice: Type hinting for function parameters improves code readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 329, 2163, 10007, 19575, 2438, 1100, 1799, 290, 5529, 1799, 13]",1.0,1924,best_practice,504,Type hinting for function parameters improves code readability and maintainability.,,1875,                       2017-01-06 -1.267771 -0.669685 -1.636733  0.295366,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3312, 532, 16, 13, 2075, 3324, 4869, 532, 15, 13, 36657, 35978, 532, 16, 13, 21, 27824, 2091, 220, 657, 13, 25710, 32459]"
‚úÖ Best Practice: Using super() to call the parent class's __init__ method ensures proper initialization.,"[26486, 227, 6705, 19939, 25, 8554, 2208, 3419, 284, 869, 262, 2560, 1398, 338, 11593, 15003, 834, 2446, 19047, 1774, 37588, 13]",1.0,1924,best_practice,506,Using super() to call the parent class's __init__ method ensures proper initialization.,,1924,,[]
üß† ML Signal: Use of **kwargs indicates a flexible function signature,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 12429, 46265, 22046, 9217, 257, 12846, 2163, 9877]",1.0,1924,ml_signal,506,Use of **kwargs indicates a flexible function signature,,1924,,[]
üß† ML Signal: Conditional logic based on presence of specific keys in kwargs,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 4931, 286, 2176, 8251, 287, 479, 86, 22046]",0.5,1932,ml_signal,508,Conditional logic based on presence of specific keys in kwargs,,1924,        -------,"[220, 220, 220, 220, 220, 220, 220, 35656]"
‚úÖ Best Practice: Call to superclass method ensures proper initialization,"[26486, 227, 6705, 19939, 25, 4889, 284, 2208, 4871, 2446, 19047, 1774, 37588]",0.5,1972,best_practice,510,Call to superclass method ensures proper initialization,,1932,"            1) the first element:  reshape the original index into a <datetime(row), instrument(column)> 2D dataframe","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 352, 8, 262, 717, 5002, 25, 220, 27179, 1758, 262, 2656, 6376, 656, 257, 1279, 19608, 8079, 7, 808, 828, 8875, 7, 28665, 8, 29, 362, 35, 1366, 14535]"
üß† ML Signal: Use of **kwargs indicates flexible function signature,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 12429, 46265, 22046, 9217, 12846, 2163, 9877]",1.0,2012,ml_signal,510,Use of **kwargs indicates flexible function signature,,1972,"            1) the first element:  reshape the original index into a <datetime(row), instrument(column)> 2D dataframe","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 352, 8, 262, 717, 5002, 25, 220, 27179, 1758, 262, 2656, 6376, 656, 257, 1279, 19608, 8079, 7, 808, 828, 8875, 7, 28665, 8, 29, 362, 35, 1366, 14535]"
üß† ML Signal: Fetching data using a handler pattern,"[8582, 100, 254, 10373, 26484, 25, 376, 7569, 278, 1366, 1262, 257, 21360, 3912]",0.5,2029,ml_signal,512,Fetching data using a handler pattern,,2012,                datetime,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4818, 8079]"
üß† ML Signal: Sorting a list of unique datetime values,"[8582, 100, 254, 10373, 26484, 25, 311, 24707, 257, 1351, 286, 3748, 4818, 8079, 3815]",0.5,2093,ml_signal,514,Sorting a list of unique datetime values,,2029,                2017-01-04        1      243      474      718      NaN      975  ...,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3023, 220, 220, 220, 220, 220, 220, 220, 352, 220, 220, 220, 220, 220, 35989, 220, 220, 220, 220, 220, 604, 4524, 220, 220, 220, 220, 220, 767, 1507, 220, 220, 220, 220, 220, 11013, 45, 220, 220, 220, 220, 220, 860, 2425, 220, 2644]"
‚úÖ Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5765, 286, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 19575, 2438, 1100, 1799, 290, 5529, 1799, 13]",1.0,2157,best_practice,514,Use of type hints for function parameters and return type improves code readability and maintainability.,,2093,                2017-01-04        1      243      474      718      NaN      975  ...,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3023, 220, 220, 220, 220, 220, 220, 220, 352, 220, 220, 220, 220, 220, 35989, 220, 220, 220, 220, 220, 604, 4524, 220, 220, 220, 220, 220, 767, 1507, 220, 220, 220, 220, 220, 11013, 45, 220, 220, 220, 220, 220, 860, 2425, 220, 2644]"
üß† ML Signal: Use of slicing and bisect operations indicates manipulation of ordered data.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 49289, 290, 47457, 478, 4560, 9217, 17512, 286, 6149, 1366, 13]",1.0,2220,ml_signal,516,Use of slicing and bisect operations indicates manipulation of ordered data.,,2157,                2017-01-06        3      245      476      720      NaN      977  ...,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 2177, 12, 486, 12, 3312, 220, 220, 220, 220, 220, 220, 220, 513, 220, 220, 220, 220, 220, 29637, 220, 220, 220, 220, 220, 604, 4304, 220, 220, 220, 220, 220, 26250, 220, 220, 220, 220, 220, 11013, 45, 220, 220, 220, 220, 220, 860, 3324, 220, 2644]"
üß† ML Signal: Use of bisect to find insertion point in a sorted list.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 47457, 478, 284, 1064, 36075, 966, 287, 257, 23243, 1351, 13]",1.0,2228,ml_signal,518,Use of bisect to find insertion point in a sorted list.,,2220,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
‚úÖ Best Practice: Use of max to ensure index does not go out of bounds.,"[26486, 227, 6705, 19939, 25, 5765, 286, 3509, 284, 4155, 6376, 857, 407, 467, 503, 286, 22303, 13]",1.0,2264,best_practice,520,Use of max to ensure index does not go out of bounds.,,2228,"        idx_df = pd.Series(range(data.shape[0]), index=data.index, dtype=object)","[220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 7568, 796, 279, 67, 13, 27996, 7, 9521, 7, 7890, 13, 43358, 58, 15, 46570, 6376, 28, 7890, 13, 9630, 11, 288, 4906, 28, 15252, 8]"
‚ö†Ô∏è SAST Risk (Low): Potential IndexError if cal is empty.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 12901, 12331, 611, 2386, 318, 6565, 13]",1.0,2290,sast_risk,521,Potential IndexError if cal is empty.,Low,2264,        idx_df = lazy_sort_index(idx_df.unstack()),"[220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 7568, 796, 16931, 62, 30619, 62, 9630, 7, 312, 87, 62, 7568, 13, 403, 25558, 28955]"
‚úÖ Best Practice: Returning a slice object maintains consistency with input type.,"[26486, 227, 6705, 19939, 25, 42882, 257, 16416, 2134, 16047, 15794, 351, 5128, 2099, 13]",0.5,2303,best_practice,525,Returning a slice object maintains consistency with input type.,,2290,        idx_map = {},"[220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 8899, 796, 23884]"
üß† ML Signal: Use of kwargs for flexible function arguments,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 479, 86, 22046, 329, 12846, 2163, 7159]",0.5,2316,ml_signal,525,Use of kwargs for flexible function arguments,,2303,        idx_map = {},"[220, 220, 220, 220, 220, 220, 220, 4686, 87, 62, 8899, 796, 23884]"
‚ö†Ô∏è SAST Risk (Low): Potential for unexpected behavior if slc is not a slice,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 10059, 4069, 611, 1017, 66, 318, 407, 257, 16416]",0.5,2343,sast_risk,528,Potential for unexpected behavior if slc is not a slice,Low,2316,                if not np.isnan(real_idx):,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 611, 407, 45941, 13, 271, 12647, 7, 5305, 62, 312, 87, 2599]"
‚úÖ Best Practice: Use of descriptive variable names like ext_slice,"[26486, 227, 6705, 19939, 25, 5765, 286, 35644, 7885, 3891, 588, 1070, 62, 48369]",0.5,2348,best_practice,532,Use of descriptive variable names like ext_slice,,2343,    @property,"[220, 220, 220, 2488, 26745]"
üß† ML Signal: Use of inheritance and method overriding,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 24155, 290, 2446, 44987]",0.5,2362,ml_signal,534,Use of inheritance and method overriding,,2348,        return len(self) == 0,"[220, 220, 220, 220, 220, 220, 220, 1441, 18896, 7, 944, 8, 6624, 657]"
‚úÖ Best Practice: Use of deepcopy to avoid side effects,"[26486, 227, 6705, 19939, 25, 5765, 286, 2769, 30073, 284, 3368, 1735, 3048]",0.5,2387,best_practice,536,Use of deepcopy to avoid side effects,,2362,"    def _get_indices(self, row: int, col: int) -> np.array:","[220, 220, 220, 825, 4808, 1136, 62, 521, 1063, 7, 944, 11, 5752, 25, 493, 11, 951, 25, 493, 8, 4613, 45941, 13, 18747, 25]"
üß† ML Signal: Conditional logic based on presence of optional parameters,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 4931, 286, 11902, 10007]",0.5,2387,ml_signal,539,Conditional logic based on presence of optional parameters,,2387,,[]
‚ö†Ô∏è SAST Risk (Low): Assertion without error handling,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 2195, 861, 295, 1231, 4049, 9041]",0.5,2387,sast_risk,539,Assertion without error handling,Low,2387,,[]
‚úÖ Best Practice: Use of named arguments for clarity,"[26486, 227, 6705, 19939, 25, 5765, 286, 3706, 7159, 329, 16287]",0.5,2395,best_practice,547,Use of named arguments for clarity,,2387,        Returns,"[220, 220, 220, 220, 220, 220, 220, 16409]"
‚úÖ Best Practice: Use of __all__ to define public API of the module,"[26486, 227, 6705, 19939, 25, 5765, 286, 11593, 439, 834, 284, 8160, 1171, 7824, 286, 262, 8265]",1.0,2403,best_practice,548,Use of __all__ to define public API of the module,,2395,        -------,"[220, 220, 220, 220, 220, 220, 220, 35656]"
