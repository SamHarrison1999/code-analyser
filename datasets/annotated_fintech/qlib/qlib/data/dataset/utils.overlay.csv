annotation,annotation_tokens,confidence,end_token,label,line,reason,severity,start_token,text,tokens
✅ Best Practice: Conditional imports with TYPE_CHECKING to avoid circular dependencies and reduce runtime overhead,"[26486, 227, 6705, 19939, 25, 9724, 1859, 17944, 351, 41876, 62, 50084, 2751, 284, 3368, 18620, 20086, 290, 4646, 19124, 16965]",0.5,6,best_practice,4,Conditional imports with TYPE_CHECKING to avoid circular dependencies and reduce runtime overhead,,0,import pandas as pd,"[11748, 19798, 292, 355, 279, 67]"
✅ Best Practice: TYPE_CHECKING import to prevent runtime import and improve performance,"[26486, 227, 6705, 19939, 25, 41876, 62, 50084, 2751, 1330, 284, 2948, 19124, 1330, 290, 2987, 2854]",0.5,6,best_practice,7,TYPE_CHECKING import to prevent runtime import and improve performance,,6,,[]
✅ Best Practice: Include type hints for function parameters and return type for better readability and maintainability,"[26486, 227, 6705, 19939, 25, 40348, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799]",1.0,6,best_practice,7,Include type hints for function parameters and return type for better readability and maintainability,,6,,[]
🧠 ML Signal: Checking the type of a variable to determine the code path,"[8582, 100, 254, 10373, 26484, 25, 39432, 262, 2099, 286, 257, 7885, 284, 5004, 262, 2438, 3108]",1.0,15,ml_signal,22,Checking the type of a variable to determine the code path,,6,        index level,"[220, 220, 220, 220, 220, 220, 220, 6376, 1241]"
🧠 ML Signal: Using DataFrame index names to find the index of a level,"[8582, 100, 254, 10373, 26484, 25, 8554, 6060, 19778, 6376, 3891, 284, 1064, 262, 6376, 286, 257, 1241]",1.0,19,ml_signal,25,Using DataFrame index names to find the index of a level,,15,    -------,"[220, 220, 220, 35656]"
"⚠️ SAST Risk (Low): Potential risk if the level is not found in the tuple, could raise a ValueError","[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 2526, 611, 262, 1241, 318, 407, 1043, 287, 262, 46545, 11, 714, 5298, 257, 11052, 12331]",1.0,33,sast_risk,27,"Potential risk if the level is not found in the tuple, could raise a ValueError",Low,19,        The level index in the multiple index,"[220, 220, 220, 220, 220, 220, 220, 383, 1241, 6376, 287, 262, 3294, 6376]"
🧠 ML Signal: Checking the type of a variable to determine the code path,"[8582, 100, 254, 10373, 26484, 25, 39432, 262, 2099, 286, 257, 7885, 284, 5004, 262, 2438, 3108]",1.0,42,ml_signal,30,Checking the type of a variable to determine the code path,,33,        try:,"[220, 220, 220, 220, 220, 220, 220, 1949, 25]"
⚠️ SAST Risk (Low): Using NotImplementedError for unsupported input types,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 8554, 1892, 3546, 1154, 12061, 12331, 329, 24222, 5128, 3858]",1.0,66,sast_risk,34,Using NotImplementedError for unsupported input types,Low,42,"            return (""datetime"", ""instrument"").index(level)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1441, 5855, 19608, 8079, 1600, 366, 259, 43872, 11074, 9630, 7, 5715, 8]"
✅ Best Practice: Consider adding type hints for the function parameters and return type for better readability and maintainability.,"[26486, 227, 6705, 19939, 25, 12642, 4375, 2099, 20269, 329, 262, 2163, 10007, 290, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799, 13]",0.5,75,best_practice,30,Consider adding type hints for the function parameters and return type for better readability and maintainability.,,66,        try:,"[220, 220, 220, 220, 220, 220, 220, 1949, 25]"
"⚠️ SAST Risk (Low): If `level` is None, it might lead to unexpected behavior. Consider validating input parameters.","[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 1002, 4600, 5715, 63, 318, 6045, 11, 340, 1244, 1085, 284, 10059, 4069, 13, 12642, 4938, 803, 5128, 10007, 13]",0.5,96,sast_risk,51,"If `level` is None, it might lead to unexpected behavior. Consider validating input parameters.",Low,75,    `fetch_df_by_index` is only responsible for get the right level,"[220, 220, 220, 4600, 69, 7569, 62, 7568, 62, 1525, 62, 9630, 63, 318, 691, 4497, 329, 651, 262, 826, 1241]"
✅ Best Practice: Use descriptive variable names for better readability.,"[26486, 227, 6705, 19939, 25, 5765, 35644, 7885, 3891, 329, 1365, 1100, 1799, 13]",1.0,114,best_practice,55,Use descriptive variable names for better readability.,,96,"    selector : Union[pd.Timestamp, slice, str, list]","[220, 220, 220, 31870, 1058, 4479, 58, 30094, 13, 14967, 27823, 11, 16416, 11, 965, 11, 1351, 60]"
✅ Best Practice: Import statements should be at the top of the file for better readability and maintainability.,"[26486, 227, 6705, 19939, 25, 17267, 6299, 815, 307, 379, 262, 1353, 286, 262, 2393, 329, 1365, 1100, 1799, 290, 5529, 1799, 13]",1.0,118,best_practice,63,Import statements should be at the top of the file for better readability and maintainability.,,114,"    """"""","[220, 220, 220, 37227]"
⚠️ SAST Risk (Low): Dynamic attribute access on DataFrame columns can lead to KeyError if col_set is not present.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 26977, 11688, 1895, 319, 6060, 19778, 15180, 460, 1085, 284, 7383, 12331, 611, 951, 62, 2617, 318, 407, 1944, 13]",0.5,138,sast_risk,65,Dynamic attribute access on DataFrame columns can lead to KeyError if col_set is not present.,Low,118,"    if level is None or isinstance(selector, pd.MultiIndex):","[220, 220, 220, 611, 1241, 318, 6045, 393, 318, 39098, 7, 19738, 273, 11, 279, 67, 13, 29800, 15732, 2599]"
⚠️ SAST Risk (Low): Dropping levels in a MultiIndex DataFrame can lead to data misinterpretation if not handled carefully.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 21045, 2105, 2974, 287, 257, 15237, 15732, 6060, 19778, 460, 1085, 284, 1366, 40882, 341, 611, 407, 12118, 7773, 13]",0.5,157,sast_risk,68,Dropping levels in a MultiIndex DataFrame can lead to data misinterpretation if not handled carefully.,Low,138,"    idx_slc = (selector, slice(None, None))","[220, 220, 220, 4686, 87, 62, 6649, 66, 796, 357, 19738, 273, 11, 16416, 7, 14202, 11, 6045, 4008]"
⚠️ SAST Risk (Low): Using loc with dynamic column selection can lead to KeyError if col_set is not present.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 8554, 1179, 351, 8925, 5721, 6356, 460, 1085, 284, 7383, 12331, 611, 951, 62, 2617, 318, 407, 1944, 13]",0.5,165,sast_risk,71,Using loc with dynamic column selection can lead to KeyError if col_set is not present.,Low,157,    if fetch_orig:,"[220, 220, 220, 611, 21207, 62, 11612, 25]"
✅ Best Practice: Include type hints for function parameters and return type for better readability and maintainability.,"[26486, 227, 6705, 19939, 25, 40348, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799, 13]",1.0,173,best_practice,71,Include type hints for function parameters and return type for better readability and maintainability.,,165,    if fetch_orig:,"[220, 220, 220, 611, 21207, 62, 11612, 25]"
⚠️ SAST Risk (Low): Assumes that the MultiIndex has exactly two levels without validation.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 2195, 8139, 326, 262, 15237, 15732, 468, 3446, 734, 2974, 1231, 21201, 13]",0.5,173,sast_risk,90,Assumes that the MultiIndex has exactly two levels without validation.,Low,173,,[]
🧠 ML Signal: Usage of swaplevel and sort_index indicates data manipulation patterns.,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 16075, 5715, 290, 3297, 62, 9630, 9217, 1366, 17512, 7572, 13]",0.5,215,ml_signal,92,Usage of swaplevel and sort_index indicates data manipulation patterns.,,173,"def convert_index_format(df: Union[pd.DataFrame, pd.Series], level: str = ""datetime"") -> Union[pd.DataFrame, pd.Series]:","[4299, 10385, 62, 9630, 62, 18982, 7, 7568, 25, 4479, 58, 30094, 13, 6601, 19778, 11, 279, 67, 13, 27996, 4357, 1241, 25, 965, 796, 366, 19608, 8079, 4943, 4613, 4479, 58, 30094, 13, 6601, 19778, 11, 279, 67, 13, 27996, 5974]"
✅ Best Practice: Add type hint for the return type in the function signature,"[26486, 227, 6705, 19939, 25, 3060, 2099, 9254, 329, 262, 1441, 2099, 287, 262, 2163, 9877]",0.5,257,best_practice,92,Add type hint for the return type in the function signature,,215,"def convert_index_format(df: Union[pd.DataFrame, pd.Series], level: str = ""datetime"") -> Union[pd.DataFrame, pd.Series]:","[4299, 10385, 62, 9630, 62, 18982, 7, 7568, 25, 4479, 58, 30094, 13, 6601, 19778, 11, 279, 67, 13, 27996, 4357, 1241, 25, 965, 796, 366, 19608, 8079, 4943, 4613, 4479, 58, 30094, 13, 6601, 19778, 11, 279, 67, 13, 27996, 5974]"
✅ Best Practice: Import statements should be at the top of the file,"[26486, 227, 6705, 19939, 25, 17267, 6299, 815, 307, 379, 262, 1353, 286, 262, 2393]",0.5,265,best_practice,105,Import statements should be at the top of the file,,257,"    level : str, optional","[220, 220, 220, 1241, 1058, 965, 11, 11902]"
🧠 ML Signal: Accessing nested dictionary keys,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 28376, 22155, 8251]",0.5,265,ml_signal,107,Accessing nested dictionary keys,,265,,[]
🧠 ML Signal: Conditional logic based on configuration presence,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 8398, 4931]",0.5,269,ml_signal,109,Conditional logic based on configuration presence,,265,    -------,"[220, 220, 220, 35656]"
🧠 ML Signal: Function call with specific argument types,"[8582, 100, 254, 10373, 26484, 25, 15553, 869, 351, 2176, 4578, 3858]",0.5,281,ml_signal,111,Function call with specific argument types,,269,        converted DataFrame/Series,"[220, 220, 220, 220, 220, 220, 220, 11513, 6060, 19778, 14, 27996]"
🧠 ML Signal: Modifying a dictionary in place,"[8582, 100, 254, 10373, 26484, 25, 3401, 4035, 257, 22155, 287, 1295]",0.5,293,ml_signal,111,Modifying a dictionary in place,,281,        converted DataFrame/Series,"[220, 220, 220, 220, 220, 220, 220, 11513, 6060, 19778, 14, 27996]"
⚠️ SAST Risk (Low): Raising a generic exception without additional context,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 7567, 1710, 257, 14276, 6631, 1231, 3224, 4732]",0.5,305,sast_risk,111,Raising a generic exception without additional context,Low,293,        converted DataFrame/Series,"[220, 220, 220, 220, 220, 220, 220, 11513, 6060, 19778, 14, 27996]"
