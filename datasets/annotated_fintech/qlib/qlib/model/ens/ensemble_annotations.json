[
  {
    "line": 4,
    "text": "\"\"\"",
    "annotation": "\u2705 Best Practice: Specify all imported symbols explicitly to avoid namespace pollution and improve readability.",
    "confidence": 0.5,
    "tokens": [
      37811
    ],
    "start_token": 0,
    "end_token": 1,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18291,
      1958,
      477,
      17392,
      14354,
      11777,
      284,
      3368,
      25745,
      12231,
      290,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Specify all imported symbols explicitly to avoid namespace pollution and improve readability."
  },
  {
    "line": 6,
    "text": "\"\"\"",
    "annotation": "\u2705 Best Practice: Importing pandas as pd is a common convention and improves code readability.",
    "confidence": 1.0,
    "tokens": [
      37811
    ],
    "start_token": 1,
    "end_token": 2,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      19798,
      292,
      355,
      279,
      67,
      318,
      257,
      2219,
      9831,
      290,
      19575,
      2438,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing pandas as pd is a common convention and improves code readability."
  },
  {
    "line": 8,
    "text": "from typing import Union",
    "annotation": "\u2705 Best Practice: Importing specific utilities from a module can improve code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      6738,
      19720,
      1330,
      4479
    ],
    "start_token": 2,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      20081,
      422,
      257,
      8265,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific utilities from a module can improve code readability and maintainability."
  },
  {
    "line": 9,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Importing specific functions from a module can improve code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 6,
    "end_token": 12,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      422,
      257,
      8265,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions from a module can improve code readability and maintainability."
  },
  {
    "line": 17,
    "text": "    For example: {Rollinga_b: object, Rollingb_c: object} -> object",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the class purpose and usage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1114,
      1672,
      25,
      1391,
      26869,
      278,
      64,
      62,
      65,
      25,
      2134,
      11,
      21567,
      65,
      62,
      66,
      25,
      2134,
      92,
      4613,
      2134
    ],
    "start_token": 12,
    "end_token": 36,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the class purpose and usage"
  },
  {
    "line": 17,
    "text": "    For example: {Rollinga_b: object, Rollingb_c: object} -> object",
    "annotation": "\u2705 Best Practice: Use of NotImplementedError to indicate an abstract method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1114,
      1672,
      25,
      1391,
      26869,
      278,
      64,
      62,
      65,
      25,
      2134,
      11,
      21567,
      65,
      62,
      66,
      25,
      2134,
      92,
      4613,
      2134
    ],
    "start_token": 36,
    "end_token": 60,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      284,
      7603,
      281,
      12531,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of NotImplementedError to indicate an abstract method"
  },
  {
    "line": 19,
    "text": "    When calling this class:",
    "annotation": "\ud83e\udde0 ML Signal: Use of NotImplementedError can indicate abstract methods or interfaces",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1649,
      4585,
      428,
      1398,
      25
    ],
    "start_token": 60,
    "end_token": 68,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      460,
      7603,
      12531,
      5050,
      393,
      20314
    ],
    "label": "ml_signal",
    "reason": "Use of NotImplementedError can indicate abstract methods or interfaces"
  },
  {
    "line": 32,
    "text": "class SingleKeyEnsemble(Ensemble):",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the class functionality and usage.",
    "confidence": 0.5,
    "tokens": [
      4871,
      14206,
      9218,
      4834,
      15140,
      7,
      4834,
      15140,
      2599
    ],
    "start_token": 68,
    "end_token": 77,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      11244,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the class functionality and usage."
  },
  {
    "line": 33,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: The class is designed to process dictionaries, which is a common data structure in ML pipelines.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 77,
    "end_token": 81,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      1398,
      318,
      3562,
      284,
      1429,
      48589,
      3166,
      11,
      543,
      318,
      257,
      2219,
      1366,
      4645,
      287,
      10373,
      31108,
      13
    ],
    "label": "ml_signal",
    "reason": "The class is designed to process dictionaries, which is a common data structure in ML pipelines."
  },
  {
    "line": 32,
    "text": "class SingleKeyEnsemble(Ensemble):",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and helps with static analysis.",
    "confidence": 1.0,
    "tokens": [
      4871,
      14206,
      9218,
      4834,
      15140,
      7,
      4834,
      15140,
      2599
    ],
    "start_token": 81,
    "end_token": 90,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5419,
      351,
      9037,
      3781,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and helps with static analysis."
  },
  {
    "line": 34,
    "text": "    Extract the object if there is only one key and value in the dict. Make the result more readable.",
    "annotation": "\u2705 Best Practice: Checking the type of ensemble_dict ensures the function behaves correctly.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      29677,
      262,
      2134,
      611,
      612,
      318,
      691,
      530,
      1994,
      290,
      1988,
      287,
      262,
      8633,
      13,
      6889,
      262,
      1255,
      517,
      31744,
      13
    ],
    "start_token": 90,
    "end_token": 114,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      262,
      2099,
      286,
      34549,
      62,
      11600,
      19047,
      262,
      2163,
      39341,
      9380,
      13
    ],
    "label": "best_practice",
    "reason": "Checking the type of ensemble_dict ensures the function behaves correctly."
  },
  {
    "line": 39,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over dictionary items is a common pattern.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 114,
    "end_token": 114,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      22155,
      3709,
      318,
      257,
      2219,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over dictionary items is a common pattern."
  },
  {
    "line": 41,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Recursive function calls can indicate complex data processing.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 114,
    "end_token": 114,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3311,
      30753,
      2163,
      3848,
      460,
      7603,
      3716,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Recursive function calls can indicate complex data processing."
  },
  {
    "line": 44,
    "text": "        Args:",
    "annotation": "\ud83e\udde0 ML Signal: Converting dictionary keys to a list is a common operation.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      943,
      14542,
      25
    ],
    "start_token": 114,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      22155,
      8251,
      284,
      257,
      1351,
      318,
      257,
      2219,
      4905,
      13
    ],
    "label": "ml_signal",
    "reason": "Converting dictionary keys to a list is a common operation."
  },
  {
    "line": 45,
    "text": "            ensemble_dict (dict): the dict. The key of the dict will be ignored.",
    "annotation": "\u2705 Best Practice: Checking the length of keys before accessing ensures safe operations.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      34549,
      62,
      11600,
      357,
      11600,
      2599,
      262,
      8633,
      13,
      383,
      1994,
      286,
      262,
      8633,
      481,
      307,
      9514,
      13
    ],
    "start_token": 124,
    "end_token": 153,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      262,
      4129,
      286,
      8251,
      878,
      22534,
      19047,
      3338,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Checking the length of keys before accessing ensures safe operations."
  },
  {
    "line": 44,
    "text": "        Args:",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the class functionality and usage.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      943,
      14542,
      25
    ],
    "start_token": 153,
    "end_token": 163,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1398,
      11244,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the class functionality and usage."
  },
  {
    "line": 54,
    "text": "        if recursion:",
    "annotation": "\u2705 Best Practice: Type hinting for the return type improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      664,
      24197,
      25
    ],
    "start_token": 163,
    "end_token": 174,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      262,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for the return type improves code readability and maintainability"
  },
  {
    "line": 56,
    "text": "            for k, v in ensemble_dict.items():",
    "annotation": "\ud83e\udde0 ML Signal: Logging usage pattern can be used to identify how often and where logging is implemented",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      479,
      11,
      410,
      287,
      34549,
      62,
      11600,
      13,
      23814,
      33529
    ],
    "start_token": 174,
    "end_token": 196,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      8748,
      3912,
      460,
      307,
      973,
      284,
      5911,
      703,
      1690,
      290,
      810,
      18931,
      318,
      9177
    ],
    "label": "ml_signal",
    "reason": "Logging usage pattern can be used to identify how often and where logging is implemented"
  },
  {
    "line": 58,
    "text": "            ensemble_dict = tmp_dict",
    "annotation": "\ud83e\udde0 ML Signal: Converting dictionary values to a list is a common pattern for processing collections",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      34549,
      62,
      11600,
      796,
      45218,
      62,
      11600
    ],
    "start_token": 196,
    "end_token": 214,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      35602,
      889,
      22155,
      3815,
      284,
      257,
      1351,
      318,
      257,
      2219,
      3912,
      329,
      7587,
      17268
    ],
    "label": "ml_signal",
    "reason": "Converting dictionary values to a list is a common pattern for processing collections"
  },
  {
    "line": 60,
    "text": "        if len(keys) == 1:",
    "annotation": "\u2705 Best Practice: Using a lambda function for sorting improves code readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      18896,
      7,
      13083,
      8,
      6624,
      352,
      25
    ],
    "start_token": 214,
    "end_token": 229,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      37456,
      2163,
      329,
      29407,
      19575,
      2438,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Using a lambda function for sorting improves code readability"
  },
  {
    "line": 62,
    "text": "        return ensemble_dict",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): pd.concat can raise exceptions if the dataframes have incompatible indices",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      34549,
      62,
      11600
    ],
    "start_token": 229,
    "end_token": 240,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      279,
      67,
      13,
      1102,
      9246,
      460,
      5298,
      13269,
      611,
      262,
      1366,
      37805,
      423,
      27294,
      36525
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "pd.concat can raise exceptions if the dataframes have incompatible indices"
  },
  {
    "line": 63,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Removing duplicates without checking the reason for duplication might lead to data loss",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 240,
    "end_token": 240,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      3982,
      5165,
      14184,
      16856,
      1231,
      10627,
      262,
      1738,
      329,
      50124,
      1244,
      1085,
      284,
      1366,
      2994
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Removing duplicates without checking the reason for duplication might lead to data loss"
  },
  {
    "line": 63,
    "text": "",
    "annotation": "\u2705 Best Practice: Sorting the index ensures that the DataFrame is in a predictable order",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 240,
    "end_token": 240,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      262,
      6376,
      19047,
      326,
      262,
      6060,
      19778,
      318,
      287,
      257,
      20039,
      1502
    ],
    "label": "best_practice",
    "reason": "Sorting the index ensures that the DataFrame is in a predictable order"
  },
  {
    "line": 62,
    "text": "        return ensemble_dict",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear explanation of the class purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      34549,
      62,
      11600
    ],
    "start_token": 240,
    "end_token": 251,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear explanation of the class purpose and usage."
  },
  {
    "line": 74,
    "text": "            The key of the dict will be ignored.",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the method's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      1994,
      286,
      262,
      8633,
      481,
      307,
      9514,
      13
    ],
    "start_token": 251,
    "end_token": 271,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2446,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the method's purpose and usage."
  },
  {
    "line": 74,
    "text": "            The key of the dict will be ignored.",
    "annotation": "\u2705 Best Practice: Type hinting for `ensemble_dict` and return type improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      1994,
      286,
      262,
      8633,
      481,
      307,
      9514,
      13
    ],
    "start_token": 271,
    "end_token": 291,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      4600,
      1072,
      11306,
      62,
      11600,
      63,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for `ensemble_dict` and return type improves code readability and maintainability."
  },
  {
    "line": 88,
    "text": "        return artifact",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): No validation of `ensemble_dict` structure or content, which may lead to runtime errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      24127
    ],
    "start_token": 291,
    "end_token": 300,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1400,
      21201,
      286,
      4600,
      1072,
      11306,
      62,
      11600,
      63,
      4645,
      393,
      2695,
      11,
      543,
      743,
      1085,
      284,
      19124,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "No validation of `ensemble_dict` structure or content, which may lead to runtime errors."
  },
  {
    "line": 90,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Logging the keys of the ensemble_dict can be useful for debugging and monitoring.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 300,
    "end_token": 300,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      2667,
      262,
      8251,
      286,
      262,
      34549,
      62,
      11600,
      460,
      307,
      4465,
      329,
      28769,
      290,
      9904,
      13
    ],
    "label": "ml_signal",
    "reason": "Logging the keys of the ensemble_dict can be useful for debugging and monitoring."
  },
  {
    "line": 93,
    "text": "    Average and standardize a dict of same shape dataframe like `prediction` or `IC` into an ensemble.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes all values in `ensemble_dict` are compatible DataFrames for concatenation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      13475,
      290,
      3210,
      1096,
      257,
      8633,
      286,
      976,
      5485,
      1366,
      14535,
      588,
      4600,
      28764,
      2867,
      63,
      393,
      4600,
      2149,
      63,
      656,
      281,
      34549,
      13
    ],
    "start_token": 300,
    "end_token": 327,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      477,
      3815,
      287,
      4600,
      1072,
      11306,
      62,
      11600,
      63,
      389,
      11670,
      6060,
      35439,
      329,
      1673,
      36686,
      341,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes all values in `ensemble_dict` are compatible DataFrames for concatenation."
  },
  {
    "line": 93,
    "text": "    Average and standardize a dict of same shape dataframe like `prediction` or `IC` into an ensemble.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'datetime' column exists in all DataFrames, which may lead to KeyError.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      13475,
      290,
      3210,
      1096,
      257,
      8633,
      286,
      976,
      5485,
      1366,
      14535,
      588,
      4600,
      28764,
      2867,
      63,
      393,
      4600,
      2149,
      63,
      656,
      281,
      34549,
      13
    ],
    "start_token": 327,
    "end_token": 354,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      19608,
      8079,
      6,
      5721,
      7160,
      287,
      477,
      6060,
      35439,
      11,
      543,
      743,
      1085,
      284,
      7383,
      12331,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'datetime' column exists in all DataFrames, which may lead to KeyError."
  },
  {
    "line": 93,
    "text": "    Average and standardize a dict of same shape dataframe like `prediction` or `IC` into an ensemble.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if `df.std()` results in zero.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      13475,
      290,
      3210,
      1096,
      257,
      8633,
      286,
      976,
      5485,
      1366,
      14535,
      588,
      4600,
      28764,
      2867,
      63,
      393,
      4600,
      2149,
      63,
      656,
      281,
      34549,
      13
    ],
    "start_token": 354,
    "end_token": 381,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      4600,
      7568,
      13,
      19282,
      3419,
      63,
      2482,
      287,
      6632,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if `df.std()` results in zero."
  }
]