[
  {
    "line": 5,
    "text": "Collector module can collect objects from everywhere and process them such as merging, grouping, averaging and so on.",
    "annotation": "\u2705 Best Practice: Group imports from the same module together to improve readability.",
    "confidence": 0.5,
    "tokens": [
      31337,
      273,
      8265,
      460,
      2824,
      5563,
      422,
      8347,
      290,
      1429,
      606,
      884,
      355,
      35981,
      11,
      36115,
      11,
      20430,
      290,
      523,
      319,
      13
    ],
    "start_token": 0,
    "end_token": 22,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      17944,
      422,
      262,
      976,
      8265,
      1978,
      284,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Group imports from the same module together to improve readability."
  },
  {
    "line": 8,
    "text": "from collections import defaultdict",
    "annotation": "\u2705 Best Practice: Group imports from the same module together to improve readability.",
    "confidence": 0.5,
    "tokens": [
      6738,
      17268,
      1330,
      4277,
      11600
    ],
    "start_token": 22,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      17944,
      422,
      262,
      976,
      8265,
      1978,
      284,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Group imports from the same module together to improve readability."
  },
  {
    "line": 13,
    "text": "from qlib.utils.exceptions import LoadObjectError",
    "annotation": "\u2705 Best Practice: Class docstring provides a brief description of the class purpose",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      26791,
      13,
      1069,
      11755,
      1330,
      8778,
      10267,
      12331
    ],
    "start_token": 27,
    "end_token": 39,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      4506,
      6764,
      286,
      262,
      1398,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a brief description of the class purpose"
  },
  {
    "line": 15,
    "text": "from qlib.workflow.exp import Experiment",
    "annotation": "\u2705 Best Practice: Class attribute with a default value for serialization backend",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      1818,
      11125,
      13,
      11201,
      1330,
      29544
    ],
    "start_token": 39,
    "end_token": 49,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      11688,
      351,
      257,
      4277,
      1988,
      329,
      11389,
      1634,
      30203
    ],
    "label": "best_practice",
    "reason": "Class attribute with a default value for serialization backend"
  },
  {
    "line": 17,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument can lead to unexpected behavior if modified.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 49,
    "end_token": 49,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      9518,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument can lead to unexpected behavior if modified."
  },
  {
    "line": 24,
    "text": "    def __init__(self, process_list=[]):",
    "annotation": "\u2705 Best Practice: Ensures process_list is always a list, improving consistency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      1429,
      62,
      4868,
      28,
      21737,
      2599
    ],
    "start_token": 49,
    "end_token": 65,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      942,
      1429,
      62,
      4868,
      318,
      1464,
      257,
      1351,
      11,
      10068,
      15794,
      13
    ],
    "label": "best_practice",
    "reason": "Ensures process_list is always a list, improving consistency."
  },
  {
    "line": 26,
    "text": "        Init Collector.",
    "annotation": "\ud83e\udde0 ML Signal: Storing a list of processors indicates a pattern of applying multiple operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      44707,
      17573,
      13
    ],
    "start_token": 65,
    "end_token": 75,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      1351,
      286,
      20399,
      9217,
      257,
      3912,
      286,
      11524,
      3294,
      4560,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing a list of processors indicates a pattern of applying multiple operations."
  },
  {
    "line": 35,
    "text": "    def collect(self) -> dict:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using NotImplementedError without implementation can lead to runtime errors if not handled properly.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      2824,
      7,
      944,
      8,
      4613,
      8633,
      25
    ],
    "start_token": 75,
    "end_token": 86,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118,
      6105,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using NotImplementedError without implementation can lead to runtime errors if not handled properly."
  },
  {
    "line": 38,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument (process_list) can lead to unexpected behavior.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 86,
    "end_token": 86,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      357,
      14681,
      62,
      4868,
      8,
      460,
      1085,
      284,
      10059,
      4069,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument (process_list) can lead to unexpected behavior."
  },
  {
    "line": 51,
    "text": "",
    "annotation": "\u2705 Best Practice: Ensures process_list is always a list, improving consistency.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 86,
    "end_token": 86,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      942,
      1429,
      62,
      4868,
      318,
      1464,
      257,
      1351,
      11,
      10068,
      15794,
      13
    ],
    "label": "best_practice",
    "reason": "Ensures process_list is always a list, improving consistency."
  },
  {
    "line": 55,
    "text": "        Do a series of processing to the dict returned by collect and return a dict like {key: things}",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a dictionary to process its values.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2141,
      257,
      2168,
      286,
      7587,
      284,
      262,
      8633,
      4504,
      416,
      2824,
      290,
      1441,
      257,
      8633,
      588,
      1391,
      2539,
      25,
      1243,
      92
    ],
    "start_token": 86,
    "end_token": 114,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      22155,
      284,
      1429,
      663,
      3815,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over a dictionary to process its values."
  },
  {
    "line": 58,
    "text": "        Args:",
    "annotation": "\ud83e\udde0 ML Signal: Applying a series of functions to data, common in data processing pipelines.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      943,
      14542,
      25
    ],
    "start_token": 114,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      2168,
      286,
      5499,
      284,
      1366,
      11,
      2219,
      287,
      1366,
      7587,
      31108,
      13
    ],
    "label": "ml_signal",
    "reason": "Applying a series of functions to data, common in data processing pipelines."
  },
  {
    "line": 60,
    "text": "            process_list (list or Callable): the list of processors or the instance of a processor to process dict.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raises an exception for unsupported types, which could be handled more gracefully.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1429,
      62,
      4868,
      357,
      4868,
      393,
      4889,
      540,
      2599,
      262,
      1351,
      286,
      20399,
      393,
      262,
      4554,
      286,
      257,
      12649,
      284,
      1429,
      8633,
      13
    ],
    "start_token": 124,
    "end_token": 158,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      2696,
      281,
      6631,
      329,
      24222,
      3858,
      11,
      543,
      714,
      307,
      12118,
      517,
      11542,
      2759,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raises an exception for unsupported types, which could be handled more gracefully."
  },
  {
    "line": 61,
    "text": "                The processor order is the same as the list order.",
    "annotation": "\u2705 Best Practice: Docstring provides a clear description of the method's purpose and return value.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      383,
      12649,
      1502,
      318,
      262,
      976,
      355,
      262,
      1351,
      1502,
      13
    ],
    "start_token": 158,
    "end_token": 184,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      2446,
      338,
      4007,
      290,
      1441,
      1988,
      13
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear description of the method's purpose and return value."
  },
  {
    "line": 67,
    "text": "        if not isinstance(process_list, list):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a method named `collect` suggests a data collection pattern.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      318,
      39098,
      7,
      14681,
      62,
      4868,
      11,
      1351,
      2599
    ],
    "start_token": 184,
    "end_token": 202,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2446,
      3706,
      4600,
      33327,
      63,
      5644,
      257,
      1366,
      4947,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a method named `collect` suggests a data collection pattern."
  },
  {
    "line": 69,
    "text": "        result = {}",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with `process_collect` indicates a data processing workflow.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1255,
      796,
      23884
    ],
    "start_token": 202,
    "end_token": 212,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      4600,
      14681,
      62,
      33327,
      63,
      9217,
      257,
      1366,
      7587,
      30798,
      13
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with `process_collect` indicates a data processing workflow."
  },
  {
    "line": 68,
    "text": "            process_list = [process_list]",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear explanation of the class's purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1429,
      62,
      4868,
      796,
      685,
      14681,
      62,
      4868,
      60
    ],
    "start_token": 212,
    "end_token": 232,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      338,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear explanation of the class's purpose and usage."
  },
  {
    "line": 78,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 232,
    "end_token": 232,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability."
  },
  {
    "line": 78,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument (process_list) can lead to unexpected behavior if modified.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 232,
    "end_token": 232,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      357,
      14681,
      62,
      4868,
      8,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      9518,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument (process_list) can lead to unexpected behavior if modified."
  },
  {
    "line": 89,
    "text": "",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass initializer ensures proper initialization of inherited attributes.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 232,
    "end_token": 232,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      4238,
      7509,
      19047,
      1774,
      37588,
      286,
      19552,
      12608,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass initializer ensures proper initialization of inherited attributes."
  },
  {
    "line": 90,
    "text": "class MergeCollector(Collector):",
    "annotation": "\ud83e\udde0 ML Signal: Storing a dictionary of collectors could indicate a pattern of managing multiple data sources or handlers.",
    "confidence": 1.0,
    "tokens": [
      4871,
      39407,
      31337,
      273,
      7,
      31337,
      273,
      2599
    ],
    "start_token": 232,
    "end_token": 240,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      22155,
      286,
      26668,
      714,
      7603,
      257,
      3912,
      286,
      11149,
      3294,
      1366,
      4237,
      393,
      32847,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing a dictionary of collectors could indicate a pattern of managing multiple data sources or handlers."
  },
  {
    "line": 95,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Storing a function for merging keys suggests a pattern of customizable data processing or transformation.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 240,
    "end_token": 240,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      2163,
      329,
      35981,
      8251,
      5644,
      257,
      3912,
      286,
      38322,
      1366,
      7587,
      393,
      13389,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing a function for merging keys suggests a pattern of customizable data processing or transformation."
  },
  {
    "line": 97,
    "text": "        A can collect {\"prediction\": pd.Series} and B can collect {\"IC\": {\"Xgboost\": pd.Series, \"LSTM\": pd.Series}}.",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a dictionary and calling functions stored as values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      317,
      460,
      2824,
      19779,
      28764,
      2867,
      1298,
      279,
      67,
      13,
      27996,
      92,
      290,
      347,
      460,
      2824,
      19779,
      2149,
      1298,
      19779,
      55,
      70,
      39521,
      1298,
      279,
      67,
      13,
      27996,
      11,
      366,
      43,
      2257,
      44,
      1298,
      279,
      67,
      13,
      27996,
      11709,
      13
    ],
    "start_token": 240,
    "end_token": 287,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      22155,
      290,
      4585,
      5499,
      8574,
      355,
      3815
    ],
    "label": "ml_signal",
    "reason": "Iterating over a dictionary and calling functions stored as values"
  },
  {
    "line": 100,
    "text": "        ...",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on the presence of a function",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2644
    ],
    "start_token": 287,
    "end_token": 295,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      262,
      4931,
      286,
      257,
      2163
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on the presence of a function"
  },
  {
    "line": 102,
    "text": "    \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Using a function to transform keys",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 295,
    "end_token": 299,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      257,
      2163,
      284,
      6121,
      8251
    ],
    "label": "ml_signal",
    "reason": "Using a function to transform keys"
  },
  {
    "line": 105,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Using a tuple as a dictionary key for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 299,
    "end_token": 307,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      46545,
      355,
      257,
      22155,
      1994,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Using a tuple as a dictionary key for clarity"
  },
  {
    "line": 104,
    "text": "    def __init__(self, collector_dict: Dict[str, Collector], process_list: List[Callable] = [], merge_func=None):",
    "annotation": "\u2705 Best Practice: Class should have a docstring explaining its purpose and usage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      22967,
      62,
      11600,
      25,
      360,
      713,
      58,
      2536,
      11,
      17573,
      4357,
      1429,
      62,
      4868,
      25,
      7343,
      58,
      14134,
      540,
      60,
      796,
      685,
      4357,
      20121,
      62,
      20786,
      28,
      14202,
      2599
    ],
    "start_token": 307,
    "end_token": 346,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748
    ],
    "label": "best_practice",
    "reason": "Class should have a docstring explaining its purpose and usage"
  },
  {
    "line": 106,
    "text": "        Init MergeCollector.",
    "annotation": "\u2705 Best Practice: Constants should be documented or self-explanatory",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      44707,
      39407,
      31337,
      273,
      13
    ],
    "start_token": 346,
    "end_token": 358,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4757,
      1187,
      815,
      307,
      12395,
      393,
      2116,
      12,
      1069,
      11578,
      2870
    ],
    "label": "best_practice",
    "reason": "Constants should be documented or self-explanatory"
  },
  {
    "line": 117,
    "text": "",
    "annotation": "\u2705 Best Practice: Provide a docstring to describe the purpose and usage of the class constructor.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 358,
    "end_token": 358,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      1398,
      23772,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a docstring to describe the purpose and usage of the class constructor."
  },
  {
    "line": 132,
    "text": "                    collect_dict[(collector_key, key)] = value",
    "annotation": "\u2705 Best Practice: Call the superclass's __init__ method to ensure proper initialization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2824,
      62,
      11600,
      58,
      7,
      33327,
      273,
      62,
      2539,
      11,
      1994,
      15437,
      796,
      1988
    ],
    "start_token": 358,
    "end_token": 391,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      284,
      4155,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Call the superclass's __init__ method to ensure proper initialization."
  },
  {
    "line": 134,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using isinstance with a string type check can lead to unexpected behavior if experiment is not a string.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 391,
    "end_token": 391,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      318,
      39098,
      351,
      257,
      4731,
      2099,
      2198,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      6306,
      318,
      407,
      257,
      4731,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using isinstance with a string type check can lead to unexpected behavior if experiment is not a string."
  },
  {
    "line": 136,
    "text": "class RecorderCollector(Collector):",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic retrieval of experiment based on string input.",
    "confidence": 0.5,
    "tokens": [
      4871,
      3311,
      2875,
      31337,
      273,
      7,
      31337,
      273,
      2599
    ],
    "start_token": 391,
    "end_token": 400,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      45069,
      286,
      6306,
      1912,
      319,
      4731,
      5128,
      13
    ],
    "label": "ml_signal",
    "reason": "Dynamic retrieval of experiment based on string input."
  },
  {
    "line": 138,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using assert for type checking can be bypassed if Python is run with optimizations.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 400,
    "end_token": 400,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      6818,
      329,
      2099,
      10627,
      460,
      307,
      17286,
      276,
      611,
      11361,
      318,
      1057,
      351,
      41446,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using assert for type checking can be bypassed if Python is run with optimizations."
  },
  {
    "line": 140,
    "text": "        self,",
    "annotation": "\ud83e\udde0 ML Signal: Storing experiment object or callable for later use.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 400,
    "end_token": 409,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      6306,
      2134,
      393,
      869,
      540,
      329,
      1568,
      779,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing experiment object or callable for later use."
  },
  {
    "line": 142,
    "text": "        process_list=[],",
    "annotation": "\ud83e\udde0 ML Signal: Storing configuration for artifact paths.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1429,
      62,
      4868,
      41888,
      4357
    ],
    "start_token": 409,
    "end_token": 421,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      8398,
      329,
      24127,
      13532,
      13
    ],
    "label": "ml_signal",
    "reason": "Storing configuration for artifact paths."
  },
  {
    "line": 144,
    "text": "        rec_filter_func=None,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential issue with mutable default arguments like lists or dictionaries.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      664,
      62,
      24455,
      62,
      20786,
      28,
      14202,
      11
    ],
    "start_token": 421,
    "end_token": 436,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2071,
      351,
      4517,
      540,
      4277,
      7159,
      588,
      8341,
      393,
      48589,
      3166,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential issue with mutable default arguments like lists or dictionaries."
  },
  {
    "line": 140,
    "text": "        self,",
    "annotation": "\u2705 Best Practice: Check if artifacts_key is None before assigning a default value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      11
    ],
    "start_token": 436,
    "end_token": 445,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      20316,
      62,
      2539,
      318,
      6045,
      878,
      38875,
      257,
      4277,
      1988
    ],
    "label": "best_practice",
    "reason": "Check if artifacts_key is None before assigning a default value"
  },
  {
    "line": 143,
    "text": "        rec_key_func=None,",
    "annotation": "\u2705 Best Practice: Assigning function to an instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      664,
      62,
      2539,
      62,
      20786,
      28,
      14202,
      11
    ],
    "start_token": 445,
    "end_token": 460,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2195,
      38944,
      2163,
      284,
      281,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "best_practice",
    "reason": "Assigning function to an instance variable for later use"
  },
  {
    "line": 145,
    "text": "        artifacts_path={\"pred\": \"pred.pkl\"},",
    "annotation": "\u2705 Best Practice: Assigning a potentially modified artifacts_key to an instance variable",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      20316,
      62,
      6978,
      28,
      4895,
      28764,
      1298,
      366,
      28764,
      13,
      79,
      41582,
      25719
    ],
    "start_token": 460,
    "end_token": 480,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2195,
      38944,
      257,
      6196,
      9518,
      20316,
      62,
      2539,
      284,
      281,
      4554,
      7885
    ],
    "label": "best_practice",
    "reason": "Assigning a potentially modified artifacts_key to an instance variable"
  },
  {
    "line": 147,
    "text": "        list_kwargs={},",
    "annotation": "\u2705 Best Practice: Assigning function to an instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1351,
      62,
      46265,
      22046,
      34758,
      5512
    ],
    "start_token": 480,
    "end_token": 493,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2195,
      38944,
      2163,
      284,
      281,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "best_practice",
    "reason": "Assigning function to an instance variable for later use"
  },
  {
    "line": 148,
    "text": "        status: Iterable = {Recorder.STATUS_FI},",
    "annotation": "\u2705 Best Practice: Assigning list_kwargs to an instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3722,
      25,
      40806,
      540,
      796,
      1391,
      6690,
      2875,
      13,
      35744,
      2937,
      62,
      11674,
      5512
    ],
    "start_token": 493,
    "end_token": 514,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2195,
      38944,
      1351,
      62,
      46265,
      22046,
      284,
      281,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "best_practice",
    "reason": "Assigning list_kwargs to an instance variable for later use"
  },
  {
    "line": 148,
    "text": "        status: Iterable = {Recorder.STATUS_FI},",
    "annotation": "\u2705 Best Practice: Assigning status to an instance variable for later use",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3722,
      25,
      40806,
      540,
      796,
      1391,
      6690,
      2875,
      13,
      35744,
      2937,
      62,
      11674,
      5512
    ],
    "start_token": 514,
    "end_token": 535,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2195,
      38944,
      3722,
      284,
      281,
      4554,
      7885,
      329,
      1568,
      779
    ],
    "label": "best_practice",
    "reason": "Assigning status to an instance variable for later use"
  },
  {
    "line": 208,
    "text": "        if isinstance(self.experiment, Experiment):",
    "annotation": "\ud83e\udde0 ML Signal: Method returning an attribute of an object",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      944,
      13,
      23100,
      3681,
      11,
      29544,
      2599
    ],
    "start_token": 535,
    "end_token": 553,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      8024,
      281,
      11688,
      286,
      281,
      2134
    ],
    "label": "ml_signal",
    "reason": "Method returning an attribute of an object"
  }
]