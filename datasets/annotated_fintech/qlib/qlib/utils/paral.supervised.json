[
  {
    "line": 2,
    "text": "# Licensed under the MIT License.",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      2,
      49962,
      739,
      262,
      17168,
      13789,
      13
    ],
    "start_token": 0,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 4,
    "text": "import threading",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      4704,
      278
    ],
    "start_token": 7,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 6,
    "text": "from threading import Thread",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      6738,
      4704,
      278,
      1330,
      14122
    ],
    "start_token": 10,
    "end_token": 15,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 8,
    "text": "",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 15,
    "end_token": 15,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 10,
    "text": "from joblib import Parallel, delayed",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      6738,
      1693,
      8019,
      1330,
      42945,
      11,
      11038
    ],
    "start_token": 15,
    "end_token": 22,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 12,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 22,
    "end_token": 28,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 14,
    "text": "from queue import Empty, Queue",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      6738,
      16834,
      1330,
      33523,
      11,
      4670,
      518
    ],
    "start_token": 28,
    "end_token": 35,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 16,
    "text": "",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 35,
    "end_token": 35,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 35,
    "end_token": 35,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 20,
    "text": "class ParallelExt(Parallel):",
    "annotation": "\u2705 Best Practice: Importing specific functions or classes can improve code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      4871,
      42945,
      11627,
      7,
      10044,
      29363,
      2599
    ],
    "start_token": 35,
    "end_token": 42,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      5499,
      393,
      6097,
      460,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific functions or classes can improve code readability and maintainability."
  },
  {
    "line": 13,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring is missing, consider adding one for better documentation.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 42,
    "end_token": 42,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      318,
      4814,
      11,
      2074,
      4375,
      530,
      329,
      1365,
      10314,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring is missing, consider adding one for better documentation."
  },
  {
    "line": 15,
    "text": "import concurrent",
    "annotation": "\ud83e\udde0 ML Signal: Use of super() to call parent class constructor",
    "confidence": 1.0,
    "tokens": [
      11748,
      24580
    ],
    "start_token": 42,
    "end_token": 44,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      2560,
      1398,
      23772
    ],
    "label": "ml_signal",
    "reason": "Use of super() to call parent class constructor"
  },
  {
    "line": 17,
    "text": "from qlib.config import C, QlibConfig",
    "annotation": "\u2705 Best Practice: Check if the backend is an instance of a specific class",
    "confidence": 1.0,
    "tokens": [
      6738,
      10662,
      8019,
      13,
      11250,
      1330,
      327,
      11,
      1195,
      8019,
      16934
    ],
    "start_token": 44,
    "end_token": 55,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      262,
      30203,
      318,
      281,
      4554,
      286,
      257,
      2176,
      1398
    ],
    "label": "best_practice",
    "reason": "Check if the backend is an instance of a specific class"
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on version checking",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 55,
    "end_token": 55,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      2196,
      10627
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on version checking"
  },
  {
    "line": 21,
    "text": "    def __init__(self, *args, **kwargs):",
    "annotation": "\u2705 Best Practice: Use of dictionary to store configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 55,
    "end_token": 72,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      22155,
      284,
      3650,
      8398
    ],
    "label": "best_practice",
    "reason": "Use of dictionary to store configuration"
  },
  {
    "line": 24,
    "text": "        if isinstance(self._backend, MultiprocessingBackend):",
    "annotation": "\u2705 Best Practice: Use of dictionary to store configuration",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      944,
      13557,
      1891,
      437,
      11,
      7854,
      541,
      305,
      919,
      278,
      7282,
      437,
      2599
    ],
    "start_token": 72,
    "end_token": 96,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      22155,
      284,
      3650,
      8398
    ],
    "label": "best_practice",
    "reason": "Use of dictionary to store configuration"
  },
  {
    "line": 44,
    "text": "        apply_func for processing the data",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the `df` parameter for better code clarity and type checking.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4174,
      62,
      20786,
      329,
      7587,
      262,
      1366
    ],
    "start_token": 96,
    "end_token": 110,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      4600,
      7568,
      63,
      11507,
      329,
      1365,
      2438,
      16287,
      290,
      2099,
      10627,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the `df` parameter for better code clarity and type checking."
  },
  {
    "line": 45,
    "text": "        if a string is given, then it is treated as naive pandas function",
    "annotation": "\u2705 Best Practice: Consider using more descriptive parameter names for `axis`, `level`, and `n_jobs` for better readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      257,
      4731,
      318,
      1813,
      11,
      788,
      340,
      318,
      5716,
      355,
      24354,
      19798,
      292,
      2163
    ],
    "start_token": 110,
    "end_token": 132,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      517,
      35644,
      11507,
      3891,
      329,
      4600,
      22704,
      47671,
      4600,
      5715,
      47671,
      290,
      4600,
      77,
      62,
      43863,
      63,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using more descriptive parameter names for `axis`, `level`, and `n_jobs` for better readability."
  },
  {
    "line": 46,
    "text": "    axis :",
    "annotation": "\u2705 Best Practice: Use of docstring to describe the function and its parameters improves code maintainability and readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      16488,
      1058
    ],
    "start_token": 132,
    "end_token": 137,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      290,
      663,
      10007,
      19575,
      2438,
      5529,
      1799,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of docstring to describe the function and its parameters improves code maintainability and readability."
  },
  {
    "line": 47,
    "text": "        which axis is the datetime level located",
    "annotation": "\ud83e\udde0 ML Signal: The use of `apply_func` as a parameter indicates a higher-order function pattern, which is useful for ML models to learn about function composition.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      16488,
      318,
      262,
      4818,
      8079,
      1241,
      5140
    ],
    "start_token": 137,
    "end_token": 152,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      779,
      286,
      4600,
      39014,
      62,
      20786,
      63,
      355,
      257,
      11507,
      9217,
      257,
      2440,
      12,
      2875,
      2163,
      3912,
      11,
      543,
      318,
      4465,
      329,
      10373,
      4981,
      284,
      2193,
      546,
      2163,
      11742,
      13
    ],
    "label": "ml_signal",
    "reason": "The use of `apply_func` as a parameter indicates a higher-order function pattern, which is useful for ML models to learn about function composition."
  },
  {
    "line": 48,
    "text": "    level :",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): If `apply_func` is user-controlled, it could lead to code execution vulnerabilities. Ensure proper validation and sanitization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1241,
      1058
    ],
    "start_token": 152,
    "end_token": 157,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1002,
      4600,
      39014,
      62,
      20786,
      63,
      318,
      2836,
      12,
      14401,
      11,
      340,
      714,
      1085,
      284,
      2438,
      9706,
      23805,
      13,
      48987,
      1774,
      21201,
      290,
      5336,
      270,
      1634,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "If `apply_func` is user-controlled, it could lead to code execution vulnerabilities. Ensure proper validation and sanitization."
  },
  {
    "line": 49,
    "text": "        which level is the datetime level",
    "annotation": "\u2705 Best Practice: Default values for parameters like `axis`, `level`, `resample_rule`, and `n_jobs` provide flexibility and ease of use.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      1241,
      318,
      262,
      4818,
      8079,
      1241
    ],
    "start_token": 157,
    "end_token": 171,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      3815,
      329,
      10007,
      588,
      4600,
      22704,
      47671,
      4600,
      5715,
      47671,
      4600,
      411,
      1403,
      62,
      25135,
      47671,
      290,
      4600,
      77,
      62,
      43863,
      63,
      2148,
      13688,
      290,
      10152,
      286,
      779,
      13
    ],
    "label": "best_practice",
    "reason": "Default values for parameters like `axis`, `level`, `resample_rule`, and `n_jobs` provide flexibility and ease of use."
  },
  {
    "line": 45,
    "text": "        if a string is given, then it is treated as naive pandas function",
    "annotation": "\ud83e\udde0 ML Signal: Use of isinstance to check the type of apply_func",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      257,
      4731,
      318,
      1813,
      11,
      788,
      340,
      318,
      5716,
      355,
      24354,
      19798,
      292,
      2163
    ],
    "start_token": 171,
    "end_token": 193,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      318,
      39098,
      284,
      2198,
      262,
      2099,
      286,
      4174,
      62,
      20786
    ],
    "label": "ml_signal",
    "reason": "Use of isinstance to check the type of apply_func"
  },
  {
    "line": 47,
    "text": "        which axis is the datetime level located",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): getattr with user-controlled input could lead to unexpected behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      16488,
      318,
      262,
      4818,
      8079,
      1241,
      5140
    ],
    "start_token": 193,
    "end_token": 208,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      651,
      35226,
      351,
      2836,
      12,
      14401,
      5128,
      714,
      1085,
      284,
      10059,
      4069
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "getattr with user-controlled input could lead to unexpected behavior"
  },
  {
    "line": 49,
    "text": "        which level is the datetime level",
    "annotation": "\ud83e\udde0 ML Signal: Use of groupby and apply pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      543,
      1241,
      318,
      262,
      4818,
      8079,
      1241
    ],
    "start_token": 208,
    "end_token": 222,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1448,
      1525,
      290,
      4174,
      3912
    ],
    "label": "ml_signal",
    "reason": "Use of groupby and apply pattern"
  },
  {
    "line": 52,
    "text": "    n_jobs :",
    "annotation": "\ud83e\udde0 ML Signal: Use of parallel processing with n_jobs",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      299,
      62,
      43863,
      1058
    ],
    "start_token": 222,
    "end_token": 229,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      10730,
      7587,
      351,
      299,
      62,
      43863
    ],
    "label": "ml_signal",
    "reason": "Use of parallel processing with n_jobs"
  },
  {
    "line": 52,
    "text": "    n_jobs :",
    "annotation": "\ud83e\udde0 ML Signal: Use of ParallelExt and delayed for parallel execution",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      299,
      62,
      43863,
      1058
    ],
    "start_token": 229,
    "end_token": 236,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      42945,
      11627,
      290,
      11038,
      329,
      10730,
      9706
    ],
    "label": "ml_signal",
    "reason": "Use of ParallelExt and delayed for parallel execution"
  },
  {
    "line": 55,
    "text": "        pd.DataFrame",
    "annotation": "\ud83e\udde0 ML Signal: Use of resample method on DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778
    ],
    "start_token": 236,
    "end_token": 248,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      581,
      1403,
      2446,
      319,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Use of resample method on DataFrame"
  },
  {
    "line": 56,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Use of pd.concat to combine DataFrames",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 248,
    "end_token": 252,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      1102,
      9246,
      284,
      12082,
      6060,
      35439
    ],
    "label": "best_practice",
    "reason": "Use of pd.concat to combine DataFrames"
  },
  {
    "line": 62,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a special marker to indicate stopping, which can be a pattern for async operations",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 252,
    "end_token": 252,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2041,
      18364,
      284,
      7603,
      12225,
      11,
      543,
      460,
      307,
      257,
      3912,
      329,
      30351,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of a special marker to indicate stopping, which can be a pattern for async operations"
  },
  {
    "line": 64,
    "text": "        dfs = ParallelExt(n_jobs=n_jobs)(",
    "annotation": "\u2705 Best Practice: Use of private attributes to encapsulate class internals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      9501,
      796,
      42945,
      11627,
      7,
      77,
      62,
      43863,
      28,
      77,
      62,
      43863,
      5769
    ],
    "start_token": 252,
    "end_token": 273,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2839,
      12608,
      284,
      32652,
      5039,
      1398,
      1788,
      874
    ],
    "label": "best_practice",
    "reason": "Use of private attributes to encapsulate class internals"
  },
  {
    "line": 66,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Use of private attributes to encapsulate class internals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 273,
    "end_token": 281,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2839,
      12608,
      284,
      32652,
      5039,
      1398,
      1788,
      874
    ],
    "label": "best_practice",
    "reason": "Use of private attributes to encapsulate class internals"
  },
  {
    "line": 68,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Use of private attributes to encapsulate class internals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 281,
    "end_token": 286,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2839,
      12608,
      284,
      32652,
      5039,
      1398,
      1788,
      874
    ],
    "label": "best_practice",
    "reason": "Use of private attributes to encapsulate class internals"
  },
  {
    "line": 70,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Starting a thread in the constructor indicates asynchronous behavior",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 286,
    "end_token": 286,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17962,
      257,
      4704,
      287,
      262,
      23772,
      9217,
      39354,
      4069
    ],
    "label": "ml_signal",
    "reason": "Starting a thread in the constructor indicates asynchronous behavior"
  },
  {
    "line": 68,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Method definition should have a docstring explaining its purpose.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 286,
    "end_token": 291,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      6770,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      13
    ],
    "label": "best_practice",
    "reason": "Method definition should have a docstring explaining its purpose."
  },
  {
    "line": 70,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a queue to signal stopping, which is a common pattern in concurrent programming.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 291,
    "end_token": 291,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      16834,
      284,
      6737,
      12225,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      24580,
      8300,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a queue to signal stopping, which is a common pattern in concurrent programming."
  },
  {
    "line": 73,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Check if the main thread is alive to determine if the loop should continue.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 291,
    "end_token": 295,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      262,
      1388,
      4704,
      318,
      6776,
      284,
      5004,
      611,
      262,
      9052,
      815,
      2555,
      13
    ],
    "label": "best_practice",
    "reason": "Check if the main thread is alive to determine if the loop should continue."
  },
  {
    "line": 76,
    "text": "    Currently, it is used in MLflowRecorder to make functions like `log_params` async",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a queue to get data with a timeout.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      16888,
      11,
      340,
      318,
      973,
      287,
      10373,
      11125,
      6690,
      2875,
      284,
      787,
      5499,
      588,
      4600,
      6404,
      62,
      37266,
      63,
      30351
    ],
    "start_token": 295,
    "end_token": 318,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      16834,
      284,
      651,
      1366,
      351,
      257,
      26827,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a queue to get data with a timeout."
  },
  {
    "line": 80,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Continue the loop if the queue is empty, allowing for non-blocking behavior.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 318,
    "end_token": 322,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      10054,
      262,
      9052,
      611,
      262,
      16834,
      318,
      6565,
      11,
      5086,
      329,
      1729,
      12,
      41938,
      4069,
      13
    ],
    "label": "best_practice",
    "reason": "Continue the loop if the queue is empty, allowing for non-blocking behavior."
  },
  {
    "line": 82,
    "text": "    STOP_MARK = \"__STOP\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific marker to determine when to stop processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      44934,
      62,
      44,
      14175,
      796,
      366,
      834,
      2257,
      3185,
      1
    ],
    "start_token": 322,
    "end_token": 335,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      18364,
      284,
      5004,
      618,
      284,
      2245,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a specific marker to determine when to stop processing."
  },
  {
    "line": 85,
    "text": "        self._q = Queue()",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Executing a callable object from a queue without validation can lead to code execution vulnerabilities.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      80,
      796,
      4670,
      518,
      3419
    ],
    "start_token": 335,
    "end_token": 349,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      8393,
      15129,
      257,
      869,
      540,
      2134,
      422,
      257,
      16834,
      1231,
      21201,
      460,
      1085,
      284,
      2438,
      9706,
      23805,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Executing a callable object from a queue without validation can lead to code execution vulnerabilities."
  },
  {
    "line": 82,
    "text": "    STOP_MARK = \"__STOP\"",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the __call__ method",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      44934,
      62,
      44,
      14175,
      796,
      366,
      834,
      2257,
      3185,
      1
    ],
    "start_token": 349,
    "end_token": 362,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      11593,
      13345,
      834,
      2446
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the __call__ method"
  },
  {
    "line": 84,
    "text": "    def __init__(self) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of partial function application",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 362,
    "end_token": 375,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      13027,
      2163,
      3586
    ],
    "label": "ml_signal",
    "reason": "Usage of partial function application"
  },
  {
    "line": 85,
    "text": "        self._q = Queue()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the function and arguments being passed do not lead to unintended execution or side effects",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      80,
      796,
      4670,
      518,
      3419
    ],
    "start_token": 375,
    "end_token": 389,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      2163,
      290,
      7159,
      852,
      3804,
      466,
      407,
      1085,
      284,
      30261,
      9706,
      393,
      1735,
      3048
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the function and arguments being passed do not lead to unintended execution or side effects"
  },
  {
    "line": 85,
    "text": "        self._q = Queue()",
    "annotation": "\ud83e\udde0 ML Signal: Method with a boolean parameter that alters behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      80,
      796,
      4670,
      518,
      3419
    ],
    "start_token": 389,
    "end_token": 403,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      351,
      257,
      25131,
      11507,
      326,
      40866,
      4069
    ],
    "label": "ml_signal",
    "reason": "Method with a boolean parameter that alters behavior"
  },
  {
    "line": 87,
    "text": "        self._t = Thread(target=self.run)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on method parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      83,
      796,
      14122,
      7,
      16793,
      28,
      944,
      13,
      5143,
      8
    ],
    "start_token": 403,
    "end_token": 422,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      2446,
      10007
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on method parameters"
  },
  {
    "line": 89,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of threading or concurrency",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 422,
    "end_token": 422,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4704,
      278,
      393,
      1673,
      13382
    ],
    "label": "ml_signal",
    "reason": "Use of threading or concurrency"
  },
  {
    "line": 89,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 422,
    "end_token": 422,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function"
  },
  {
    "line": 90,
    "text": "    def close(self):",
    "annotation": "\u2705 Best Practice: Use descriptive function names for better readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      1969,
      7,
      944,
      2599
    ],
    "start_token": 422,
    "end_token": 430,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      35644,
      2163,
      3891,
      329,
      1365,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use descriptive function names for better readability"
  },
  {
    "line": 92,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of isinstance to check if an object is callable",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 430,
    "end_token": 430,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      318,
      39098,
      284,
      2198,
      611,
      281,
      2134,
      318,
      869,
      540
    ],
    "label": "best_practice",
    "reason": "Use of isinstance to check if an object is callable"
  },
  {
    "line": 93,
    "text": "    def run(self):",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic method invocation pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      1057,
      7,
      944,
      2599
    ],
    "start_token": 430,
    "end_token": 438,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      2446,
      43219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Dynamic method invocation pattern"
  },
  {
    "line": 97,
    "text": "            # So the child-threading should actively watch the status of main threading to stop itself.",
    "annotation": "\ud83e\udde0 ML Signal: Fallback to default function execution",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      1406,
      262,
      1200,
      12,
      16663,
      278,
      815,
      10630,
      2342,
      262,
      3722,
      286,
      1388,
      4704,
      278,
      284,
      2245,
      2346,
      13
    ],
    "start_token": 438,
    "end_token": 469,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7218,
      1891,
      284,
      4277,
      2163,
      9706
    ],
    "label": "ml_signal",
    "reason": "Fallback to default function execution"
  },
  {
    "line": 100,
    "text": "                break",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2270
    ],
    "start_token": 469,
    "end_token": 485,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose"
  },
  {
    "line": 104,
    "text": "                # NOTE: avoid deadlock. make checking main thread possible",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising NotImplementedError without implementation can lead to runtime errors if not handled",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      24550,
      25,
      3368,
      2636,
      5354,
      13,
      787,
      10627,
      1388,
      4704,
      1744
    ],
    "start_token": 485,
    "end_token": 512,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      1231,
      7822,
      460,
      1085,
      284,
      19124,
      8563,
      611,
      407,
      12118
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising NotImplementedError without implementation can lead to runtime errors if not handled"
  },
  {
    "line": 105,
    "text": "                continue",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2555
    ],
    "start_token": 512,
    "end_token": 528,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose and parameters"
  },
  {
    "line": 112,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method that sets an attribute, indicating a common pattern of state mutation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 528,
    "end_token": 528,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      326,
      5621,
      281,
      11688,
      11,
      12739,
      257,
      2219,
      3912,
      286,
      1181,
      15148
    ],
    "label": "ml_signal",
    "reason": "Method that sets an attribute, indicating a common pattern of state mutation"
  },
  {
    "line": 114,
    "text": "        if close:",
    "annotation": "\u2705 Best Practice: Raising NotImplementedError is a clear way to indicate that this method should be overridden in subclasses.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1969,
      25
    ],
    "start_token": 528,
    "end_token": 538,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7567,
      1710,
      1892,
      3546,
      1154,
      12061,
      12331,
      318,
      257,
      1598,
      835,
      284,
      7603,
      326,
      428,
      2446,
      815,
      307,
      23170,
      4651,
      287,
      850,
      37724,
      13
    ],
    "label": "best_practice",
    "reason": "Raising NotImplementedError is a clear way to indicate that this method should be overridden in subclasses."
  },
  {
    "line": 115,
    "text": "            self.close()",
    "annotation": "\u2705 Best Practice: Inheriting from a base class promotes code reuse and consistency",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      19836,
      3419
    ],
    "start_token": 538,
    "end_token": 553,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      257,
      2779,
      1398,
      21068,
      2438,
      32349,
      290,
      15794
    ],
    "label": "best_practice",
    "reason": "Inheriting from a base class promotes code reuse and consistency"
  },
  {
    "line": 117,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Constructor method, common pattern for class initialization",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 553,
    "end_token": 553,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28407,
      273,
      2446,
      11,
      2219,
      3912,
      329,
      1398,
      37588
    ],
    "label": "ml_signal",
    "reason": "Constructor method, common pattern for class initialization"
  },
  {
    "line": 119,
    "text": "    def async_dec(ac_attr):",
    "annotation": "\u2705 Best Practice: Initialize instance variables in the constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      30351,
      62,
      12501,
      7,
      330,
      62,
      35226,
      2599
    ],
    "start_token": 553,
    "end_token": 565,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      4554,
      9633,
      287,
      262,
      23772
    ],
    "label": "best_practice",
    "reason": "Initialize instance variables in the constructor"
  },
  {
    "line": 121,
    "text": "            def wrapper(self, *args, **kwargs):",
    "annotation": "\u2705 Best Practice: Initialize instance variables in the constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      825,
      29908,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 565,
    "end_token": 588,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      4554,
      9633,
      287,
      262,
      23772
    ],
    "label": "best_practice",
    "reason": "Initialize instance variables in the constructor"
  },
  {
    "line": 119,
    "text": "    def async_dec(ac_attr):",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      30351,
      62,
      12501,
      7,
      330,
      62,
      35226,
      2599
    ],
    "start_token": 588,
    "end_token": 600,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose"
  },
  {
    "line": 121,
    "text": "            def wrapper(self, *args, **kwargs):",
    "annotation": "\ud83e\udde0 ML Signal: Accessing an instance variable, indicating a getter method pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      825,
      29908,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 600,
    "end_token": 623,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      281,
      4554,
      7885,
      11,
      12739,
      257,
      651,
      353,
      2446,
      3912
    ],
    "label": "ml_signal",
    "reason": "Accessing an instance variable, indicating a getter method pattern"
  },
  {
    "line": 121,
    "text": "            def wrapper(self, *args, **kwargs):",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose and return value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      825,
      29908,
      7,
      944,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      2599
    ],
    "start_token": 623,
    "end_token": 646,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose and return value"
  },
  {
    "line": 123,
    "text": "                    return getattr(self, ac_attr)(func, self, *args, **kwargs)",
    "annotation": "\u2705 Best Practice: Consider using a more descriptive attribute name than 'res'",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      651,
      35226,
      7,
      944,
      11,
      936,
      62,
      35226,
      5769,
      20786,
      11,
      2116,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 646,
    "end_token": 686,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      517,
      35644,
      11688,
      1438,
      621,
      705,
      411,
      6
    ],
    "label": "best_practice",
    "reason": "Consider using a more descriptive attribute name than 'res'"
  },
  {
    "line": 123,
    "text": "                    return getattr(self, ac_attr)(func, self, *args, **kwargs)",
    "annotation": "\u2705 Best Practice: Class docstring provides a clear description of the class purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      651,
      35226,
      7,
      944,
      11,
      936,
      62,
      35226,
      5769,
      20786,
      11,
      2116,
      11,
      1635,
      22046,
      11,
      12429,
      46265,
      22046,
      8
    ],
    "start_token": 686,
    "end_token": 726,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      1398,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a clear description of the class purpose and usage."
  },
  {
    "line": 133,
    "text": "# The code are for implementing following workflow",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of instance variables",
    "confidence": 0.5,
    "tokens": [
      2,
      383,
      2438,
      389,
      329,
      15427,
      1708,
      30798
    ],
    "start_token": 726,
    "end_token": 734,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Initialization of instance variables"
  },
  {
    "line": 135,
    "text": "#      - For example,  {\"job\": [<delayed_joblib_task>,  {\"1\": <delayed_joblib_task>}]}",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of instance variables",
    "confidence": 0.5,
    "tokens": [
      2,
      220,
      220,
      220,
      220,
      220,
      532,
      1114,
      1672,
      11,
      220,
      19779,
      21858,
      1298,
      685,
      27,
      12381,
      16548,
      62,
      21858,
      8019,
      62,
      35943,
      22330,
      220,
      19779,
      16,
      1298,
      1279,
      12381,
      16548,
      62,
      21858,
      8019,
      62,
      35943,
      29,
      92,
      48999
    ],
    "start_token": 734,
    "end_token": 773,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4554,
      9633
    ],
    "label": "ml_signal",
    "reason": "Initialization of instance variables"
  },
  {
    "line": 135,
    "text": "#      - For example,  {\"job\": [<delayed_joblib_task>,  {\"1\": <delayed_joblib_task>}]}",
    "annotation": "\u2705 Best Practice: Method should have a docstring explaining its purpose",
    "confidence": 1.0,
    "tokens": [
      2,
      220,
      220,
      220,
      220,
      220,
      532,
      1114,
      1672,
      11,
      220,
      19779,
      21858,
      1298,
      685,
      27,
      12381,
      16548,
      62,
      21858,
      8019,
      62,
      35943,
      22330,
      220,
      19779,
      16,
      1298,
      1279,
      12381,
      16548,
      62,
      21858,
      8019,
      62,
      35943,
      29,
      92,
      48999
    ],
    "start_token": 773,
    "end_token": 812,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      815,
      423,
      257,
      2205,
      8841,
      11170,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Method should have a docstring explaining its purpose"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of 'self' indicates this is an instance method",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 812,
    "end_token": 812,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      705,
      944,
      6,
      9217,
      428,
      318,
      281,
      4554,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of 'self' indicates this is an instance method"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of zip to combine two lists into a dictionary is efficient and readable",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 812,
    "end_token": 812,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      19974,
      284,
      12082,
      734,
      8341,
      656,
      257,
      22155,
      318,
      6942,
      290,
      31744
    ],
    "label": "best_practice",
    "reason": "Use of zip to combine two lists into a dictionary is efficient and readable"
  },
  {
    "line": 139,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method returns a dictionary created from two lists, indicating a pattern of data transformation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 812,
    "end_token": 812,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      5860,
      257,
      22155,
      2727,
      422,
      734,
      8341,
      11,
      12739,
      257,
      3912,
      286,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Method returns a dictionary created from two lists, indicating a pattern of data transformation"
  },
  {
    "line": 149,
    "text": "        \"\"\"set_res.",
    "annotation": "\u2705 Best Practice: Use of isinstance for type checking is a good practice for readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227,
      2617,
      62,
      411,
      13
    ],
    "start_token": 812,
    "end_token": 824,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      318,
      39098,
      329,
      2099,
      10627,
      318,
      257,
      922,
      3357,
      329,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of isinstance for type checking is a good practice for readability and maintainability."
  },
  {
    "line": 151,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Checking the length of the tuple ensures the expected structure.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 824,
    "end_token": 832,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      39432,
      262,
      4129,
      286,
      262,
      46545,
      19047,
      262,
      2938,
      4645,
      13
    ],
    "label": "best_practice",
    "reason": "Checking the length of the tuple ensures the expected structure."
  },
  {
    "line": 151,
    "text": "        Parameters",
    "annotation": "\u2705 Best Practice: Using callable to check if the first element is a function enhances code reliability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 832,
    "end_token": 840,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      869,
      540,
      284,
      2198,
      611,
      262,
      717,
      5002,
      318,
      257,
      2163,
      32479,
      2438,
      17843,
      13
    ],
    "label": "best_practice",
    "reason": "Using callable to check if the first element is a function enhances code reliability."
  },
  {
    "line": 158,
    "text": "    def get_replacement(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential infinite loop if complex_iter contains circular references.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      35666,
      5592,
      7,
      944,
      2599
    ],
    "start_token": 840,
    "end_token": 851,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      15541,
      9052,
      611,
      3716,
      62,
      2676,
      4909,
      18620,
      10288,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential infinite loop if complex_iter contains circular references."
  },
  {
    "line": 162,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom type checking with is_delayed_tuple function.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 851,
    "end_token": 851,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      2099,
      10627,
      351,
      318,
      62,
      12381,
      16548,
      62,
      83,
      29291,
      2163,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of custom type checking with is_delayed_tuple function."
  },
  {
    "line": 170,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Recursive function call pattern.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 851,
    "end_token": 851,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3311,
      30753,
      2163,
      869,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Recursive function call pattern."
  },
  {
    "line": 179,
    "text": "    - constructing a dict",
    "annotation": "\ud83e\udde0 ML Signal: Recursive function call pattern.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      532,
      30580,
      257,
      8633
    ],
    "start_token": 851,
    "end_token": 858,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3311,
      30753,
      2163,
      869,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Recursive function call pattern."
  },
  {
    "line": 182,
    "text": "        - AND ALL the values are calculated in a SINGLE function",
    "annotation": "\u2705 Best Practice: Add type hints for function parameters and return type for better readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      5357,
      11096,
      262,
      3815,
      389,
      10488,
      287,
      257,
      311,
      2751,
      2538,
      2163
    ],
    "start_token": 858,
    "end_token": 878,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Add type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 192,
    "text": "    def get_replacement(self):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential infinite loop if complex_iter contains circular references",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      35666,
      5592,
      7,
      944,
      2599
    ],
    "start_token": 878,
    "end_token": 889,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      15541,
      9052,
      611,
      3716,
      62,
      2676,
      4909,
      18620,
      10288
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential infinite loop if complex_iter contains circular references"
  },
  {
    "line": 194,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom class method get_replacement",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 889,
    "end_token": 889,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      1398,
      2446,
      651,
      62,
      35666,
      5592
    ],
    "label": "ml_signal",
    "reason": "Usage of custom class method get_replacement"
  },
  {
    "line": 196,
    "text": "def is_delayed_tuple(obj) -> bool:",
    "annotation": "\ud83e\udde0 ML Signal: Recursive function pattern",
    "confidence": 0.5,
    "tokens": [
      4299,
      318,
      62,
      12381,
      16548,
      62,
      83,
      29291,
      7,
      26801,
      8,
      4613,
      20512,
      25
    ],
    "start_token": 889,
    "end_token": 903,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3311,
      30753,
      2163,
      3912
    ],
    "label": "ml_signal",
    "reason": "Recursive function pattern"
  },
  {
    "line": 200,
    "text": "    ----------",
    "annotation": "\ud83e\udde0 ML Signal: Recursive function pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 903,
    "end_token": 908,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3311,
      30753,
      2163,
      3912
    ],
    "label": "ml_signal",
    "reason": "Recursive function pattern"
  },
  {
    "line": 217,
    "text": "    ----------",
    "annotation": "\u2705 Best Practice: Descriptive function name _replace_and_get_dt suggests its purpose",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 908,
    "end_token": 913,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2935,
      6519,
      425,
      2163,
      1438,
      4808,
      33491,
      62,
      392,
      62,
      1136,
      62,
      28664,
      5644,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Descriptive function name _replace_and_get_dt suggests its purpose"
  },
  {
    "line": 219,
    "text": "        complex_iter",
    "annotation": "\ud83e\udde0 ML Signal: Usage of parallel processing with joblib's Parallel",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3716,
      62,
      2676
    ],
    "start_token": 913,
    "end_token": 923,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      10730,
      7587,
      351,
      1693,
      8019,
      338,
      42945
    ],
    "label": "ml_signal",
    "reason": "Usage of parallel processing with joblib's Parallel"
  },
  {
    "line": 221,
    "text": "    if isinstance(complex_iter, DelayedTask):",
    "annotation": "\u2705 Best Practice: Descriptive method name set_res suggests its purpose",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      318,
      39098,
      7,
      41887,
      62,
      2676,
      11,
      4216,
      16548,
      25714,
      2599
    ],
    "start_token": 923,
    "end_token": 938,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2935,
      6519,
      425,
      2446,
      1438,
      900,
      62,
      411,
      5644,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Descriptive method name set_res suggests its purpose"
  },
  {
    "line": 223,
    "text": "        return dt, [dt]",
    "annotation": "\u2705 Best Practice: Descriptive function name _recover_dt suggests its purpose",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      288,
      83,
      11,
      685,
      28664,
      60
    ],
    "start_token": 938,
    "end_token": 952,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2935,
      6519,
      425,
      2163,
      1438,
      4808,
      260,
      9631,
      62,
      28664,
      5644,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Descriptive function name _recover_dt suggests its purpose"
  },
  {
    "line": 229,
    "text": "        dt_all = []",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the class purpose and implementation details",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      83,
      62,
      439,
      796,
      17635
    ],
    "start_token": 952,
    "end_token": 965,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      1398,
      4007,
      290,
      7822,
      3307
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the class purpose and implementation details"
  },
  {
    "line": 229,
    "text": "        dt_all = []",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      83,
      62,
      439,
      796,
      17635
    ],
    "start_token": 965,
    "end_token": 978,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters improves code readability and maintainability"
  },
  {
    "line": 242,
    "text": "        return new_ci, dt_all",
    "annotation": "\ud83e\udde0 ML Signal: Storing function references in objects can indicate patterns of dynamic behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      649,
      62,
      979,
      11,
      288,
      83,
      62,
      439
    ],
    "start_token": 978,
    "end_token": 994,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      2163,
      10288,
      287,
      5563,
      460,
      7603,
      7572,
      286,
      8925,
      4069
    ],
    "label": "ml_signal",
    "reason": "Storing function references in objects can indicate patterns of dynamic behavior"
  },
  {
    "line": 244,
    "text": "        return complex_iter, []",
    "annotation": "\ud83e\udde0 ML Signal: Optional configuration objects can indicate patterns of flexible or customizable behavior",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3716,
      62,
      2676,
      11,
      17635
    ],
    "start_token": 994,
    "end_token": 1007,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      32233,
      8398,
      5563,
      460,
      7603,
      7572,
      286,
      12846,
      393,
      38322,
      4069
    ],
    "label": "ml_signal",
    "reason": "Optional configuration objects can indicate patterns of flexible or customizable behavior"
  },
  {
    "line": 243,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Use of docstring to describe the function's purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1007,
    "end_token": 1012,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Use of docstring to describe the function's purpose"
  },
  {
    "line": 246,
    "text": "",
    "annotation": "\u2705 Best Practice: Check if qlib_config is not None before using it",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1012,
    "end_token": 1012,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      10662,
      8019,
      62,
      11250,
      318,
      407,
      6045,
      878,
      1262,
      340
    ],
    "label": "best_practice",
    "reason": "Check if qlib_config is not None before using it"
  },
  {
    "line": 248,
    "text": "    \"\"\"_recover_dt.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if qlib_config contains untrusted data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227,
      62,
      260,
      9631,
      62,
      28664,
      13
    ],
    "start_token": 1012,
    "end_token": 1022,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      10662,
      8019,
      62,
      11250,
      4909,
      1418,
      81,
      8459,
      1366
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if qlib_config contains untrusted data"
  },
  {
    "line": 250,
    "text": "    replace all the DelayedTask in the `complex_iter` with its `.res` value",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of modifying a function's behavior with additional initialization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6330,
      477,
      262,
      4216,
      16548,
      25714,
      287,
      262,
      4600,
      41887,
      62,
      2676,
      63,
      351,
      663,
      4600,
      13,
      411,
      63,
      1988
    ],
    "start_token": 1022,
    "end_token": 1045,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      30620,
      257,
      2163,
      338,
      4069,
      351,
      3224,
      37588
    ],
    "label": "ml_signal",
    "reason": "Pattern of modifying a function's behavior with additional initialization"
  },
  {
    "line": 248,
    "text": "    \"\"\"_recover_dt.",
    "annotation": "\u2705 Best Practice: Use of __call__ method to make instances callable",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227,
      62,
      260,
      9631,
      62,
      28664,
      13
    ],
    "start_token": 1045,
    "end_token": 1055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      13345,
      834,
      2446,
      284,
      787,
      10245,
      869,
      540
    ],
    "label": "best_practice",
    "reason": "Use of __call__ method to make instances callable"
  },
  {
    "line": 250,
    "text": "    replace all the DelayedTask in the `complex_iter` with its `.res` value",
    "annotation": "\u2705 Best Practice: Use of ProcessPoolExecutor for parallel execution",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      6330,
      477,
      262,
      4216,
      16548,
      25714,
      287,
      262,
      4600,
      41887,
      62,
      2676,
      63,
      351,
      663,
      4600,
      13,
      411,
      63,
      1988
    ],
    "start_token": 1055,
    "end_token": 1078,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      9706
    ],
    "label": "best_practice",
    "reason": "Use of ProcessPoolExecutor for parallel execution"
  },
  {
    "line": 250,
    "text": "    replace all the DelayedTask in the `complex_iter` with its `.res` value",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Potential deadlock if self._func_mod is blocking",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      6330,
      477,
      262,
      4216,
      16548,
      25714,
      287,
      262,
      4600,
      41887,
      62,
      2676,
      63,
      351,
      663,
      4600,
      13,
      411,
      63,
      1988
    ],
    "start_token": 1078,
    "end_token": 1101,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      32480,
      2636,
      5354,
      611,
      2116,
      13557,
      20786,
      62,
      4666,
      318,
      12013
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Potential deadlock if self._func_mod is blocking"
  },
  {
    "line": 250,
    "text": "    replace all the DelayedTask in the `complex_iter` with its `.res` value",
    "annotation": "\ud83e\udde0 ML Signal: Use of ProcessPoolExecutor for parallel processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6330,
      477,
      262,
      4216,
      16548,
      25714,
      287,
      262,
      4600,
      41887,
      62,
      2676,
      63,
      351,
      663,
      4600,
      13,
      411,
      63,
      1988
    ],
    "start_token": 1101,
    "end_token": 1124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      10854,
      27201,
      23002,
      38409,
      329,
      10730,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of ProcessPoolExecutor for parallel processing"
  }
]