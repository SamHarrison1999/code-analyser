[
  {
    "line": 5,
    "text": "from typing import Union, Callable",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules",
    "confidence": 1.0,
    "tokens": [
      6738,
      19720,
      1330,
      4479,
      11,
      4889,
      540
    ],
    "start_token": 0,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules"
  },
  {
    "line": 7,
    "text": "from . import lazy_sort_index",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules",
    "confidence": 1.0,
    "tokens": [
      6738,
      764,
      1330,
      16931,
      62,
      30619,
      62,
      9630
    ],
    "start_token": 7,
    "end_token": 15,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules"
  },
  {
    "line": 8,
    "text": "from .time import Freq, cal_sam_minute",
    "annotation": "\u2705 Best Practice: Use of relative imports for internal modules",
    "confidence": 1.0,
    "tokens": [
      6738,
      764,
      2435,
      1330,
      4848,
      80,
      11,
      2386,
      62,
      37687,
      62,
      11374
    ],
    "start_token": 15,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3585,
      17944,
      329,
      5387,
      13103
    ],
    "label": "best_practice",
    "reason": "Use of relative imports for internal modules"
  },
  {
    "line": 65,
    "text": "            _day_in_month = np.array(list(map(lambda x: x.day, _calendar_day)))",
    "annotation": "\u2705 Best Practice: Importing modules inside functions can reduce memory usage and improve startup time.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      820,
      62,
      259,
      62,
      8424,
      796,
      45941,
      13,
      18747,
      7,
      4868,
      7,
      8899,
      7,
      50033,
      2124,
      25,
      2124,
      13,
      820,
      11,
      4808,
      9948,
      9239,
      62,
      820,
      22305
    ],
    "start_token": 27,
    "end_token": 66,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      13103,
      2641,
      5499,
      460,
      4646,
      4088,
      8748,
      290,
      2987,
      13693,
      640,
      13
    ],
    "label": "best_practice",
    "reason": "Importing modules inside functions can reduce memory usage and improve startup time."
  },
  {
    "line": 68,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a data retrieval function with specific parameters.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 66,
    "end_token": 75,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      1366,
      45069,
      2163,
      351,
      2176,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a data retrieval function with specific parameters."
  },
  {
    "line": 72,
    "text": "def get_higher_eq_freq_feature(instruments, fields, start_time=None, end_time=None, freq=\"day\", disk_cache=1):",
    "annotation": "\ud83e\udde0 ML Signal: Handling specific exceptions to adjust behavior based on frequency.",
    "confidence": 1.0,
    "tokens": [
      4299,
      651,
      62,
      46503,
      62,
      27363,
      62,
      19503,
      80,
      62,
      30053,
      7,
      259,
      2536,
      2886,
      11,
      7032,
      11,
      923,
      62,
      2435,
      28,
      14202,
      11,
      886,
      62,
      2435,
      28,
      14202,
      11,
      2030,
      80,
      2625,
      820,
      1600,
      11898,
      62,
      23870,
      28,
      16,
      2599
    ],
    "start_token": 75,
    "end_token": 116,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      2176,
      13269,
      284,
      4532,
      4069,
      1912,
      319,
      8373,
      13
    ],
    "label": "ml_signal",
    "reason": "Handling specific exceptions to adjust behavior based on frequency."
  },
  {
    "line": 76,
    "text": "    pd.DataFrame",
    "annotation": "\ud83e\udde0 ML Signal: Fallback mechanism to a default frequency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      279,
      67,
      13,
      6601,
      19778
    ],
    "start_token": 116,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7218,
      1891,
      9030,
      284,
      257,
      4277,
      8373,
      13
    ],
    "label": "ml_signal",
    "reason": "Fallback mechanism to a default frequency."
  },
  {
    "line": 80,
    "text": "    from ..data.data import D  # pylint: disable=C0415",
    "annotation": "\ud83e\udde0 ML Signal: Further fallback to a more granular frequency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      422,
      11485,
      7890,
      13,
      7890,
      1330,
      360,
      220,
      1303,
      279,
      2645,
      600,
      25,
      15560,
      28,
      34,
      3023,
      1314
    ],
    "start_token": 124,
    "end_token": 145,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7735,
      2121,
      1891,
      284,
      257,
      517,
      19468,
      934,
      8373,
      13
    ],
    "label": "ml_signal",
    "reason": "Further fallback to a more granular frequency."
  },
  {
    "line": 84,
    "text": "        _freq = freq",
    "annotation": "\ud83e\udde0 ML Signal: Direct handling for minute frequency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4808,
      19503,
      80,
      796,
      2030,
      80
    ],
    "start_token": 145,
    "end_token": 158,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4128,
      9041,
      329,
      5664,
      8373,
      13
    ],
    "label": "ml_signal",
    "reason": "Direct handling for minute frequency."
  },
  {
    "line": 88,
    "text": "            try:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a ValueError with dynamic content could expose internal logic.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1949,
      25
    ],
    "start_token": 158,
    "end_token": 171,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      11052,
      12331,
      351,
      8925,
      2695,
      714,
      15651,
      5387,
      9156,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a ValueError with dynamic content could expose internal logic."
  },
  {
    "line": 91,
    "text": "            except (ValueError, KeyError):",
    "annotation": "\u2705 Best Practice: Docstring provides detailed explanation and examples for function usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2845,
      357,
      11395,
      12331,
      11,
      7383,
      12331,
      2599
    ],
    "start_token": 171,
    "end_token": 190,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      6496,
      7468,
      290,
      6096,
      329,
      2163,
      8748
    ],
    "label": "best_practice",
    "reason": "Docstring provides detailed explanation and examples for function usage"
  },
  {
    "line": 149,
    "text": "                2010-01-08  84.730675   16044853.0",
    "annotation": "\u2705 Best Practice: Use of slice for datetime selection improves readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3050,
      12,
      486,
      12,
      2919,
      220,
      9508,
      13,
      22,
      20548,
      2425,
      220,
      220,
      13454,
      31115,
      4310,
      13,
      15
    ],
    "start_token": 190,
    "end_token": 223,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      16416,
      329,
      4818,
      8079,
      6356,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of slice for datetime selection improves readability"
  },
  {
    "line": 151,
    "text": "                print(resam_ts_data(feature, start_time=\"2010-01-04\", end_time=\"2010-01-05\", method=\"last\"))",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Relative import can lead to issues if the module structure changes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      411,
      321,
      62,
      912,
      62,
      7890,
      7,
      30053,
      11,
      923,
      62,
      2435,
      2625,
      10333,
      12,
      486,
      12,
      3023,
      1600,
      886,
      62,
      2435,
      2625,
      10333,
      12,
      486,
      12,
      2713,
      1600,
      2446,
      2625,
      12957,
      48774
    ],
    "start_token": 223,
    "end_token": 273,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      45344,
      1330,
      460,
      1085,
      284,
      2428,
      611,
      262,
      8265,
      4645,
      2458
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Relative import can lead to issues if the module structure changes"
  },
  {
    "line": 153,
    "text": "                $close 87.433578",
    "annotation": "\u2705 Best Practice: Sorting index before processing ensures consistent behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      720,
      19836,
      10083,
      13,
      42117,
      38907
    ],
    "start_token": 273,
    "end_token": 294,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      6376,
      878,
      7587,
      19047,
      6414,
      4069
    ],
    "label": "best_practice",
    "reason": "Sorting index before processing ensures consistent behavior"
  },
  {
    "line": 155,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of get_level_index to determine index level improves code clarity",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 294,
    "end_token": 294,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      651,
      62,
      5715,
      62,
      9630,
      284,
      5004,
      6376,
      1241,
      19575,
      2438,
      16287
    ],
    "label": "best_practice",
    "reason": "Use of get_level_index to determine index level improves code clarity"
  },
  {
    "line": 166,
    "text": "    end_time : Union[str, pd.Timestamp], optional",
    "annotation": "\ud83e\udde0 ML Signal: Use of groupby and apply indicates a pattern for data aggregation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      886,
      62,
      2435,
      1058,
      4479,
      58,
      2536,
      11,
      279,
      67,
      13,
      14967,
      27823,
      4357,
      11902
    ],
    "start_token": 294,
    "end_token": 312,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1448,
      1525,
      290,
      4174,
      9217,
      257,
      3912,
      329,
      1366,
      46500
    ],
    "label": "ml_signal",
    "reason": "Use of groupby and apply indicates a pattern for data aggregation"
  },
  {
    "line": 169,
    "text": "        sample method, apply method function to each stock series data, by default \"last\"",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic method invocation based on string input",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6291,
      2446,
      11,
      4174,
      2446,
      2163,
      284,
      1123,
      4283,
      2168,
      1366,
      11,
      416,
      4277,
      366,
      12957,
      1
    ],
    "start_token": 312,
    "end_token": 336,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      2446,
      43219,
      1912,
      319,
      4731,
      5128
    ],
    "label": "ml_signal",
    "reason": "Dynamic method invocation based on string input"
  },
  {
    "line": 171,
    "text": "        - If method is None, do nothing for the sliced time-series data.",
    "annotation": "\ud83e\udde0 ML Signal: Function with parameters and return values, useful for learning function signatures and usage patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      532,
      1002,
      2446,
      318,
      6045,
      11,
      466,
      2147,
      329,
      262,
      26790,
      640,
      12,
      25076,
      1366,
      13
    ],
    "start_token": 336,
    "end_token": 359,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      351,
      10007,
      290,
      1441,
      3815,
      11,
      4465,
      329,
      4673,
      2163,
      17239,
      290,
      8748,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function with parameters and return values, useful for learning function signatures and usage patterns"
  },
  {
    "line": 172,
    "text": "    method_kwargs : dict, optional",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return values",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2446,
      62,
      46265,
      22046,
      1058,
      8633,
      11,
      11902
    ],
    "start_token": 359,
    "end_token": 370,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      3815
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return values"
  },
  {
    "line": 188,
    "text": "        feature = feature.loc[selector_datetime]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes series is not empty, which could lead to IndexError if assumption is violated",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3895,
      796,
      3895,
      13,
      17946,
      58,
      19738,
      273,
      62,
      19608,
      8079,
      60
    ],
    "start_token": 370,
    "end_token": 389,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      2168,
      318,
      407,
      6565,
      11,
      543,
      714,
      1085,
      284,
      12901,
      12331,
      611,
      13196,
      318,
      13998
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes series is not empty, which could lead to IndexError if assumption is violated"
  },
  {
    "line": 189,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Use of fillna with method parameter for forward/backward filling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 389,
    "end_token": 394,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      6070,
      2616,
      351,
      2446,
      11507,
      329,
      2651,
      14,
      1891,
      904,
      12591
    ],
    "label": "best_practice",
    "reason": "Use of fillna with method parameter for forward/backward filling"
  },
  {
    "line": 189,
    "text": "    else:",
    "annotation": "\ud83e\udde0 ML Signal: Checks for type of input data, which can be used to infer data handling patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 394,
    "end_token": 399,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      329,
      2099,
      286,
      5128,
      1366,
      11,
      543,
      460,
      307,
      973,
      284,
      13249,
      1366,
      9041,
      7572
    ],
    "label": "ml_signal",
    "reason": "Checks for type of input data, which can be used to infer data handling patterns"
  },
  {
    "line": 191,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of lambda functions for column-wise operations",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 399,
    "end_token": 399,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      37456,
      5499,
      329,
      5721,
      12,
      3083,
      4560
    ],
    "label": "ml_signal",
    "reason": "Usage of lambda functions for column-wise operations"
  },
  {
    "line": 192,
    "text": "    if feature.empty:",
    "annotation": "\ud83e\udde0 ML Signal: Checks for type of input data, which can be used to infer data handling patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      3895,
      13,
      28920,
      25
    ],
    "start_token": 399,
    "end_token": 407,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47719,
      329,
      2099,
      286,
      5128,
      1366,
      11,
      543,
      460,
      307,
      973,
      284,
      13249,
      1366,
      9041,
      7572
    ],
    "label": "ml_signal",
    "reason": "Checks for type of input data, which can be used to infer data handling patterns"
  },
  {
    "line": 196,
    "text": "            method_func = method",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raises a TypeError with potentially sensitive type information",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2446,
      62,
      20786,
      796,
      2446
    ],
    "start_token": 407,
    "end_token": 423,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      2696,
      257,
      5994,
      12331,
      351,
      6196,
      8564,
      2099,
      1321
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raises a TypeError with potentially sensitive type information"
  },
  {
    "line": 196,
    "text": "            method_func = method",
    "annotation": "\u2705 Best Practice: Use of functools.partial to create specialized versions of a function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2446,
      62,
      20786,
      796,
      2446
    ],
    "start_token": 423,
    "end_token": 439,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1257,
      310,
      10141,
      13,
      47172,
      284,
      2251,
      16976,
      6300,
      286,
      257,
      2163
    ],
    "label": "best_practice",
    "reason": "Use of functools.partial to create specialized versions of a function"
  },
  {
    "line": 196,
    "text": "            method_func = method",
    "annotation": "\u2705 Best Practice: Use of functools.partial to create specialized versions of a function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2446,
      62,
      20786,
      796,
      2446
    ],
    "start_token": 439,
    "end_token": 455,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1257,
      310,
      10141,
      13,
      47172,
      284,
      2251,
      16976,
      6300,
      286,
      257,
      2163
    ],
    "label": "best_practice",
    "reason": "Use of functools.partial to create specialized versions of a function"
  }
]