annotation,annotation_tokens,confidence,end_token,label,line,reason,severity,start_token,text,tokens
‚úÖ Best Practice: Use of lru_cache to cache results and improve performance for repeated function calls,"[26486, 227, 6705, 19939, 25, 5765, 286, 300, 622, 62, 23870, 284, 12940, 2482, 290, 2987, 2854, 329, 5100, 2163, 3848]",0.5,8,best_practice,1,Use of lru_cache to cache results and improve performance for repeated function calls,,0,# Copyright (c) Microsoft Corporation.,"[2, 15069, 357, 66, 8, 5413, 10501, 13]"
‚úÖ Best Practice: Use of datetime.combine to create datetime objects from date and time,"[26486, 227, 6705, 19939, 25, 5765, 286, 4818, 8079, 13, 24011, 500, 284, 2251, 4818, 8079, 5563, 422, 3128, 290, 640]",0.5,14,best_practice,12,Use of datetime.combine to create datetime objects from date and time,,8,import pandas as pd,"[11748, 19798, 292, 355, 279, 67]"
‚úÖ Best Practice: Use of datetime.now to get the current time,"[26486, 227, 6705, 19939, 25, 5765, 286, 4818, 8079, 13, 2197, 284, 651, 262, 1459, 640]",0.5,34,best_practice,19,Use of datetime.now to get the current time,,14,"    datetime.strptime(""9:30"", ""%H:%M""),","[220, 220, 220, 4818, 8079, 13, 2536, 457, 524, 7203, 24, 25, 1270, 1600, 36521, 39, 25, 4, 44, 12340]"
üß† ML Signal: Pattern of checking if a time falls within a specific range,"[8582, 100, 254, 10373, 26484, 25, 23939, 286, 10627, 611, 257, 640, 8953, 1626, 257, 2176, 2837]",0.5,39,ml_signal,25,Pattern of checking if a time falls within a specific range,,34,TW_TIME = [,"[34551, 62, 34694, 796, 685]"
üß† ML Signal: Pattern of finding the next available time slot,"[8582, 100, 254, 10373, 26484, 25, 23939, 286, 4917, 262, 1306, 1695, 640, 10852]",0.5,43,ml_signal,45,Pattern of finding the next available time slot,,39,    -------,"[220, 220, 220, 35656]"
‚úÖ Best Practice: Use of timedelta to add days to a date,"[26486, 227, 6705, 19939, 25, 5765, 286, 28805, 12514, 284, 751, 1528, 284, 257, 3128]",0.5,43,best_practice,50,Use of timedelta to add days to a date,,43,,[]
‚ö†Ô∏è SAST Risk (Low): Potential risk of ValueError if time_str is not in the expected format,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 2526, 286, 11052, 12331, 611, 640, 62, 2536, 318, 407, 287, 262, 2938, 5794]",0.5,101,sast_risk,55,Potential risk of ValueError if time_str is not in the expected format,Low,43,"            pd.date_range(CN_TIME[2], CN_TIME[3] - timedelta(minutes=1), freq=""1min"") - pd.Timedelta(minutes=shift)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 279, 67, 13, 4475, 62, 9521, 7, 44175, 62, 34694, 58, 17, 4357, 31171, 62, 34694, 58, 18, 60, 532, 28805, 12514, 7, 1084, 1769, 28, 16, 828, 2030, 80, 2625, 16, 1084, 4943, 532, 279, 67, 13, 14967, 276, 12514, 7, 1084, 1769, 28, 30846, 8]"
‚úÖ Best Practice: Use of strftime to format datetime objects as strings,"[26486, 227, 6705, 19939, 25, 5765, 286, 965, 31387, 284, 5794, 4818, 8079, 5563, 355, 13042]",0.5,112,best_practice,58,Use of strftime to format datetime objects as strings,,101,    elif region == REG_TW:,"[220, 220, 220, 1288, 361, 3814, 6624, 23337, 62, 34551, 25]"
‚ö†Ô∏è SAST Risk (Low): Potential risk of ValueError if date strings are not in the expected format,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 2526, 286, 11052, 12331, 611, 3128, 13042, 389, 407, 287, 262, 2938, 5794]",0.5,170,sast_risk,60,Potential risk of ValueError if date strings are not in the expected format,Low,112,"            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=""1min"") - pd.Timedelta(minutes=shift)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 279, 67, 13, 4475, 62, 9521, 7, 34551, 62, 34694, 58, 15, 4357, 17306, 62, 34694, 58, 16, 60, 532, 28805, 12514, 7, 1084, 1769, 28, 16, 828, 2030, 80, 2625, 16, 1084, 4943, 532, 279, 67, 13, 14967, 276, 12514, 7, 1084, 1769, 28, 30846, 8]"
üß† ML Signal: Pattern of generating a list of dates within a range,"[8582, 100, 254, 10373, 26484, 25, 23939, 286, 15453, 257, 1351, 286, 9667, 1626, 257, 2837]",0.5,228,ml_signal,60,Pattern of generating a list of dates within a range,,170,"            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=""1min"") - pd.Timedelta(minutes=shift)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 279, 67, 13, 4475, 62, 9521, 7, 34551, 62, 34694, 58, 15, 4357, 17306, 62, 34694, 58, 16, 60, 532, 28805, 12514, 7, 1084, 1769, 28, 16, 828, 2030, 80, 2625, 16, 1084, 4943, 532, 279, 67, 13, 14967, 276, 12514, 7, 1084, 1769, 28, 30846, 8]"
‚úÖ Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5765, 286, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 19575, 2438, 1100, 1799, 290, 5529, 1799, 13]",1.0,268,best_practice,24,Use of type hints for function parameters and return type improves code readability and maintainability.,,228,"US_TIME = [datetime.strptime(""9:30"", ""%H:%M""), datetime.strptime(""16:00"", ""%H:%M"")]","[2937, 62, 34694, 796, 685, 19608, 8079, 13, 2536, 457, 524, 7203, 24, 25, 1270, 1600, 36521, 39, 25, 4, 44, 12340, 4818, 8079, 13, 2536, 457, 524, 7203, 1433, 25, 405, 1600, 36521, 39, 25, 4, 44, 4943, 60]"
üß† ML Signal: Conditional logic based on region can indicate regional-specific behavior.,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 3814, 460, 7603, 7915, 12, 11423, 4069, 13]",0.5,302,ml_signal,40,Conditional logic based on region can indicate regional-specific behavior.,,268,        series.shift(1) will replace the value at `i`-th with the one at `i-1`-th,"[220, 220, 220, 220, 220, 220, 220, 2168, 13, 30846, 7, 16, 8, 481, 6330, 262, 1988, 379, 4600, 72, 63, 12, 400, 351, 262, 530, 379, 4600, 72, 12, 16, 63, 12, 400]"
üß† ML Signal: Conditional logic based on region can indicate regional-specific behavior.,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 3814, 460, 7603, 7915, 12, 11423, 4069, 13]",0.5,302,ml_signal,50,Conditional logic based on region can indicate regional-specific behavior.,,302,,[]
üß† ML Signal: Conditional logic based on region can indicate regional-specific behavior.,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 3814, 460, 7603, 7915, 12, 11423, 4069, 13]",0.5,360,ml_signal,55,Conditional logic based on region can indicate regional-specific behavior.,,302,"            pd.date_range(CN_TIME[2], CN_TIME[3] - timedelta(minutes=1), freq=""1min"") - pd.Timedelta(minutes=shift)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 279, 67, 13, 4475, 62, 9521, 7, 44175, 62, 34694, 58, 17, 4357, 31171, 62, 34694, 58, 18, 60, 532, 28805, 12514, 7, 1084, 1769, 28, 16, 828, 2030, 80, 2625, 16, 1084, 4943, 532, 279, 67, 13, 14967, 276, 12514, 7, 1084, 1769, 28, 30846, 8]"
"‚ö†Ô∏è SAST Risk (Low): Raising a ValueError for unsupported regions is good, but consider logging the error for better traceability.","[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 7567, 1710, 257, 11052, 12331, 329, 24222, 7652, 318, 922, 11, 475, 2074, 18931, 262, 4049, 329, 1365, 12854, 1799, 13]",0.5,418,sast_risk,60,"Raising a ValueError for unsupported regions is good, but consider logging the error for better traceability.",Low,360,"            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=""1min"") - pd.Timedelta(minutes=shift)","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 279, 67, 13, 4475, 62, 9521, 7, 34551, 62, 34694, 58, 15, 4357, 17306, 62, 34694, 58, 16, 60, 532, 28805, 12514, 7, 1084, 1769, 28, 16, 828, 2030, 80, 2625, 16, 1084, 4943, 532, 279, 67, 13, 14967, 276, 12514, 7, 1084, 1769, 28, 30846, 8]"
"‚ö†Ô∏è SAST Risk (Low): The function assumes that `REG_CN`, `REG_TW`, and `REG_US` are defined elsewhere, which could lead to a NameError if they are not.","[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 383, 2163, 18533, 326, 4600, 31553, 62, 44175, 47671, 4600, 31553, 62, 34551, 47671, 290, 4600, 31553, 62, 2937, 63, 389, 5447, 8057, 11, 543, 714, 1085, 284, 257, 6530, 12331, 611, 484, 389, 407, 13]",1.0,430,sast_risk,59,"The function assumes that `REG_CN`, `REG_TW`, and `REG_US` are defined elsewhere, which could lead to a NameError if they are not.",Low,418,        for ts in list(,"[220, 220, 220, 220, 220, 220, 220, 329, 40379, 287, 1351, 7]"
‚ö†Ô∏è SAST Risk (Low): Using `NotImplementedError` for unsupported regions without logging or handling can lead to unhandled exceptions.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 8554, 4600, 3673, 3546, 1154, 12061, 12331, 63, 329, 24222, 7652, 1231, 18931, 393, 9041, 460, 1085, 284, 555, 38788, 13269, 13]",0.5,439,sast_risk,97,Using `NotImplementedError` for unsupported regions without logging or handling can lead to unhandled exceptions.,Low,430,        return False,"[220, 220, 220, 220, 220, 220, 220, 1441, 10352]"
‚úÖ Best Practice: Use of class constants for fixed values improves readability and maintainability,"[26486, 227, 6705, 19939, 25, 5765, 286, 1398, 38491, 329, 5969, 3815, 19575, 1100, 1799, 290, 5529, 1799]",1.0,450,best_practice,98,Use of class constants for fixed values improves readability and maintainability,,439,    elif region == REG_TW:,"[220, 220, 220, 1288, 361, 3814, 6624, 23337, 62, 34551, 25]"
‚úÖ Best Practice: Storing related constants in a list for easy access and modification,"[26486, 227, 6705, 19939, 25, 520, 3255, 3519, 38491, 287, 257, 1351, 329, 2562, 1895, 290, 17613]",1.0,459,best_practice,103,Storing related constants in a list for easy access and modification,,450,        return False,"[220, 220, 220, 220, 220, 220, 220, 1441, 10352]"
üß† ML Signal: Type checking and branching based on type,"[8582, 100, 254, 10373, 26484, 25, 5994, 10627, 290, 49526, 1912, 319, 2099]",0.5,470,ml_signal,104,Type checking and branching based on type,,459,    elif region == REG_US:,"[220, 220, 220, 1288, 361, 3814, 6624, 23337, 62, 2937, 25]"
üß† ML Signal: Method call with string input,"[8582, 100, 254, 10373, 26484, 25, 11789, 869, 351, 4731, 5128]",0.5,483,ml_signal,106,Method call with string input,,470,            return True,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1441, 6407]"
üß† ML Signal: Type checking and branching based on type,"[8582, 100, 254, 10373, 26484, 25, 5994, 10627, 290, 49526, 1912, 319, 2099]",0.5,515,ml_signal,107,Type checking and branching based on type,,483,        if start_time.hour == 15 and start_time.minute == 59 and start_time.second == 0:,"[220, 220, 220, 220, 220, 220, 220, 611, 923, 62, 2435, 13, 9769, 6624, 1315, 290, 923, 62, 2435, 13, 11374, 6624, 7863, 290, 923, 62, 2435, 13, 12227, 6624, 657, 25]"
üß† ML Signal: Attribute access from object,"[8582, 100, 254, 10373, 26484, 25, 3460, 4163, 1895, 422, 2134]",0.5,520,ml_signal,110,Attribute access from object,,515,    else:,"[220, 220, 220, 2073, 25]"
‚ö†Ô∏è SAST Risk (Low): Use of NotImplementedError for unsupported types,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 5765, 286, 1892, 3546, 1154, 12061, 12331, 329, 24222, 3858]",1.0,520,sast_risk,113,Use of NotImplementedError for unsupported types,Low,520,,[]
‚úÖ Best Practice: Use of a special method to define equality behavior,"[26486, 227, 6705, 19939, 25, 5765, 286, 257, 2041, 2446, 284, 8160, 10537, 4069]",0.5,525,best_practice,110,Use of a special method to define equality behavior,,520,    else:,"[220, 220, 220, 2073, 25]"
‚úÖ Best Practice: Converting input to a specific type for consistent comparison,"[26486, 227, 6705, 19939, 25, 35602, 889, 5128, 284, 257, 2176, 2099, 329, 6414, 7208]",0.5,525,best_practice,112,Converting input to a specific type for consistent comparison,,525,,[]
üß† ML Signal: Use of logical operators for comparison,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 12219, 12879, 329, 7208]",0.5,529,ml_signal,114,Use of logical operators for comparison,,525,class Freq:,"[4871, 4848, 80, 25]"
‚úÖ Best Practice: Use of f-string for string formatting improves readability and performance,"[26486, 227, 6705, 19939, 25, 5765, 286, 277, 12, 8841, 329, 4731, 33313, 19575, 1100, 1799, 290, 2854]",1.0,529,best_practice,113,Use of f-string for string formatting improves readability and performance,,529,,[]
‚úÖ Best Practice: Ternary conditional operator used for concise conditional logic,"[26486, 227, 6705, 19939, 25, 309, 1142, 560, 26340, 10088, 973, 329, 35327, 26340, 9156]",1.0,545,best_practice,115,Ternary conditional operator used for concise conditional logic,,529,"    NORM_FREQ_MONTH = ""month""","[220, 220, 220, 25273, 44, 62, 37, 2200, 48, 62, 27857, 4221, 796, 366, 8424, 1]"
‚úÖ Best Practice: Use of __repr__ for unambiguous object representation,"[26486, 227, 6705, 19939, 25, 5765, 286, 11593, 260, 1050, 834, 329, 42053, 29709, 2134, 10552]",1.0,561,best_practice,116,Use of __repr__ for unambiguous object representation,,545,"    NORM_FREQ_WEEK = ""week""","[220, 220, 220, 25273, 44, 62, 37, 2200, 48, 62, 54, 33823, 796, 366, 10464, 1]"
‚úÖ Best Practice: Use of @staticmethod for methods that do not access instance or class data,"[26486, 227, 6705, 19939, 25, 5765, 286, 2488, 12708, 24396, 329, 5050, 326, 466, 407, 1895, 4554, 393, 1398, 1366]",1.0,601,best_practice,119,Use of @staticmethod for methods that do not access instance or class data,,561,"    SUPPORT_CAL_LIST = [NORM_FREQ_MINUTE, NORM_FREQ_DAY]  # FIXME: this list should from data","[220, 220, 220, 43333, 62, 34, 1847, 62, 45849, 796, 685, 35510, 44, 62, 37, 2200, 48, 62, 23678, 37780, 11, 25273, 44, 62, 37, 2200, 48, 62, 26442, 60, 220, 1303, 44855, 11682, 25, 428, 1351, 815, 422, 1366]"
‚úÖ Best Practice: Use of regex to validate input format,"[26486, 227, 6705, 19939, 25, 5765, 286, 40364, 284, 26571, 5128, 5794]",0.5,601,best_practice,139,Use of regex to validate input format,,601,,[]
‚ö†Ô∏è SAST Risk (Low): Potential for denial of service if input is not validated before regex,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 14425, 286, 2139, 611, 5128, 318, 407, 31031, 878, 40364]",0.5,620,sast_risk,141,Potential for denial of service if input is not validated before regex,Low,601,"    def parse(freq: str) -> Tuple[int, str]:","[220, 220, 220, 825, 21136, 7, 19503, 80, 25, 965, 8, 4613, 309, 29291, 58, 600, 11, 965, 5974]"
‚úÖ Best Practice: Use of conditional expression to handle optional numeric input,"[26486, 227, 6705, 19939, 25, 5765, 286, 26340, 5408, 284, 5412, 11902, 35575, 5128]",1.0,629,best_practice,146,Use of conditional expression to handle optional numeric input,,620,        ----------,"[220, 220, 220, 220, 220, 220, 220, 24200, 438]"
üß† ML Signal: Mapping of input strings to normalized frequency values,"[8582, 100, 254, 10373, 26484, 25, 337, 5912, 286, 5128, 13042, 284, 39279, 8373, 3815]",0.5,655,ml_signal,159,Mapping of input strings to normalized frequency values,,629,"                    (1, ""day"" )","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 357, 16, 11, 366, 820, 1, 1267]"
‚úÖ Best Practice: Function docstring provides clear documentation of parameters and return type,"[26486, 227, 6705, 19939, 25, 15553, 2205, 8841, 3769, 1598, 10314, 286, 10007, 290, 1441, 2099]",1.0,681,best_practice,159,Function docstring provides clear documentation of parameters and return type,,655,"                    (1, ""day"" )","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 357, 16, 11, 366, 820, 1, 1267]"
üß† ML Signal: Usage of pd.Timedelta indicates working with time-based data,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 279, 67, 13, 14967, 276, 12514, 9217, 1762, 351, 640, 12, 3106, 1366]",1.0,738,ml_signal,170,Usage of pd.Timedelta indicates working with time-based data,,681,"                ""freq format is not supported, the freq should be like (n)month/mon, (n)week/w, (n)day/d, (n)minute/min""","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 366, 19503, 80, 5794, 318, 407, 4855, 11, 262, 2030, 80, 815, 307, 588, 357, 77, 8, 8424, 14, 2144, 11, 357, 77, 8, 10464, 14, 86, 11, 357, 77, 8, 820, 14, 67, 11, 357, 77, 8, 11374, 14, 1084, 1]"
‚úÖ Best Practice: Use of a dictionary for mapping frequency to minutes improves readability and maintainability,"[26486, 227, 6705, 19939, 25, 5765, 286, 257, 22155, 329, 16855, 8373, 284, 2431, 19575, 1100, 1799, 290, 5529, 1799]",1.0,765,best_practice,181,Use of a dictionary for mapping frequency to minutes improves readability and maintainability,,738,"            ""minute"": Freq.NORM_FREQ_MINUTE,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 366, 11374, 1298, 4848, 80, 13, 35510, 44, 62, 37, 2200, 48, 62, 23678, 37780, 11]"
üß† ML Signal: Conversion of string to Freq object indicates a pattern of data transformation,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 4731, 284, 4848, 80, 2134, 9217, 257, 3912, 286, 1366, 13389]",1.0,773,ml_signal,188,Conversion of string to Freq object indicates a pattern of data transformation,,765,"        """"""","[220, 220, 220, 220, 220, 220, 220, 37227]"
üß† ML Signal: Calculation of minutes from frequency shows a pattern of data manipulation,"[8582, 100, 254, 10373, 26484, 25, 2199, 14902, 286, 2431, 422, 8373, 2523, 257, 3912, 286, 1366, 17512]",0.5,773,ml_signal,190,Calculation of minutes from frequency shows a pattern of data manipulation,,773,,[]
üß† ML Signal: Conversion of string to Freq object indicates a pattern of data transformation,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 4731, 284, 4848, 80, 2134, 9217, 257, 3912, 286, 1366, 13389]",1.0,781,ml_signal,191,Conversion of string to Freq object indicates a pattern of data transformation,,773,        Parameters,"[220, 220, 220, 220, 220, 220, 220, 40117]"
üß† ML Signal: Calculation of minutes from frequency shows a pattern of data manipulation,"[8582, 100, 254, 10373, 26484, 25, 2199, 14902, 286, 2431, 422, 8373, 2523, 257, 3912, 286, 1366, 17512]",0.5,792,ml_signal,194,Calculation of minutes from frequency shows a pattern of data manipulation,,781,        freq : str,"[220, 220, 220, 220, 220, 220, 220, 2030, 80, 1058, 965]"
üß† ML Signal: Returning the difference between two calculated values is a common pattern,"[8582, 100, 254, 10373, 26484, 25, 42882, 262, 3580, 1022, 734, 10488, 3815, 318, 257, 2219, 3912]",0.5,803,ml_signal,194,Returning the difference between two calculated values is a common pattern,,792,        freq : str,"[220, 220, 220, 220, 220, 220, 220, 2030, 80, 1058, 965]"
‚úÖ Best Practice: Type hinting improves code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 19575, 2438, 1100, 1799, 290, 5529, 1799]",1.0,813,best_practice,193,Type hinting improves code readability and maintainability,,803,        n : int,"[220, 220, 220, 220, 220, 220, 220, 299, 1058, 493]"
üß† ML Signal: Conversion of input to a specific type (Freq) indicates a pattern of data normalization,"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 5128, 284, 257, 2176, 2099, 357, 20366, 80, 8, 9217, 257, 3912, 286, 1366, 3487, 1634]",0.5,821,ml_signal,207,Conversion of input to a specific type (Freq) indicates a pattern of data normalization,,813,        Parameters,"[220, 220, 220, 220, 220, 220, 220, 40117]"
üß† ML Signal: Use of a method to calculate a delta or difference is a common pattern in data processing,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 257, 2446, 284, 15284, 257, 25979, 393, 3580, 318, 257, 2219, 3912, 287, 1366, 7587]",0.5,821,ml_signal,211,Use of a method to calculate a delta or difference is a common pattern in data processing,,821,,[]
‚úÖ Best Practice: Use of tuple unpacking for readability,"[26486, 227, 6705, 19939, 25, 5765, 286, 46545, 8593, 5430, 329, 1100, 1799]",0.5,848,best_practice,218,Use of tuple unpacking for readability,,821,"            Freq.NORM_FREQ_DAY: 60 * 24,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4848, 80, 13, 35510, 44, 62, 37, 2200, 48, 62, 26442, 25, 3126, 1635, 1987, 11]"
‚úÖ Best Practice: Import statements should be explicitly listed at the top of the file for clarity.,"[26486, 227, 6705, 19939, 25, 17267, 6299, 815, 307, 11777, 5610, 379, 262, 1353, 286, 262, 2393, 329, 16287, 13]",1.0,874,best_practice,217,Import statements should be explicitly listed at the top of the file for clarity.,,848,"            Freq.NORM_FREQ_MINUTE: 1,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4848, 80, 13, 35510, 44, 62, 37, 2200, 48, 62, 23678, 37780, 25, 352, 11]"
‚úÖ Best Practice: Use of type hints improves code readability and maintainability.,"[26486, 227, 6705, 19939, 25, 5765, 286, 2099, 20269, 19575, 2438, 1100, 1799, 290, 5529, 1799, 13]",1.0,901,best_practice,218,Use of type hints improves code readability and maintainability.,,874,"            Freq.NORM_FREQ_DAY: 60 * 24,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4848, 80, 13, 35510, 44, 62, 37, 2200, 48, 62, 26442, 25, 3126, 1635, 1987, 11]"
üß† ML Signal: Checking the type of a variable to handle different input formats.,"[8582, 100, 254, 10373, 26484, 25, 39432, 262, 2099, 286, 257, 7885, 284, 5412, 1180, 5128, 17519, 13]",0.5,933,ml_signal,220,Checking the type of a variable to handle different input formats.,,901,"            Freq.NORM_FREQ_MONTH: 30 * 7 * 60 * 24,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4848, 80, 13, 35510, 44, 62, 37, 2200, 48, 62, 27857, 4221, 25, 1542, 1635, 767, 1635, 3126, 1635, 1987, 11]"
‚úÖ Best Practice: Using strptime for parsing strings into datetime objects is a standard practice.,"[26486, 227, 6705, 19939, 25, 8554, 965, 457, 524, 329, 32096, 13042, 656, 4818, 8079, 5563, 318, 257, 3210, 3357, 13]",0.5,953,best_practice,222,Using strptime for parsing strings into datetime objects is a standard practice.,,933,        left_freq = Freq(left_frq),"[220, 220, 220, 220, 220, 220, 220, 1364, 62, 19503, 80, 796, 4848, 80, 7, 9464, 62, 8310, 80, 8]"
"üß† ML Signal: Conditional logic based on region, indicating region-specific behavior.","[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 3814, 11, 12739, 3814, 12, 11423, 4069, 13]",0.5,973,ml_signal,224,"Conditional logic based on region, indicating region-specific behavior.",,953,        right_freq = Freq(right_freq),"[220, 220, 220, 220, 220, 220, 220, 826, 62, 19503, 80, 796, 4848, 80, 7, 3506, 62, 19503, 80, 8]"
üß† ML Signal: Time range checks for specific business logic.,"[8582, 100, 254, 10373, 26484, 25, 3862, 2837, 8794, 329, 2176, 1597, 9156, 13]",0.5,990,ml_signal,226,Time range checks for specific business logic.,,973,        return left_minutes - right_minutes,"[220, 220, 220, 220, 220, 220, 220, 1441, 1364, 62, 1084, 1769, 532, 826, 62, 1084, 1769]"
‚úÖ Best Practice: Using total_seconds() for time difference calculations is precise.,"[26486, 227, 6705, 19939, 25, 8554, 2472, 62, 43012, 3419, 329, 640, 3580, 16765, 318, 7141, 13]",0.5,996,best_practice,228,Using total_seconds() for time difference calculations is precise.,,990,    @staticmethod,"[220, 220, 220, 2488, 12708, 24396]"
‚ö†Ô∏è SAST Risk (Low): Potential information disclosure through error messages.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 1321, 13019, 832, 4049, 6218, 13]",0.5,1005,sast_risk,233,Potential information disclosure through error messages.,Low,996,        ----------,"[220, 220, 220, 220, 220, 220, 220, 24200, 438]"
‚ö†Ô∏è SAST Risk (Low): Potential information disclosure through error messages.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 1321, 13019, 832, 4049, 6218, 13]",0.5,1018,sast_risk,239,Potential information disclosure through error messages.,Low,1005,        if the recent frequency is found,"[220, 220, 220, 220, 220, 220, 220, 611, 262, 2274, 8373, 318, 1043]"
‚ö†Ô∏è SAST Risk (Low): Potential information disclosure through error messages.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 1321, 13019, 832, 4049, 6218, 13]",0.5,1031,sast_risk,240,Potential information disclosure through error messages.,Low,1018,            Freq,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4848, 80]"
‚ö†Ô∏è SAST Risk (Low): Potential information disclosure through error messages.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 1321, 13019, 832, 4049, 6218, 13]",0.5,1053,sast_risk,255,Potential information disclosure through error messages.,Low,1031,        return min_freq[1] if min_freq else None,"[220, 220, 220, 220, 220, 220, 220, 1441, 949, 62, 19503, 80, 58, 16, 60, 611, 949, 62, 19503, 80, 2073, 6045]"
‚úÖ Best Practice: Include type hints for function parameters and return type for better readability and maintainability,"[26486, 227, 6705, 19939, 25, 40348, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799]",1.0,1066,best_practice,239,Include type hints for function parameters and return type for better readability and maintainability,,1053,        if the recent frequency is found,"[220, 220, 220, 220, 220, 220, 220, 611, 262, 2274, 8373, 318, 1043]"
‚ö†Ô∏è SAST Risk (Low): Potential for incorrect time parsing if input format is not as expected,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 11491, 640, 32096, 611, 5128, 5794, 318, 407, 355, 2938]",1.0,1066,sast_risk,256,Potential for incorrect time parsing if input format is not as expected,Low,1066,,[]
‚ö†Ô∏è SAST Risk (Low): Potential for incorrect time parsing if input format is not as expected,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 11491, 640, 32096, 611, 5128, 5794, 318, 407, 355, 2938]",1.0,1094,sast_risk,258,Potential for incorrect time parsing if input format is not as expected,Low,1066,"def time_to_day_index(time_obj: Union[str, datetime], region: str = REG_CN):","[4299, 640, 62, 1462, 62, 820, 62, 9630, 7, 2435, 62, 26801, 25, 4479, 58, 2536, 11, 4818, 8079, 4357, 3814, 25, 965, 796, 23337, 62, 44175, 2599]"
"üß† ML Signal: Usage of custom frequency object, could indicate domain-specific logic","[8582, 100, 254, 10373, 26484, 25, 29566, 286, 2183, 8373, 2134, 11, 714, 7603, 7386, 12, 11423, 9156]",1.0,1122,ml_signal,260,"Usage of custom frequency object, could indicate domain-specific logic",,1094,"        time_obj = datetime.strptime(time_obj, ""%H:%M"")","[220, 220, 220, 220, 220, 220, 220, 640, 62, 26801, 796, 4818, 8079, 13, 2536, 457, 524, 7, 2435, 62, 26801, 11, 36521, 39, 25, 4, 44, 4943]"
"üß† ML Signal: Usage of region-specific calendar, could indicate domain-specific logic","[8582, 100, 254, 10373, 26484, 25, 29566, 286, 3814, 12, 11423, 11845, 11, 714, 7603, 7386, 12, 11423, 9156]",0.5,1132,ml_signal,262,"Usage of region-specific calendar, could indicate domain-specific logic",,1122,    if region == REG_CN:,"[220, 220, 220, 611, 3814, 6624, 23337, 62, 44175, 25]"
‚úÖ Best Practice: Use of bisect module for efficient searching in sorted lists,"[26486, 227, 6705, 19939, 25, 5765, 286, 47457, 478, 8265, 329, 6942, 10342, 287, 23243, 8341]",0.5,1157,best_practice,263,Use of bisect module for efficient searching in sorted lists,,1132,        if CN_TIME[0] <= time_obj < CN_TIME[1]:,"[220, 220, 220, 220, 220, 220, 220, 611, 31171, 62, 34694, 58, 15, 60, 19841, 640, 62, 26801, 1279, 31171, 62, 34694, 58, 16, 5974]"
‚úÖ Best Practice: Use of bisect module for efficient searching in sorted lists,"[26486, 227, 6705, 19939, 25, 5765, 286, 47457, 478, 8265, 329, 6942, 10342, 287, 23243, 8341]",0.5,1182,best_practice,263,Use of bisect module for efficient searching in sorted lists,,1157,        if CN_TIME[0] <= time_obj < CN_TIME[1]:,"[220, 220, 220, 220, 220, 220, 220, 611, 31171, 62, 34694, 58, 15, 60, 19841, 640, 62, 26801, 1279, 31171, 62, 34694, 58, 16, 5974]"
‚úÖ Best Practice: Type hints for function parameters and return type improve code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 20269, 329, 2163, 10007, 290, 1441, 2099, 2987, 2438, 1100, 1799, 290, 5529, 1799]",1.0,1192,best_practice,262,Type hints for function parameters and return type improve code readability and maintainability,,1182,    if region == REG_CN:,"[220, 220, 220, 611, 3814, 6624, 23337, 62, 44175, 25]"
üß† ML Signal: Usage of pd.Timestamp indicates interaction with pandas for date-time operations,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 279, 67, 13, 14967, 27823, 9217, 10375, 351, 19798, 292, 329, 3128, 12, 2435, 4560]",1.0,1217,ml_signal,263,Usage of pd.Timestamp indicates interaction with pandas for date-time operations,,1192,        if CN_TIME[0] <= time_obj < CN_TIME[1]:,"[220, 220, 220, 220, 220, 220, 220, 611, 31171, 62, 34694, 58, 15, 60, 19841, 640, 62, 26801, 1279, 31171, 62, 34694, 58, 16, 5974]"
‚úÖ Best Practice: Using datetime constructor for explicit date-time creation,"[26486, 227, 6705, 19939, 25, 8554, 4818, 8079, 23772, 329, 7952, 3128, 12, 2435, 6282]",1.0,1242,best_practice,263,Using datetime constructor for explicit date-time creation,,1217,        if CN_TIME[0] <= time_obj < CN_TIME[1]:,"[220, 220, 220, 220, 220, 220, 220, 611, 31171, 62, 34694, 58, 15, 60, 19841, 640, 62, 26801, 1279, 31171, 62, 34694, 58, 16, 5974]"
‚úÖ Best Practice: Include type hints for function parameters and return type for better readability and maintainability.,"[26486, 227, 6705, 19939, 25, 40348, 2099, 20269, 329, 2163, 10007, 290, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799, 13]",0.5,1253,best_practice,274,Include type hints for function parameters and return type for better readability and maintainability.,,1242,    elif region == REG_TW:,"[220, 220, 220, 1288, 361, 3814, 6624, 23337, 62, 34551, 25]"
‚ö†Ô∏è SAST Risk (Medium): Ensure that get_min_cal and C.min_data_shift are properly validated to prevent potential misuse or errors.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 31205, 2599, 48987, 326, 651, 62, 1084, 62, 9948, 290, 327, 13, 1084, 62, 7890, 62, 30846, 389, 6105, 31031, 284, 2948, 2785, 29169, 393, 8563, 13]",0.5,1260,sast_risk,292,Ensure that get_min_cal and C.min_data_shift are properly validated to prevent potential misuse or errors.,Medium,1253,    freq : str,"[220, 220, 220, 2030, 80, 1058, 965]"
‚ö†Ô∏è SAST Risk (Low): Ensure that the index calculation does not result in an out-of-bounds error.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 48987, 326, 262, 6376, 17952, 857, 407, 1255, 287, 281, 503, 12, 1659, 12, 65, 3733, 4049, 13]",0.5,1260,sast_risk,294,Ensure that the index calculation does not result in an out-of-bounds error.,Low,1260,,[]
‚ö†Ô∏è SAST Risk (Low): Ensure that concat_date_time handles edge cases and invalid inputs gracefully.,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 48987, 326, 1673, 265, 62, 4475, 62, 2435, 17105, 5743, 2663, 290, 12515, 17311, 11542, 2759, 13]",0.5,1264,sast_risk,296,Ensure that concat_date_time handles edge cases and invalid inputs gracefully.,Low,1260,    -------,"[220, 220, 220, 35656]"
‚úÖ Best Practice: Use of clear conditional statements for direction handling,"[26486, 227, 6705, 19939, 25, 5765, 286, 1598, 26340, 6299, 329, 4571, 9041]",1.0,1274,best_practice,311,Use of clear conditional statements for direction handling,,1264,        datetime(,"[220, 220, 220, 220, 220, 220, 220, 4818, 8079, 7]"
‚úÖ Best Practice: Use of pd.Timedelta for time manipulation,"[26486, 227, 6705, 19939, 25, 5765, 286, 279, 67, 13, 14967, 276, 12514, 329, 640, 17512]",0.5,1293,best_practice,313,Use of pd.Timedelta for time manipulation,,1274,"            month=date_obj.month,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1227, 28, 4475, 62, 26801, 13, 8424, 11]"
‚úÖ Best Practice: Use of pd.Timedelta for time manipulation,"[26486, 227, 6705, 19939, 25, 5765, 286, 279, 67, 13, 14967, 276, 12514, 329, 640, 17512]",0.5,1312,best_practice,316,Use of pd.Timedelta for time manipulation,,1293,"            minute=time_obj.minute,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 5664, 28, 2435, 62, 26801, 13, 11374, 11]"
‚ö†Ô∏è SAST Risk (Low): Error message could be more descriptive,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 13047, 3275, 714, 307, 517, 35644]",0.5,1333,sast_risk,318,Error message could be more descriptive,Low,1312,"            microsecond=time_obj.microsecond,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4580, 12227, 28, 2435, 62, 26801, 13, 24055, 12227, 11]"
‚ö†Ô∏è SAST Risk (Medium): Missing import statement for pd (pandas),"[158, 248, 254, 37929, 311, 11262, 19602, 357, 31205, 2599, 25639, 1330, 2643, 329, 279, 67, 357, 79, 392, 292, 8]",0.5,1354,sast_risk,318,Missing import statement for pd (pandas),Medium,1333,"            microsecond=time_obj.microsecond,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4580, 12227, 28, 2435, 62, 26801, 13, 24055, 12227, 11]"
‚ö†Ô∏è SAST Risk (Medium): Undefined function 'get_day_min_idx_range' and variable 'REG_CN',"[158, 248, 254, 37929, 311, 11262, 19602, 357, 31205, 2599, 13794, 18156, 2163, 705, 1136, 62, 820, 62, 1084, 62, 312, 87, 62, 9521, 6, 290, 7885, 705, 31553, 62, 44175, 6]",1.0,1375,sast_risk,318,Undefined function 'get_day_min_idx_range' and variable 'REG_CN',Medium,1354,"            microsecond=time_obj.microsecond,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4580, 12227, 28, 2435, 62, 26801, 13, 24055, 12227, 11]"
üß† ML Signal: Example of function usage in a main block,"[8582, 100, 254, 10373, 26484, 25, 17934, 286, 2163, 8748, 287, 257, 1388, 2512]",0.5,1396,ml_signal,318,Example of function usage in a main block,,1375,"            microsecond=time_obj.microsecond,","[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 4580, 12227, 28, 2435, 62, 26801, 13, 24055, 12227, 11]"
