[
  {
    "line": 1,
    "text": "# Copyright (c) Microsoft Corporation.",
    "annotation": "\u2705 Best Practice: Use of lru_cache to cache results and improve performance for repeated function calls",
    "confidence": 0.5,
    "tokens": [
      2,
      15069,
      357,
      66,
      8,
      5413,
      10501,
      13
    ],
    "start_token": 0,
    "end_token": 8,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      300,
      622,
      62,
      23870,
      284,
      12940,
      2482,
      290,
      2987,
      2854,
      329,
      5100,
      2163,
      3848
    ],
    "label": "best_practice",
    "reason": "Use of lru_cache to cache results and improve performance for repeated function calls"
  },
  {
    "line": 12,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Use of datetime.combine to create datetime objects from date and time",
    "confidence": 0.5,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 8,
    "end_token": 14,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4818,
      8079,
      13,
      24011,
      500,
      284,
      2251,
      4818,
      8079,
      5563,
      422,
      3128,
      290,
      640
    ],
    "label": "best_practice",
    "reason": "Use of datetime.combine to create datetime objects from date and time"
  },
  {
    "line": 19,
    "text": "    datetime.strptime(\"9:30\", \"%H:%M\"),",
    "annotation": "\u2705 Best Practice: Use of datetime.now to get the current time",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4818,
      8079,
      13,
      2536,
      457,
      524,
      7203,
      24,
      25,
      1270,
      1600,
      36521,
      39,
      25,
      4,
      44,
      12340
    ],
    "start_token": 14,
    "end_token": 34,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4818,
      8079,
      13,
      2197,
      284,
      651,
      262,
      1459,
      640
    ],
    "label": "best_practice",
    "reason": "Use of datetime.now to get the current time"
  },
  {
    "line": 25,
    "text": "TW_TIME = [",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking if a time falls within a specific range",
    "confidence": 0.5,
    "tokens": [
      34551,
      62,
      34694,
      796,
      685
    ],
    "start_token": 34,
    "end_token": 39,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      611,
      257,
      640,
      8953,
      1626,
      257,
      2176,
      2837
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking if a time falls within a specific range"
  },
  {
    "line": 45,
    "text": "    -------",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of finding the next available time slot",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      35656
    ],
    "start_token": 39,
    "end_token": 43,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      4917,
      262,
      1306,
      1695,
      640,
      10852
    ],
    "label": "ml_signal",
    "reason": "Pattern of finding the next available time slot"
  },
  {
    "line": 50,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of timedelta to add days to a date",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 43,
    "end_token": 43,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      28805,
      12514,
      284,
      751,
      1528,
      284,
      257,
      3128
    ],
    "label": "best_practice",
    "reason": "Use of timedelta to add days to a date"
  },
  {
    "line": 55,
    "text": "            pd.date_range(CN_TIME[2], CN_TIME[3] - timedelta(minutes=1), freq=\"1min\") - pd.Timedelta(minutes=shift)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of ValueError if time_str is not in the expected format",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7,
      44175,
      62,
      34694,
      58,
      17,
      4357,
      31171,
      62,
      34694,
      58,
      18,
      60,
      532,
      28805,
      12514,
      7,
      1084,
      1769,
      28,
      16,
      828,
      2030,
      80,
      2625,
      16,
      1084,
      4943,
      532,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      1084,
      1769,
      28,
      30846,
      8
    ],
    "start_token": 43,
    "end_token": 101,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      11052,
      12331,
      611,
      640,
      62,
      2536,
      318,
      407,
      287,
      262,
      2938,
      5794
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of ValueError if time_str is not in the expected format"
  },
  {
    "line": 58,
    "text": "    elif region == REG_TW:",
    "annotation": "\u2705 Best Practice: Use of strftime to format datetime objects as strings",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1288,
      361,
      3814,
      6624,
      23337,
      62,
      34551,
      25
    ],
    "start_token": 101,
    "end_token": 112,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      965,
      31387,
      284,
      5794,
      4818,
      8079,
      5563,
      355,
      13042
    ],
    "label": "best_practice",
    "reason": "Use of strftime to format datetime objects as strings"
  },
  {
    "line": 60,
    "text": "            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=\"1min\") - pd.Timedelta(minutes=shift)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk of ValueError if date strings are not in the expected format",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7,
      34551,
      62,
      34694,
      58,
      15,
      4357,
      17306,
      62,
      34694,
      58,
      16,
      60,
      532,
      28805,
      12514,
      7,
      1084,
      1769,
      28,
      16,
      828,
      2030,
      80,
      2625,
      16,
      1084,
      4943,
      532,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      1084,
      1769,
      28,
      30846,
      8
    ],
    "start_token": 112,
    "end_token": 170,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      286,
      11052,
      12331,
      611,
      3128,
      13042,
      389,
      407,
      287,
      262,
      2938,
      5794
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk of ValueError if date strings are not in the expected format"
  },
  {
    "line": 60,
    "text": "            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=\"1min\") - pd.Timedelta(minutes=shift)",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of generating a list of dates within a range",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7,
      34551,
      62,
      34694,
      58,
      15,
      4357,
      17306,
      62,
      34694,
      58,
      16,
      60,
      532,
      28805,
      12514,
      7,
      1084,
      1769,
      28,
      16,
      828,
      2030,
      80,
      2625,
      16,
      1084,
      4943,
      532,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      1084,
      1769,
      28,
      30846,
      8
    ],
    "start_token": 170,
    "end_token": 228,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      15453,
      257,
      1351,
      286,
      9667,
      1626,
      257,
      2837
    ],
    "label": "ml_signal",
    "reason": "Pattern of generating a list of dates within a range"
  },
  {
    "line": 24,
    "text": "US_TIME = [datetime.strptime(\"9:30\", \"%H:%M\"), datetime.strptime(\"16:00\", \"%H:%M\")]",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      2937,
      62,
      34694,
      796,
      685,
      19608,
      8079,
      13,
      2536,
      457,
      524,
      7203,
      24,
      25,
      1270,
      1600,
      36521,
      39,
      25,
      4,
      44,
      12340,
      4818,
      8079,
      13,
      2536,
      457,
      524,
      7203,
      1433,
      25,
      405,
      1600,
      36521,
      39,
      25,
      4,
      44,
      4943,
      60
    ],
    "start_token": 228,
    "end_token": 268,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 40,
    "text": "        series.shift(1) will replace the value at `i`-th with the one at `i-1`-th",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on region can indicate regional-specific behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2168,
      13,
      30846,
      7,
      16,
      8,
      481,
      6330,
      262,
      1988,
      379,
      4600,
      72,
      63,
      12,
      400,
      351,
      262,
      530,
      379,
      4600,
      72,
      12,
      16,
      63,
      12,
      400
    ],
    "start_token": 268,
    "end_token": 302,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      3814,
      460,
      7603,
      7915,
      12,
      11423,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on region can indicate regional-specific behavior."
  },
  {
    "line": 50,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on region can indicate regional-specific behavior.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 302,
    "end_token": 302,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      3814,
      460,
      7603,
      7915,
      12,
      11423,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on region can indicate regional-specific behavior."
  },
  {
    "line": 55,
    "text": "            pd.date_range(CN_TIME[2], CN_TIME[3] - timedelta(minutes=1), freq=\"1min\") - pd.Timedelta(minutes=shift)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on region can indicate regional-specific behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7,
      44175,
      62,
      34694,
      58,
      17,
      4357,
      31171,
      62,
      34694,
      58,
      18,
      60,
      532,
      28805,
      12514,
      7,
      1084,
      1769,
      28,
      16,
      828,
      2030,
      80,
      2625,
      16,
      1084,
      4943,
      532,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      1084,
      1769,
      28,
      30846,
      8
    ],
    "start_token": 302,
    "end_token": 360,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      3814,
      460,
      7603,
      7915,
      12,
      11423,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on region can indicate regional-specific behavior."
  },
  {
    "line": 60,
    "text": "            pd.date_range(TW_TIME[0], TW_TIME[1] - timedelta(minutes=1), freq=\"1min\") - pd.Timedelta(minutes=shift)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Raising a ValueError for unsupported regions is good, but consider logging the error for better traceability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      279,
      67,
      13,
      4475,
      62,
      9521,
      7,
      34551,
      62,
      34694,
      58,
      15,
      4357,
      17306,
      62,
      34694,
      58,
      16,
      60,
      532,
      28805,
      12514,
      7,
      1084,
      1769,
      28,
      16,
      828,
      2030,
      80,
      2625,
      16,
      1084,
      4943,
      532,
      279,
      67,
      13,
      14967,
      276,
      12514,
      7,
      1084,
      1769,
      28,
      30846,
      8
    ],
    "start_token": 360,
    "end_token": 418,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      7567,
      1710,
      257,
      11052,
      12331,
      329,
      24222,
      7652,
      318,
      922,
      11,
      475,
      2074,
      18931,
      262,
      4049,
      329,
      1365,
      12854,
      1799,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Raising a ValueError for unsupported regions is good, but consider logging the error for better traceability."
  },
  {
    "line": 59,
    "text": "        for ts in list(",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The function assumes that `REG_CN`, `REG_TW`, and `REG_US` are defined elsewhere, which could lead to a NameError if they are not.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      40379,
      287,
      1351,
      7
    ],
    "start_token": 418,
    "end_token": 430,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      2163,
      18533,
      326,
      4600,
      31553,
      62,
      44175,
      47671,
      4600,
      31553,
      62,
      34551,
      47671,
      290,
      4600,
      31553,
      62,
      2937,
      63,
      389,
      5447,
      8057,
      11,
      543,
      714,
      1085,
      284,
      257,
      6530,
      12331,
      611,
      484,
      389,
      407,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The function assumes that `REG_CN`, `REG_TW`, and `REG_US` are defined elsewhere, which could lead to a NameError if they are not."
  },
  {
    "line": 97,
    "text": "        return False",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using `NotImplementedError` for unsupported regions without logging or handling can lead to unhandled exceptions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      10352
    ],
    "start_token": 430,
    "end_token": 439,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      4600,
      3673,
      3546,
      1154,
      12061,
      12331,
      63,
      329,
      24222,
      7652,
      1231,
      18931,
      393,
      9041,
      460,
      1085,
      284,
      555,
      38788,
      13269,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using `NotImplementedError` for unsupported regions without logging or handling can lead to unhandled exceptions."
  },
  {
    "line": 98,
    "text": "    elif region == REG_TW:",
    "annotation": "\u2705 Best Practice: Use of class constants for fixed values improves readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1288,
      361,
      3814,
      6624,
      23337,
      62,
      34551,
      25
    ],
    "start_token": 439,
    "end_token": 450,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      38491,
      329,
      5969,
      3815,
      19575,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of class constants for fixed values improves readability and maintainability"
  },
  {
    "line": 103,
    "text": "        return False",
    "annotation": "\u2705 Best Practice: Storing related constants in a list for easy access and modification",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      10352
    ],
    "start_token": 450,
    "end_token": 459,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      520,
      3255,
      3519,
      38491,
      287,
      257,
      1351,
      329,
      2562,
      1895,
      290,
      17613
    ],
    "label": "best_practice",
    "reason": "Storing related constants in a list for easy access and modification"
  },
  {
    "line": 104,
    "text": "    elif region == REG_US:",
    "annotation": "\ud83e\udde0 ML Signal: Type checking and branching based on type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1288,
      361,
      3814,
      6624,
      23337,
      62,
      2937,
      25
    ],
    "start_token": 459,
    "end_token": 470,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      10627,
      290,
      49526,
      1912,
      319,
      2099
    ],
    "label": "ml_signal",
    "reason": "Type checking and branching based on type"
  },
  {
    "line": 106,
    "text": "            return True",
    "annotation": "\ud83e\udde0 ML Signal: Method call with string input",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6407
    ],
    "start_token": 470,
    "end_token": 483,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      351,
      4731,
      5128
    ],
    "label": "ml_signal",
    "reason": "Method call with string input"
  },
  {
    "line": 107,
    "text": "        if start_time.hour == 15 and start_time.minute == 59 and start_time.second == 0:",
    "annotation": "\ud83e\udde0 ML Signal: Type checking and branching based on type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      923,
      62,
      2435,
      13,
      9769,
      6624,
      1315,
      290,
      923,
      62,
      2435,
      13,
      11374,
      6624,
      7863,
      290,
      923,
      62,
      2435,
      13,
      12227,
      6624,
      657,
      25
    ],
    "start_token": 483,
    "end_token": 515,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5994,
      10627,
      290,
      49526,
      1912,
      319,
      2099
    ],
    "label": "ml_signal",
    "reason": "Type checking and branching based on type"
  },
  {
    "line": 110,
    "text": "    else:",
    "annotation": "\ud83e\udde0 ML Signal: Attribute access from object",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 515,
    "end_token": 520,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3460,
      4163,
      1895,
      422,
      2134
    ],
    "label": "ml_signal",
    "reason": "Attribute access from object"
  },
  {
    "line": 113,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of NotImplementedError for unsupported types",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 520,
    "end_token": 520,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      1892,
      3546,
      1154,
      12061,
      12331,
      329,
      24222,
      3858
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of NotImplementedError for unsupported types"
  },
  {
    "line": 110,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Use of a special method to define equality behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 520,
    "end_token": 525,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2041,
      2446,
      284,
      8160,
      10537,
      4069
    ],
    "label": "best_practice",
    "reason": "Use of a special method to define equality behavior"
  },
  {
    "line": 112,
    "text": "",
    "annotation": "\u2705 Best Practice: Converting input to a specific type for consistent comparison",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 525,
    "end_token": 525,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      5128,
      284,
      257,
      2176,
      2099,
      329,
      6414,
      7208
    ],
    "label": "best_practice",
    "reason": "Converting input to a specific type for consistent comparison"
  },
  {
    "line": 114,
    "text": "class Freq:",
    "annotation": "\ud83e\udde0 ML Signal: Use of logical operators for comparison",
    "confidence": 0.5,
    "tokens": [
      4871,
      4848,
      80,
      25
    ],
    "start_token": 525,
    "end_token": 529,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      12219,
      12879,
      329,
      7208
    ],
    "label": "ml_signal",
    "reason": "Use of logical operators for comparison"
  },
  {
    "line": 113,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of f-string for string formatting improves readability and performance",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 529,
    "end_token": 529,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      277,
      12,
      8841,
      329,
      4731,
      33313,
      19575,
      1100,
      1799,
      290,
      2854
    ],
    "label": "best_practice",
    "reason": "Use of f-string for string formatting improves readability and performance"
  },
  {
    "line": 115,
    "text": "    NORM_FREQ_MONTH = \"month\"",
    "annotation": "\u2705 Best Practice: Ternary conditional operator used for concise conditional logic",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      25273,
      44,
      62,
      37,
      2200,
      48,
      62,
      27857,
      4221,
      796,
      366,
      8424,
      1
    ],
    "start_token": 529,
    "end_token": 545,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      309,
      1142,
      560,
      26340,
      10088,
      973,
      329,
      35327,
      26340,
      9156
    ],
    "label": "best_practice",
    "reason": "Ternary conditional operator used for concise conditional logic"
  },
  {
    "line": 116,
    "text": "    NORM_FREQ_WEEK = \"week\"",
    "annotation": "\u2705 Best Practice: Use of __repr__ for unambiguous object representation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      25273,
      44,
      62,
      37,
      2200,
      48,
      62,
      54,
      33823,
      796,
      366,
      10464,
      1
    ],
    "start_token": 545,
    "end_token": 561,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      260,
      1050,
      834,
      329,
      42053,
      29709,
      2134,
      10552
    ],
    "label": "best_practice",
    "reason": "Use of __repr__ for unambiguous object representation"
  },
  {
    "line": 119,
    "text": "    SUPPORT_CAL_LIST = [NORM_FREQ_MINUTE, NORM_FREQ_DAY]  # FIXME: this list should from data",
    "annotation": "\u2705 Best Practice: Use of @staticmethod for methods that do not access instance or class data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      43333,
      62,
      34,
      1847,
      62,
      45849,
      796,
      685,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      23678,
      37780,
      11,
      25273,
      44,
      62,
      37,
      2200,
      48,
      62,
      26442,
      60,
      220,
      1303,
      44855,
      11682,
      25,
      428,
      1351,
      815,
      422,
      1366
    ],
    "start_token": 561,
    "end_token": 601,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      12708,
      24396,
      329,
      5050,
      326,
      466,
      407,
      1895,
      4554,
      393,
      1398,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of @staticmethod for methods that do not access instance or class data"
  },
  {
    "line": 139,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of regex to validate input format",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 601,
    "end_token": 601,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      40364,
      284,
      26571,
      5128,
      5794
    ],
    "label": "best_practice",
    "reason": "Use of regex to validate input format"
  },
  {
    "line": 141,
    "text": "    def parse(freq: str) -> Tuple[int, str]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for denial of service if input is not validated before regex",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      21136,
      7,
      19503,
      80,
      25,
      965,
      8,
      4613,
      309,
      29291,
      58,
      600,
      11,
      965,
      5974
    ],
    "start_token": 601,
    "end_token": 620,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      14425,
      286,
      2139,
      611,
      5128,
      318,
      407,
      31031,
      878,
      40364
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for denial of service if input is not validated before regex"
  },
  {
    "line": 146,
    "text": "        ----------",
    "annotation": "\u2705 Best Practice: Use of conditional expression to handle optional numeric input",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 620,
    "end_token": 629,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      26340,
      5408,
      284,
      5412,
      11902,
      35575,
      5128
    ],
    "label": "best_practice",
    "reason": "Use of conditional expression to handle optional numeric input"
  },
  {
    "line": 159,
    "text": "                    (1, \"day\" )",
    "annotation": "\ud83e\udde0 ML Signal: Mapping of input strings to normalized frequency values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      357,
      16,
      11,
      366,
      820,
      1,
      1267
    ],
    "start_token": 629,
    "end_token": 655,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      286,
      5128,
      13042,
      284,
      39279,
      8373,
      3815
    ],
    "label": "ml_signal",
    "reason": "Mapping of input strings to normalized frequency values"
  },
  {
    "line": 159,
    "text": "                    (1, \"day\" )",
    "annotation": "\u2705 Best Practice: Function docstring provides clear documentation of parameters and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      357,
      16,
      11,
      366,
      820,
      1,
      1267
    ],
    "start_token": 655,
    "end_token": 681,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15553,
      2205,
      8841,
      3769,
      1598,
      10314,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Function docstring provides clear documentation of parameters and return type"
  },
  {
    "line": 170,
    "text": "                \"freq format is not supported, the freq should be like (n)month/mon, (n)week/w, (n)day/d, (n)minute/min\"",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pd.Timedelta indicates working with time-based data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      19503,
      80,
      5794,
      318,
      407,
      4855,
      11,
      262,
      2030,
      80,
      815,
      307,
      588,
      357,
      77,
      8,
      8424,
      14,
      2144,
      11,
      357,
      77,
      8,
      10464,
      14,
      86,
      11,
      357,
      77,
      8,
      820,
      14,
      67,
      11,
      357,
      77,
      8,
      11374,
      14,
      1084,
      1
    ],
    "start_token": 681,
    "end_token": 738,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      279,
      67,
      13,
      14967,
      276,
      12514,
      9217,
      1762,
      351,
      640,
      12,
      3106,
      1366
    ],
    "label": "ml_signal",
    "reason": "Usage of pd.Timedelta indicates working with time-based data"
  },
  {
    "line": 181,
    "text": "            \"minute\": Freq.NORM_FREQ_MINUTE,",
    "annotation": "\u2705 Best Practice: Use of a dictionary for mapping frequency to minutes improves readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      11374,
      1298,
      4848,
      80,
      13,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      23678,
      37780,
      11
    ],
    "start_token": 738,
    "end_token": 765,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      22155,
      329,
      16855,
      8373,
      284,
      2431,
      19575,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of a dictionary for mapping frequency to minutes improves readability and maintainability"
  },
  {
    "line": 188,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of string to Freq object indicates a pattern of data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 765,
    "end_token": 773,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      4731,
      284,
      4848,
      80,
      2134,
      9217,
      257,
      3912,
      286,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Conversion of string to Freq object indicates a pattern of data transformation"
  },
  {
    "line": 190,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of minutes from frequency shows a pattern of data manipulation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 773,
    "end_token": 773,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      2431,
      422,
      8373,
      2523,
      257,
      3912,
      286,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Calculation of minutes from frequency shows a pattern of data manipulation"
  },
  {
    "line": 191,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of string to Freq object indicates a pattern of data transformation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 773,
    "end_token": 781,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      4731,
      284,
      4848,
      80,
      2134,
      9217,
      257,
      3912,
      286,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Conversion of string to Freq object indicates a pattern of data transformation"
  },
  {
    "line": 194,
    "text": "        freq : str",
    "annotation": "\ud83e\udde0 ML Signal: Calculation of minutes from frequency shows a pattern of data manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      1058,
      965
    ],
    "start_token": 781,
    "end_token": 792,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2199,
      14902,
      286,
      2431,
      422,
      8373,
      2523,
      257,
      3912,
      286,
      1366,
      17512
    ],
    "label": "ml_signal",
    "reason": "Calculation of minutes from frequency shows a pattern of data manipulation"
  },
  {
    "line": 194,
    "text": "        freq : str",
    "annotation": "\ud83e\udde0 ML Signal: Returning the difference between two calculated values is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2030,
      80,
      1058,
      965
    ],
    "start_token": 792,
    "end_token": 803,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      262,
      3580,
      1022,
      734,
      10488,
      3815,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Returning the difference between two calculated values is a common pattern"
  },
  {
    "line": 193,
    "text": "        n : int",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      299,
      1058,
      493
    ],
    "start_token": 803,
    "end_token": 813,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability"
  },
  {
    "line": 207,
    "text": "        Parameters",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of input to a specific type (Freq) indicates a pattern of data normalization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      40117
    ],
    "start_token": 813,
    "end_token": 821,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      5128,
      284,
      257,
      2176,
      2099,
      357,
      20366,
      80,
      8,
      9217,
      257,
      3912,
      286,
      1366,
      3487,
      1634
    ],
    "label": "ml_signal",
    "reason": "Conversion of input to a specific type (Freq) indicates a pattern of data normalization"
  },
  {
    "line": 211,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a method to calculate a delta or difference is a common pattern in data processing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 821,
    "end_token": 821,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2446,
      284,
      15284,
      257,
      25979,
      393,
      3580,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of a method to calculate a delta or difference is a common pattern in data processing"
  },
  {
    "line": 218,
    "text": "            Freq.NORM_FREQ_DAY: 60 * 24,",
    "annotation": "\u2705 Best Practice: Use of tuple unpacking for readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4848,
      80,
      13,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      26442,
      25,
      3126,
      1635,
      1987,
      11
    ],
    "start_token": 821,
    "end_token": 848,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      46545,
      8593,
      5430,
      329,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of tuple unpacking for readability"
  },
  {
    "line": 217,
    "text": "            Freq.NORM_FREQ_MINUTE: 1,",
    "annotation": "\u2705 Best Practice: Import statements should be explicitly listed at the top of the file for clarity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4848,
      80,
      13,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      23678,
      37780,
      25,
      352,
      11
    ],
    "start_token": 848,
    "end_token": 874,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      6299,
      815,
      307,
      11777,
      5610,
      379,
      262,
      1353,
      286,
      262,
      2393,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Import statements should be explicitly listed at the top of the file for clarity."
  },
  {
    "line": 218,
    "text": "            Freq.NORM_FREQ_DAY: 60 * 24,",
    "annotation": "\u2705 Best Practice: Use of type hints improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4848,
      80,
      13,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      26442,
      25,
      3126,
      1635,
      1987,
      11
    ],
    "start_token": 874,
    "end_token": 901,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints improves code readability and maintainability."
  },
  {
    "line": 220,
    "text": "            Freq.NORM_FREQ_MONTH: 30 * 7 * 60 * 24,",
    "annotation": "\ud83e\udde0 ML Signal: Checking the type of a variable to handle different input formats.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4848,
      80,
      13,
      35510,
      44,
      62,
      37,
      2200,
      48,
      62,
      27857,
      4221,
      25,
      1542,
      1635,
      767,
      1635,
      3126,
      1635,
      1987,
      11
    ],
    "start_token": 901,
    "end_token": 933,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      262,
      2099,
      286,
      257,
      7885,
      284,
      5412,
      1180,
      5128,
      17519,
      13
    ],
    "label": "ml_signal",
    "reason": "Checking the type of a variable to handle different input formats."
  },
  {
    "line": 222,
    "text": "        left_freq = Freq(left_frq)",
    "annotation": "\u2705 Best Practice: Using strptime for parsing strings into datetime objects is a standard practice.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1364,
      62,
      19503,
      80,
      796,
      4848,
      80,
      7,
      9464,
      62,
      8310,
      80,
      8
    ],
    "start_token": 933,
    "end_token": 953,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      965,
      457,
      524,
      329,
      32096,
      13042,
      656,
      4818,
      8079,
      5563,
      318,
      257,
      3210,
      3357,
      13
    ],
    "label": "best_practice",
    "reason": "Using strptime for parsing strings into datetime objects is a standard practice."
  },
  {
    "line": 224,
    "text": "        right_freq = Freq(right_freq)",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on region, indicating region-specific behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      826,
      62,
      19503,
      80,
      796,
      4848,
      80,
      7,
      3506,
      62,
      19503,
      80,
      8
    ],
    "start_token": 953,
    "end_token": 973,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      3814,
      11,
      12739,
      3814,
      12,
      11423,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on region, indicating region-specific behavior."
  },
  {
    "line": 226,
    "text": "        return left_minutes - right_minutes",
    "annotation": "\ud83e\udde0 ML Signal: Time range checks for specific business logic.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1364,
      62,
      1084,
      1769,
      532,
      826,
      62,
      1084,
      1769
    ],
    "start_token": 973,
    "end_token": 990,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3862,
      2837,
      8794,
      329,
      2176,
      1597,
      9156,
      13
    ],
    "label": "ml_signal",
    "reason": "Time range checks for specific business logic."
  },
  {
    "line": 228,
    "text": "    @staticmethod",
    "annotation": "\u2705 Best Practice: Using total_seconds() for time difference calculations is precise.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      12708,
      24396
    ],
    "start_token": 990,
    "end_token": 996,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2472,
      62,
      43012,
      3419,
      329,
      640,
      3580,
      16765,
      318,
      7141,
      13
    ],
    "label": "best_practice",
    "reason": "Using total_seconds() for time difference calculations is precise."
  },
  {
    "line": 233,
    "text": "        ----------",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through error messages.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      24200,
      438
    ],
    "start_token": 996,
    "end_token": 1005,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      4049,
      6218,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through error messages."
  },
  {
    "line": 239,
    "text": "        if the recent frequency is found",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through error messages.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      262,
      2274,
      8373,
      318,
      1043
    ],
    "start_token": 1005,
    "end_token": 1018,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      4049,
      6218,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through error messages."
  },
  {
    "line": 240,
    "text": "            Freq",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through error messages.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4848,
      80
    ],
    "start_token": 1018,
    "end_token": 1031,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      4049,
      6218,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through error messages."
  },
  {
    "line": 255,
    "text": "        return min_freq[1] if min_freq else None",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential information disclosure through error messages.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      949,
      62,
      19503,
      80,
      58,
      16,
      60,
      611,
      949,
      62,
      19503,
      80,
      2073,
      6045
    ],
    "start_token": 1031,
    "end_token": 1053,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      1321,
      13019,
      832,
      4049,
      6218,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential information disclosure through error messages."
  },
  {
    "line": 239,
    "text": "        if the recent frequency is found",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      262,
      2274,
      8373,
      318,
      1043
    ],
    "start_token": 1053,
    "end_token": 1066,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 256,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for incorrect time parsing if input format is not as expected",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1066,
    "end_token": 1066,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11491,
      640,
      32096,
      611,
      5128,
      5794,
      318,
      407,
      355,
      2938
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for incorrect time parsing if input format is not as expected"
  },
  {
    "line": 258,
    "text": "def time_to_day_index(time_obj: Union[str, datetime], region: str = REG_CN):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for incorrect time parsing if input format is not as expected",
    "confidence": 1.0,
    "tokens": [
      4299,
      640,
      62,
      1462,
      62,
      820,
      62,
      9630,
      7,
      2435,
      62,
      26801,
      25,
      4479,
      58,
      2536,
      11,
      4818,
      8079,
      4357,
      3814,
      25,
      965,
      796,
      23337,
      62,
      44175,
      2599
    ],
    "start_token": 1066,
    "end_token": 1094,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      11491,
      640,
      32096,
      611,
      5128,
      5794,
      318,
      407,
      355,
      2938
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for incorrect time parsing if input format is not as expected"
  },
  {
    "line": 260,
    "text": "        time_obj = datetime.strptime(time_obj, \"%H:%M\")",
    "annotation": "\ud83e\udde0 ML Signal: Usage of custom frequency object, could indicate domain-specific logic",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      62,
      26801,
      796,
      4818,
      8079,
      13,
      2536,
      457,
      524,
      7,
      2435,
      62,
      26801,
      11,
      36521,
      39,
      25,
      4,
      44,
      4943
    ],
    "start_token": 1094,
    "end_token": 1122,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      2183,
      8373,
      2134,
      11,
      714,
      7603,
      7386,
      12,
      11423,
      9156
    ],
    "label": "ml_signal",
    "reason": "Usage of custom frequency object, could indicate domain-specific logic"
  },
  {
    "line": 262,
    "text": "    if region == REG_CN:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of region-specific calendar, could indicate domain-specific logic",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      3814,
      6624,
      23337,
      62,
      44175,
      25
    ],
    "start_token": 1122,
    "end_token": 1132,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      3814,
      12,
      11423,
      11845,
      11,
      714,
      7603,
      7386,
      12,
      11423,
      9156
    ],
    "label": "ml_signal",
    "reason": "Usage of region-specific calendar, could indicate domain-specific logic"
  },
  {
    "line": 263,
    "text": "        if CN_TIME[0] <= time_obj < CN_TIME[1]:",
    "annotation": "\u2705 Best Practice: Use of bisect module for efficient searching in sorted lists",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      31171,
      62,
      34694,
      58,
      15,
      60,
      19841,
      640,
      62,
      26801,
      1279,
      31171,
      62,
      34694,
      58,
      16,
      5974
    ],
    "start_token": 1132,
    "end_token": 1157,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      47457,
      478,
      8265,
      329,
      6942,
      10342,
      287,
      23243,
      8341
    ],
    "label": "best_practice",
    "reason": "Use of bisect module for efficient searching in sorted lists"
  },
  {
    "line": 263,
    "text": "        if CN_TIME[0] <= time_obj < CN_TIME[1]:",
    "annotation": "\u2705 Best Practice: Use of bisect module for efficient searching in sorted lists",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      31171,
      62,
      34694,
      58,
      15,
      60,
      19841,
      640,
      62,
      26801,
      1279,
      31171,
      62,
      34694,
      58,
      16,
      5974
    ],
    "start_token": 1157,
    "end_token": 1182,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      47457,
      478,
      8265,
      329,
      6942,
      10342,
      287,
      23243,
      8341
    ],
    "label": "best_practice",
    "reason": "Use of bisect module for efficient searching in sorted lists"
  },
  {
    "line": 262,
    "text": "    if region == REG_CN:",
    "annotation": "\u2705 Best Practice: Type hints for function parameters and return type improve code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      3814,
      6624,
      23337,
      62,
      44175,
      25
    ],
    "start_token": 1182,
    "end_token": 1192,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      2987,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hints for function parameters and return type improve code readability and maintainability"
  },
  {
    "line": 263,
    "text": "        if CN_TIME[0] <= time_obj < CN_TIME[1]:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of pd.Timestamp indicates interaction with pandas for date-time operations",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      31171,
      62,
      34694,
      58,
      15,
      60,
      19841,
      640,
      62,
      26801,
      1279,
      31171,
      62,
      34694,
      58,
      16,
      5974
    ],
    "start_token": 1192,
    "end_token": 1217,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      279,
      67,
      13,
      14967,
      27823,
      9217,
      10375,
      351,
      19798,
      292,
      329,
      3128,
      12,
      2435,
      4560
    ],
    "label": "ml_signal",
    "reason": "Usage of pd.Timestamp indicates interaction with pandas for date-time operations"
  },
  {
    "line": 263,
    "text": "        if CN_TIME[0] <= time_obj < CN_TIME[1]:",
    "annotation": "\u2705 Best Practice: Using datetime constructor for explicit date-time creation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      31171,
      62,
      34694,
      58,
      15,
      60,
      19841,
      640,
      62,
      26801,
      1279,
      31171,
      62,
      34694,
      58,
      16,
      5974
    ],
    "start_token": 1217,
    "end_token": 1242,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4818,
      8079,
      23772,
      329,
      7952,
      3128,
      12,
      2435,
      6282
    ],
    "label": "best_practice",
    "reason": "Using datetime constructor for explicit date-time creation"
  },
  {
    "line": 274,
    "text": "    elif region == REG_TW:",
    "annotation": "\u2705 Best Practice: Include type hints for function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1288,
      361,
      3814,
      6624,
      23337,
      62,
      34551,
      25
    ],
    "start_token": 1242,
    "end_token": 1253,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Include type hints for function parameters and return type for better readability and maintainability."
  },
  {
    "line": 292,
    "text": "    freq : str",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Ensure that get_min_cal and C.min_data_shift are properly validated to prevent potential misuse or errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2030,
      80,
      1058,
      965
    ],
    "start_token": 1253,
    "end_token": 1260,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      48987,
      326,
      651,
      62,
      1084,
      62,
      9948,
      290,
      327,
      13,
      1084,
      62,
      7890,
      62,
      30846,
      389,
      6105,
      31031,
      284,
      2948,
      2785,
      29169,
      393,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Ensure that get_min_cal and C.min_data_shift are properly validated to prevent potential misuse or errors."
  },
  {
    "line": 294,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that the index calculation does not result in an out-of-bounds error.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1260,
    "end_token": 1260,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      262,
      6376,
      17952,
      857,
      407,
      1255,
      287,
      281,
      503,
      12,
      1659,
      12,
      65,
      3733,
      4049,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that the index calculation does not result in an out-of-bounds error."
  },
  {
    "line": 296,
    "text": "    -------",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that concat_date_time handles edge cases and invalid inputs gracefully.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      35656
    ],
    "start_token": 1260,
    "end_token": 1264,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      1673,
      265,
      62,
      4475,
      62,
      2435,
      17105,
      5743,
      2663,
      290,
      12515,
      17311,
      11542,
      2759,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that concat_date_time handles edge cases and invalid inputs gracefully."
  },
  {
    "line": 311,
    "text": "        datetime(",
    "annotation": "\u2705 Best Practice: Use of clear conditional statements for direction handling",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4818,
      8079,
      7
    ],
    "start_token": 1264,
    "end_token": 1274,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      26340,
      6299,
      329,
      4571,
      9041
    ],
    "label": "best_practice",
    "reason": "Use of clear conditional statements for direction handling"
  },
  {
    "line": 313,
    "text": "            month=date_obj.month,",
    "annotation": "\u2705 Best Practice: Use of pd.Timedelta for time manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1227,
      28,
      4475,
      62,
      26801,
      13,
      8424,
      11
    ],
    "start_token": 1274,
    "end_token": 1293,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      14967,
      276,
      12514,
      329,
      640,
      17512
    ],
    "label": "best_practice",
    "reason": "Use of pd.Timedelta for time manipulation"
  },
  {
    "line": 316,
    "text": "            minute=time_obj.minute,",
    "annotation": "\u2705 Best Practice: Use of pd.Timedelta for time manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5664,
      28,
      2435,
      62,
      26801,
      13,
      11374,
      11
    ],
    "start_token": 1293,
    "end_token": 1312,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      279,
      67,
      13,
      14967,
      276,
      12514,
      329,
      640,
      17512
    ],
    "label": "best_practice",
    "reason": "Use of pd.Timedelta for time manipulation"
  },
  {
    "line": 318,
    "text": "            microsecond=time_obj.microsecond,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Error message could be more descriptive",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4580,
      12227,
      28,
      2435,
      62,
      26801,
      13,
      24055,
      12227,
      11
    ],
    "start_token": 1312,
    "end_token": 1333,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      13047,
      3275,
      714,
      307,
      517,
      35644
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Error message could be more descriptive"
  },
  {
    "line": 318,
    "text": "            microsecond=time_obj.microsecond,",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Missing import statement for pd (pandas)",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4580,
      12227,
      28,
      2435,
      62,
      26801,
      13,
      24055,
      12227,
      11
    ],
    "start_token": 1333,
    "end_token": 1354,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      25639,
      1330,
      2643,
      329,
      279,
      67,
      357,
      79,
      392,
      292,
      8
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Missing import statement for pd (pandas)"
  },
  {
    "line": 318,
    "text": "            microsecond=time_obj.microsecond,",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Undefined function 'get_day_min_idx_range' and variable 'REG_CN'",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4580,
      12227,
      28,
      2435,
      62,
      26801,
      13,
      24055,
      12227,
      11
    ],
    "start_token": 1354,
    "end_token": 1375,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      13794,
      18156,
      2163,
      705,
      1136,
      62,
      820,
      62,
      1084,
      62,
      312,
      87,
      62,
      9521,
      6,
      290,
      7885,
      705,
      31553,
      62,
      44175,
      6
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Undefined function 'get_day_min_idx_range' and variable 'REG_CN'"
  },
  {
    "line": 318,
    "text": "            microsecond=time_obj.microsecond,",
    "annotation": "\ud83e\udde0 ML Signal: Example of function usage in a main block",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4580,
      12227,
      28,
      2435,
      62,
      26801,
      13,
      24055,
      12227,
      11
    ],
    "start_token": 1375,
    "end_token": 1396,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17934,
      286,
      2163,
      8748,
      287,
      257,
      1388,
      2512
    ],
    "label": "ml_signal",
    "reason": "Example of function usage in a main block"
  }
]