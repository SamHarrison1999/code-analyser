[
  {
    "line": 2,
    "text": "from _collections_abc import dict_keys",
    "annotation": "\u2705 Best Practice: Importing specific classes or functions is preferred for clarity and to avoid namespace pollution.",
    "confidence": 0.5,
    "tokens": [
      6738,
      4808,
      4033,
      26448,
      62,
      39305,
      1330,
      8633,
      62,
      13083
    ],
    "start_token": 0,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      6097,
      393,
      5499,
      318,
      9871,
      329,
      16287,
      290,
      284,
      3368,
      25745,
      12231,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific classes or functions is preferred for clarity and to avoid namespace pollution."
  },
  {
    "line": 5,
    "text": "",
    "annotation": "\u2705 Best Practice: Importing specific classes or functions is preferred for clarity and to avoid namespace pollution.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 10,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      6097,
      393,
      5499,
      318,
      9871,
      329,
      16287,
      290,
      284,
      3368,
      25745,
      12231,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific classes or functions is preferred for clarity and to avoid namespace pollution."
  },
  {
    "line": 8,
    "text": "",
    "annotation": "\u2705 Best Practice: Importing specific classes or functions is preferred for clarity and to avoid namespace pollution.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 10,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2176,
      6097,
      393,
      5499,
      318,
      9871,
      329,
      16287,
      290,
      284,
      3368,
      25745,
      12231,
      13
    ],
    "label": "best_practice",
    "reason": "Importing specific classes or functions is preferred for clarity and to avoid namespace pollution."
  },
  {
    "line": 11,
    "text": "",
    "annotation": "\u2705 Best Practice: Relative imports are useful for maintaining package structure and avoiding conflicts with other modules.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 10,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      45344,
      17944,
      389,
      4465,
      329,
      10941,
      5301,
      4645,
      290,
      14928,
      12333,
      351,
      584,
      13103,
      13
    ],
    "label": "best_practice",
    "reason": "Relative imports are useful for maintaining package structure and avoiding conflicts with other modules."
  },
  {
    "line": 7,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding a class docstring to describe the purpose and usage of the class.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 10,
    "end_token": 10,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      1398,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a class docstring to describe the purpose and usage of the class."
  },
  {
    "line": 9,
    "text": "class BarManager:",
    "annotation": "\u2705 Best Practice: Use of type annotations for class attributes improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      4871,
      2409,
      13511,
      25
    ],
    "start_token": 10,
    "end_token": 14,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      37647,
      329,
      1398,
      12608,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type annotations for class attributes improves code readability and maintainability."
  },
  {
    "line": 18,
    "text": "        self._price_ranges: dict[tuple[int, int], tuple[float, float]] = {}",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a list to update a dictionary",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      20888,
      62,
      81,
      6231,
      25,
      8633,
      58,
      83,
      29291,
      58,
      600,
      11,
      493,
      4357,
      46545,
      58,
      22468,
      11,
      12178,
      11907,
      796,
      23884
    ],
    "start_token": 14,
    "end_token": 45,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      1351,
      284,
      4296,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Iterating over a list to update a dictionary"
  },
  {
    "line": 20,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Using datetime as a key in a dictionary",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 45,
    "end_token": 45,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      4818,
      8079,
      355,
      257,
      1994,
      287,
      257,
      22155
    ],
    "label": "ml_signal",
    "reason": "Using datetime as a key in a dictionary"
  },
  {
    "line": 22,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Sorting dictionary items by key for ordered storage",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 45,
    "end_token": 53,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      311,
      24707,
      22155,
      3709,
      416,
      1994,
      329,
      6149,
      6143
    ],
    "label": "best_practice",
    "reason": "Sorting dictionary items by key for ordered storage"
  },
  {
    "line": 24,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Using range for index generation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 53,
    "end_token": 61,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2837,
      329,
      6376,
      5270
    ],
    "label": "best_practice",
    "reason": "Using range for index generation"
  },
  {
    "line": 26,
    "text": "        for bar in history:",
    "annotation": "\u2705 Best Practice: Accessing dictionary keys for mapping",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      2318,
      287,
      2106,
      25
    ],
    "start_token": 61,
    "end_token": 73,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8798,
      278,
      22155,
      8251,
      329,
      16855
    ],
    "label": "best_practice",
    "reason": "Accessing dictionary keys for mapping"
  },
  {
    "line": 27,
    "text": "            self._bars[bar.datetime] = bar",
    "annotation": "\ud83e\udde0 ML Signal: Creating a mapping from datetime to index",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      34046,
      58,
      5657,
      13,
      19608,
      8079,
      60,
      796,
      2318
    ],
    "start_token": 73,
    "end_token": 95,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      16855,
      422,
      4818,
      8079,
      284,
      6376
    ],
    "label": "ml_signal",
    "reason": "Creating a mapping from datetime to index"
  },
  {
    "line": 30,
    "text": "        self._bars = dict(sorted(self._bars.items(), key=lambda tp: tp[0]))",
    "annotation": "\ud83e\udde0 ML Signal: Creating a mapping from index to datetime",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      34046,
      796,
      8633,
      7,
      82,
      9741,
      7,
      944,
      13557,
      34046,
      13,
      23814,
      22784,
      1994,
      28,
      50033,
      256,
      79,
      25,
      256,
      79,
      58,
      15,
      60,
      4008
    ],
    "start_token": 95,
    "end_token": 129,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      16855,
      422,
      6376,
      284,
      4818,
      8079
    ],
    "label": "ml_signal",
    "reason": "Creating a mapping from index to datetime"
  },
  {
    "line": 32,
    "text": "        # Update map relationiship",
    "annotation": "\u2705 Best Practice: Clearing cache after updating data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10133,
      3975,
      8695,
      680,
      541
    ],
    "start_token": 129,
    "end_token": 142,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3779,
      1723,
      12940,
      706,
      19698,
      1366
    ],
    "label": "best_practice",
    "reason": "Clearing cache after updating data"
  },
  {
    "line": 30,
    "text": "        self._bars = dict(sorted(self._bars.items(), key=lambda tp: tp[0]))",
    "annotation": "\u2705 Best Practice: Type hint for 'dt' improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      34046,
      796,
      8633,
      7,
      82,
      9741,
      7,
      944,
      13557,
      34046,
      13,
      23814,
      22784,
      1994,
      28,
      50033,
      256,
      79,
      25,
      256,
      79,
      58,
      15,
      60,
      4008
    ],
    "start_token": 142,
    "end_token": 176,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      329,
      705,
      28664,
      6,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hint for 'dt' improves code readability and maintainability"
  },
  {
    "line": 32,
    "text": "        # Update map relationiship",
    "annotation": "\ud83e\udde0 ML Signal: Checking if an item is in a dictionary is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10133,
      3975,
      8695,
      680,
      541
    ],
    "start_token": 176,
    "end_token": 189,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      281,
      2378,
      318,
      287,
      257,
      22155,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Checking if an item is in a dictionary is a common pattern"
  },
  {
    "line": 34,
    "text": "        dt_list: dict_keys = self._bars.keys()",
    "annotation": "\ud83e\udde0 ML Signal: Using the length of a list to determine the next index is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      83,
      62,
      4868,
      25,
      8633,
      62,
      13083,
      796,
      2116,
      13557,
      34046,
      13,
      13083,
      3419
    ],
    "start_token": 189,
    "end_token": 211,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8554,
      262,
      4129,
      286,
      257,
      1351,
      284,
      5004,
      262,
      1306,
      6376,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Using the length of a list to determine the next index is a common pattern"
  },
  {
    "line": 36,
    "text": "        self._datetime_index_map = dict(zip(dt_list, ix_list, strict=False))",
    "annotation": "\ud83e\udde0 ML Signal: Storing a mapping from datetime to index",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      19608,
      8079,
      62,
      9630,
      62,
      8899,
      796,
      8633,
      7,
      13344,
      7,
      28664,
      62,
      4868,
      11,
      220,
      844,
      62,
      4868,
      11,
      7646,
      28,
      25101,
      4008
    ],
    "start_token": 211,
    "end_token": 244,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      16855,
      422,
      4818,
      8079,
      284,
      6376
    ],
    "label": "ml_signal",
    "reason": "Storing a mapping from datetime to index"
  },
  {
    "line": 38,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Storing a mapping from index to datetime",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 244,
    "end_token": 244,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      257,
      16855,
      422,
      6376,
      284,
      4818,
      8079
    ],
    "label": "ml_signal",
    "reason": "Storing a mapping from index to datetime"
  },
  {
    "line": 41,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Updating a dictionary with a new or existing key",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 244,
    "end_token": 244,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3205,
      38734,
      257,
      22155,
      351,
      257,
      649,
      393,
      4683,
      1994
    ],
    "label": "ml_signal",
    "reason": "Updating a dictionary with a new or existing key"
  },
  {
    "line": 42,
    "text": "    def update_bar(self, bar: BarData) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Clearing a cache after updating data is a common pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4296,
      62,
      5657,
      7,
      944,
      11,
      2318,
      25,
      2409,
      6601,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 244,
    "end_token": 262,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      3779,
      1723,
      257,
      12940,
      706,
      19698,
      1366,
      318,
      257,
      2219,
      3912
    ],
    "label": "ml_signal",
    "reason": "Clearing a cache after updating data is a common pattern"
  },
  {
    "line": 37,
    "text": "        self._index_datetime_map = dict(zip(ix_list, dt_list, strict=False))",
    "annotation": "\u2705 Best Practice: Method docstring provides a clear description of the method's purpose",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13557,
      9630,
      62,
      19608,
      8079,
      62,
      8899,
      796,
      8633,
      7,
      13344,
      7,
      844,
      62,
      4868,
      11,
      288,
      83,
      62,
      4868,
      11,
      7646,
      28,
      25101,
      4008
    ],
    "start_token": 262,
    "end_token": 295,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      2205,
      8841,
      3769,
      257,
      1598,
      6764,
      286,
      262,
      2446,
      338,
      4007
    ],
    "label": "best_practice",
    "reason": "Method docstring provides a clear description of the method's purpose"
  },
  {
    "line": 42,
    "text": "    def update_bar(self, bar: BarData) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of len() to get the count of elements in a collection",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4296,
      62,
      5657,
      7,
      944,
      11,
      2318,
      25,
      2409,
      6601,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 295,
    "end_token": 313,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      18896,
      3419,
      284,
      651,
      262,
      954,
      286,
      4847,
      287,
      257,
      4947
    ],
    "label": "ml_signal",
    "reason": "Usage of len() to get the count of elements in a collection"
  },
  {
    "line": 43,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 313,
    "end_token": 321,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 47,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dictionary get method with a default value.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 321,
    "end_token": 321,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      22155,
      651,
      2446,
      351,
      257,
      4277,
      1988,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of dictionary get method with a default value."
  },
  {
    "line": 47,
    "text": "",
    "annotation": "\u2705 Best Practice: Include type hints for better code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 321,
    "end_token": 321,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      2099,
      20269,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Include type hints for better code readability and maintainability"
  },
  {
    "line": 52,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of float to int indicates a pattern of handling numeric indices",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 321,
    "end_token": 321,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      12178,
      284,
      493,
      9217,
      257,
      3912,
      286,
      9041,
      35575,
      36525
    ],
    "label": "ml_signal",
    "reason": "Conversion of float to int indicates a pattern of handling numeric indices"
  },
  {
    "line": 54,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of dictionary get method with default value indicates a pattern of safe dictionary access",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 321,
    "end_token": 321,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      22155,
      651,
      2446,
      351,
      4277,
      1988,
      9217,
      257,
      3912,
      286,
      3338,
      22155,
      1895
    ],
    "label": "ml_signal",
    "reason": "Use of dictionary get method with default value indicates a pattern of safe dictionary access"
  },
  {
    "line": 54,
    "text": "",
    "annotation": "\u2705 Best Practice: Include a docstring to describe the method's purpose and parameters.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 321,
    "end_token": 321,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      40348,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2446,
      338,
      4007,
      290,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Include a docstring to describe the method's purpose and parameters."
  },
  {
    "line": 58,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of float to int indicates handling of numeric indices.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 321,
    "end_token": 329,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      12178,
      284,
      493,
      9217,
      9041,
      286,
      35575,
      36525,
      13
    ],
    "label": "ml_signal",
    "reason": "Conversion of float to int indicates handling of numeric indices."
  },
  {
    "line": 60,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 329,
    "end_token": 337,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and maintainability."
  },
  {
    "line": 63,
    "text": "    def get_index(self, dt: datetime) -> int | None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of dictionary access pattern to retrieve data.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      9630,
      7,
      944,
      11,
      288,
      83,
      25,
      4818,
      8079,
      8,
      4613,
      493,
      930,
      6045,
      25
    ],
    "start_token": 337,
    "end_token": 358,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      22155,
      1895,
      3912,
      284,
      19818,
      1366,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of dictionary access pattern to retrieve data."
  },
  {
    "line": 62,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hinting for return type improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 358,
    "end_token": 358,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      9254,
      278,
      329,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of type hinting for return type improves code readability and maintainability"
  },
  {
    "line": 67,
    "text": "        return self._datetime_index_map.get(dt, None)",
    "annotation": "\ud83e\udde0 ML Signal: Accessing instance variables, indicating a pattern of object-oriented design",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13557,
      19608,
      8079,
      62,
      9630,
      62,
      8899,
      13,
      1136,
      7,
      28664,
      11,
      6045,
      8
    ],
    "start_token": 358,
    "end_token": 381,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      4554,
      9633,
      11,
      12739,
      257,
      3912,
      286,
      2134,
      12,
      17107,
      1486
    ],
    "label": "ml_signal",
    "reason": "Accessing instance variables, indicating a pattern of object-oriented design"
  },
  {
    "line": 68,
    "text": "",
    "annotation": "\u2705 Best Practice: Using list() to convert values to a list ensures the return type is consistent",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 381,
    "end_token": 381,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      1351,
      3419,
      284,
      10385,
      3815,
      284,
      257,
      1351,
      19047,
      262,
      1441,
      2099,
      318,
      6414
    ],
    "label": "best_practice",
    "reason": "Using list() to convert values to a list ensures the return type is consistent"
  },
  {
    "line": 71,
    "text": "        Get datetime with index.",
    "annotation": "\u2705 Best Practice: Check for empty data early to avoid unnecessary processing.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3497,
      4818,
      8079,
      351,
      6376,
      13
    ],
    "start_token": 381,
    "end_token": 394,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      1366,
      1903,
      284,
      3368,
      13114,
      7587,
      13
    ],
    "label": "best_practice",
    "reason": "Check for empty data early to avoid unnecessary processing."
  },
  {
    "line": 78,
    "text": "        Get bar data with index.",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if to_int does not handle invalid inputs safely.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3497,
      2318,
      1366,
      351,
      6376,
      13
    ],
    "start_token": 394,
    "end_token": 407,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      284,
      62,
      600,
      857,
      407,
      5412,
      12515,
      17311,
      11512,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if to_int does not handle invalid inputs safely."
  },
  {
    "line": 80,
    "text": "        ix = to_int(ix)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if to_int does not handle invalid inputs safely.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      844,
      796,
      284,
      62,
      600,
      7,
      844,
      8
    ],
    "start_token": 407,
    "end_token": 423,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      284,
      62,
      600,
      857,
      407,
      5412,
      12515,
      17311,
      11512,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if to_int does not handle invalid inputs safely."
  },
  {
    "line": 82,
    "text": "        if not dt:",
    "annotation": "\u2705 Best Practice: Use min to ensure max_ix does not exceed the count.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      288,
      83,
      25
    ],
    "start_token": 423,
    "end_token": 435,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      949,
      284,
      4155,
      3509,
      62,
      844,
      857,
      407,
      7074,
      262,
      954,
      13
    ],
    "label": "best_practice",
    "reason": "Use min to ensure max_ix does not exceed the count."
  },
  {
    "line": 84,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Caching pattern for performance optimization.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 435,
    "end_token": 435,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      8103,
      3912,
      329,
      2854,
      23989,
      13
    ],
    "label": "ml_signal",
    "reason": "Caching pattern for performance optimization."
  },
  {
    "line": 88,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use list slicing for concise and efficient sublist creation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 435,
    "end_token": 443,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1351,
      49289,
      329,
      35327,
      290,
      6942,
      850,
      4868,
      6282,
      13
    ],
    "label": "best_practice",
    "reason": "Use list slicing for concise and efficient sublist creation."
  },
  {
    "line": 93,
    "text": "    def get_price_range(self, min_ix: float | None = None, max_ix: float | None = None) -> tuple[float, float]:",
    "annotation": "\u2705 Best Practice: Use built-in max and min for clarity and efficiency.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      20888,
      62,
      9521,
      7,
      944,
      11,
      949,
      62,
      844,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      11,
      3509,
      62,
      844,
      25,
      12178,
      930,
      6045,
      796,
      6045,
      8,
      4613,
      46545,
      58,
      22468,
      11,
      12178,
      5974
    ],
    "start_token": 443,
    "end_token": 482,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      3170,
      12,
      259,
      3509,
      290,
      949,
      329,
      16287,
      290,
      9332,
      13
    ],
    "label": "best_practice",
    "reason": "Use built-in max and min for clarity and efficiency."
  },
  {
    "line": 97,
    "text": "        if not self._bars:",
    "annotation": "\ud83e\udde0 ML Signal: Caching pattern for performance optimization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13557,
      34046,
      25
    ],
    "start_token": 482,
    "end_token": 495,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      8103,
      3912,
      329,
      2854,
      23989,
      13
    ],
    "label": "ml_signal",
    "reason": "Caching pattern for performance optimization."
  },
  {
    "line": 96,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Check for empty data early to avoid unnecessary processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 495,
    "end_token": 503,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      6565,
      1366,
      1903,
      284,
      3368,
      13114,
      7587,
      13
    ],
    "label": "best_practice",
    "reason": "Check for empty data early to avoid unnecessary processing."
  },
  {
    "line": 103,
    "text": "        else:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if to_int does not handle invalid inputs safely.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 503,
    "end_token": 512,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      284,
      62,
      600,
      857,
      407,
      5412,
      12515,
      17311,
      11512,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if to_int does not handle invalid inputs safely."
  },
  {
    "line": 105,
    "text": "            max_ix = to_int(max_ix)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if to_int does not handle invalid inputs safely.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      844,
      796,
      284,
      62,
      600,
      7,
      9806,
      62,
      844,
      8
    ],
    "start_token": 512,
    "end_token": 535,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      284,
      62,
      600,
      857,
      407,
      5412,
      12515,
      17311,
      11512,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if to_int does not handle invalid inputs safely."
  },
  {
    "line": 108,
    "text": "        buf: tuple[float, float] | None = self._price_ranges.get((min_ix, max_ix), None)",
    "annotation": "\u2705 Best Practice: Use of type hints for better code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      42684,
      25,
      46545,
      58,
      22468,
      11,
      12178,
      60,
      930,
      6045,
      796,
      2116,
      13557,
      20888,
      62,
      81,
      6231,
      13,
      1136,
      19510,
      1084,
      62,
      844,
      11,
      3509,
      62,
      844,
      828,
      6045,
      8
    ],
    "start_token": 535,
    "end_token": 572,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for better code readability and maintainability."
  },
  {
    "line": 112,
    "text": "        bar_list: list[BarData] = list(self._bars.values())[min_ix:max_ix + 1]",
    "annotation": "\u2705 Best Practice: Use of type hints for better code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2318,
      62,
      4868,
      25,
      1351,
      58,
      10374,
      6601,
      60,
      796,
      1351,
      7,
      944,
      13557,
      34046,
      13,
      27160,
      28955,
      58,
      1084,
      62,
      844,
      25,
      9806,
      62,
      844,
      1343,
      352,
      60
    ],
    "start_token": 572,
    "end_token": 608,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for better code readability and maintainability."
  },
  {
    "line": 114,
    "text": "        max_price: float = first_bar.high_price",
    "annotation": "\u2705 Best Practice: Use of type hints for better code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3509,
      62,
      20888,
      25,
      12178,
      796,
      717,
      62,
      5657,
      13,
      8929,
      62,
      20888
    ],
    "start_token": 608,
    "end_token": 628,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for better code readability and maintainability."
  },
  {
    "line": 117,
    "text": "        for bar in bar_list[1:]:",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a list to find max value, common pattern for ML feature extraction.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      2318,
      287,
      2318,
      62,
      4868,
      58,
      16,
      25,
      5974
    ],
    "start_token": 628,
    "end_token": 645,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      1351,
      284,
      1064,
      3509,
      1988,
      11,
      2219,
      3912,
      329,
      10373,
      3895,
      22236,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over a list to find max value, common pattern for ML feature extraction."
  },
  {
    "line": 120,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of clear() method to empty lists is efficient and clear.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 645,
    "end_token": 645,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      3419,
      2446,
      284,
      6565,
      8341,
      318,
      6942,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Use of clear() method to empty lists is efficient and clear."
  },
  {
    "line": 122,
    "text": "        return min_price, max_price",
    "annotation": "\u2705 Best Practice: Use of clear() method to empty lists is efficient and clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      949,
      62,
      20888,
      11,
      3509,
      62,
      20888
    ],
    "start_token": 645,
    "end_token": 660,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      3419,
      2446,
      284,
      6565,
      8341,
      318,
      6942,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Use of clear() method to empty lists is efficient and clear."
  },
  {
    "line": 126,
    "text": "        Get volume range to show within given index range.",
    "annotation": "\u2705 Best Practice: Use of clear method to empty collections is efficient and clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3497,
      6115,
      2837,
      284,
      905,
      1626,
      1813,
      6376,
      2837,
      13
    ],
    "start_token": 660,
    "end_token": 677,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      2446,
      284,
      6565,
      17268,
      318,
      6942,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Use of clear method to empty collections is efficient and clear."
  },
  {
    "line": 128,
    "text": "        if not self._bars:",
    "annotation": "\u2705 Best Practice: Use of clear method to empty collections is efficient and clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      2116,
      13557,
      34046,
      25
    ],
    "start_token": 677,
    "end_token": 690,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      2446,
      284,
      6565,
      17268,
      318,
      6942,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Use of clear method to empty collections is efficient and clear."
  },
  {
    "line": 129,
    "text": "            return 0, 1",
    "annotation": "\u2705 Best Practice: Use of clear method to empty collections is efficient and clear.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      657,
      11,
      352
    ],
    "start_token": 690,
    "end_token": 705,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1598,
      2446,
      284,
      6565,
      17268,
      318,
      6942,
      290,
      1598,
      13
    ],
    "label": "best_practice",
    "reason": "Use of clear method to empty collections is efficient and clear."
  },
  {
    "line": 129,
    "text": "            return 0, 1",
    "annotation": "\ud83e\udde0 ML Signal: Method call pattern that could indicate cache management behavior.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      657,
      11,
      352
    ],
    "start_token": 705,
    "end_token": 720,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      869,
      3912,
      326,
      714,
      7603,
      12940,
      4542,
      4069,
      13
    ],
    "label": "ml_signal",
    "reason": "Method call pattern that could indicate cache management behavior."
  }
]