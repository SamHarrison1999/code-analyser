[
  {
    "line": 3,
    "text": "",
    "annotation": "\u2705 Best Practice: Grouping imports into standard library, third-party, and local can improve readability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 0,
    "end_token": 0,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      656,
      3210,
      5888,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      460,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports into standard library, third-party, and local can improve readability."
  },
  {
    "line": 11,
    "text": "from zvt.factors.technical_factor import TechnicalFactor",
    "annotation": "\u2705 Best Practice: Consider adding type hints for function parameters and return type for better readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      22584,
      669,
      13,
      47944,
      62,
      31412,
      1330,
      20671,
      41384
    ],
    "start_token": 0,
    "end_token": 13,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for function parameters and return type for better readability and maintainability."
  },
  {
    "line": 13,
    "text": "from zvt.utils.time_utils import pre_month_start_date, date_time_by_interval",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over a function that returns multiple values can indicate a pattern of processing data in chunks.",
    "confidence": 1.0,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      26791,
      13,
      2435,
      62,
      26791,
      1330,
      662,
      62,
      8424,
      62,
      9688,
      62,
      4475,
      11,
      3128,
      62,
      2435,
      62,
      1525,
      62,
      3849,
      2100
    ],
    "start_token": 13,
    "end_token": 39,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      257,
      2163,
      326,
      5860,
      3294,
      3815,
      460,
      7603,
      257,
      3912,
      286,
      7587,
      1366,
      287,
      22716,
      13
    ],
    "label": "ml_signal",
    "reason": "Iterating over a function that returns multiple values can indicate a pattern of processing data in chunks."
  },
  {
    "line": 18,
    "text": "    for start_date, end_date, df in get_top_performance_by_month(",
    "annotation": "\u2705 Best Practice: Consider using a more descriptive variable name than 'df' for better readability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      329,
      923,
      62,
      4475,
      11,
      886,
      62,
      4475,
      11,
      47764,
      287,
      651,
      62,
      4852,
      62,
      26585,
      62,
      1525,
      62,
      8424,
      7
    ],
    "start_token": 39,
    "end_token": 63,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      517,
      35644,
      7885,
      1438,
      621,
      705,
      7568,
      6,
      329,
      1365,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a more descriptive variable name than 'df' for better readability."
  },
  {
    "line": 18,
    "text": "    for start_date, end_date, df in get_top_performance_by_month(",
    "annotation": "\ud83e\udde0 ML Signal: Accessing a specific range of indices in a DataFrame can indicate a pattern of selecting top records.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      329,
      923,
      62,
      4475,
      11,
      886,
      62,
      4475,
      11,
      47764,
      287,
      651,
      62,
      4852,
      62,
      26585,
      62,
      1525,
      62,
      8424,
      7
    ],
    "start_token": 63,
    "end_token": 87,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      257,
      2176,
      2837,
      286,
      36525,
      287,
      257,
      6060,
      19778,
      460,
      7603,
      257,
      3912,
      286,
      17246,
      1353,
      4406,
      13
    ],
    "label": "ml_signal",
    "reason": "Accessing a specific range of indices in a DataFrame can indicate a pattern of selecting top records."
  },
  {
    "line": 25,
    "text": "                start_timestamp=date_time_by_interval(start_date, 15),",
    "annotation": "\ud83e\udde0 ML Signal: Function calls with multiple parameters can indicate a pattern of complex data retrieval.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      16514,
      27823,
      28,
      4475,
      62,
      2435,
      62,
      1525,
      62,
      3849,
      2100,
      7,
      9688,
      62,
      4475,
      11,
      1315,
      828
    ],
    "start_token": 87,
    "end_token": 122,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      3848,
      351,
      3294,
      10007,
      460,
      7603,
      257,
      3912,
      286,
      3716,
      1366,
      45069,
      13
    ],
    "label": "ml_signal",
    "reason": "Function calls with multiple parameters can indicate a pattern of complex data retrieval."
  },
  {
    "line": 30,
    "text": "            print(players)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Printing sensitive data can lead to information leakage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      32399,
      8
    ],
    "start_token": 122,
    "end_token": 137,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      44118,
      8564,
      1366,
      460,
      1085,
      284,
      1321,
      47988,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Printing sensitive data can lead to information leakage."
  },
  {
    "line": 30,
    "text": "            print(players)",
    "annotation": "\u2705 Best Practice: Check if 'dfs' is not empty before concatenating to avoid potential errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      32399,
      8
    ],
    "start_token": 137,
    "end_token": 152,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      7568,
      82,
      6,
      318,
      407,
      6565,
      878,
      1673,
      36686,
      803,
      284,
      3368,
      2785,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Check if 'dfs' is not empty before concatenating to avoid potential errors."
  },
  {
    "line": 30,
    "text": "            print(players)",
    "annotation": "\u2705 Best Practice: Consider specifying the 'inplace' parameter if sorting should modify the DataFrame in place.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      32399,
      8
    ],
    "start_token": 152,
    "end_token": 167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      31577,
      262,
      705,
      259,
      5372,
      6,
      11507,
      611,
      29407,
      815,
      13096,
      262,
      6060,
      19778,
      287,
      1295,
      13
    ],
    "label": "best_practice",
    "reason": "Consider specifying the 'inplace' parameter if sorting should modify the DataFrame in place."
  },
  {
    "line": 30,
    "text": "            print(players)",
    "annotation": "\u2705 Best Practice: Class definition should follow PEP 8 naming conventions, using CamelCase.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      32399,
      8
    ],
    "start_token": 167,
    "end_token": 182,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      350,
      8905,
      807,
      19264,
      21396,
      11,
      1262,
      43281,
      20448,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should follow PEP 8 naming conventions, using CamelCase."
  },
  {
    "line": 60,
    "text": "        accumulator: Accumulator = None,",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass constructor ensures proper initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10507,
      8927,
      25,
      6366,
      388,
      8927,
      796,
      6045,
      11
    ],
    "start_token": 182,
    "end_token": 198,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      23772,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass constructor ensures proper initialization."
  },
  {
    "line": 89,
    "text": "            accumulator,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a function to retrieve data based on parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10507,
      8927,
      11
    ],
    "start_token": 198,
    "end_token": 212,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2163,
      284,
      19818,
      1366,
      1912,
      319,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a function to retrieve data based on parameters."
  },
  {
    "line": 89,
    "text": "            accumulator,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `get_players` function does not handle input validation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10507,
      8927,
      11
    ],
    "start_token": 212,
    "end_token": 226,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      1136,
      62,
      32399,
      63,
      2163,
      857,
      407,
      5412,
      5128,
      21201,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `get_players` function does not handle input validation."
  },
  {
    "line": 96,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and helps with static analysis.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 226,
    "end_token": 234,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5419,
      351,
      9037,
      3781,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and helps with static analysis."
  },
  {
    "line": 98,
    "text": "            entity_id=entity_id,",
    "annotation": "\ud83e\udde0 ML Signal: Custom function for data transformation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9312,
      62,
      312,
      28,
      26858,
      62,
      312,
      11
    ],
    "start_token": 234,
    "end_token": 253,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      2163,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Custom function for data transformation"
  },
  {
    "line": 101,
    "text": "            provider=\"em\",",
    "annotation": "\ud83e\udde0 ML Signal: Conditional check for DataFrame nullity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10131,
      2625,
      368,
      1600
    ],
    "start_token": 253,
    "end_token": 268,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      2198,
      329,
      6060,
      19778,
      9242,
      414
    ],
    "label": "ml_signal",
    "reason": "Conditional check for DataFrame nullity"
  },
  {
    "line": 102,
    "text": "            direction=\"in\",",
    "annotation": "\u2705 Best Practice: Use of DataFrame.copy() to avoid modifying the original DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4571,
      2625,
      259,
      1600
    ],
    "start_token": 268,
    "end_token": 283,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      6060,
      19778,
      13,
      30073,
      3419,
      284,
      3368,
      30620,
      262,
      2656,
      6060,
      19778
    ],
    "label": "best_practice",
    "reason": "Use of DataFrame.copy() to avoid modifying the original DataFrame"
  },
  {
    "line": 105,
    "text": "    def drawer_annotation_df(self) -> Optional[pd.DataFrame]:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if 'close' column is missing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      33451,
      62,
      1236,
      14221,
      62,
      7568,
      7,
      944,
      8,
      4613,
      32233,
      58,
      30094,
      13,
      6601,
      19778,
      5974
    ],
    "start_token": 283,
    "end_token": 304,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      705,
      19836,
      6,
      5721,
      318,
      4814
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if 'close' column is missing"
  },
  {
    "line": 107,
    "text": "            return \"<br>\".join(df.tolist())",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential KeyError if any of 'dep1', 'dep2', 'dep3', 'dep4', 'dep5' columns are missing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      33490,
      1671,
      29,
      1911,
      22179,
      7,
      7568,
      13,
      83,
      349,
      396,
      28955
    ],
    "start_token": 304,
    "end_token": 328,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7383,
      12331,
      611,
      597,
      286,
      705,
      10378,
      16,
      3256,
      705,
      10378,
      17,
      3256,
      705,
      10378,
      18,
      3256,
      705,
      10378,
      19,
      3256,
      705,
      10378,
      20,
      6,
      15180,
      389,
      4814
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential KeyError if any of 'dep1', 'dep2', 'dep3', 'dep4', 'dep5' columns are missing"
  },
  {
    "line": 108,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda function for row-wise operation",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 328,
    "end_token": 328,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      2163,
      329,
      5752,
      12,
      3083,
      4905
    ],
    "label": "ml_signal",
    "reason": "Use of lambda function for row-wise operation"
  },
  {
    "line": 108,
    "text": "",
    "annotation": "\u2705 Best Practice: Hardcoded color value for consistency",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 328,
    "end_token": 328,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6912,
      40976,
      3124,
      1988,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Hardcoded color value for consistency"
  },
  {
    "line": 108,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Entry point for script execution",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 328,
    "end_token": 328,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21617,
      966,
      329,
      4226,
      9706
    ],
    "label": "ml_signal",
    "reason": "Entry point for script execution"
  }
]