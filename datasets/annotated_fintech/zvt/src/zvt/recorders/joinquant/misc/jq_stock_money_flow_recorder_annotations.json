[
  {
    "line": 7,
    "text": "from zvt.contract import IntervalLevel",
    "annotation": "\u2705 Best Practice: Group related imports together for better readability and organization",
    "confidence": 1.0,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      28484,
      1330,
      4225,
      2100,
      4971
    ],
    "start_token": 0,
    "end_token": 9,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      3519,
      17944,
      1978,
      329,
      1365,
      1100,
      1799,
      290,
      4009
    ],
    "label": "best_practice",
    "reason": "Group related imports together for better readability and organization"
  },
  {
    "line": 14,
    "text": "from zvt.utils.time_utils import TIME_FORMAT_DAY, to_time_str",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from FixedCycleDataRecorder indicates a pattern of extending functionality",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      26791,
      13,
      2435,
      62,
      26791,
      1330,
      20460,
      62,
      21389,
      1404,
      62,
      26442,
      11,
      284,
      62,
      2435,
      62,
      2536
    ],
    "start_token": 9,
    "end_token": 31,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      10832,
      20418,
      2375,
      6601,
      6690,
      2875,
      9217,
      257,
      3912,
      286,
      16610,
      11244
    ],
    "label": "ml_signal",
    "reason": "Inheritance from FixedCycleDataRecorder indicates a pattern of extending functionality"
  },
  {
    "line": 16,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific data provider suggests a pattern in data source preference",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 31,
    "end_token": 31,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      1366,
      10131,
      5644,
      257,
      3912,
      287,
      1366,
      2723,
      12741
    ],
    "label": "ml_signal",
    "reason": "Use of a specific data provider suggests a pattern in data source preference"
  },
  {
    "line": 18,
    "text": "    entity_provider = \"joinquant\"",
    "annotation": "\ud83e\udde0 ML Signal: Association with a specific schema indicates a pattern in data structure usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      15234,
      1304,
      796,
      366,
      7639,
      18934,
      415,
      1
    ],
    "start_token": 31,
    "end_token": 44,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5396,
      351,
      257,
      2176,
      32815,
      9217,
      257,
      3912,
      287,
      1366,
      4645,
      8748
    ],
    "label": "ml_signal",
    "reason": "Association with a specific schema indicates a pattern in data structure usage"
  },
  {
    "line": 18,
    "text": "    entity_provider = \"joinquant\"",
    "annotation": "\ud83e\udde0 ML Signal: Repeated use of the same provider suggests a strong dependency or preference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      15234,
      1304,
      796,
      366,
      7639,
      18934,
      415,
      1
    ],
    "start_token": 44,
    "end_token": 57,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30558,
      515,
      779,
      286,
      262,
      976,
      10131,
      5644,
      257,
      1913,
      20203,
      393,
      12741
    ],
    "label": "ml_signal",
    "reason": "Repeated use of the same provider suggests a strong dependency or preference"
  },
  {
    "line": 18,
    "text": "    entity_provider = \"joinquant\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific data schema indicates a pattern in data handling and processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      15234,
      1304,
      796,
      366,
      7639,
      18934,
      415,
      1
    ],
    "start_token": 57,
    "end_token": 70,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      1366,
      32815,
      9217,
      257,
      3912,
      287,
      1366,
      9041,
      290,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of a specific data schema indicates a pattern in data handling and processing"
  },
  {
    "line": 40,
    "text": "        level=IntervalLevel.LEVEL_1DAY,",
    "annotation": "\u2705 Best Practice: Call to superclass constructor ensures proper initialization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      9492,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      11
    ],
    "start_token": 70,
    "end_token": 89,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      4871,
      23772,
      19047,
      1774,
      37588
    ],
    "label": "best_practice",
    "reason": "Call to superclass constructor ensures proper initialization"
  },
  {
    "line": 61,
    "text": "            level,",
    "annotation": "\ud83e\udde0 ML Signal: Tracking the use of compute_index_money_flow for feature importance",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      11
    ],
    "start_token": 89,
    "end_token": 102,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      37169,
      262,
      779,
      286,
      24061,
      62,
      9630,
      62,
      26316,
      62,
      11125,
      329,
      3895,
      6817
    ],
    "label": "ml_signal",
    "reason": "Tracking the use of compute_index_money_flow for feature importance"
  },
  {
    "line": 63,
    "text": "            one_day_trading_minutes,",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Storing sensitive information like username and password in code",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      11
    ],
    "start_token": 102,
    "end_token": 123,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      520,
      3255,
      8564,
      1321,
      588,
      20579,
      290,
      9206,
      287,
      2438
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Storing sensitive information like username and password in code"
  },
  {
    "line": 62,
    "text": "            kdata_use_begin_time,",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with parameters indicating a pattern of generating IDs",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      479,
      7890,
      62,
      1904,
      62,
      27471,
      62,
      2435,
      11
    ],
    "start_token": 123,
    "end_token": 143,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      10007,
      12739,
      257,
      3912,
      286,
      15453,
      32373
    ],
    "label": "ml_signal",
    "reason": "Function definition with parameters indicating a pattern of generating IDs"
  },
  {
    "line": 64,
    "text": "            return_unfinished,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a function to generate an ID based on entity and timestamp",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      62,
      403,
      43952,
      11
    ],
    "start_token": 143,
    "end_token": 159,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2163,
      284,
      7716,
      281,
      4522,
      1912,
      319,
      9312,
      290,
      41033
    ],
    "label": "ml_signal",
    "reason": "Usage of a function to generate an ID based on entity and timestamp"
  },
  {
    "line": 65,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Using descriptive function and parameter names for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 159,
    "end_token": 167,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      35644,
      2163,
      290,
      11507,
      3891,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Using descriptive function and parameter names for clarity"
  },
  {
    "line": 65,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Method that triggers actions based on a condition",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 167,
    "end_token": 175,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      326,
      20022,
      4028,
      1912,
      319,
      257,
      4006
    ],
    "label": "ml_signal",
    "reason": "Method that triggers actions based on a condition"
  },
  {
    "line": 67,
    "text": "        get_token(zvt_config[\"jq_username\"], zvt_config[\"jq_password\"], force=True)",
    "annotation": "\ud83e\udde0 ML Signal: Instantiation and execution of a specific recorder class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      651,
      62,
      30001,
      7,
      89,
      36540,
      62,
      11250,
      14692,
      73,
      80,
      62,
      29460,
      33116,
      1976,
      36540,
      62,
      11250,
      14692,
      73,
      80,
      62,
      28712,
      33116,
      2700,
      28,
      17821,
      8
    ],
    "start_token": 175,
    "end_token": 210,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24470,
      3920,
      290,
      9706,
      286,
      257,
      2176,
      38156,
      1398
    ],
    "label": "ml_signal",
    "reason": "Instantiation and execution of a specific recorder class"
  },
  {
    "line": 68,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for unhandled exceptions during execution",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 210,
    "end_token": 210,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      555,
      38788,
      13269,
      1141,
      9706
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for unhandled exceptions during execution"
  },
  {
    "line": 68,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `self.end_timestamp` is not properly validated before use.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 210,
    "end_token": 210,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      944,
      13,
      437,
      62,
      16514,
      27823,
      63,
      318,
      407,
      6105,
      31031,
      878,
      779,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `self.end_timestamp` is not properly validated before use."
  },
  {
    "line": 69,
    "text": "    def generate_domain_id(self, entity, original_data):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external function `get_money_flow` with specific parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7716,
      62,
      27830,
      62,
      312,
      7,
      944,
      11,
      9312,
      11,
      2656,
      62,
      7890,
      2599
    ],
    "start_token": 210,
    "end_token": 228,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      2163,
      4600,
      1136,
      62,
      26316,
      62,
      11125,
      63,
      351,
      2176,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of external function `get_money_flow` with specific parameters."
  },
  {
    "line": 73,
    "text": "        # \u6839\u636e \u4e2a\u80a1\u8d44\u91d1\u6d41 \u8ba1\u7b97 \u5927\u76d8\u8d44\u91d1\u6d41",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic affecting function call parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      10545,
      254,
      117,
      162,
      235,
      106,
      220,
      10310,
      103,
      164,
      224,
      94,
      164,
      113,
      226,
      34932,
      239,
      38184,
      223,
      5525,
      106,
      94,
      163,
      106,
      245,
      36469,
      100,
      33566,
      246,
      164,
      113,
      226,
      34932,
      239,
      38184,
      223
    ],
    "start_token": 228,
    "end_token": 272,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      13891,
      2163,
      869,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic affecting function call parameters."
  },
  {
    "line": 75,
    "text": "            JoinquantIndexMoneyFlowRecorder().run()",
    "annotation": "\u2705 Best Practice: Dropping NaN values to ensure data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15251,
      40972,
      15732,
      26788,
      37535,
      6690,
      2875,
      22446,
      5143,
      3419
    ],
    "start_token": 272,
    "end_token": 293,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      11013,
      45,
      3815,
      284,
      4155,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Dropping NaN values to ensure data integrity."
  },
  {
    "line": 75,
    "text": "            JoinquantIndexMoneyFlowRecorder().run()",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes `pd_is_not_null` correctly identifies non-null DataFrames.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15251,
      40972,
      15732,
      26788,
      37535,
      6690,
      2875,
      22446,
      5143,
      3419
    ],
    "start_token": 293,
    "end_token": 314,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      4600,
      30094,
      62,
      271,
      62,
      1662,
      62,
      8423,
      63,
      9380,
      21079,
      1729,
      12,
      8423,
      6060,
      35439,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes `pd_is_not_null` correctly identifies non-null DataFrames."
  },
  {
    "line": 75,
    "text": "            JoinquantIndexMoneyFlowRecorder().run()",
    "annotation": "\ud83e\udde0 ML Signal: Adding a new column with a constant value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15251,
      40972,
      15732,
      26788,
      37535,
      6690,
      2875,
      22446,
      5143,
      3419
    ],
    "start_token": 314,
    "end_token": 335,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      649,
      5721,
      351,
      257,
      6937,
      1988,
      13
    ],
    "label": "ml_signal",
    "reason": "Adding a new column with a constant value."
  },
  {
    "line": 75,
    "text": "            JoinquantIndexMoneyFlowRecorder().run()",
    "annotation": "\u2705 Best Practice: Renaming columns for clarity and consistency.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15251,
      40972,
      15732,
      26788,
      37535,
      6690,
      2875,
      22446,
      5143,
      3419
    ],
    "start_token": 335,
    "end_token": 356,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7152,
      3723,
      15180,
      329,
      16287,
      290,
      15794,
      13
    ],
    "label": "best_practice",
    "reason": "Renaming columns for clarity and consistency."
  },
  {
    "line": 98,
    "text": "                    \"net_amount_s\": \"net_small_inflows\",",
    "annotation": "\u2705 Best Practice: Using a list to manage related column names.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      3262,
      62,
      17287,
      62,
      82,
      1298,
      366,
      3262,
      62,
      17470,
      62,
      259,
      44041,
      1600
    ],
    "start_token": 356,
    "end_token": 390,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      1351,
      284,
      6687,
      3519,
      5721,
      3891,
      13
    ],
    "label": "best_practice",
    "reason": "Using a list to manage related column names."
  },
  {
    "line": 104,
    "text": "            # \u8f6c\u6362\u5230\u6807\u51c6float",
    "annotation": "\u2705 Best Practice: Converting data to numeric type with error handling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      5525,
      121,
      105,
      162,
      235,
      95,
      26344,
      108,
      43718,
      229,
      49035,
      228,
      22468
    ],
    "start_token": 390,
    "end_token": 415,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      1366,
      284,
      35575,
      2099,
      351,
      4049,
      9041,
      13
    ],
    "label": "best_practice",
    "reason": "Converting data to numeric type with error handling."
  },
  {
    "line": 111,
    "text": "            ]",
    "annotation": "\u2705 Best Practice: Dropping NaN values to ensure data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 415,
    "end_token": 427,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      11013,
      45,
      3815,
      284,
      4155,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Dropping NaN values to ensure data integrity."
  },
  {
    "line": 111,
    "text": "            ]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes `pd_is_not_null` correctly identifies non-null DataFrames.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 427,
    "end_token": 439,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      4600,
      30094,
      62,
      271,
      62,
      1662,
      62,
      8423,
      63,
      9380,
      21079,
      1729,
      12,
      8423,
      6060,
      35439,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes `pd_is_not_null` correctly identifies non-null DataFrames."
  },
  {
    "line": 114,
    "text": "            df = df.dropna()",
    "annotation": "\ud83e\udde0 ML Signal: Applying a transformation to a DataFrame column.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      47764,
      13,
      14781,
      2616,
      3419
    ],
    "start_token": 439,
    "end_token": 457,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      13389,
      284,
      257,
      6060,
      19778,
      5721,
      13
    ],
    "label": "ml_signal",
    "reason": "Applying a transformation to a DataFrame column."
  },
  {
    "line": 116,
    "text": "            if not pd_is_not_null(df):",
    "annotation": "\u2705 Best Practice: Using a list to manage related column names.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      279,
      67,
      62,
      271,
      62,
      1662,
      62,
      8423,
      7,
      7568,
      2599
    ],
    "start_token": 457,
    "end_token": 481,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      257,
      1351,
      284,
      6687,
      3519,
      5721,
      3891,
      13
    ],
    "label": "best_practice",
    "reason": "Using a list to manage related column names."
  },
  {
    "line": 125,
    "text": "                \"net_medium_inflow_rate\",",
    "annotation": "\u2705 Best Practice: Converting data to numeric type with error handling.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      366,
      3262,
      62,
      24132,
      62,
      259,
      11125,
      62,
      4873,
      1600
    ],
    "start_token": 481,
    "end_token": 506,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      1366,
      284,
      35575,
      2099,
      351,
      4049,
      9041,
      13
    ],
    "label": "best_practice",
    "reason": "Converting data to numeric type with error handling."
  },
  {
    "line": 127,
    "text": "            ]",
    "annotation": "\u2705 Best Practice: Dropping NaN values to ensure data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 506,
    "end_token": 518,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      21045,
      2105,
      11013,
      45,
      3815,
      284,
      4155,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Dropping NaN values to ensure data integrity."
  },
  {
    "line": 129,
    "text": "                df[col] = pd.to_numeric(df[col], errors=\"coerce\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes `pd_is_not_null` correctly identifies non-null DataFrames.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      4033,
      60,
      796,
      279,
      67,
      13,
      1462,
      62,
      77,
      39223,
      7,
      7568,
      58,
      4033,
      4357,
      8563,
      2625,
      1073,
      263,
      344,
      4943
    ],
    "start_token": 518,
    "end_token": 556,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      4600,
      30094,
      62,
      271,
      62,
      1662,
      62,
      8423,
      63,
      9380,
      21079,
      1729,
      12,
      8423,
      6060,
      35439,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes `pd_is_not_null` correctly identifies non-null DataFrames."
  },
  {
    "line": 132,
    "text": "                return None",
    "annotation": "\ud83e\udde0 ML Signal: Applying a transformation to a DataFrame column.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 556,
    "end_token": 573,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      13389,
      284,
      257,
      6060,
      19778,
      5721,
      13
    ],
    "label": "ml_signal",
    "reason": "Applying a transformation to a DataFrame column."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Creating a new column based on arithmetic operations on existing columns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 573,
    "end_token": 614,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      649,
      5721,
      1912,
      319,
      34768,
      4560,
      319,
      4683,
      15180,
      13
    ],
    "label": "ml_signal",
    "reason": "Creating a new column based on arithmetic operations on existing columns."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential division by zero if `df[\"net_main_inflow_rate\"]` contains zeros.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 614,
    "end_token": 655,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7297,
      416,
      6632,
      611,
      4600,
      7568,
      14692,
      3262,
      62,
      12417,
      62,
      259,
      11125,
      62,
      4873,
      8973,
      63,
      4909,
      1976,
      27498,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential division by zero if `df[\"net_main_inflow_rate\"]` contains zeros."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Creating a new column based on arithmetic operations on existing columns.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 655,
    "end_token": 696,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      649,
      5721,
      1912,
      319,
      34768,
      4560,
      319,
      4683,
      15180,
      13
    ],
    "label": "ml_signal",
    "reason": "Creating a new column based on arithmetic operations on existing columns."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Adding a new column with a constant value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 696,
    "end_token": 737,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      649,
      5721,
      351,
      257,
      6937,
      1988,
      13
    ],
    "label": "ml_signal",
    "reason": "Adding a new column with a constant value."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\u2705 Best Practice: Converting string to datetime for consistency and operations.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 737,
    "end_token": 778,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      4731,
      284,
      4818,
      8079,
      329,
      15794,
      290,
      4560,
      13
    ],
    "label": "best_practice",
    "reason": "Converting string to datetime for consistency and operations."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Adding a new column with a constant value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 778,
    "end_token": 819,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      649,
      5721,
      351,
      257,
      6937,
      1988,
      13
    ],
    "label": "ml_signal",
    "reason": "Adding a new column with a constant value."
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Adding a new column with a constant value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 819,
    "end_token": 860,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      649,
      5721,
      351,
      257,
      6937,
      1988,
      13
    ],
    "label": "ml_signal",
    "reason": "Adding a new column with a constant value."
  },
  {
    "line": 127,
    "text": "            ]",
    "annotation": "\u2705 Best Practice: Use of string formatting for constructing unique identifiers",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2361
    ],
    "start_token": 860,
    "end_token": 872,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4731,
      33313,
      329,
      30580,
      3748,
      42814
    ],
    "label": "best_practice",
    "reason": "Use of string formatting for constructing unique identifiers"
  },
  {
    "line": 129,
    "text": "                df[col] = pd.to_numeric(df[col], errors=\"coerce\")",
    "annotation": "\ud83e\udde0 ML Signal: Applying a function across DataFrame rows",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      4033,
      60,
      796,
      279,
      67,
      13,
      1462,
      62,
      77,
      39223,
      7,
      7568,
      58,
      4033,
      4357,
      8563,
      2625,
      1073,
      263,
      344,
      4943
    ],
    "start_token": 872,
    "end_token": 910,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      3157,
      257,
      2163,
      1973,
      6060,
      19778,
      15274
    ],
    "label": "ml_signal",
    "reason": "Applying a function across DataFrame rows"
  },
  {
    "line": 131,
    "text": "            if not pd_is_not_null(df):",
    "annotation": "\ud83e\udde0 ML Signal: Dropping duplicates in a DataFrame",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      279,
      67,
      62,
      271,
      62,
      1662,
      62,
      8423,
      7,
      7568,
      2599
    ],
    "start_token": 910,
    "end_token": 934,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21045,
      2105,
      14184,
      16856,
      287,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Dropping duplicates in a DataFrame"
  },
  {
    "line": 133,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Saving DataFrame to a database",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 934,
    "end_token": 934,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      34689,
      6060,
      19778,
      284,
      257,
      6831
    ],
    "label": "ml_signal",
    "reason": "Saving DataFrame to a database"
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Running a specific function or class with a set of parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 934,
    "end_token": 975,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18162,
      257,
      2176,
      2163,
      393,
      1398,
      351,
      257,
      900,
      286,
      10007
    ],
    "label": "ml_signal",
    "reason": "Running a specific function or class with a set of parameters"
  },
  {
    "line": 134,
    "text": "            df[inflow_rate_cols] = df[inflow_rate_cols].apply(lambda x: x / 100)",
    "annotation": "\ud83e\udde0 ML Signal: Defining __all__ for module exports",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      60,
      796,
      47764,
      58,
      259,
      11125,
      62,
      4873,
      62,
      4033,
      82,
      4083,
      39014,
      7,
      50033,
      2124,
      25,
      2124,
      1220,
      1802,
      8
    ],
    "start_token": 975,
    "end_token": 1016,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2896,
      3191,
      11593,
      439,
      834,
      329,
      8265,
      15319
    ],
    "label": "ml_signal",
    "reason": "Defining __all__ for module exports"
  }
]