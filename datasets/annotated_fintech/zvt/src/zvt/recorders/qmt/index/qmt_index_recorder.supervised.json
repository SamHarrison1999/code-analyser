[
  {
    "line": 7,
    "text": "from zvt.contract import IntervalLevel",
    "annotation": "\u2705 Best Practice: Grouping imports by their source (standard library, third-party, local) improves readability.",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      28484,
      1330,
      4225,
      2100,
      4971
    ],
    "start_token": 0,
    "end_token": 9,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      416,
      511,
      2723,
      357,
      20307,
      5888,
      11,
      2368,
      12,
      10608,
      11,
      1957,
      8,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports by their source (standard library, third-party, local) improves readability."
  },
  {
    "line": 12,
    "text": "from zvt.utils.pd_utils import pd_is_not_null",
    "annotation": "\u2705 Best Practice: Class definition should follow PEP 8 naming conventions, using CamelCase.",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      26791,
      13,
      30094,
      62,
      26791,
      1330,
      279,
      67,
      62,
      271,
      62,
      1662,
      62,
      8423
    ],
    "start_token": 9,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      350,
      8905,
      807,
      19264,
      21396,
      11,
      1262,
      43281,
      20448,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should follow PEP 8 naming conventions, using CamelCase."
  },
  {
    "line": 14,
    "text": "",
    "annotation": "\u2705 Best Practice: Class attributes should be documented for clarity and maintainability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 27,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12608,
      815,
      307,
      12395,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class attributes should be documented for clarity and maintainability."
  },
  {
    "line": 16,
    "text": "class QmtIndexRecorder(FixedCycleDataRecorder):",
    "annotation": "\u2705 Best Practice: Class attributes should be documented for clarity and maintainability.",
    "confidence": 0.5,
    "tokens": [
      4871,
      1195,
      16762,
      15732,
      6690,
      2875,
      7,
      13715,
      20418,
      2375,
      6601,
      6690,
      2875,
      2599
    ],
    "start_token": 27,
    "end_token": 41,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12608,
      815,
      307,
      12395,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class attributes should be documented for clarity and maintainability."
  },
  {
    "line": 18,
    "text": "    # class level kdata schema should always use common",
    "annotation": "\u2705 Best Practice: Class attributes should be documented for clarity and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      1398,
      1241,
      479,
      7890,
      32815,
      815,
      1464,
      779,
      2219
    ],
    "start_token": 41,
    "end_token": 54,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12608,
      815,
      307,
      12395,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class attributes should be documented for clarity and maintainability."
  },
  {
    "line": 18,
    "text": "    # class level kdata schema should always use common",
    "annotation": "\u2705 Best Practice: Class attributes should be documented for clarity and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      1398,
      1241,
      479,
      7890,
      32815,
      815,
      1464,
      779,
      2219
    ],
    "start_token": 54,
    "end_token": 67,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12608,
      815,
      307,
      12395,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class attributes should be documented for clarity and maintainability."
  },
  {
    "line": 18,
    "text": "    # class level kdata schema should always use common",
    "annotation": "\u2705 Best Practice: Class attributes should be documented for clarity and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      1398,
      1241,
      479,
      7890,
      32815,
      815,
      1464,
      779,
      2219
    ],
    "start_token": 67,
    "end_token": 80,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      12608,
      815,
      307,
      12395,
      329,
      16287,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Class attributes should be documented for clarity and maintainability."
  },
  {
    "line": 40,
    "text": "        level=IntervalLevel.LEVEL_1DAY,",
    "annotation": "\u2705 Best Practice: Convert level to IntervalLevel to ensure type consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      9492,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      11
    ],
    "start_token": 80,
    "end_token": 99,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      1241,
      284,
      4225,
      2100,
      4971,
      284,
      4155,
      2099,
      15794
    ],
    "label": "best_practice",
    "reason": "Convert level to IntervalLevel to ensure type consistency"
  },
  {
    "line": 42,
    "text": "        one_day_trading_minutes=24 * 60,",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded entity type can indicate specific domain usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      28,
      1731,
      1635,
      3126,
      11
    ],
    "start_token": 99,
    "end_token": 120,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      9312,
      2099,
      460,
      7603,
      2176,
      7386,
      8748
    ],
    "label": "ml_signal",
    "reason": "Hardcoded entity type can indicate specific domain usage"
  },
  {
    "line": 44,
    "text": "        download_history_data=False,",
    "annotation": "\ud83e\udde0 ML Signal: Tracking download history data preference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4321,
      62,
      23569,
      62,
      7890,
      28,
      25101,
      11
    ],
    "start_token": 120,
    "end_token": 135,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      37169,
      4321,
      2106,
      1366,
      12741
    ],
    "label": "ml_signal",
    "reason": "Tracking download history data preference"
  },
  {
    "line": 44,
    "text": "        download_history_data=False,",
    "annotation": "\u2705 Best Practice: Use of a function to get schema improves maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4321,
      62,
      23569,
      62,
      7890,
      28,
      25101,
      11
    ],
    "start_token": 135,
    "end_token": 150,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      2163,
      284,
      651,
      32815,
      19575,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of a function to get schema improves maintainability"
  },
  {
    "line": 44,
    "text": "        download_history_data=False,",
    "annotation": "\u2705 Best Practice: Use of super() to call parent class constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4321,
      62,
      23569,
      62,
      7890,
      28,
      25101,
      11
    ],
    "start_token": 150,
    "end_token": 165,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      2560,
      1398,
      23772
    ],
    "label": "best_practice",
    "reason": "Use of super() to call parent class constructor"
  },
  {
    "line": 69,
    "text": "            one_day_trading_minutes,",
    "annotation": "\u2705 Best Practice: Explicitly setting one_day_trading_minutes for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      11
    ],
    "start_token": 165,
    "end_token": 186,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      530,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly setting one_day_trading_minutes for clarity"
  },
  {
    "line": 66,
    "text": "            end_timestamp,",
    "annotation": "\u2705 Best Practice: Check if 'start' is not None before using it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      16514,
      27823,
      11
    ],
    "start_token": 186,
    "end_token": 202,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      9688,
      6,
      318,
      407,
      6045,
      878,
      1262,
      340
    ],
    "label": "best_practice",
    "reason": "Check if 'start' is not None before using it"
  },
  {
    "line": 69,
    "text": "            one_day_trading_minutes,",
    "annotation": "\u2705 Best Practice: Provide a default value for 'start' if it is None",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      530,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      11
    ],
    "start_token": 202,
    "end_token": 223,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      4277,
      1988,
      329,
      705,
      9688,
      6,
      611,
      340,
      318,
      6045
    ],
    "label": "best_practice",
    "reason": "Provide a default value for 'start' if it is None"
  },
  {
    "line": 72,
    "text": "        self.one_day_trading_minutes = 240",
    "annotation": "\u2705 Best Practice: Provide a default value for 'end' if it is None",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      505,
      62,
      820,
      62,
      2213,
      4980,
      62,
      1084,
      1769,
      796,
      14956
    ],
    "start_token": 223,
    "end_token": 243,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      4277,
      1988,
      329,
      705,
      437,
      6,
      611,
      340,
      318,
      6045
    ],
    "label": "best_practice",
    "reason": "Provide a default value for 'end' if it is None"
  },
  {
    "line": 74,
    "text": "    def record(self, entity, start, end, size, timestamps):",
    "annotation": "\u2705 Best Practice: Adjust 'end' for specific interval levels",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      1700,
      7,
      944,
      11,
      9312,
      11,
      923,
      11,
      886,
      11,
      2546,
      11,
      4628,
      395,
      9430,
      2599
    ],
    "start_token": 243,
    "end_token": 263,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20292,
      705,
      437,
      6,
      329,
      2176,
      16654,
      2974
    ],
    "label": "best_practice",
    "reason": "Adjust 'end' for specific interval levels"
  },
  {
    "line": 74,
    "text": "    def record(self, entity, start, end, size, timestamps):",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external data fetching function",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      1700,
      7,
      944,
      11,
      9312,
      11,
      923,
      11,
      886,
      11,
      2546,
      11,
      4628,
      395,
      9430,
      2599
    ],
    "start_token": 263,
    "end_token": 283,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      1366,
      21207,
      278,
      2163
    ],
    "label": "ml_signal",
    "reason": "Usage of external data fetching function"
  },
  {
    "line": 86,
    "text": "        df = qmt_quote.get_kdata(",
    "annotation": "\u2705 Best Practice: Use a conditional expression to determine time format",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      796,
      10662,
      16762,
      62,
      22708,
      13,
      1136,
      62,
      74,
      7890,
      7
    ],
    "start_token": 283,
    "end_token": 302,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      257,
      26340,
      5408,
      284,
      5004,
      640,
      5794
    ],
    "label": "best_practice",
    "reason": "Use a conditional expression to determine time format"
  },
  {
    "line": 89,
    "text": "            end_timestamp=end,",
    "annotation": "\u2705 Best Practice: Check if DataFrame is not null before processing",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      16514,
      27823,
      28,
      437,
      11
    ],
    "start_token": 302,
    "end_token": 320,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      6060,
      19778,
      318,
      407,
      9242,
      878,
      7587
    ],
    "label": "best_practice",
    "reason": "Check if DataFrame is not null before processing"
  },
  {
    "line": 92,
    "text": "            download_history=self.download_history_data,",
    "annotation": "\u2705 Best Practice: Convert index to datetime for consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4321,
      62,
      23569,
      28,
      944,
      13,
      15002,
      62,
      23569,
      62,
      7890,
      11
    ],
    "start_token": 320,
    "end_token": 343,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      38240,
      6376,
      284,
      4818,
      8079,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Convert index to datetime for consistency"
  },
  {
    "line": 94,
    "text": "        time_str_fmt = TIME_FORMAT_DAY if self.level == IntervalLevel.LEVEL_1DAY else TIME_FORMAT_MINUTE",
    "annotation": "\ud83e\udde0 ML Signal: Creation of unique identifiers for rows",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      62,
      2536,
      62,
      69,
      16762,
      796,
      20460,
      62,
      21389,
      1404,
      62,
      26442,
      611,
      2116,
      13,
      5715,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      2073,
      20460,
      62,
      21389,
      1404,
      62,
      23678,
      37780
    ],
    "start_token": 343,
    "end_token": 385,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21582,
      286,
      3748,
      42814,
      329,
      15274
    ],
    "label": "ml_signal",
    "reason": "Creation of unique identifiers for rows"
  },
  {
    "line": 100,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Rename columns for clarity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 385,
    "end_token": 397,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      7152,
      480,
      15180,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Rename columns for clarity"
  },
  {
    "line": 106,
    "text": "            df[\"change_pct\"] = (df[\"close\"] - df[\"preClose\"]) / df[\"preClose\"]",
    "annotation": "\u2705 Best Practice: Calculate percentage change for analysis",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      62,
      79,
      310,
      8973,
      796,
      357,
      7568,
      14692,
      19836,
      8973,
      532,
      47764,
      14692,
      3866,
      26125,
      8973,
      8,
      1220,
      47764,
      14692,
      3866,
      26125,
      8973
    ],
    "start_token": 397,
    "end_token": 434,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      378,
      5873,
      1487,
      329,
      3781
    ],
    "label": "best_practice",
    "reason": "Calculate percentage change for analysis"
  },
  {
    "line": 106,
    "text": "            df[\"change_pct\"] = (df[\"close\"] - df[\"preClose\"]) / df[\"preClose\"]",
    "annotation": "\ud83e\udde0 ML Signal: Storing processed data into a database",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      62,
      79,
      310,
      8973,
      796,
      357,
      7568,
      14692,
      19836,
      8973,
      532,
      47764,
      14692,
      3866,
      26125,
      8973,
      8,
      1220,
      47764,
      14692,
      3866,
      26125,
      8973
    ],
    "start_token": 434,
    "end_token": 471,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      520,
      3255,
      13686,
      1366,
      656,
      257,
      6831
    ],
    "label": "ml_signal",
    "reason": "Storing processed data into a database"
  },
  {
    "line": 106,
    "text": "            df[\"change_pct\"] = (df[\"close\"] - df[\"preClose\"]) / df[\"preClose\"]",
    "annotation": "\u2705 Best Practice: Log information when no data is found",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      62,
      79,
      310,
      8973,
      796,
      357,
      7568,
      14692,
      19836,
      8973,
      532,
      47764,
      14692,
      3866,
      26125,
      8973,
      8,
      1220,
      47764,
      14692,
      3866,
      26125,
      8973
    ],
    "start_token": 471,
    "end_token": 508,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5972,
      1321,
      618,
      645,
      1366,
      318,
      1043
    ],
    "label": "best_practice",
    "reason": "Log information when no data is found"
  },
  {
    "line": 99,
    "text": "                lambda row: f\"{row['entity_id']}_{to_time_str(row['timestamp'], fmt=time_str_fmt)}\", axis=1",
    "annotation": "\u2705 Best Practice: Check if all required conditions are met before proceeding with the logic.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37456,
      5752,
      25,
      277,
      1,
      90,
      808,
      17816,
      26858,
      62,
      312,
      20520,
      92,
      23330,
      1462,
      62,
      2435,
      62,
      2536,
      7,
      808,
      17816,
      16514,
      27823,
      6,
      4357,
      46996,
      28,
      2435,
      62,
      2536,
      62,
      69,
      16762,
      38165,
      1600,
      16488,
      28,
      16
    ],
    "start_token": 508,
    "end_token": 562,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      477,
      2672,
      3403,
      389,
      1138,
      878,
      18788,
      351,
      262,
      9156,
      13
    ],
    "label": "best_practice",
    "reason": "Check if all required conditions are met before proceeding with the logic."
  },
  {
    "line": 100,
    "text": "            )",
    "annotation": "\ud83e\udde0 ML Signal: Evaluating size based on timestamps can indicate data completeness.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 562,
    "end_token": 574,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26439,
      11927,
      2546,
      1912,
      319,
      4628,
      395,
      9430,
      460,
      7603,
      1366,
      1224,
      43205,
      13
    ],
    "label": "ml_signal",
    "reason": "Evaluating size based on timestamps can indicate data completeness."
  },
  {
    "line": 106,
    "text": "            df[\"change_pct\"] = (df[\"close\"] - df[\"preClose\"]) / df[\"preClose\"]",
    "annotation": "\ud83e\udde0 ML Signal: Querying a database to count records within a timestamp range.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47764,
      14692,
      3803,
      62,
      79,
      310,
      8973,
      796,
      357,
      7568,
      14692,
      19836,
      8973,
      532,
      47764,
      14692,
      3866,
      26125,
      8973,
      8,
      1220,
      47764,
      14692,
      3866,
      26125,
      8973
    ],
    "start_token": 574,
    "end_token": 611,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2264,
      263,
      1112,
      257,
      6831,
      284,
      954,
      4406,
      1626,
      257,
      41033,
      2837,
      13
    ],
    "label": "ml_signal",
    "reason": "Querying a database to count records within a timestamp range."
  },
  {
    "line": 118,
    "text": "                level=self.level,",
    "annotation": "\u2705 Best Practice: Compare expected and recorded sizes to ensure data integrity.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      944,
      13,
      5715,
      11
    ],
    "start_token": 611,
    "end_token": 632,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27814,
      2938,
      290,
      6264,
      10620,
      284,
      4155,
      1366,
      11540,
      13
    ],
    "label": "best_practice",
    "reason": "Compare expected and recorded sizes to ensure data integrity."
  },
  {
    "line": 120,
    "text": "            )",
    "annotation": "\u2705 Best Practice: Use of super() to call a method from the parent class.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 632,
    "end_token": 644,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      257,
      2446,
      422,
      262,
      2560,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Use of super() to call a method from the parent class."
  },
  {
    "line": 122,
    "text": "            recorded_size = (",
    "annotation": "\u2705 Best Practice: Check if end_timestamp is not None before comparing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6264,
      62,
      7857,
      796,
      357
    ],
    "start_token": 644,
    "end_token": 660,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      886,
      62,
      16514,
      27823,
      318,
      407,
      6045,
      878,
      14176,
      13
    ],
    "label": "best_practice",
    "reason": "Check if end_timestamp is not None before comparing."
  },
  {
    "line": 122,
    "text": "            recorded_size = (",
    "annotation": "\u2705 Best Practice: Ensure start_timestamp is less than end_timestamp.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6264,
      62,
      7857,
      796,
      357
    ],
    "start_token": 660,
    "end_token": 676,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48987,
      923,
      62,
      16514,
      27823,
      318,
      1342,
      621,
      886,
      62,
      16514,
      27823,
      13
    ],
    "label": "best_practice",
    "reason": "Ensure start_timestamp is less than end_timestamp."
  },
  {
    "line": 129,
    "text": "                .count()",
    "annotation": "\ud83e\udde0 ML Signal: Re-evaluating size based on updated timestamps.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      764,
      9127,
      3419
    ],
    "start_token": 676,
    "end_token": 694,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      797,
      12,
      18206,
      11927,
      2546,
      1912,
      319,
      6153,
      4628,
      395,
      9430,
      13
    ],
    "label": "ml_signal",
    "reason": "Re-evaluating size based on updated timestamps."
  },
  {
    "line": 141,
    "text": "            else:",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of timestamps for a specific date range.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 694,
    "end_token": 707,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      4628,
      395,
      9430,
      329,
      257,
      2176,
      3128,
      2837,
      13
    ],
    "label": "ml_signal",
    "reason": "Initialization of timestamps for a specific date range."
  },
  {
    "line": 141,
    "text": "            else:",
    "annotation": "\ud83e\udde0 ML Signal: Instantiation and execution of a recorder with specific parameters.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 707,
    "end_token": 720,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24470,
      3920,
      290,
      9706,
      286,
      257,
      38156,
      351,
      2176,
      10007,
      13
    ],
    "label": "ml_signal",
    "reason": "Instantiation and execution of a recorder with specific parameters."
  },
  {
    "line": 141,
    "text": "            else:",
    "annotation": "\u2705 Best Practice: Use of __all__ to define public symbols in a module.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 720,
    "end_token": 733,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      439,
      834,
      284,
      8160,
      1171,
      14354,
      287,
      257,
      8265,
      13
    ],
    "label": "best_practice",
    "reason": "Use of __all__ to define public symbols in a module."
  }
]