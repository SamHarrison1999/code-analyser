[
  {
    "line": 3,
    "text": "",
    "annotation": "\u2705 Best Practice: Grouping imports into standard library, third-party, and local can improve readability.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 0,
    "end_token": 0,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      656,
      3210,
      5888,
      11,
      2368,
      12,
      10608,
      11,
      290,
      1957,
      460,
      2987,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports into standard library, third-party, and local can improve readability."
  },
  {
    "line": 11,
    "text": "from zvt.factors.algorithm import MaTransformer, MaAndVolumeTransformer",
    "annotation": "\u2705 Best Practice: Consider importing Union from typing for type hinting",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      22584,
      669,
      13,
      282,
      42289,
      1330,
      6669,
      8291,
      16354,
      11,
      6669,
      1870,
      31715,
      8291,
      16354
    ],
    "start_token": 0,
    "end_token": 19,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      33332,
      4479,
      422,
      19720,
      329,
      2099,
      9254,
      278
    ],
    "label": "best_practice",
    "reason": "Consider importing Union from typing for type hinting"
  },
  {
    "line": 13,
    "text": "from zvt.utils.time_utils import now_pd_timestamp",
    "annotation": "\u2705 Best Practice: Use isinstance() instead of type() for type checking",
    "confidence": 0.5,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      26791,
      13,
      2435,
      62,
      26791,
      1330,
      783,
      62,
      30094,
      62,
      16514,
      27823
    ],
    "start_token": 19,
    "end_token": 35,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      318,
      39098,
      3419,
      2427,
      286,
      2099,
      3419,
      329,
      2099,
      10627
    ],
    "label": "best_practice",
    "reason": "Use isinstance() instead of type() for type checking"
  },
  {
    "line": 15,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider handling exceptions when converting string to IntervalLevel",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 35,
    "end_token": 35,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      9041,
      13269,
      618,
      23202,
      4731,
      284,
      4225,
      2100,
      4971
    ],
    "label": "best_practice",
    "reason": "Consider handling exceptions when converting string to IntervalLevel"
  },
  {
    "line": 17,
    "text": "    if type(level) == str:",
    "annotation": "\ud83e\udde0 ML Signal: Usage of string formatting to create schema names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      2099,
      7,
      5715,
      8,
      6624,
      965,
      25
    ],
    "start_token": 35,
    "end_token": 46,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      4731,
      33313,
      284,
      2251,
      32815,
      3891
    ],
    "label": "ml_signal",
    "reason": "Usage of string formatting to create schema names"
  },
  {
    "line": 17,
    "text": "    if type(level) == str:",
    "annotation": "\ud83e\udde0 ML Signal: Function call pattern to retrieve schema by name",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      2099,
      7,
      5715,
      8,
      6624,
      965,
      25
    ],
    "start_token": 46,
    "end_token": 57,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      869,
      3912,
      284,
      19818,
      32815,
      416,
      1438
    ],
    "label": "ml_signal",
    "reason": "Function call pattern to retrieve schema by name"
  },
  {
    "line": 16,
    "text": "def get_ma_factor_schema(entity_type: str, level: Union[IntervalLevel, str] = IntervalLevel.LEVEL_1DAY):",
    "annotation": "\u2705 Best Practice: Class definition should follow PEP 8 naming conventions, which is CamelCase.",
    "confidence": 0.5,
    "tokens": [
      4299,
      651,
      62,
      2611,
      62,
      31412,
      62,
      15952,
      2611,
      7,
      26858,
      62,
      4906,
      25,
      965,
      11,
      1241,
      25,
      4479,
      58,
      9492,
      2100,
      4971,
      11,
      965,
      60,
      796,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      2599
    ],
    "start_token": 57,
    "end_token": 94,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      350,
      8905,
      807,
      19264,
      21396,
      11,
      543,
      318,
      43281,
      20448,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should follow PEP 8 naming conventions, which is CamelCase."
  },
  {
    "line": 46,
    "text": "        effective_number: int = None,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `need_persist` is set to True without proper validation of `entity_schema`.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4050,
      62,
      17618,
      25,
      493,
      796,
      6045,
      11
    ],
    "start_token": 94,
    "end_token": 109,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      31227,
      62,
      19276,
      396,
      63,
      318,
      900,
      284,
      6407,
      1231,
      1774,
      21201,
      286,
      4600,
      26858,
      62,
      15952,
      2611,
      44646
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `need_persist` is set to True without proper validation of `entity_schema`."
  },
  {
    "line": 48,
    "text": "        only_compute_factor: bool = False,",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dynamic schema generation based on entity type and level.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      691,
      62,
      5589,
      1133,
      62,
      31412,
      25,
      20512,
      796,
      10352,
      11
    ],
    "start_token": 109,
    "end_token": 127,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8925,
      32815,
      5270,
      1912,
      319,
      9312,
      2099,
      290,
      1241,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of dynamic schema generation based on entity type and level."
  },
  {
    "line": 50,
    "text": "        clear_state: bool = False,",
    "annotation": "\u2705 Best Practice: Defaulting `windows` to a list of integers if not provided.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1598,
      62,
      5219,
      25,
      20512,
      796,
      10352,
      11
    ],
    "start_token": 127,
    "end_token": 142,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      278,
      4600,
      28457,
      63,
      284,
      257,
      1351,
      286,
      37014,
      611,
      407,
      2810,
      13
    ],
    "label": "best_practice",
    "reason": "Defaulting `windows` to a list of integers if not provided."
  },
  {
    "line": 52,
    "text": "        adjust_type: Union[AdjustType, str] = None,",
    "annotation": "\ud83e\udde0 ML Signal: Initialization of a transformer with specific window sizes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4532,
      62,
      4906,
      25,
      4479,
      58,
      39668,
      6030,
      11,
      965,
      60,
      796,
      6045,
      11
    ],
    "start_token": 142,
    "end_token": 163,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20768,
      1634,
      286,
      257,
      47385,
      351,
      2176,
      4324,
      10620,
      13
    ],
    "label": "ml_signal",
    "reason": "Initialization of a transformer with specific window sizes."
  },
  {
    "line": 52,
    "text": "        adjust_type: Union[AdjustType, str] = None,",
    "annotation": "\u2705 Best Practice: Using `super()` to ensure proper initialization of the base class.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4532,
      62,
      4906,
      25,
      4479,
      58,
      39668,
      6030,
      11,
      965,
      60,
      796,
      6045,
      11
    ],
    "start_token": 163,
    "end_token": 184,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4600,
      16668,
      3419,
      63,
      284,
      4155,
      1774,
      37588,
      286,
      262,
      2779,
      1398,
      13
    ],
    "label": "best_practice",
    "reason": "Using `super()` to ensure proper initialization of the base class."
  },
  {
    "line": 83,
    "text": "            transformer,",
    "annotation": "\u2705 Best Practice: Call to superclass method ensures base class functionality is executed",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      47385,
      11
    ],
    "start_token": 184,
    "end_token": 197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      4871,
      2446,
      19047,
      2779,
      1398,
      11244,
      318,
      10945
    ],
    "label": "best_practice",
    "reason": "Call to superclass method ensures base class functionality is executed"
  },
  {
    "line": 85,
    "text": "            need_persist,",
    "annotation": "\ud83e\udde0 ML Signal: List comprehension used for dynamic column name generation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      761,
      62,
      19276,
      396,
      11
    ],
    "start_token": 197,
    "end_token": 213,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7343,
      35915,
      973,
      329,
      8925,
      5721,
      1438,
      5270
    ],
    "label": "ml_signal",
    "reason": "List comprehension used for dynamic column name generation"
  },
  {
    "line": 87,
    "text": "            factor_name,",
    "annotation": "\ud83e\udde0 ML Signal: Boolean indexing pattern for DataFrame filtering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5766,
      62,
      3672,
      11
    ],
    "start_token": 213,
    "end_token": 228,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      41146,
      6376,
      278,
      3912,
      329,
      6060,
      19778,
      25431
    ],
    "label": "ml_signal",
    "reason": "Boolean indexing pattern for DataFrame filtering"
  },
  {
    "line": 91,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Iterative boolean condition refinement",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 228,
    "end_token": 236,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      876,
      25131,
      4006,
      47517
    ],
    "label": "ml_signal",
    "reason": "Iterative boolean condition refinement"
  },
  {
    "line": 93,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of print statement for debugging can expose data in production",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 236,
    "end_token": 236,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      3601,
      2643,
      329,
      28769,
      460,
      15651,
      1366,
      287,
      3227
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of print statement for debugging can expose data in production"
  },
  {
    "line": 93,
    "text": "",
    "annotation": "\u2705 Best Practice: Converting boolean Series to DataFrame for consistent data handling",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 236,
    "end_token": 236,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      35602,
      889,
      25131,
      7171,
      284,
      6060,
      19778,
      329,
      6414,
      1366,
      9041
    ],
    "label": "best_practice",
    "reason": "Converting boolean Series to DataFrame for consistent data handling"
  },
  {
    "line": 128,
    "text": "        fill_method: str = \"ffill\",",
    "annotation": "\u2705 Best Practice: Use of default mutable arguments (like lists) should be avoided to prevent shared state across instances.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      25,
      965,
      796,
      366,
      487,
      359,
      1600
    ],
    "start_token": 236,
    "end_token": 253,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      4517,
      540,
      7159,
      357,
      2339,
      8341,
      8,
      815,
      307,
      13941,
      284,
      2948,
      4888,
      1181,
      1973,
      10245,
      13
    ],
    "label": "best_practice",
    "reason": "Use of default mutable arguments (like lists) should be avoided to prevent shared state across instances."
  },
  {
    "line": 131,
    "text": "        need_persist: bool = False,",
    "annotation": "\u2705 Best Practice: Use of default mutable arguments (like lists) should be avoided to prevent shared state across instances.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      761,
      62,
      19276,
      396,
      25,
      20512,
      796,
      10352,
      11
    ],
    "start_token": 253,
    "end_token": 269,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      4517,
      540,
      7159,
      357,
      2339,
      8341,
      8,
      815,
      307,
      13941,
      284,
      2948,
      4888,
      1181,
      1973,
      10245,
      13
    ],
    "label": "best_practice",
    "reason": "Use of default mutable arguments (like lists) should be avoided to prevent shared state across instances."
  },
  {
    "line": 139,
    "text": "        turnover_threshold=300000000,",
    "annotation": "\ud83e\udde0 ML Signal: Use of a specific transformer class indicates a pattern for data transformation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25079,
      62,
      400,
      10126,
      28,
      18,
      8269,
      11
    ],
    "start_token": 269,
    "end_token": 284,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2176,
      47385,
      1398,
      9217,
      257,
      3912,
      329,
      1366,
      13389,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a specific transformer class indicates a pattern for data transformation."
  },
  {
    "line": 139,
    "text": "        turnover_threshold=300000000,",
    "annotation": "\ud83e\udde0 ML Signal: Use of a superclass constructor with many parameters suggests a pattern for object initialization.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      25079,
      62,
      400,
      10126,
      28,
      18,
      8269,
      11
    ],
    "start_token": 284,
    "end_token": 299,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      257,
      2208,
      4871,
      23772,
      351,
      867,
      10007,
      5644,
      257,
      3912,
      329,
      2134,
      37588,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of a superclass constructor with many parameters suggests a pattern for object initialization."
  },
  {
    "line": 169,
    "text": "            order,",
    "annotation": "\u2705 Best Practice: Call to superclass method ensures base functionality is executed",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      11
    ],
    "start_token": 299,
    "end_token": 312,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      4871,
      2446,
      19047,
      2779,
      11244,
      318,
      10945
    ],
    "label": "best_practice",
    "reason": "Call to superclass method ensures base functionality is executed"
  },
  {
    "line": 171,
    "text": "            level,",
    "annotation": "\ud83e\udde0 ML Signal: Use of list comprehension to generate column names",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      11
    ],
    "start_token": 312,
    "end_token": 325,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1351,
      35915,
      284,
      7716,
      5721,
      3891
    ],
    "label": "ml_signal",
    "reason": "Use of list comprehension to generate column names"
  },
  {
    "line": 174,
    "text": "            keep_window,",
    "annotation": "\ud83e\udde0 ML Signal: Use of boolean indexing for filtering data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1394,
      62,
      17497,
      11
    ],
    "start_token": 325,
    "end_token": 340,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      25131,
      6376,
      278,
      329,
      25431,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of boolean indexing for filtering data"
  },
  {
    "line": 176,
    "text": "            fill_method,",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on attribute value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      11
    ],
    "start_token": 340,
    "end_token": 355,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      11688,
      1988
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on attribute value"
  },
  {
    "line": 189,
    "text": "        super().compute_result()",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on attribute presence",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      5589,
      1133,
      62,
      20274,
      3419
    ],
    "start_token": 355,
    "end_token": 369,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      11688,
      4931
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on attribute presence"
  },
  {
    "line": 190,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of list comprehension to generate column names",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 369,
    "end_token": 369,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1351,
      35915,
      284,
      7716,
      5721,
      3891
    ],
    "label": "ml_signal",
    "reason": "Use of list comprehension to generate column names"
  },
  {
    "line": 196,
    "text": "        for col in cols[1:]:",
    "annotation": "\ud83e\udde0 ML Signal: Use of boolean indexing for filtering data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      951,
      287,
      951,
      82,
      58,
      16,
      25,
      5974
    ],
    "start_token": 369,
    "end_token": 385,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      25131,
      6376,
      278,
      329,
      25431,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of boolean indexing for filtering data"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\ud83e\udde0 ML Signal: Combination of multiple filters using logical AND",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 385,
    "end_token": 427,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      14336,
      1883,
      286,
      3294,
      16628,
      1262,
      12219,
      5357
    ],
    "label": "ml_signal",
    "reason": "Combination of multiple filters using logical AND"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of '==' to compare with False, consider using 'is False'",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 427,
    "end_token": 469,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      705,
      855,
      6,
      284,
      8996,
      351,
      10352,
      11,
      2074,
      1262,
      705,
      271,
      10352,
      6
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of '==' to compare with False, consider using 'is False'"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\ud83e\udde0 ML Signal: Use of groupby and fillna for forward filling missing values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 469,
    "end_token": 511,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1448,
      1525,
      290,
      6070,
      2616,
      329,
      2651,
      12591,
      4814,
      3815
    ],
    "label": "ml_signal",
    "reason": "Use of groupby and fillna for forward filling missing values"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of 'isna()' to check for NaN values",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 511,
    "end_token": 553,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      705,
      271,
      2616,
      3419,
      6,
      284,
      2198,
      329,
      11013,
      45,
      3815
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of 'isna()' to check for NaN values"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\ud83e\udde0 ML Signal: Combination of multiple filters using logical AND",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 553,
    "end_token": 595,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      14336,
      1883,
      286,
      3294,
      16628,
      1262,
      12219,
      5357
    ],
    "label": "ml_signal",
    "reason": "Combination of multiple filters using logical AND"
  },
  {
    "line": 200,
    "text": "                    & (self.factor_df[\"close\"] < 1.1 * self.factor_df[col])",
    "annotation": "\u2705 Best Practice: Storing result in a DataFrame for further processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1222,
      357,
      944,
      13,
      31412,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      352,
      13,
      16,
      1635,
      2116,
      13,
      31412,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 595,
    "end_token": 637,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      520,
      3255,
      1255,
      287,
      257,
      6060,
      19778,
      329,
      2252,
      7587
    ],
    "label": "best_practice",
    "reason": "Storing result in a DataFrame for further processing"
  },
  {
    "line": 235,
    "text": "    def __init__(",
    "annotation": "\u2705 Best Practice: Use of super() to call the parent class's __init__ method ensures proper initialization.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7
    ],
    "start_token": 637,
    "end_token": 645,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2208,
      3419,
      284,
      869,
      262,
      2560,
      1398,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      13
    ],
    "label": "best_practice",
    "reason": "Use of super() to call the parent class's __init__ method ensures proper initialization."
  },
  {
    "line": 270,
    "text": "        super().__init__(",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dynamic column names based on a pattern",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      7
    ],
    "start_token": 645,
    "end_token": 658,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8925,
      5721,
      3891,
      1912,
      319,
      257,
      3912
    ],
    "label": "ml_signal",
    "reason": "Usage of dynamic column names based on a pattern"
  },
  {
    "line": 272,
    "text": "            provider,",
    "annotation": "\ud83e\udde0 ML Signal: Filtering data based on a condition",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      10131,
      11
    ],
    "start_token": 658,
    "end_token": 671,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      1366,
      1912,
      319,
      257,
      4006
    ],
    "label": "ml_signal",
    "reason": "Filtering data based on a condition"
  },
  {
    "line": 276,
    "text": "            codes,",
    "annotation": "\ud83e\udde0 ML Signal: Iterative filtering with logical AND",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      12416,
      11
    ],
    "start_token": 671,
    "end_token": 684,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      876,
      25431,
      351,
      12219,
      5357
    ],
    "label": "ml_signal",
    "reason": "Iterative filtering with logical AND"
  },
  {
    "line": 279,
    "text": "            columns,",
    "annotation": "\ud83e\udde0 ML Signal: Additional filtering based on a threshold",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      11
    ],
    "start_token": 684,
    "end_token": 697,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15891,
      25431,
      1912,
      319,
      257,
      11387
    ],
    "label": "ml_signal",
    "reason": "Additional filtering based on a threshold"
  },
  {
    "line": 279,
    "text": "            columns,",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of filter result to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      11
    ],
    "start_token": 697,
    "end_token": 710,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      8106,
      1255,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Conversion of filter result to DataFrame"
  },
  {
    "line": 287,
    "text": "            keep_all_timestamp,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `CrossMaVolumeFactor` is not properly validated",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1394,
      62,
      439,
      62,
      16514,
      27823,
      11
    ],
    "start_token": 710,
    "end_token": 728,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      21544,
      21467,
      31715,
      41384,
      63,
      318,
      407,
      6105,
      31031
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `CrossMaVolumeFactor` is not properly validated"
  },
  {
    "line": 288,
    "text": "            fill_method,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of current timestamp can lead to non-deterministic behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      11
    ],
    "start_token": 728,
    "end_token": 743,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      1459,
      41033,
      460,
      1085,
      284,
      1729,
      12,
      67,
      2357,
      49228,
      4069
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of current timestamp can lead to non-deterministic behavior"
  },
  {
    "line": 288,
    "text": "            fill_method,",
    "annotation": "\u2705 Best Practice: Explicitly setting persistence behavior",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      11
    ],
    "start_token": 743,
    "end_token": 758,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4634,
      30802,
      4069
    ],
    "label": "best_practice",
    "reason": "Explicitly setting persistence behavior"
  },
  {
    "line": 288,
    "text": "            fill_method,",
    "annotation": "\ud83e\udde0 ML Signal: Visualization of results",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      11
    ],
    "start_token": 758,
    "end_token": 773,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15612,
      1634,
      286,
      2482
    ],
    "label": "ml_signal",
    "reason": "Visualization of results"
  },
  {
    "line": 288,
    "text": "            fill_method,",
    "annotation": "\u2705 Best Practice: Use of __all__ to define public API of the module",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6070,
      62,
      24396,
      11
    ],
    "start_token": 773,
    "end_token": 788,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      439,
      834,
      284,
      8160,
      1171,
      7824,
      286,
      262,
      8265
    ],
    "label": "best_practice",
    "reason": "Use of __all__ to define public API of the module"
  }
]