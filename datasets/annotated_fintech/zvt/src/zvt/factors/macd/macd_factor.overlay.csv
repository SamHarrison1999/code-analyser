annotation,annotation_tokens,confidence,end_token,label,line,reason,start_token,text,tokens
✅ Best Practice: Grouping related imports together improves readability and maintainability.,"[26486, 227, 6705, 19939, 25, 4912, 278, 3519, 17944, 1978, 19575, 1100, 1799, 290, 5529, 1799, 13]",1.0,5,best_practice,4,Grouping related imports together improves readability and maintainability.,0,import numpy as np,"[11748, 299, 32152, 355, 45941]"
🧠 ML Signal: Inheritance from TechnicalFactor suggests a pattern for feature engineering in financial data,"[8582, 100, 254, 10373, 26484, 25, 47025, 42942, 422, 20671, 41384, 5644, 257, 3912, 329, 3895, 8705, 287, 3176, 1366]",1.0,5,ml_signal,6,Inheritance from TechnicalFactor suggests a pattern for feature engineering in financial data,5,,[]
🧠 ML Signal: Use of a transformer object indicates a pattern of data transformation,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 257, 47385, 2134, 9217, 257, 3912, 286, 1366, 13389]",1.0,18,ml_signal,8,Use of a transformer object indicates a pattern of data transformation,5,from zvt.factors.technical_factor import TechnicalFactor,"[6738, 1976, 36540, 13, 22584, 669, 13, 47944, 62, 31412, 1330, 20671, 41384]"
✅ Best Practice: Initializing class variables directly can improve readability and maintainability,"[26486, 227, 6705, 19939, 25, 20768, 2890, 1398, 9633, 3264, 460, 2987, 1100, 1799, 290, 5529, 1799]",0.5,18,best_practice,9,Initializing class variables directly can improve readability and maintainability,18,,[]
✅ Best Practice: Type hinting improves code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 19575, 2438, 1100, 1799, 290, 5529, 1799]",1.0,31,best_practice,8,Type hinting improves code readability and maintainability,18,from zvt.factors.technical_factor import TechnicalFactor,"[6738, 1976, 36540, 13, 22584, 669, 13, 47944, 62, 31412, 1330, 20671, 41384]"
✅ Best Practice: Explicitly returning None improves code clarity,"[26486, 227, 6705, 19939, 25, 11884, 306, 8024, 6045, 19575, 2438, 16287]",1.0,31,best_practice,10,Explicitly returning None improves code clarity,31,,[]
✅ Best Practice: Specify the return type for better readability and maintainability,"[26486, 227, 6705, 19939, 25, 18291, 1958, 262, 1441, 2099, 329, 1365, 1100, 1799, 290, 5529, 1799]",1.0,31,best_practice,10,Specify the return type for better readability and maintainability,31,,[]
🧠 ML Signal: Accessing specific columns from a DataFrame,"[8582, 100, 254, 10373, 26484, 25, 8798, 278, 2176, 15180, 422, 257, 6060, 19778]",1.0,49,ml_signal,12,Accessing specific columns from a DataFrame,31,    transformer = MacdTransformer(count_live_dead=True),"[220, 220, 220, 47385, 796, 4100, 67, 8291, 16354, 7, 9127, 62, 12583, 62, 25124, 28, 17821, 8]"
✅ Best Practice: Use list comprehension for concise and efficient list creation,"[26486, 227, 6705, 19939, 25, 5765, 1351, 35915, 329, 35327, 290, 6942, 1351, 6282]",1.0,49,best_practice,13,Use list comprehension for concise and efficient list creation,49,,[]
✅ Best Practice: Use of type hinting for return type improves code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5765, 286, 2099, 9254, 278, 329, 1441, 2099, 19575, 2438, 1100, 1799, 290, 5529, 1799]",1.0,67,best_practice,12,Use of type hinting for return type improves code readability and maintainability,49,    transformer = MacdTransformer(count_live_dead=True),"[220, 220, 220, 47385, 796, 4100, 67, 8291, 16354, 7, 9127, 62, 12583, 62, 25124, 28, 17821, 8]"
"🧠 ML Signal: Returns a dictionary with specific keys and values, indicating a pattern in data representation","[8582, 100, 254, 10373, 26484, 25, 16409, 257, 22155, 351, 2176, 8251, 290, 3815, 11, 12739, 257, 3912, 287, 1366, 10552]",1.0,92,ml_signal,14,"Returns a dictionary with specific keys and values, indicating a pattern in data representation",67,    def drawer_factor_df_list(self) -> Optional[List[pd.DataFrame]]:,"[220, 220, 220, 825, 33451, 62, 31412, 62, 7568, 62, 4868, 7, 944, 8, 4613, 32233, 58, 8053, 58, 30094, 13, 6601, 19778, 60, 5974]"
✅ Best Practice: Add a docstring to describe the purpose and usage of the class,"[26486, 227, 6705, 19939, 25, 3060, 257, 2205, 8841, 284, 6901, 262, 4007, 290, 8748, 286, 262, 1398]",0.5,101,best_practice,15,Add a docstring to describe the purpose and usage of the class,92,        return None,"[220, 220, 220, 220, 220, 220, 220, 1441, 6045]"
🧠 ML Signal: Method overriding in class inheritance,"[8582, 100, 254, 10373, 26484, 25, 11789, 44987, 287, 1398, 24155]",0.5,101,ml_signal,16,Method overriding in class inheritance,101,,[]
🧠 ML Signal: DataFrame column selection and transformation,"[8582, 100, 254, 10373, 26484, 25, 6060, 19778, 5721, 6356, 290, 13389]",0.5,128,ml_signal,18,DataFrame column selection and transformation,101,"        return [self.factor_df[[""diff"", ""dea"", ""macd""]]]","[220, 220, 220, 220, 220, 220, 220, 1441, 685, 944, 13, 31412, 62, 7568, 58, 14692, 26069, 1600, 366, 2934, 64, 1600, 366, 20285, 67, 8973, 11907]"
✅ Best Practice: Use to_frame() for creating a DataFrame from a Series,"[26486, 227, 6705, 19939, 25, 5765, 284, 62, 14535, 3419, 329, 4441, 257, 6060, 19778, 422, 257, 7171]",0.5,128,best_practice,19,Use to_frame() for creating a DataFrame from a Series,128,,[]
✅ Best Practice: Class should have a docstring explaining its purpose and usage,"[26486, 227, 6705, 19939, 25, 5016, 815, 423, 257, 2205, 8841, 11170, 663, 4007, 290, 8748]",0.5,155,best_practice,18,Class should have a docstring explaining its purpose and usage,128,"        return [self.factor_df[[""diff"", ""dea"", ""macd""]]]","[220, 220, 220, 220, 220, 220, 220, 1441, 685, 944, 13, 31412, 62, 7568, 58, 14692, 26069, 1600, 366, 2934, 64, 1600, 366, 20285, 67, 8973, 11907]"
✅ Best Practice: Class variables should have comments explaining their purpose,"[26486, 227, 6705, 19939, 25, 5016, 9633, 815, 423, 3651, 11170, 511, 4007]",0.5,174,best_practice,20,Class variables should have comments explaining their purpose,155,    def drawer_sub_col_chart(self) -> Optional[dict]:,"[220, 220, 220, 825, 33451, 62, 7266, 62, 4033, 62, 40926, 7, 944, 8, 4613, 32233, 58, 11600, 5974]"
✅ Best Practice: Call to superclass method ensures base functionality is executed.,"[26486, 227, 6705, 19939, 25, 4889, 284, 2208, 4871, 2446, 19047, 2779, 11244, 318, 10945, 13]",0.5,202,best_practice,21,Call to superclass method ensures base functionality is executed.,174,"        return {""diff"": ""line"", ""dea"": ""line"", ""macd"": ""bar""}","[220, 220, 220, 220, 220, 220, 220, 1441, 19779, 26069, 1298, 366, 1370, 1600, 366, 2934, 64, 1298, 366, 1370, 1600, 366, 20285, 67, 1298, 366, 5657, 20662]"
🧠 ML Signal: Use of DataFrame and groupby operation indicates data processing pattern.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 6060, 19778, 290, 1448, 1525, 4905, 9217, 1366, 7587, 3912, 13]",1.0,202,ml_signal,22,Use of DataFrame and groupby operation indicates data processing pattern.,202,,[]
🧠 ML Signal: Use of rolling window operation is common in time series analysis.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 10708, 4324, 4905, 318, 2219, 287, 640, 2168, 3781, 13]",1.0,202,ml_signal,28,Use of rolling window operation is common in time series analysis.,202,,[]
🧠 ML Signal: Use of lambda function for custom aggregation.,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 37456, 2163, 329, 2183, 46500, 13]",0.5,202,ml_signal,29,Use of lambda function for custom aggregation.,202,,[]
✅ Best Practice: Resetting index improves DataFrame consistency after groupby operations.,"[26486, 227, 6705, 19939, 25, 30027, 889, 6376, 19575, 6060, 19778, 15794, 706, 1448, 1525, 4560, 13]",0.5,202,best_practice,32,Resetting index improves DataFrame consistency after groupby operations.,202,,[]
🧠 ML Signal: Assignment back to DataFrame column indicates data transformation.,"[8582, 100, 254, 10373, 26484, 25, 50144, 736, 284, 6060, 19778, 5721, 9217, 1366, 13389, 13]",0.5,216,ml_signal,34,Assignment back to DataFrame column indicates data transformation.,202,        super().compute_result(),"[220, 220, 220, 220, 220, 220, 220, 2208, 22446, 5589, 1133, 62, 20274, 3419]"
🧠 ML Signal: Inheritance from MacdFactor suggests a pattern for financial analysis,"[8582, 100, 254, 10373, 26484, 25, 47025, 42942, 422, 4100, 67, 41384, 5644, 257, 3912, 329, 3176, 3781]",0.5,224,ml_signal,30,Inheritance from MacdFactor suggests a pattern for financial analysis,216,class KeepBullFactor(BullFactor):,"[4871, 9175, 39549, 41384, 7, 39549, 41384, 2599]"
🧠 ML Signal: The pattern attribute could be used to identify specific market conditions,"[8582, 100, 254, 10373, 26484, 25, 383, 3912, 11688, 714, 307, 973, 284, 5911, 2176, 1910, 3403]",0.5,232,ml_signal,31,The pattern attribute could be used to identify specific market conditions,224,    keep_window = 10,"[220, 220, 220, 1394, 62, 17497, 796, 838]"
✅ Best Practice: Call to superclass method ensures base class functionality is preserved.,"[26486, 227, 6705, 19939, 25, 4889, 284, 2208, 4871, 2446, 19047, 2779, 1398, 11244, 318, 17232, 13]",1.0,242,best_practice,33,Call to superclass method ensures base class functionality is preserved.,232,    def compute_result(self):,"[220, 220, 220, 825, 24061, 62, 20274, 7, 944, 2599]"
✅ Best Practice: Using shift() to access previous row values is a common and efficient pattern in data manipulation.,"[26486, 227, 6705, 19939, 25, 8554, 6482, 3419, 284, 1895, 2180, 5752, 3815, 318, 257, 2219, 290, 6942, 3912, 287, 1366, 17512, 13]",1.0,252,best_practice,35,Using shift() to access previous row values is a common and efficient pattern in data manipulation.,242,        df = (,"[220, 220, 220, 220, 220, 220, 220, 47764, 796, 357]"
🧠 ML Signal: Pattern matching on DataFrame columns can indicate feature engineering for ML models.,"[8582, 100, 254, 10373, 26484, 25, 23939, 12336, 319, 6060, 19778, 15180, 460, 7603, 3895, 8705, 329, 10373, 4981, 13]",1.0,271,ml_signal,37,Pattern matching on DataFrame columns can indicate feature engineering for ML models.,252,            .groupby(level=0),"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 764, 8094, 1525, 7, 5715, 28, 15, 8]"
✅ Best Practice: Converting a Series to a DataFrame with a specific column name improves code readability.,"[26486, 227, 6705, 19939, 25, 35602, 889, 257, 7171, 284, 257, 6060, 19778, 351, 257, 2176, 5721, 1438, 19575, 2438, 1100, 1799, 13]",1.0,300,best_practice,39,Converting a Series to a DataFrame with a specific column name improves code readability.,271,            .apply(lambda x: np.logical_and.reduce(x)),"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 764, 39014, 7, 50033, 2124, 25, 45941, 13, 6404, 605, 62, 392, 13, 445, 7234, 7, 87, 4008]"
✅ Best Practice: Use of descriptive variable names improves code readability.,"[26486, 227, 6705, 19939, 25, 5765, 286, 35644, 7885, 3891, 19575, 2438, 1100, 1799, 13]",0.5,308,best_practice,40,Use of descriptive variable names improves code readability.,300,        ),"[220, 220, 220, 220, 220, 220, 220, 1267]"
✅ Best Practice: Converting a Series to a DataFrame with a specific column name enhances clarity.,"[26486, 227, 6705, 19939, 25, 35602, 889, 257, 7171, 284, 257, 6060, 19778, 351, 257, 2176, 5721, 1438, 32479, 16287, 13]",0.5,327,best_practice,42,Converting a Series to a DataFrame with a specific column name enhances clarity.,308,"        self.result_df[""filter_result""] = df","[220, 220, 220, 220, 220, 220, 220, 2116, 13, 20274, 62, 7568, 14692, 24455, 62, 20274, 8973, 796, 47764]"
"🧠 ML Signal: Entry point for script execution, common pattern for standalone scripts.","[8582, 100, 254, 10373, 26484, 25, 21617, 966, 329, 4226, 9706, 11, 2219, 3912, 329, 27669, 14750, 13]",0.5,357,ml_signal,45,"Entry point for script execution, common pattern for standalone scripts.",327,# 金叉 死叉 持续时间 切换点,"[2, 16268, 229, 239, 20998, 231, 10545, 255, 119, 20998, 231, 10545, 234, 223, 163, 119, 255, 33768, 114, 29785, 112, 10263, 230, 229, 162, 235, 95, 163, 224, 117]"
"🧠 ML Signal: Instantiation of a class with specific parameters, useful for understanding usage patterns.","[8582, 100, 254, 10373, 26484, 25, 24470, 3920, 286, 257, 1398, 351, 2176, 10007, 11, 4465, 329, 4547, 8748, 7572, 13]",0.5,387,ml_signal,45,"Instantiation of a class with specific parameters, useful for understanding usage patterns.",357,# 金叉 死叉 持续时间 切换点,"[2, 16268, 229, 239, 20998, 231, 10545, 255, 119, 20998, 231, 10545, 234, 223, 163, 119, 255, 33768, 114, 29785, 112, 10263, 230, 229, 162, 235, 95, 163, 224, 117]"
"🧠 ML Signal: Method chaining pattern, often used in fluent interfaces.","[8582, 100, 254, 10373, 26484, 25, 11789, 442, 1397, 3912, 11, 1690, 973, 287, 43472, 20314, 13]",0.5,417,ml_signal,45,"Method chaining pattern, often used in fluent interfaces.",387,# 金叉 死叉 持续时间 切换点,"[2, 16268, 229, 239, 20998, 231, 10545, 255, 119, 20998, 231, 10545, 234, 223, 163, 119, 255, 33768, 114, 29785, 112, 10263, 230, 229, 162, 235, 95, 163, 224, 117]"
✅ Best Practice: Defining __all__ for module exports improves code maintainability and clarity.,"[26486, 227, 6705, 19939, 25, 2896, 3191, 11593, 439, 834, 329, 8265, 15319, 19575, 2438, 5529, 1799, 290, 16287, 13]",0.5,447,best_practice,45,Defining __all__ for module exports improves code maintainability and clarity.,417,# 金叉 死叉 持续时间 切换点,"[2, 16268, 229, 239, 20998, 231, 10545, 255, 119, 20998, 231, 10545, 234, 223, 163, 119, 255, 33768, 114, 29785, 112, 10263, 230, 229, 162, 235, 95, 163, 224, 117]"
