annotation,annotation_tokens,confidence,end_token,label,line,reason,severity,start_token,text,tokens
✅ Best Practice: Grouping related imports together improves readability and maintainability.,"[26486, 227, 6705, 19939, 25, 4912, 278, 3519, 17944, 1978, 19575, 1100, 1799, 290, 5529, 1799, 13]",1.0,6,best_practice,3,Grouping related imports together improves readability and maintainability.,,0,import pandas as pd,"[11748, 19798, 292, 355, 279, 67]"
✅ Best Practice: Function name should be descriptive and use lowercase with words separated by underscores,"[26486, 227, 6705, 19939, 25, 15553, 1438, 815, 307, 35644, 290, 779, 2793, 7442, 351, 2456, 11266, 416, 41731]",1.0,39,best_practice,8,Function name should be descriptive and use lowercase with words separated by underscores,,6,"from zvt.utils.pd_utils import group_by_entity_id, normalize_group_compute_result, merge_filter_result","[6738, 1976, 36540, 13, 26791, 13, 30094, 62, 26791, 1330, 1448, 62, 1525, 62, 26858, 62, 312, 11, 3487, 1096, 62, 8094, 62, 5589, 1133, 62, 20274, 11, 20121, 62, 24455, 62, 20274]"
✅ Best Practice: Use of assert to validate input assumptions,"[26486, 227, 6705, 19939, 25, 5765, 286, 6818, 284, 26571, 5128, 14895]",1.0,39,best_practice,10,Use of assert to validate input assumptions,,39,,[]
🧠 ML Signal: Use of DataFrame indexing and slicing,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 6060, 19778, 6376, 278, 290, 49289]",1.0,55,ml_signal,12,Use of DataFrame indexing and slicing,,39,"def _cal_state(s, df, pre, interval, col):","[4299, 4808, 9948, 62, 5219, 7, 82, 11, 47764, 11, 662, 11, 16654, 11, 951, 2599]"
✅ Best Practice: Type hinting for better code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 329, 1365, 2438, 1100, 1799, 290, 5529, 1799]",1.0,70,best_practice,14,Type hinting for better code readability and maintainability,,55,"    s = df.loc[s.index, :]","[220, 220, 220, 264, 796, 47764, 13, 17946, 58, 82, 13, 9630, 11, 1058, 60]"
✅ Best Practice: Type hinting for better code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 329, 1365, 2438, 1100, 1799, 290, 5529, 1799]",1.0,94,best_practice,16,Type hinting for better code readability and maintainability,,70,"    recent_df: pd.DataFrame = s.iloc[-interval:, :]","[220, 220, 220, 2274, 62, 7568, 25, 279, 67, 13, 6601, 19778, 796, 264, 13, 346, 420, 58, 12, 3849, 2100, 45299, 1058, 60]"
🧠 ML Signal: Checking for null values in DataFrame,"[8582, 100, 254, 10373, 26484, 25, 39432, 329, 9242, 3815, 287, 6060, 19778]",0.5,105,ml_signal,18,Checking for null values in DataFrame,,94,        return np.nan,"[220, 220, 220, 220, 220, 220, 220, 1441, 45941, 13, 12647]"
🧠 ML Signal: Logical operations on DataFrame columns,"[8582, 100, 254, 10373, 26484, 25, 5972, 605, 4560, 319, 6060, 19778, 15180]",1.0,117,ml_signal,21,Logical operations on DataFrame columns,,105,    if pre_result and recent_result:,"[220, 220, 220, 611, 662, 62, 20274, 290, 2274, 62, 20274, 25]"
🧠 ML Signal: Logical operations on DataFrame columns,"[8582, 100, 254, 10373, 26484, 25, 5972, 605, 4560, 319, 6060, 19778, 15180]",1.0,124,ml_signal,23,Logical operations on DataFrame columns,,117,    return np.nan,"[220, 220, 220, 1441, 45941, 13, 12647]"
🧠 ML Signal: Conditional logic based on computed results,"[8582, 100, 254, 10373, 26484, 25, 9724, 1859, 9156, 1912, 319, 29231, 2482]",1.0,124,ml_signal,25,Conditional logic based on computed results,,124,,[]
🧠 ML Signal: Returning NaN for specific conditions,"[8582, 100, 254, 10373, 26484, 25, 42882, 11013, 45, 329, 2176, 3403]",0.5,146,ml_signal,28,Returning NaN for specific conditions,,124,"        super().__init__(windows, cal_change_pct)","[220, 220, 220, 220, 220, 220, 220, 2208, 22446, 834, 15003, 834, 7, 28457, 11, 2386, 62, 3803, 62, 79, 310, 8]"
✅ Best Practice: Class definition should follow the naming convention of using CamelCase.,"[26486, 227, 6705, 19939, 25, 5016, 6770, 815, 1061, 262, 19264, 9831, 286, 1262, 43281, 20448, 13]",0.5,176,best_practice,20,Class definition should follow the naming convention of using CamelCase.,,146,"    recent_result = np.logical_and.reduce(recent_df[""close""] < recent_df[col])","[220, 220, 220, 2274, 62, 20274, 796, 45941, 13, 6404, 605, 62, 392, 13, 445, 7234, 7, 49921, 62, 7568, 14692, 19836, 8973, 1279, 2274, 62, 7568, 58, 4033, 12962]"
✅ Best Practice: Use of default mutable arguments (like lists) can lead to unexpected behavior; consider using None and initializing inside the method.,"[26486, 227, 6705, 19939, 25, 5765, 286, 4277, 4517, 540, 7159, 357, 2339, 8341, 8, 460, 1085, 284, 10059, 4069, 26, 2074, 1262, 6045, 290, 4238, 2890, 2641, 262, 2446, 13]",0.5,188,best_practice,21,Use of default mutable arguments (like lists) can lead to unexpected behavior; consider using None and initializing inside the method.,,176,    if pre_result and recent_result:,"[220, 220, 220, 611, 662, 62, 20274, 290, 2274, 62, 20274, 25]"
✅ Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization of inherited attributes.,"[26486, 227, 6705, 19939, 25, 11884, 306, 4585, 262, 2208, 4871, 338, 11593, 15003, 834, 2446, 19047, 1774, 37588, 286, 19552, 12608, 13]",0.5,195,best_practice,23,Explicitly calling the superclass's __init__ method ensures proper initialization of inherited attributes.,,188,    return np.nan,"[220, 220, 220, 1441, 45941, 13, 12647]"
✅ Best Practice: Type hinting for input and output improves code readability and maintainability,"[26486, 227, 6705, 19939, 25, 5994, 9254, 278, 329, 5128, 290, 5072, 19575, 2438, 1100, 1799, 290, 5529, 1799]",0.5,202,best_practice,23,Type hinting for input and output improves code readability and maintainability,,195,    return np.nan,"[220, 220, 220, 1441, 45941, 13, 12647]"
"🧠 ML Signal: Use of super() indicates inheritance, which is common in ML pipelines for data transformation","[8582, 100, 254, 10373, 26484, 25, 5765, 286, 2208, 3419, 9217, 24155, 11, 543, 318, 2219, 287, 10373, 31108, 329, 1366, 13389]",0.5,202,ml_signal,25,"Use of super() indicates inheritance, which is common in ML pipelines for data transformation",,202,,[]
🧠 ML Signal: Dynamic column naming based on a list of windows suggests a pattern for feature engineering,"[8582, 100, 254, 10373, 26484, 25, 26977, 5721, 19264, 1912, 319, 257, 1351, 286, 9168, 5644, 257, 3912, 329, 3895, 8705]",0.5,228,ml_signal,27,Dynamic column naming based on a list of windows suggests a pattern for feature engineering,,202,"    def __init__(self, windows=None, cal_change_pct=False) -> None:","[220, 220, 220, 825, 11593, 15003, 834, 7, 944, 11, 9168, 28, 14202, 11, 2386, 62, 3803, 62, 79, 310, 28, 25101, 8, 4613, 6045, 25]"
🧠 ML Signal: Use of boolean indexing for filtering is a common pattern in data preprocessing,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 25131, 6376, 278, 329, 25431, 318, 257, 2219, 3912, 287, 1366, 662, 36948]",0.5,228,ml_signal,29,Use of boolean indexing for filtering is a common pattern in data preprocessing,,228,,[]
🧠 ML Signal: Iterative comparison across columns is a pattern for complex feature creation,"[8582, 100, 254, 10373, 26484, 25, 40806, 876, 7208, 1973, 15180, 318, 257, 3912, 329, 3716, 3895, 6282]",0.5,256,ml_signal,33,Iterative comparison across columns is a pattern for complex feature creation,,228,        s = input_df[cols[0]] > input_df[cols[1]],"[220, 220, 220, 220, 220, 220, 220, 264, 796, 5128, 62, 7568, 58, 4033, 82, 58, 15, 11907, 1875, 5128, 62, 7568, 58, 4033, 82, 58, 16, 11907]"
✅ Best Practice: Adding a new column to the DataFrame for results is a clear and maintainable approach,"[26486, 227, 6705, 19939, 25, 18247, 257, 649, 5721, 284, 262, 6060, 19778, 329, 2482, 318, 257, 1598, 290, 5529, 540, 3164]",0.5,287,best_practice,36,Adding a new column to the DataFrame for results is a clear and maintainable approach,,256,            s = s & (input_df[current_col] > input_df[col]),"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 264, 796, 264, 1222, 357, 15414, 62, 7568, 58, 14421, 62, 4033, 60, 1875, 5128, 62, 7568, 58, 4033, 12962]"
✅ Best Practice: Class definition should include a docstring explaining its purpose and usage.,"[26486, 227, 6705, 19939, 25, 5016, 6770, 815, 2291, 257, 2205, 8841, 11170, 663, 4007, 290, 8748, 13]",1.0,303,best_practice,34,Class definition should include a docstring explaining its purpose and usage.,,287,        current_col = cols[1],"[220, 220, 220, 220, 220, 220, 220, 1459, 62, 4033, 796, 951, 82, 58, 16, 60]"
✅ Best Practice: Use of __init__ method to initialize object attributes,"[26486, 227, 6705, 19939, 25, 5765, 286, 11593, 15003, 834, 2446, 284, 41216, 2134, 12608]",1.0,319,best_practice,34,Use of __init__ method to initialize object attributes,,303,        current_col = cols[1],"[220, 220, 220, 220, 220, 220, 220, 1459, 62, 4033, 796, 951, 82, 58, 16, 60]"
🧠 ML Signal: Conversion of input data to a specific format (timestamp),"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 5128, 1366, 284, 257, 2176, 5794, 357, 16514, 27823, 8]",1.0,350,ml_signal,36,Conversion of input data to a specific format (timestamp),,319,            s = s & (input_df[current_col] > input_df[col]),"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 264, 796, 264, 1222, 357, 15414, 62, 7568, 58, 14421, 62, 4033, 60, 1875, 5128, 62, 7568, 58, 4033, 12962]"
🧠 ML Signal: Conversion of input data to a specific format (timestamp),"[8582, 100, 254, 10373, 26484, 25, 44101, 286, 5128, 1366, 284, 257, 2176, 5794, 357, 16514, 27823, 8]",1.0,367,ml_signal,38,Conversion of input data to a specific format (timestamp),,350,"        input_df[""filter_result""] = s","[220, 220, 220, 220, 220, 220, 220, 5128, 62, 7568, 14692, 24455, 62, 20274, 8973, 796, 264]"
✅ Best Practice: Use parentheses for method calls to avoid confusion with indexing,"[26486, 227, 6705, 19939, 25, 5765, 46672, 329, 2446, 3848, 284, 3368, 10802, 351, 6376, 278]",0.5,384,best_practice,38,Use parentheses for method calls to avoid confusion with indexing,,367,"        input_df[""filter_result""] = s","[220, 220, 220, 220, 220, 220, 220, 5128, 62, 7568, 14692, 24455, 62, 20274, 8973, 796, 264]"
⚠️ SAST Risk (Low): Direct comparison with False can lead to unexpected results if s contains non-boolean values,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 4128, 7208, 351, 10352, 460, 1085, 284, 10059, 2482, 611, 264, 4909, 1729, 12, 2127, 21052, 3815]",1.0,384,sast_risk,40,Direct comparison with False can lead to unexpected results if s contains non-boolean values,Low,384,,[]
✅ Best Practice: Use parentheses for method calls to avoid confusion with indexing,"[26486, 227, 6705, 19939, 25, 5765, 46672, 329, 2446, 3848, 284, 3368, 10802, 351, 6376, 278]",0.5,392,best_practice,42,Use parentheses for method calls to avoid confusion with indexing,,384,class SpecificTransformer(Transformer):,"[4871, 17377, 8291, 16354, 7, 8291, 16354, 2599]"
🧠 ML Signal: Adding a new column based on conditions can indicate feature engineering,"[8582, 100, 254, 10373, 26484, 25, 18247, 257, 649, 5721, 1912, 319, 3403, 460, 7603, 3895, 8705]",1.0,418,ml_signal,44,Adding a new column based on conditions can indicate feature engineering,,392,        self.buy_timestamp = to_pd_timestamp(buy_timestamp),"[220, 220, 220, 220, 220, 220, 220, 2116, 13, 17846, 62, 16514, 27823, 796, 284, 62, 30094, 62, 16514, 27823, 7, 17846, 62, 16514, 27823, 8]"
✅ Best Practice: Call to super() ensures proper initialization of the base class,"[26486, 227, 6705, 19939, 25, 4889, 284, 2208, 3419, 19047, 1774, 37588, 286, 262, 2779, 1398]",0.5,444,best_practice,45,Call to super() ensures proper initialization of the base class,,418,        self.sell_timestamp = to_pd_timestamp(sell_timestamp),"[220, 220, 220, 220, 220, 220, 220, 2116, 13, 7255, 62, 16514, 27823, 796, 284, 62, 30094, 62, 16514, 27823, 7, 7255, 62, 16514, 27823, 8]"
🧠 ML Signal: Use of default parameters in a constructor,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 4277, 10007, 287, 257, 23772]",0.5,469,ml_signal,47,Use of default parameters in a constructor,,444,"    def transform(self, input_df: pd.DataFrame) -> pd.DataFrame:","[220, 220, 220, 825, 6121, 7, 944, 11, 5128, 62, 7568, 25, 279, 67, 13, 6601, 19778, 8, 4613, 279, 67, 13, 6601, 19778, 25]"
🧠 ML Signal: Use of default parameters in a constructor,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 4277, 10007, 287, 257, 23772]",0.5,484,ml_signal,49,Use of default parameters in a constructor,,469,        s[s == False] = None,"[220, 220, 220, 220, 220, 220, 220, 264, 58, 82, 6624, 10352, 60, 796, 6045]"
🧠 ML Signal: Usage of dynamic column naming based on class attributes,"[8582, 100, 254, 10373, 26484, 25, 29566, 286, 8925, 5721, 19264, 1912, 319, 1398, 12608]",0.5,499,ml_signal,49,Usage of dynamic column naming based on class attributes,,484,        s[s == False] = None,"[220, 220, 220, 220, 220, 220, 220, 264, 58, 82, 6624, 10352, 60, 796, 6045]"
⚠️ SAST Risk (Low): Potential for KeyError if 'close' column is missing,"[158, 248, 254, 37929, 311, 11262, 19602, 357, 20535, 2599, 32480, 329, 7383, 12331, 611, 705, 19836, 6, 5721, 318, 4814]",0.5,516,sast_risk,51,Potential for KeyError if 'close' column is missing,Low,499,"        input_df[""filter_result""] = s","[220, 220, 220, 220, 220, 220, 220, 5128, 62, 7568, 14692, 24455, 62, 20274, 8973, 796, 264]"
🧠 ML Signal: Use of normalization function on computed results,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 3487, 1634, 2163, 319, 29231, 2482]",1.0,537,ml_signal,56,Use of normalization function on computed results,,516,"    def __init__(self, window=10, interval=3) -> None:","[220, 220, 220, 825, 11593, 15003, 834, 7, 944, 11, 4324, 28, 940, 11, 16654, 28, 18, 8, 4613, 6045, 25]"
🧠 ML Signal: Logical comparison between DataFrame columns,"[8582, 100, 254, 10373, 26484, 25, 5972, 605, 7208, 1022, 6060, 19778, 15180]",0.5,550,ml_signal,57,Logical comparison between DataFrame columns,,537,        super().__init__(),"[220, 220, 220, 220, 220, 220, 220, 2208, 22446, 834, 15003, 834, 3419]"
🧠 ML Signal: Use of lambda function for custom rolling window operations,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 37456, 2163, 329, 2183, 10708, 4324, 4560]",0.5,566,ml_signal,64,Use of lambda function for custom rolling window operations,,550,            group_result = (,"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1448, 62, 20274, 796, 357]"
🧠 ML Signal: Use of normalization function on computed results,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 3487, 1634, 2163, 319, 29231, 2482]",1.0,599,ml_signal,67,Use of normalization function on computed results,,566,            group_result = normalize_group_compute_result(group_result=group_result),"[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 1448, 62, 20274, 796, 3487, 1096, 62, 8094, 62, 5589, 1133, 62, 20274, 7, 8094, 62, 20274, 28, 8094, 62, 20274, 8]"
✅ Best Practice: Use 'is' for comparison with True/False/None,"[26486, 227, 6705, 19939, 25, 5765, 705, 271, 6, 329, 7208, 351, 6407, 14, 25101, 14, 14202]",0.5,599,best_practice,69,Use 'is' for comparison with True/False/None,,599,,[]
✅ Best Practice: Use 'is' for comparison with True/False/None,"[26486, 227, 6705, 19939, 25, 5765, 705, 271, 6, 329, 7208, 351, 6407, 14, 25101, 14, 14202]",0.5,599,best_practice,69,Use 'is' for comparison with True/False/None,,599,,[]
🧠 ML Signal: Merging filter results back into the DataFrame,"[8582, 100, 254, 10373, 26484, 25, 4638, 2667, 8106, 2482, 736, 656, 262, 6060, 19778]",1.0,599,ml_signal,69,Merging filter results back into the DataFrame,,599,,[]
✅ Best Practice: Use of __name__ guard for script entry point,"[26486, 227, 6705, 19939, 25, 5765, 286, 11593, 3672, 834, 4860, 329, 4226, 5726, 966]",0.5,599,best_practice,69,Use of __name__ guard for script entry point,,599,,[]
🧠 ML Signal: Instantiation of a class with specific parameters,"[8582, 100, 254, 10373, 26484, 25, 24470, 3920, 286, 257, 1398, 351, 2176, 10007]",1.0,599,ml_signal,69,Instantiation of a class with specific parameters,,599,,[]
🧠 ML Signal: Use of __all__ to define public API of the module,"[8582, 100, 254, 10373, 26484, 25, 5765, 286, 11593, 439, 834, 284, 8160, 1171, 7824, 286, 262, 8265]",1.0,599,ml_signal,69,Use of __all__ to define public API of the module,,599,,[]
