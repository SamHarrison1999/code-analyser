[
  {
    "line": 3,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Grouping related imports together improves readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 0,
    "end_token": 6,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      3519,
      17944,
      1978,
      19575,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping related imports together improves readability and maintainability."
  },
  {
    "line": 8,
    "text": "from zvt.utils.pd_utils import group_by_entity_id, normalize_group_compute_result, merge_filter_result",
    "annotation": "\u2705 Best Practice: Function name should be descriptive and use lowercase with words separated by underscores",
    "confidence": 1.0,
    "tokens": [
      6738,
      1976,
      36540,
      13,
      26791,
      13,
      30094,
      62,
      26791,
      1330,
      1448,
      62,
      1525,
      62,
      26858,
      62,
      312,
      11,
      3487,
      1096,
      62,
      8094,
      62,
      5589,
      1133,
      62,
      20274,
      11,
      20121,
      62,
      24455,
      62,
      20274
    ],
    "start_token": 6,
    "end_token": 39,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15553,
      1438,
      815,
      307,
      35644,
      290,
      779,
      2793,
      7442,
      351,
      2456,
      11266,
      416,
      41731
    ],
    "label": "best_practice",
    "reason": "Function name should be descriptive and use lowercase with words separated by underscores"
  },
  {
    "line": 10,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of assert to validate input assumptions",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 39,
    "end_token": 39,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      6818,
      284,
      26571,
      5128,
      14895
    ],
    "label": "best_practice",
    "reason": "Use of assert to validate input assumptions"
  },
  {
    "line": 12,
    "text": "def _cal_state(s, df, pre, interval, col):",
    "annotation": "\ud83e\udde0 ML Signal: Use of DataFrame indexing and slicing",
    "confidence": 1.0,
    "tokens": [
      4299,
      4808,
      9948,
      62,
      5219,
      7,
      82,
      11,
      47764,
      11,
      662,
      11,
      16654,
      11,
      951,
      2599
    ],
    "start_token": 39,
    "end_token": 55,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6060,
      19778,
      6376,
      278,
      290,
      49289
    ],
    "label": "ml_signal",
    "reason": "Use of DataFrame indexing and slicing"
  },
  {
    "line": 14,
    "text": "    s = df.loc[s.index, :]",
    "annotation": "\u2705 Best Practice: Type hinting for better code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      264,
      796,
      47764,
      13,
      17946,
      58,
      82,
      13,
      9630,
      11,
      1058,
      60
    ],
    "start_token": 55,
    "end_token": 70,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for better code readability and maintainability"
  },
  {
    "line": 16,
    "text": "    recent_df: pd.DataFrame = s.iloc[-interval:, :]",
    "annotation": "\u2705 Best Practice: Type hinting for better code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2274,
      62,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      796,
      264,
      13,
      346,
      420,
      58,
      12,
      3849,
      2100,
      45299,
      1058,
      60
    ],
    "start_token": 70,
    "end_token": 94,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for better code readability and maintainability"
  },
  {
    "line": 18,
    "text": "        return np.nan",
    "annotation": "\ud83e\udde0 ML Signal: Checking for null values in DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      45941,
      13,
      12647
    ],
    "start_token": 94,
    "end_token": 105,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      329,
      9242,
      3815,
      287,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Checking for null values in DataFrame"
  },
  {
    "line": 21,
    "text": "    if pre_result and recent_result:",
    "annotation": "\ud83e\udde0 ML Signal: Logical operations on DataFrame columns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      662,
      62,
      20274,
      290,
      2274,
      62,
      20274,
      25
    ],
    "start_token": 105,
    "end_token": 117,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      605,
      4560,
      319,
      6060,
      19778,
      15180
    ],
    "label": "ml_signal",
    "reason": "Logical operations on DataFrame columns"
  },
  {
    "line": 23,
    "text": "    return np.nan",
    "annotation": "\ud83e\udde0 ML Signal: Logical operations on DataFrame columns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1441,
      45941,
      13,
      12647
    ],
    "start_token": 117,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      605,
      4560,
      319,
      6060,
      19778,
      15180
    ],
    "label": "ml_signal",
    "reason": "Logical operations on DataFrame columns"
  },
  {
    "line": 25,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on computed results",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 124,
    "end_token": 124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      29231,
      2482
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on computed results"
  },
  {
    "line": 28,
    "text": "        super().__init__(windows, cal_change_pct)",
    "annotation": "\ud83e\udde0 ML Signal: Returning NaN for specific conditions",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      7,
      28457,
      11,
      2386,
      62,
      3803,
      62,
      79,
      310,
      8
    ],
    "start_token": 124,
    "end_token": 146,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      11013,
      45,
      329,
      2176,
      3403
    ],
    "label": "ml_signal",
    "reason": "Returning NaN for specific conditions"
  },
  {
    "line": 20,
    "text": "    recent_result = np.logical_and.reduce(recent_df[\"close\"] < recent_df[col])",
    "annotation": "\u2705 Best Practice: Class definition should follow the naming convention of using CamelCase.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2274,
      62,
      20274,
      796,
      45941,
      13,
      6404,
      605,
      62,
      392,
      13,
      445,
      7234,
      7,
      49921,
      62,
      7568,
      14692,
      19836,
      8973,
      1279,
      2274,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 146,
    "end_token": 176,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      1061,
      262,
      19264,
      9831,
      286,
      1262,
      43281,
      20448,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should follow the naming convention of using CamelCase."
  },
  {
    "line": 21,
    "text": "    if pre_result and recent_result:",
    "annotation": "\u2705 Best Practice: Use of default mutable arguments (like lists) can lead to unexpected behavior; consider using None and initializing inside the method.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      662,
      62,
      20274,
      290,
      2274,
      62,
      20274,
      25
    ],
    "start_token": 176,
    "end_token": 188,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      4517,
      540,
      7159,
      357,
      2339,
      8341,
      8,
      460,
      1085,
      284,
      10059,
      4069,
      26,
      2074,
      1262,
      6045,
      290,
      4238,
      2890,
      2641,
      262,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Use of default mutable arguments (like lists) can lead to unexpected behavior; consider using None and initializing inside the method."
  },
  {
    "line": 23,
    "text": "    return np.nan",
    "annotation": "\u2705 Best Practice: Explicitly calling the superclass's __init__ method ensures proper initialization of inherited attributes.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      45941,
      13,
      12647
    ],
    "start_token": 188,
    "end_token": 195,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      4585,
      262,
      2208,
      4871,
      338,
      11593,
      15003,
      834,
      2446,
      19047,
      1774,
      37588,
      286,
      19552,
      12608,
      13
    ],
    "label": "best_practice",
    "reason": "Explicitly calling the superclass's __init__ method ensures proper initialization of inherited attributes."
  },
  {
    "line": 23,
    "text": "    return np.nan",
    "annotation": "\u2705 Best Practice: Type hinting for input and output improves code readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      45941,
      13,
      12647
    ],
    "start_token": 195,
    "end_token": 202,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      5128,
      290,
      5072,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Type hinting for input and output improves code readability and maintainability"
  },
  {
    "line": 25,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of super() indicates inheritance, which is common in ML pipelines for data transformation",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 202,
    "end_token": 202,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      2208,
      3419,
      9217,
      24155,
      11,
      543,
      318,
      2219,
      287,
      10373,
      31108,
      329,
      1366,
      13389
    ],
    "label": "ml_signal",
    "reason": "Use of super() indicates inheritance, which is common in ML pipelines for data transformation"
  },
  {
    "line": 27,
    "text": "    def __init__(self, windows=None, cal_change_pct=False) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Dynamic column naming based on a list of windows suggests a pattern for feature engineering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      9168,
      28,
      14202,
      11,
      2386,
      62,
      3803,
      62,
      79,
      310,
      28,
      25101,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 202,
    "end_token": 228,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      26977,
      5721,
      19264,
      1912,
      319,
      257,
      1351,
      286,
      9168,
      5644,
      257,
      3912,
      329,
      3895,
      8705
    ],
    "label": "ml_signal",
    "reason": "Dynamic column naming based on a list of windows suggests a pattern for feature engineering"
  },
  {
    "line": 29,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of boolean indexing for filtering is a common pattern in data preprocessing",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 228,
    "end_token": 228,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      25131,
      6376,
      278,
      329,
      25431,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      662,
      36948
    ],
    "label": "ml_signal",
    "reason": "Use of boolean indexing for filtering is a common pattern in data preprocessing"
  },
  {
    "line": 33,
    "text": "        s = input_df[cols[0]] > input_df[cols[1]]",
    "annotation": "\ud83e\udde0 ML Signal: Iterative comparison across columns is a pattern for complex feature creation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      264,
      796,
      5128,
      62,
      7568,
      58,
      4033,
      82,
      58,
      15,
      11907,
      1875,
      5128,
      62,
      7568,
      58,
      4033,
      82,
      58,
      16,
      11907
    ],
    "start_token": 228,
    "end_token": 256,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      876,
      7208,
      1973,
      15180,
      318,
      257,
      3912,
      329,
      3716,
      3895,
      6282
    ],
    "label": "ml_signal",
    "reason": "Iterative comparison across columns is a pattern for complex feature creation"
  },
  {
    "line": 36,
    "text": "            s = s & (input_df[current_col] > input_df[col])",
    "annotation": "\u2705 Best Practice: Adding a new column to the DataFrame for results is a clear and maintainable approach",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      264,
      796,
      264,
      1222,
      357,
      15414,
      62,
      7568,
      58,
      14421,
      62,
      4033,
      60,
      1875,
      5128,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 256,
    "end_token": 287,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      18247,
      257,
      649,
      5721,
      284,
      262,
      6060,
      19778,
      329,
      2482,
      318,
      257,
      1598,
      290,
      5529,
      540,
      3164
    ],
    "label": "best_practice",
    "reason": "Adding a new column to the DataFrame for results is a clear and maintainable approach"
  },
  {
    "line": 34,
    "text": "        current_col = cols[1]",
    "annotation": "\u2705 Best Practice: Class definition should include a docstring explaining its purpose and usage.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1459,
      62,
      4033,
      796,
      951,
      82,
      58,
      16,
      60
    ],
    "start_token": 287,
    "end_token": 303,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      6770,
      815,
      2291,
      257,
      2205,
      8841,
      11170,
      663,
      4007,
      290,
      8748,
      13
    ],
    "label": "best_practice",
    "reason": "Class definition should include a docstring explaining its purpose and usage."
  },
  {
    "line": 34,
    "text": "        current_col = cols[1]",
    "annotation": "\u2705 Best Practice: Use of __init__ method to initialize object attributes",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1459,
      62,
      4033,
      796,
      951,
      82,
      58,
      16,
      60
    ],
    "start_token": 303,
    "end_token": 319,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      15003,
      834,
      2446,
      284,
      41216,
      2134,
      12608
    ],
    "label": "best_practice",
    "reason": "Use of __init__ method to initialize object attributes"
  },
  {
    "line": 36,
    "text": "            s = s & (input_df[current_col] > input_df[col])",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of input data to a specific format (timestamp)",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      264,
      796,
      264,
      1222,
      357,
      15414,
      62,
      7568,
      58,
      14421,
      62,
      4033,
      60,
      1875,
      5128,
      62,
      7568,
      58,
      4033,
      12962
    ],
    "start_token": 319,
    "end_token": 350,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      5128,
      1366,
      284,
      257,
      2176,
      5794,
      357,
      16514,
      27823,
      8
    ],
    "label": "ml_signal",
    "reason": "Conversion of input data to a specific format (timestamp)"
  },
  {
    "line": 38,
    "text": "        input_df[\"filter_result\"] = s",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of input data to a specific format (timestamp)",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5128,
      62,
      7568,
      14692,
      24455,
      62,
      20274,
      8973,
      796,
      264
    ],
    "start_token": 350,
    "end_token": 367,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      5128,
      1366,
      284,
      257,
      2176,
      5794,
      357,
      16514,
      27823,
      8
    ],
    "label": "ml_signal",
    "reason": "Conversion of input data to a specific format (timestamp)"
  },
  {
    "line": 38,
    "text": "        input_df[\"filter_result\"] = s",
    "annotation": "\u2705 Best Practice: Use parentheses for method calls to avoid confusion with indexing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5128,
      62,
      7568,
      14692,
      24455,
      62,
      20274,
      8973,
      796,
      264
    ],
    "start_token": 367,
    "end_token": 384,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46672,
      329,
      2446,
      3848,
      284,
      3368,
      10802,
      351,
      6376,
      278
    ],
    "label": "best_practice",
    "reason": "Use parentheses for method calls to avoid confusion with indexing"
  },
  {
    "line": 40,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Direct comparison with False can lead to unexpected results if s contains non-boolean values",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 384,
    "end_token": 384,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      7208,
      351,
      10352,
      460,
      1085,
      284,
      10059,
      2482,
      611,
      264,
      4909,
      1729,
      12,
      2127,
      21052,
      3815
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Direct comparison with False can lead to unexpected results if s contains non-boolean values"
  },
  {
    "line": 42,
    "text": "class SpecificTransformer(Transformer):",
    "annotation": "\u2705 Best Practice: Use parentheses for method calls to avoid confusion with indexing",
    "confidence": 0.5,
    "tokens": [
      4871,
      17377,
      8291,
      16354,
      7,
      8291,
      16354,
      2599
    ],
    "start_token": 384,
    "end_token": 392,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      46672,
      329,
      2446,
      3848,
      284,
      3368,
      10802,
      351,
      6376,
      278
    ],
    "label": "best_practice",
    "reason": "Use parentheses for method calls to avoid confusion with indexing"
  },
  {
    "line": 44,
    "text": "        self.buy_timestamp = to_pd_timestamp(buy_timestamp)",
    "annotation": "\ud83e\udde0 ML Signal: Adding a new column based on conditions can indicate feature engineering",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      17846,
      62,
      16514,
      27823,
      796,
      284,
      62,
      30094,
      62,
      16514,
      27823,
      7,
      17846,
      62,
      16514,
      27823,
      8
    ],
    "start_token": 392,
    "end_token": 418,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      257,
      649,
      5721,
      1912,
      319,
      3403,
      460,
      7603,
      3895,
      8705
    ],
    "label": "ml_signal",
    "reason": "Adding a new column based on conditions can indicate feature engineering"
  },
  {
    "line": 45,
    "text": "        self.sell_timestamp = to_pd_timestamp(sell_timestamp)",
    "annotation": "\u2705 Best Practice: Call to super() ensures proper initialization of the base class",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2116,
      13,
      7255,
      62,
      16514,
      27823,
      796,
      284,
      62,
      30094,
      62,
      16514,
      27823,
      7,
      7255,
      62,
      16514,
      27823,
      8
    ],
    "start_token": 418,
    "end_token": 444,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4889,
      284,
      2208,
      3419,
      19047,
      1774,
      37588,
      286,
      262,
      2779,
      1398
    ],
    "label": "best_practice",
    "reason": "Call to super() ensures proper initialization of the base class"
  },
  {
    "line": 47,
    "text": "    def transform(self, input_df: pd.DataFrame) -> pd.DataFrame:",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameters in a constructor",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      6121,
      7,
      944,
      11,
      5128,
      62,
      7568,
      25,
      279,
      67,
      13,
      6601,
      19778,
      8,
      4613,
      279,
      67,
      13,
      6601,
      19778,
      25
    ],
    "start_token": 444,
    "end_token": 469,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      10007,
      287,
      257,
      23772
    ],
    "label": "ml_signal",
    "reason": "Use of default parameters in a constructor"
  },
  {
    "line": 49,
    "text": "        s[s == False] = None",
    "annotation": "\ud83e\udde0 ML Signal: Use of default parameters in a constructor",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      264,
      58,
      82,
      6624,
      10352,
      60,
      796,
      6045
    ],
    "start_token": 469,
    "end_token": 484,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4277,
      10007,
      287,
      257,
      23772
    ],
    "label": "ml_signal",
    "reason": "Use of default parameters in a constructor"
  },
  {
    "line": 49,
    "text": "        s[s == False] = None",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dynamic column naming based on class attributes",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      264,
      58,
      82,
      6624,
      10352,
      60,
      796,
      6045
    ],
    "start_token": 484,
    "end_token": 499,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8925,
      5721,
      19264,
      1912,
      319,
      1398,
      12608
    ],
    "label": "ml_signal",
    "reason": "Usage of dynamic column naming based on class attributes"
  },
  {
    "line": 51,
    "text": "        input_df[\"filter_result\"] = s",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential for KeyError if 'close' column is missing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      5128,
      62,
      7568,
      14692,
      24455,
      62,
      20274,
      8973,
      796,
      264
    ],
    "start_token": 499,
    "end_token": 516,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      329,
      7383,
      12331,
      611,
      705,
      19836,
      6,
      5721,
      318,
      4814
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential for KeyError if 'close' column is missing"
  },
  {
    "line": 56,
    "text": "    def __init__(self, window=10, interval=3) -> None:",
    "annotation": "\ud83e\udde0 ML Signal: Use of normalization function on computed results",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      15003,
      834,
      7,
      944,
      11,
      4324,
      28,
      940,
      11,
      16654,
      28,
      18,
      8,
      4613,
      6045,
      25
    ],
    "start_token": 516,
    "end_token": 537,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3487,
      1634,
      2163,
      319,
      29231,
      2482
    ],
    "label": "ml_signal",
    "reason": "Use of normalization function on computed results"
  },
  {
    "line": 57,
    "text": "        super().__init__()",
    "annotation": "\ud83e\udde0 ML Signal: Logical comparison between DataFrame columns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2208,
      22446,
      834,
      15003,
      834,
      3419
    ],
    "start_token": 537,
    "end_token": 550,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5972,
      605,
      7208,
      1022,
      6060,
      19778,
      15180
    ],
    "label": "ml_signal",
    "reason": "Logical comparison between DataFrame columns"
  },
  {
    "line": 64,
    "text": "            group_result = (",
    "annotation": "\ud83e\udde0 ML Signal: Use of lambda function for custom rolling window operations",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1448,
      62,
      20274,
      796,
      357
    ],
    "start_token": 550,
    "end_token": 566,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      37456,
      2163,
      329,
      2183,
      10708,
      4324,
      4560
    ],
    "label": "ml_signal",
    "reason": "Use of lambda function for custom rolling window operations"
  },
  {
    "line": 67,
    "text": "            group_result = normalize_group_compute_result(group_result=group_result)",
    "annotation": "\ud83e\udde0 ML Signal: Use of normalization function on computed results",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1448,
      62,
      20274,
      796,
      3487,
      1096,
      62,
      8094,
      62,
      5589,
      1133,
      62,
      20274,
      7,
      8094,
      62,
      20274,
      28,
      8094,
      62,
      20274,
      8
    ],
    "start_token": 566,
    "end_token": 599,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      3487,
      1634,
      2163,
      319,
      29231,
      2482
    ],
    "label": "ml_signal",
    "reason": "Use of normalization function on computed results"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\u2705 Best Practice: Use 'is' for comparison with True/False/None",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      271,
      6,
      329,
      7208,
      351,
      6407,
      14,
      25101,
      14,
      14202
    ],
    "label": "best_practice",
    "reason": "Use 'is' for comparison with True/False/None"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\u2705 Best Practice: Use 'is' for comparison with True/False/None",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      271,
      6,
      329,
      7208,
      351,
      6407,
      14,
      25101,
      14,
      14202
    ],
    "label": "best_practice",
    "reason": "Use 'is' for comparison with True/False/None"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Merging filter results back into the DataFrame",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4638,
      2667,
      8106,
      2482,
      736,
      656,
      262,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Merging filter results back into the DataFrame"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of __name__ guard for script entry point",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      3672,
      834,
      4860,
      329,
      4226,
      5726,
      966
    ],
    "label": "best_practice",
    "reason": "Use of __name__ guard for script entry point"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Instantiation of a class with specific parameters",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24470,
      3920,
      286,
      257,
      1398,
      351,
      2176,
      10007
    ],
    "label": "ml_signal",
    "reason": "Instantiation of a class with specific parameters"
  },
  {
    "line": 69,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of __all__ to define public API of the module",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 599,
    "end_token": 599,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      11593,
      439,
      834,
      284,
      8160,
      1171,
      7824,
      286,
      262,
      8265
    ],
    "label": "ml_signal",
    "reason": "Use of __all__ to define public API of the module"
  }
]