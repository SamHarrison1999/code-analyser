[
  {
    "line": 16,
    "text": "    to_pd_timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with parameters indicating a date range",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      284,
      62,
      30094,
      62,
      16514,
      27823,
      11
    ],
    "start_token": 0,
    "end_token": 10,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      10007,
      12739,
      257,
      3128,
      2837
    ],
    "label": "ml_signal",
    "reason": "Function definition with parameters indicating a date range"
  },
  {
    "line": 17,
    "text": "    date_time_by_interval,",
    "annotation": "\ud83e\udde0 ML Signal: Querying data from a specific entity and provider",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3128,
      62,
      2435,
      62,
      1525,
      62,
      3849,
      2100,
      11
    ],
    "start_token": 10,
    "end_token": 22,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2264,
      263,
      1112,
      1366,
      422,
      257,
      2176,
      9312,
      290,
      10131
    ],
    "label": "ml_signal",
    "reason": "Querying data from a specific entity and provider"
  },
  {
    "line": 17,
    "text": "    date_time_by_interval,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if 'query_data' method is vulnerable to injection attacks",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      3128,
      62,
      2435,
      62,
      1525,
      62,
      3849,
      2100,
      11
    ],
    "start_token": 22,
    "end_token": 34,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      705,
      22766,
      62,
      7890,
      6,
      2446,
      318,
      8826,
      284,
      16954,
      3434
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if 'query_data' method is vulnerable to injection attacks"
  },
  {
    "line": 17,
    "text": "    date_time_by_interval,",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded entity_id and provider, indicating specific data source usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      3128,
      62,
      2435,
      62,
      1525,
      62,
      3849,
      2100,
      11
    ],
    "start_token": 34,
    "end_token": 46,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      9312,
      62,
      312,
      290,
      10131,
      11,
      12739,
      2176,
      1366,
      2723,
      8748
    ],
    "label": "ml_signal",
    "reason": "Hardcoded entity_id and provider, indicating specific data source usage"
  },
  {
    "line": 26,
    "text": "        columns=[\"timestamp\"],",
    "annotation": "\ud83e\udde0 ML Signal: Specific columns being queried, indicating data selection pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      28,
      14692,
      16514,
      27823,
      33116
    ],
    "start_token": 46,
    "end_token": 59,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      17377,
      15180,
      852,
      42517,
      798,
      11,
      12739,
      1366,
      6356,
      3912
    ],
    "label": "ml_signal",
    "reason": "Specific columns being queried, indicating data selection pattern"
  },
  {
    "line": 26,
    "text": "        columns=[\"timestamp\"],",
    "annotation": "\ud83e\udde0 ML Signal: Use of start and end timestamps for data filtering",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      28,
      14692,
      16514,
      27823,
      33116
    ],
    "start_token": 59,
    "end_token": 72,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      923,
      290,
      886,
      4628,
      395,
      9430,
      329,
      1366,
      25431
    ],
    "label": "ml_signal",
    "reason": "Use of start and end timestamps for data filtering"
  },
  {
    "line": 29,
    "text": "        order=Index1dKdata.timestamp.asc(),",
    "annotation": "\ud83e\udde0 ML Signal: Ordering data by timestamp in ascending order",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      28,
      15732,
      16,
      67,
      42,
      7890,
      13,
      16514,
      27823,
      13,
      3372,
      22784
    ],
    "start_token": 72,
    "end_token": 92,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8284,
      278,
      1366,
      416,
      41033,
      287,
      41988,
      1502
    ],
    "label": "ml_signal",
    "reason": "Ordering data by timestamp in ascending order"
  },
  {
    "line": 31,
    "text": "    )",
    "annotation": "\ud83e\udde0 ML Signal: Specifying return type as DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 92,
    "end_token": 96,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18291,
      4035,
      1441,
      2099,
      355,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Specifying return type as DataFrame"
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\u2705 Best Practice: Accessing DataFrame column directly for conversion to list",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 96,
    "end_token": 96,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8798,
      278,
      6060,
      19778,
      5721,
      3264,
      329,
      11315,
      284,
      1351
    ],
    "label": "best_practice",
    "reason": "Accessing DataFrame column directly for conversion to list"
  },
  {
    "line": 27,
    "text": "        start_timestamp=start,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a mutable default argument like current_date() can lead to unexpected behavior if the function is called multiple times.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      16514,
      27823,
      28,
      9688,
      11
    ],
    "start_token": 96,
    "end_token": 110,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4517,
      540,
      4277,
      4578,
      588,
      1459,
      62,
      4475,
      3419,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      262,
      2163,
      318,
      1444,
      3294,
      1661,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a mutable default argument like current_date() can lead to unexpected behavior if the function is called multiple times."
  },
  {
    "line": 29,
    "text": "        order=Index1dKdata.timestamp.asc(),",
    "annotation": "\u2705 Best Practice: Calculate a buffer period to ensure enough dates are fetched.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1502,
      28,
      15732,
      16,
      67,
      42,
      7890,
      13,
      16514,
      27823,
      13,
      3372,
      22784
    ],
    "start_token": 110,
    "end_token": 130,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      27131,
      378,
      257,
      11876,
      2278,
      284,
      4155,
      1576,
      9667,
      389,
      11351,
      1740,
      13
    ],
    "label": "best_practice",
    "reason": "Calculate a buffer period to ensure enough dates are fetched."
  },
  {
    "line": 31,
    "text": "    )",
    "annotation": "\ud83e\udde0 ML Signal: Fetching trade dates based on a calculated start date and a target date.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 130,
    "end_token": 134,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      376,
      7569,
      278,
      3292,
      9667,
      1912,
      319,
      257,
      10488,
      923,
      3128,
      290,
      257,
      2496,
      3128,
      13
    ],
    "label": "ml_signal",
    "reason": "Fetching trade dates based on a calculated start date and a target date."
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\u2705 Best Practice: Handle edge case where days_count is zero.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 134,
    "end_token": 134,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      33141,
      5743,
      1339,
      810,
      1528,
      62,
      9127,
      318,
      6632,
      13
    ],
    "label": "best_practice",
    "reason": "Handle edge case where days_count is zero."
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Slicing a list to get the most recent trade dates.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 134,
    "end_token": 134,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      311,
      677,
      278,
      257,
      1351,
      284,
      651,
      262,
      749,
      2274,
      3292,
      9667,
      13
    ],
    "label": "ml_signal",
    "reason": "Slicing a list to get the most recent trade dates."
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of type hints for function parameters and return type improves code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 134,
    "end_token": 134,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use of type hints for function parameters and return type improves code readability and maintainability."
  },
  {
    "line": 40,
    "text": "    return dates[-days_count:]",
    "annotation": "\u2705 Best Practice: Type hint for variable 'data_schema' improves code readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1441,
      9667,
      58,
      12,
      12545,
      62,
      9127,
      47715
    ],
    "start_token": 134,
    "end_token": 145,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      329,
      7885,
      705,
      7890,
      62,
      15952,
      2611,
      6,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hint for variable 'data_schema' improves code readability and maintainability."
  },
  {
    "line": 43,
    "text": "def get_latest_kdata_date(",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of querying data with specific order and limit can be used to train models on data retrieval patterns.",
    "confidence": 0.5,
    "tokens": [
      4299,
      651,
      62,
      42861,
      62,
      74,
      7890,
      62,
      4475,
      7
    ],
    "start_token": 145,
    "end_token": 155,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      42517,
      1112,
      1366,
      351,
      2176,
      1502,
      290,
      4179,
      460,
      307,
      973,
      284,
      4512,
      4981,
      319,
      1366,
      45069,
      7572,
      13
    ],
    "label": "ml_signal",
    "reason": "Pattern of querying data with specific order and limit can be used to train models on data retrieval patterns."
  },
  {
    "line": 44,
    "text": "    entity_type: str,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes 'latest_data' is not empty; potential IndexError if assumption is incorrect.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      4906,
      25,
      965,
      11
    ],
    "start_token": 155,
    "end_token": 164,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      705,
      42861,
      62,
      7890,
      6,
      318,
      407,
      6565,
      26,
      2785,
      12901,
      12331,
      611,
      13196,
      318,
      11491,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes 'latest_data' is not empty; potential IndexError if assumption is incorrect."
  },
  {
    "line": 44,
    "text": "    entity_type: str,",
    "annotation": "\u2705 Best Practice: Type hinting improves code readability and helps with static analysis",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      4906,
      25,
      965,
      11
    ],
    "start_token": 164,
    "end_token": 173,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      19575,
      2438,
      1100,
      1799,
      290,
      5419,
      351,
      9037,
      3781
    ],
    "label": "best_practice",
    "reason": "Type hinting improves code readability and helps with static analysis"
  },
  {
    "line": 50,
    "text": "",
    "annotation": "\u2705 Best Practice: Using type checking to ensure correct type conversion",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 173,
    "end_token": 173,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2099,
      10627,
      284,
      4155,
      3376,
      2099,
      11315
    ],
    "label": "best_practice",
    "reason": "Using type checking to ensure correct type conversion"
  },
  {
    "line": 53,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Using type checking to ensure correct type conversion",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 173,
    "end_token": 177,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      2099,
      10627,
      284,
      4155,
      3376,
      2099,
      11315
    ],
    "label": "best_practice",
    "reason": "Using type checking to ensure correct type conversion"
  },
  {
    "line": 54,
    "text": "    return to_pd_timestamp(latest_data[0].timestamp)",
    "annotation": "\u2705 Best Practice: Using clear and descriptive variable names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      284,
      62,
      30094,
      62,
      16514,
      27823,
      7,
      42861,
      62,
      7890,
      58,
      15,
      4083,
      16514,
      27823,
      8
    ],
    "start_token": 177,
    "end_token": 197,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      1598,
      290,
      35644,
      7885,
      3891
    ],
    "label": "best_practice",
    "reason": "Using clear and descriptive variable names"
  },
  {
    "line": 60,
    "text": "    adjust_type: Union[AdjustType, str] = None,",
    "annotation": "\u2705 Best Practice: Using format for string formatting improves readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      4532,
      62,
      4906,
      25,
      4479,
      58,
      39668,
      6030,
      11,
      965,
      60,
      796,
      6045,
      11
    ],
    "start_token": 197,
    "end_token": 214,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      5794,
      329,
      4731,
      33313,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Using format for string formatting improves readability"
  },
  {
    "line": 62,
    "text": "    if type(level) == str:",
    "annotation": "\u2705 Best Practice: Using format for string formatting improves readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      2099,
      7,
      5715,
      8,
      6624,
      965,
      25
    ],
    "start_token": 214,
    "end_token": 225,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      5794,
      329,
      4731,
      33313,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Using format for string formatting improves readability"
  },
  {
    "line": 62,
    "text": "    if type(level) == str:",
    "annotation": "\ud83e\udde0 ML Signal: Function return values can be used to learn about schema generation patterns",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      2099,
      7,
      5715,
      8,
      6624,
      965,
      25
    ],
    "start_token": 225,
    "end_token": 236,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      1441,
      3815,
      460,
      307,
      973,
      284,
      2193,
      546,
      32815,
      5270,
      7572
    ],
    "label": "ml_signal",
    "reason": "Function return values can be used to learn about schema generation patterns"
  },
  {
    "line": 79,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using assert for control flow can be disabled in production with optimization flags.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 236,
    "end_token": 236,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      6818,
      329,
      1630,
      5202,
      460,
      307,
      10058,
      287,
      3227,
      351,
      23989,
      9701,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using assert for control flow can be disabled in production with optimization flags."
  },
  {
    "line": 81,
    "text": "    entity_id=None,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of selecting the first element from a list.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      9312,
      62,
      312,
      28,
      14202,
      11
    ],
    "start_token": 236,
    "end_token": 245,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      17246,
      262,
      717,
      5002,
      422,
      257,
      1351,
      13
    ],
    "label": "ml_signal",
    "reason": "Pattern of selecting the first element from a list."
  },
  {
    "line": 85,
    "text": "    columns=None,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of wrapping a single item into a list.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      15180,
      28,
      14202,
      11
    ],
    "start_token": 245,
    "end_token": 252,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      27074,
      257,
      2060,
      2378,
      656,
      257,
      1351,
      13
    ],
    "label": "ml_signal",
    "reason": "Pattern of wrapping a single item into a list."
  },
  {
    "line": 86,
    "text": "    return_type=\"df\",",
    "annotation": "\u2705 Best Practice: Unpacking values from a function return for clarity.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      62,
      4906,
      2625,
      7568,
      1600
    ],
    "start_token": 252,
    "end_token": 261,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      791,
      41291,
      3815,
      422,
      257,
      2163,
      1441,
      329,
      16287,
      13
    ],
    "label": "best_practice",
    "reason": "Unpacking values from a function return for clarity."
  },
  {
    "line": 86,
    "text": "    return_type=\"df\",",
    "annotation": "\u2705 Best Practice: Type hinting for better code readability and maintainability.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      62,
      4906,
      2625,
      7568,
      1600
    ],
    "start_token": 261,
    "end_token": 270,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5994,
      9254,
      278,
      329,
      1365,
      2438,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Type hinting for better code readability and maintainability."
  },
  {
    "line": 101,
    "text": "        entity_ids = [entity_id]",
    "annotation": "\u2705 Best Practice: Add type hint for the return value for better readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      9312,
      62,
      2340,
      796,
      685,
      26858,
      62,
      312,
      60
    ],
    "start_token": 270,
    "end_token": 286,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      2099,
      9254,
      329,
      262,
      1441,
      1988,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Add type hint for the return value for better readability and maintainability"
  },
  {
    "line": 106,
    "text": "    return data_schema.query_data(",
    "annotation": "\u2705 Best Practice: Use .lower() to handle case-insensitive comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1441,
      1366,
      62,
      15952,
      2611,
      13,
      22766,
      62,
      7890,
      7
    ],
    "start_token": 286,
    "end_token": 299,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      764,
      21037,
      3419,
      284,
      5412,
      1339,
      12,
      1040,
      18464,
      17909
    ],
    "label": "best_practice",
    "reason": "Use .lower() to handle case-insensitive comparisons"
  },
  {
    "line": 108,
    "text": "        level=level,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of returning specific enum based on string prefix",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      5715,
      11
    ],
    "start_token": 299,
    "end_token": 310,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      8024,
      2176,
      33829,
      1912,
      319,
      4731,
      21231
    ],
    "label": "ml_signal",
    "reason": "Pattern of returning specific enum based on string prefix"
  },
  {
    "line": 110,
    "text": "        columns=columns,",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of returning default enum when condition is not met",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      28,
      28665,
      82,
      11
    ],
    "start_token": 310,
    "end_token": 322,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      8024,
      4277,
      33829,
      618,
      4006,
      318,
      407,
      1138
    ],
    "label": "ml_signal",
    "reason": "Pattern of returning default enum when condition is not met"
  },
  {
    "line": 108,
    "text": "        level=level,",
    "annotation": "\ud83e\udde0 ML Signal: Function definition with parameters indicating a pattern for generating unique identifiers",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      5715,
      11
    ],
    "start_token": 322,
    "end_token": 333,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      6770,
      351,
      10007,
      12739,
      257,
      3912,
      329,
      15453,
      3748,
      42814
    ],
    "label": "ml_signal",
    "reason": "Function definition with parameters indicating a pattern for generating unique identifiers"
  },
  {
    "line": 110,
    "text": "        columns=columns,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential risk if `level` is not validated and can be influenced by user input",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      15180,
      28,
      28665,
      82,
      11
    ],
    "start_token": 333,
    "end_token": 345,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      2526,
      611,
      4600,
      5715,
      63,
      318,
      407,
      31031,
      290,
      460,
      307,
      12824,
      416,
      2836,
      5128
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential risk if `level` is not validated and can be influenced by user input"
  },
  {
    "line": 112,
    "text": "        start_timestamp=start_timestamp,",
    "annotation": "\u2705 Best Practice: Use of format method for string formatting improves readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      62,
      16514,
      27823,
      28,
      9688,
      62,
      16514,
      27823,
      11
    ],
    "start_token": 345,
    "end_token": 362,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      5794,
      2446,
      329,
      4731,
      33313,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of format method for string formatting improves readability"
  },
  {
    "line": 115,
    "text": "        session=session,",
    "annotation": "\u2705 Best Practice: Use of format method for string formatting improves readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6246,
      28,
      29891,
      11
    ],
    "start_token": 362,
    "end_token": 373,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      5794,
      2446,
      329,
      4731,
      33313,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of format method for string formatting improves readability"
  },
  {
    "line": 113,
    "text": "        end_timestamp=end_timestamp,",
    "annotation": "\u2705 Best Practice: Add type hints for function parameters and return type for better readability and maintainability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      16514,
      27823,
      28,
      437,
      62,
      16514,
      27823,
      11
    ],
    "start_token": 373,
    "end_token": 390,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3060,
      2099,
      20269,
      329,
      2163,
      10007,
      290,
      1441,
      2099,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Add type hints for function parameters and return type for better readability and maintainability"
  },
  {
    "line": 115,
    "text": "        session=session,",
    "annotation": "\u2705 Best Practice: Check if 's' is a list or has a length before accessing the last element",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6246,
      28,
      29891,
      11
    ],
    "start_token": 390,
    "end_token": 401,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      705,
      82,
      6,
      318,
      257,
      1351,
      393,
      468,
      257,
      4129,
      878,
      22534,
      262,
      938,
      5002
    ],
    "label": "best_practice",
    "reason": "Check if 's' is a list or has a length before accessing the last element"
  },
  {
    "line": 117,
    "text": "        limit=limit,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential IndexError if 's' is empty",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      4179,
      28,
      32374,
      11
    ],
    "start_token": 401,
    "end_token": 412,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      12901,
      12331,
      611,
      705,
      82,
      6,
      318,
      6565
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential IndexError if 's' is empty"
  },
  {
    "line": 118,
    "text": "        index=index,",
    "annotation": "\u2705 Best Practice: Check for null values before accessing elements to avoid runtime errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      28,
      9630,
      11
    ],
    "start_token": 412,
    "end_token": 423,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      9242,
      3815,
      878,
      22534,
      4847,
      284,
      3368,
      19124,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Check for null values before accessing elements to avoid runtime errors."
  },
  {
    "line": 120,
    "text": "    )",
    "annotation": "\u2705 Best Practice: Return the first element of the sequence if it is not null.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 423,
    "end_token": 427,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      262,
      717,
      5002,
      286,
      262,
      8379,
      611,
      340,
      318,
      407,
      9242,
      13
    ],
    "label": "best_practice",
    "reason": "Return the first element of the sequence if it is not null."
  },
  {
    "line": 120,
    "text": "    )",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of np.max without input validation can lead to unexpected errors if 's' is not a valid array.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1267
    ],
    "start_token": 427,
    "end_token": 431,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      45941,
      13,
      9806,
      1231,
      5128,
      21201,
      460,
      1085,
      284,
      10059,
      8563,
      611,
      705,
      82,
      6,
      318,
      407,
      257,
      4938,
      7177,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of np.max without input validation can lead to unexpected errors if 's' is not a valid array."
  },
  {
    "line": 121,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding input validation to ensure 's' is a valid numpy array.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 431,
    "end_token": 431,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      5128,
      21201,
      284,
      4155,
      705,
      82,
      6,
      318,
      257,
      4938,
      299,
      32152,
      7177,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding input validation to ensure 's' is a valid numpy array."
  },
  {
    "line": 123,
    "text": "def default_adjust_type(entity_type: str) -> AdjustType:",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy's max function to find the maximum value in an array.",
    "confidence": 0.5,
    "tokens": [
      4299,
      4277,
      62,
      23032,
      62,
      4906,
      7,
      26858,
      62,
      4906,
      25,
      965,
      8,
      4613,
      20292,
      6030,
      25
    ],
    "start_token": 431,
    "end_token": 448,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      338,
      3509,
      2163,
      284,
      1064,
      262,
      5415,
      1988,
      287,
      281,
      7177,
      13
    ],
    "label": "ml_signal",
    "reason": "Use of numpy's max function to find the maximum value in an array."
  },
  {
    "line": 122,
    "text": "",
    "annotation": "\u2705 Best Practice: Function name could be more descriptive to indicate its purpose",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 448,
    "end_token": 448,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15553,
      1438,
      714,
      307,
      517,
      35644,
      284,
      7603,
      663,
      4007
    ],
    "label": "best_practice",
    "reason": "Function name could be more descriptive to indicate its purpose"
  },
  {
    "line": 124,
    "text": "    \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes input 's' is a valid sequence for np.min, lacks input validation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 448,
    "end_token": 452,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      5128,
      705,
      82,
      6,
      318,
      257,
      4938,
      8379,
      329,
      45941,
      13,
      1084,
      11,
      16523,
      5128,
      21201
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes input 's' is a valid sequence for np.min, lacks input validation"
  },
  {
    "line": 125,
    "text": "    :type entity_type: entity type, e.g stock, stockhk, stockus",
    "annotation": "\ud83e\udde0 ML Signal: Use of numpy's sum function indicates numerical data processing",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1058,
      4906,
      9312,
      62,
      4906,
      25,
      9312,
      2099,
      11,
      304,
      13,
      70,
      4283,
      11,
      4283,
      71,
      74,
      11,
      4283,
      385
    ],
    "start_token": 452,
    "end_token": 475,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      299,
      32152,
      338,
      2160,
      2163,
      9217,
      29052,
      1366,
      7587
    ],
    "label": "ml_signal",
    "reason": "Use of numpy's sum function indicates numerical data processing"
  },
  {
    "line": 127,
    "text": "    if entity_type.lower().startswith(\"stock\"):",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific columns from a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      9312,
      62,
      4906,
      13,
      21037,
      22446,
      9688,
      2032,
      342,
      7203,
      13578,
      1,
      2599
    ],
    "start_token": 475,
    "end_token": 492,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      15180,
      422,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accessing specific columns from a DataFrame"
  },
  {
    "line": 129,
    "text": "    return AdjustType.qfq",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific columns from a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1441,
      20292,
      6030,
      13,
      80,
      69,
      80
    ],
    "start_token": 492,
    "end_token": 502,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      15180,
      422,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accessing specific columns from a DataFrame"
  },
  {
    "line": 131,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific columns from a DataFrame",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 502,
    "end_token": 502,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      15180,
      422,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accessing specific columns from a DataFrame"
  },
  {
    "line": 133,
    "text": "    if level >= IntervalLevel.LEVEL_1DAY:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific columns from a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      1241,
      18189,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      25
    ],
    "start_token": 502,
    "end_token": 518,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      15180,
      422,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accessing specific columns from a DataFrame"
  },
  {
    "line": 135,
    "text": "    else:",
    "annotation": "\ud83e\udde0 ML Signal: Accessing specific columns from a DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 518,
    "end_token": 523,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      2176,
      15180,
      422,
      257,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Accessing specific columns from a DataFrame"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Decoding entity ID to extract information",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 523,
    "end_token": 523,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      4280,
      7656,
      9312,
      4522,
      284,
      7925,
      1321
    ],
    "label": "ml_signal",
    "reason": "Decoding entity ID to extract information"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for runtime checks can be disabled with optimization",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 523,
    "end_token": 523,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      19124,
      8794,
      460,
      307,
      10058,
      351,
      23989
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for runtime checks can be disabled with optimization"
  },
  {
    "line": 137,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Use of assert for runtime checks can be disabled with optimization",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 523,
    "end_token": 523,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      5765,
      286,
      6818,
      329,
      19124,
      8794,
      460,
      307,
      10058,
      351,
      23989
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Use of assert for runtime checks can be disabled with optimization"
  },
  {
    "line": 148,
    "text": "    def to_high(s):",
    "annotation": "\u2705 Best Practice: Explicit type hinting for DataFrame initialization",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      284,
      62,
      8929,
      7,
      82,
      2599
    ],
    "start_token": 523,
    "end_token": 533,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      2099,
      9254,
      278,
      329,
      6060,
      19778,
      37588
    ],
    "label": "best_practice",
    "reason": "Explicit type hinting for DataFrame initialization"
  },
  {
    "line": 148,
    "text": "    def to_high(s):",
    "annotation": "\ud83e\udde0 ML Signal: Resampling data based on time intervals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      284,
      62,
      8929,
      7,
      82,
      2599
    ],
    "start_token": 533,
    "end_token": 543,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1874,
      321,
      11347,
      1366,
      1912,
      319,
      640,
      20016
    ],
    "label": "ml_signal",
    "reason": "Resampling data based on time intervals"
  },
  {
    "line": 159,
    "text": "    provider = kdata_df[\"provider\"][0]",
    "annotation": "\ud83e\udde0 ML Signal: Resampling data based on time intervals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      10131,
      796,
      479,
      7890,
      62,
      7568,
      14692,
      15234,
      1304,
      1,
      7131,
      15,
      60
    ],
    "start_token": 543,
    "end_token": 559,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      1874,
      321,
      11347,
      1366,
      1912,
      319,
      640,
      20016
    ],
    "label": "ml_signal",
    "reason": "Resampling data based on time intervals"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Dropping NaN values from DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 559,
    "end_token": 580,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21045,
      2105,
      11013,
      45,
      3815,
      422,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Dropping NaN values from DataFrame"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Adding metadata columns to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 580,
    "end_token": 601,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      20150,
      15180,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding metadata columns to DataFrame"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Adding metadata columns to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 601,
    "end_token": 622,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      20150,
      15180,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding metadata columns to DataFrame"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Adding metadata columns to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 622,
    "end_token": 643,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      20150,
      15180,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding metadata columns to DataFrame"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Adding metadata columns to DataFrame",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 643,
    "end_token": 664,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      18247,
      20150,
      15180,
      284,
      6060,
      19778
    ],
    "label": "ml_signal",
    "reason": "Adding metadata columns to DataFrame"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\ud83e\udde0 ML Signal: Entry point for script execution",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 664,
    "end_token": 685,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      21617,
      966,
      329,
      4226,
      9706
    ],
    "label": "ml_signal",
    "reason": "Entry point for script execution"
  },
  {
    "line": 166,
    "text": "    assert IntervalLevel(original_level) < IntervalLevel(to_level)",
    "annotation": "\u2705 Best Practice: Use of __all__ to define public API of the module",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      6818,
      4225,
      2100,
      4971,
      7,
      14986,
      62,
      5715,
      8,
      1279,
      4225,
      2100,
      4971,
      7,
      1462,
      62,
      5715,
      8
    ],
    "start_token": 685,
    "end_token": 706,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      439,
      834,
      284,
      8160,
      1171,
      7824,
      286,
      262,
      8265
    ],
    "label": "best_practice",
    "reason": "Use of __all__ to define public API of the module"
  }
]