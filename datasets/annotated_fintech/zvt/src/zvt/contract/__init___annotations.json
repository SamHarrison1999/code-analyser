[
  {
    "line": 2,
    "text": "from enum import Enum",
    "annotation": "\u2705 Best Practice: Use of Enum for fixed set of constants improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      6738,
      33829,
      1330,
      2039,
      388
    ],
    "start_token": 0,
    "end_token": 5,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2039,
      388,
      329,
      5969,
      900,
      286,
      38491,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of Enum for fixed set of constants improves code readability and maintainability"
  },
  {
    "line": 7,
    "text": "    Repeated fixed time interval, e.g, 5m, 1d.",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      30558,
      515,
      5969,
      640,
      16654,
      11,
      304,
      13,
      70,
      11,
      642,
      76,
      11,
      352,
      67,
      13
    ],
    "start_token": 5,
    "end_token": 24,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 9,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 24,
    "end_token": 24,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 11,
    "text": "    LEVEL_L2_QUOTE = \"l2quote\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      43,
      17,
      62,
      10917,
      23051,
      796,
      366,
      75,
      17,
      22708,
      1
    ],
    "start_token": 24,
    "end_token": 40,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 13,
    "text": "    LEVEL_TICK = \"tick\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      51,
      11860,
      796,
      366,
      42298,
      1
    ],
    "start_token": 40,
    "end_token": 51,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 15,
    "text": "    LEVEL_1MIN = \"1m\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      16,
      23678,
      796,
      366,
      16,
      76,
      1
    ],
    "start_token": 51,
    "end_token": 63,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 17,
    "text": "    LEVEL_5MIN = \"5m\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      20,
      23678,
      796,
      366,
      20,
      76,
      1
    ],
    "start_token": 63,
    "end_token": 75,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 19,
    "text": "    LEVEL_15MIN = \"15m\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      1314,
      23678,
      796,
      366,
      1314,
      76,
      1
    ],
    "start_token": 75,
    "end_token": 87,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 21,
    "text": "    LEVEL_30MIN = \"30m\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      1270,
      23678,
      796,
      366,
      1270,
      76,
      1
    ],
    "start_token": 87,
    "end_token": 99,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 23,
    "text": "    LEVEL_1HOUR = \"1h\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      16,
      39,
      11698,
      796,
      366,
      16,
      71,
      1
    ],
    "start_token": 99,
    "end_token": 112,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 25,
    "text": "    LEVEL_4HOUR = \"4h\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      19,
      39,
      11698,
      796,
      366,
      19,
      71,
      1
    ],
    "start_token": 112,
    "end_token": 125,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 27,
    "text": "    LEVEL_1DAY = \"1d\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of string constants in an Enum can indicate categorical data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      16,
      26442,
      796,
      366,
      16,
      67,
      1
    ],
    "start_token": 125,
    "end_token": 137,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      4731,
      38491,
      287,
      281,
      2039,
      388,
      460,
      7603,
      4253,
      12409,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of string constants in an Enum can indicate categorical data"
  },
  {
    "line": 17,
    "text": "    LEVEL_5MIN = \"5m\"",
    "annotation": "\u2705 Best Practice: Consider using a dictionary to map IntervalLevel to strings for better maintainability and readability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      20,
      23678,
      796,
      366,
      20,
      76,
      1
    ],
    "start_token": 137,
    "end_token": 149,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      257,
      22155,
      284,
      3975,
      4225,
      2100,
      4971,
      284,
      13042,
      329,
      1365,
      5529,
      1799,
      290,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using a dictionary to map IntervalLevel to strings for better maintainability and readability."
  },
  {
    "line": 19,
    "text": "    LEVEL_15MIN = \"15m\"",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      1314,
      23678,
      796,
      366,
      1314,
      76,
      1
    ],
    "start_token": 149,
    "end_token": 161,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 22,
    "text": "    #: 1 hour",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      352,
      1711
    ],
    "start_token": 161,
    "end_token": 168,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 25,
    "text": "    LEVEL_4HOUR = \"4h\"",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      19,
      39,
      11698,
      796,
      366,
      19,
      71,
      1
    ],
    "start_token": 168,
    "end_token": 181,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 28,
    "text": "    #: 1 week",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      352,
      1285
    ],
    "start_token": 181,
    "end_token": 188,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 31,
    "text": "    LEVEL_1MON = \"1mon\"",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      49277,
      62,
      16,
      27857,
      796,
      366,
      16,
      2144,
      1
    ],
    "start_token": 188,
    "end_token": 200,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 34,
    "text": "        if self == IntervalLevel.LEVEL_1MIN:",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      23678,
      25
    ],
    "start_token": 200,
    "end_token": 220,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 37,
    "text": "            return \"5min\"",
    "annotation": "\u2705 Best Practice: Use elif for mutually exclusive conditions to improve readability and performance.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      20,
      1084,
      1
    ],
    "start_token": 220,
    "end_token": 236,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      1288,
      361,
      329,
      26519,
      8568,
      3403,
      284,
      2987,
      1100,
      1799,
      290,
      2854,
      13
    ],
    "label": "best_practice",
    "reason": "Use elif for mutually exclusive conditions to improve readability and performance."
  },
  {
    "line": 33,
    "text": "    def to_pd_freq(self):",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      284,
      62,
      30094,
      62,
      19503,
      80,
      7,
      944,
      2599
    ],
    "start_token": 236,
    "end_token": 249,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 35,
    "text": "            return \"1min\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      16,
      1084,
      1
    ],
    "start_token": 249,
    "end_token": 265,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 37,
    "text": "            return \"5min\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      20,
      1084,
      1
    ],
    "start_token": 265,
    "end_token": 281,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 39,
    "text": "            return \"15min\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      1314,
      1084,
      1
    ],
    "start_token": 281,
    "end_token": 297,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 41,
    "text": "            return \"30min\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      1270,
      1084,
      1
    ],
    "start_token": 297,
    "end_token": 313,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 43,
    "text": "            return \"1H\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      16,
      39,
      1
    ],
    "start_token": 313,
    "end_token": 329,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 45,
    "text": "            return \"4H\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      19,
      39,
      1
    ],
    "start_token": 329,
    "end_token": 345,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 47,
    "text": "            return \"1D\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      16,
      35,
      1
    ],
    "start_token": 345,
    "end_token": 361,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 49,
    "text": "    def floor_timestamp(self, pd_timestamp):",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4314,
      62,
      16514,
      27823,
      7,
      944,
      11,
      279,
      67,
      62,
      16514,
      27823,
      2599
    ],
    "start_token": 361,
    "end_token": 378,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 51,
    "text": "            return pd_timestamp.floor(\"1min\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      62,
      16514,
      27823,
      13,
      28300,
      7203,
      16,
      1084,
      4943
    ],
    "start_token": 378,
    "end_token": 401,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 52,
    "text": "        if self == IntervalLevel.LEVEL_5MIN:",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      20,
      23678,
      25
    ],
    "start_token": 401,
    "end_token": 421,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 56,
    "text": "        if self == IntervalLevel.LEVEL_30MIN:",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      1270,
      23678,
      25
    ],
    "start_token": 421,
    "end_token": 441,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 57,
    "text": "            return pd_timestamp.floor(\"30min\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of conditional logic to handle different cases based on self value",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      62,
      16514,
      27823,
      13,
      28300,
      7203,
      1270,
      1084,
      4943
    ],
    "start_token": 441,
    "end_token": 464,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      26340,
      9156,
      284,
      5412,
      1180,
      2663,
      1912,
      319,
      2116,
      1988
    ],
    "label": "ml_signal",
    "reason": "Use of conditional logic to handle different cases based on self value"
  },
  {
    "line": 59,
    "text": "            return pd_timestamp.floor(\"1h\")",
    "annotation": "\ud83e\udde0 ML Signal: Use of pandas' floor method for timestamp manipulation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      62,
      16514,
      27823,
      13,
      28300,
      7203,
      16,
      71,
      4943
    ],
    "start_token": 464,
    "end_token": 487,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      19798,
      292,
      6,
      4314,
      2446,
      329,
      41033,
      17512
    ],
    "label": "ml_signal",
    "reason": "Use of pandas' floor method for timestamp manipulation"
  },
  {
    "line": 47,
    "text": "            return \"1D\"",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      366,
      16,
      35,
      1
    ],
    "start_token": 487,
    "end_token": 503,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function."
  },
  {
    "line": 49,
    "text": "    def floor_timestamp(self, pd_timestamp):",
    "annotation": "\ud83e\udde0 ML Signal: Method chaining pattern with self, indicating object-oriented design.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      4314,
      62,
      16514,
      27823,
      7,
      944,
      11,
      279,
      67,
      62,
      16514,
      27823,
      2599
    ],
    "start_token": 503,
    "end_token": 520,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      442,
      1397,
      3912,
      351,
      2116,
      11,
      12739,
      2134,
      12,
      17107,
      1486,
      13
    ],
    "label": "ml_signal",
    "reason": "Method chaining pattern with self, indicating object-oriented design."
  },
  {
    "line": 50,
    "text": "        if self == IntervalLevel.LEVEL_1MIN:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure to_second() handles edge cases and returns a valid number.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      23678,
      25
    ],
    "start_token": 520,
    "end_token": 540,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      284,
      62,
      12227,
      3419,
      17105,
      5743,
      2663,
      290,
      5860,
      257,
      4938,
      1271,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure to_second() handles edge cases and returns a valid number."
  },
  {
    "line": 49,
    "text": "    def floor_timestamp(self, pd_timestamp):",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the function.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      4314,
      62,
      16514,
      27823,
      7,
      944,
      11,
      279,
      67,
      62,
      16514,
      27823,
      2599
    ],
    "start_token": 540,
    "end_token": 557,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the function."
  },
  {
    "line": 51,
    "text": "            return pd_timestamp.floor(\"1min\")",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of time units, which may indicate a pattern of time manipulation.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      62,
      16514,
      27823,
      13,
      28300,
      7203,
      16,
      1084,
      4943
    ],
    "start_token": 557,
    "end_token": 580,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      640,
      4991,
      11,
      543,
      743,
      7603,
      257,
      3912,
      286,
      640,
      17512,
      13
    ],
    "label": "ml_signal",
    "reason": "Conversion of time units, which may indicate a pattern of time manipulation."
  },
  {
    "line": 52,
    "text": "        if self == IntervalLevel.LEVEL_5MIN:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Ensure that self.to_ms() returns a valid number to avoid exceptions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      20,
      23678,
      25
    ],
    "start_token": 580,
    "end_token": 600,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      48987,
      326,
      2116,
      13,
      1462,
      62,
      907,
      3419,
      5860,
      257,
      4938,
      1271,
      284,
      3368,
      13269,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Ensure that self.to_ms() returns a valid number to avoid exceptions."
  },
  {
    "line": 56,
    "text": "        if self == IntervalLevel.LEVEL_30MIN:",
    "annotation": "\u2705 Best Practice: Use of self to access instance-specific data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      1270,
      23678,
      25
    ],
    "start_token": 600,
    "end_token": 620,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2116,
      284,
      1895,
      4554,
      12,
      11423,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of self to access instance-specific data"
  },
  {
    "line": 59,
    "text": "            return pd_timestamp.floor(\"1h\")",
    "annotation": "\u2705 Best Practice: Consistent use of multiplication for time conversion",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      279,
      67,
      62,
      16514,
      27823,
      13,
      28300,
      7203,
      16,
      71,
      4943
    ],
    "start_token": 620,
    "end_token": 643,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      3515,
      7609,
      779,
      286,
      48473,
      329,
      640,
      11315
    ],
    "label": "best_practice",
    "reason": "Consistent use of multiplication for time conversion"
  },
  {
    "line": 76,
    "text": "        \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Hardcoded value for month length may lead to inaccuracies",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 643,
    "end_token": 651,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      6912,
      40976,
      1988,
      329,
      1227,
      4129,
      743,
      1085,
      284,
      47283,
      13433
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Hardcoded value for month length may lead to inaccuracies"
  },
  {
    "line": 76,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of dunder method for operator overloading",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 651,
    "end_token": 659,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      288,
      4625,
      2446,
      329,
      10088,
      625,
      25138
    ],
    "label": "best_practice",
    "reason": "Use of dunder method for operator overloading"
  },
  {
    "line": 78,
    "text": "        if self == IntervalLevel.LEVEL_TICK:",
    "annotation": "\u2705 Best Practice: Check if both objects are of the same class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      51,
      11860,
      25
    ],
    "start_token": 659,
    "end_token": 679,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      1111,
      5563,
      389,
      286,
      262,
      976,
      1398
    ],
    "label": "best_practice",
    "reason": "Check if both objects are of the same class"
  },
  {
    "line": 80,
    "text": "        if self == IntervalLevel.LEVEL_1MIN:",
    "annotation": "\ud83e\udde0 ML Signal: Custom comparison logic using a method call",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      23678,
      25
    ],
    "start_token": 679,
    "end_token": 699,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      7208,
      9156,
      1262,
      257,
      2446,
      869
    ],
    "label": "ml_signal",
    "reason": "Custom comparison logic using a method call"
  },
  {
    "line": 82,
    "text": "        if self == IntervalLevel.LEVEL_5MIN:",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      20,
      23678,
      25
    ],
    "start_token": 699,
    "end_token": 719,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported comparisons"
  },
  {
    "line": 81,
    "text": "            return 60 * 1000",
    "annotation": "\u2705 Best Practice: Check if both objects are of the same class before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3126,
      1635,
      8576
    ],
    "start_token": 719,
    "end_token": 734,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      1111,
      5563,
      389,
      286,
      262,
      976,
      1398,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check if both objects are of the same class before comparison"
  },
  {
    "line": 83,
    "text": "            return 5 * 60 * 1000",
    "annotation": "\ud83e\udde0 ML Signal: Custom greater-than operator implementation",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      642,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 734,
    "end_token": 751,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      3744,
      12,
      14813,
      10088,
      7822
    ],
    "label": "ml_signal",
    "reason": "Custom greater-than operator implementation"
  },
  {
    "line": 85,
    "text": "            return 15 * 60 * 1000",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1315,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 751,
    "end_token": 768,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported comparisons"
  },
  {
    "line": 85,
    "text": "            return 15 * 60 * 1000",
    "annotation": "\u2705 Best Practice: Check if both objects are of the same class before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1315,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 768,
    "end_token": 785,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      1111,
      5563,
      389,
      286,
      262,
      976,
      1398,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check if both objects are of the same class before comparison"
  },
  {
    "line": 87,
    "text": "            return 30 * 60 * 1000",
    "annotation": "\ud83e\udde0 ML Signal: Custom comparison logic using a method call",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1542,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 785,
    "end_token": 802,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      7208,
      9156,
      1262,
      257,
      2446,
      869
    ],
    "label": "ml_signal",
    "reason": "Custom comparison logic using a method call"
  },
  {
    "line": 89,
    "text": "            return 60 * 60 * 1000",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3126,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 802,
    "end_token": 819,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported comparisons"
  },
  {
    "line": 88,
    "text": "        if self == IntervalLevel.LEVEL_1HOUR:",
    "annotation": "\u2705 Best Practice: Use of dunder method for implementing less-than comparison",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      39,
      11698,
      25
    ],
    "start_token": 819,
    "end_token": 840,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      288,
      4625,
      2446,
      329,
      15427,
      1342,
      12,
      14813,
      7208
    ],
    "label": "best_practice",
    "reason": "Use of dunder method for implementing less-than comparison"
  },
  {
    "line": 90,
    "text": "        if self == IntervalLevel.LEVEL_4HOUR:",
    "annotation": "\u2705 Best Practice: Check if both objects are of the same class before comparison",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      19,
      39,
      11698,
      25
    ],
    "start_token": 840,
    "end_token": 861,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      1111,
      5563,
      389,
      286,
      262,
      976,
      1398,
      878,
      7208
    ],
    "label": "best_practice",
    "reason": "Check if both objects are of the same class before comparison"
  },
  {
    "line": 92,
    "text": "        if self == IntervalLevel.LEVEL_1DAY:",
    "annotation": "\ud83e\udde0 ML Signal: Custom comparison logic using a method call",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      25
    ],
    "start_token": 861,
    "end_token": 881,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8562,
      7208,
      9156,
      1262,
      257,
      2446,
      869
    ],
    "label": "ml_signal",
    "reason": "Custom comparison logic using a method call"
  },
  {
    "line": 93,
    "text": "            return 24 * 60 * 60 * 1000",
    "annotation": "\u2705 Best Practice: Return NotImplemented for unsupported comparisons",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1987,
      1635,
      3126,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 881,
    "end_token": 900,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8229,
      1892,
      3546,
      1154,
      12061,
      329,
      24222,
      17909
    ],
    "label": "best_practice",
    "reason": "Return NotImplemented for unsupported comparisons"
  },
  {
    "line": 92,
    "text": "        if self == IntervalLevel.LEVEL_1DAY:",
    "annotation": "\u2705 Best Practice: Use of Enum for defining a set of related constants",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      6624,
      4225,
      2100,
      4971,
      13,
      2538,
      18697,
      62,
      16,
      26442,
      25
    ],
    "start_token": 900,
    "end_token": 920,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2039,
      388,
      329,
      16215,
      257,
      900,
      286,
      3519,
      38491
    ],
    "label": "best_practice",
    "reason": "Use of Enum for defining a set of related constants"
  },
  {
    "line": 97,
    "text": "            return 31 * 7 * 24 * 60 * 60 * 1000",
    "annotation": "\u2705 Best Practice: Use of descriptive and meaningful constant names",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      3261,
      1635,
      767,
      1635,
      1987,
      1635,
      3126,
      1635,
      3126,
      1635,
      8576
    ],
    "start_token": 920,
    "end_token": 943,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      35644,
      290,
      11570,
      6937,
      3891
    ],
    "label": "best_practice",
    "reason": "Use of descriptive and meaningful constant names"
  },
  {
    "line": 99,
    "text": "    def __ge__(self, other):",
    "annotation": "\u2705 Best Practice: Use of Enum for defining a set of related constants improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      469,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 943,
    "end_token": 955,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2039,
      388,
      329,
      16215,
      257,
      900,
      286,
      3519,
      38491,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of Enum for defining a set of related constants improves code readability and maintainability"
  },
  {
    "line": 101,
    "text": "            return self.to_ms() >= other.to_ms()",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      1462,
      62,
      907,
      3419,
      18189,
      584,
      13,
      1462,
      62,
      907,
      3419
    ],
    "start_token": 955,
    "end_token": 980,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 103,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 980,
    "end_token": 980,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 105,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 980,
    "end_token": 980,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 107,
    "text": "            return self.to_ms() > other.to_ms()",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      1462,
      62,
      907,
      3419,
      1875,
      584,
      13,
      1462,
      62,
      907,
      3419
    ],
    "start_token": 980,
    "end_token": 1005,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 109,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1005,
    "end_token": 1005,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 111,
    "text": "        if self.__class__ is other.__class__:",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      834,
      4871,
      834,
      318,
      584,
      13,
      834,
      4871,
      834,
      25
    ],
    "start_token": 1005,
    "end_token": 1025,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 113,
    "text": "        return NotImplemented",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      1892,
      3546,
      1154,
      12061
    ],
    "start_token": 1025,
    "end_token": 1037,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 115,
    "text": "    def __lt__(self, other):",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      11593,
      2528,
      834,
      7,
      944,
      11,
      584,
      2599
    ],
    "start_token": 1037,
    "end_token": 1049,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 117,
    "text": "            return self.to_ms() < other.to_ms()",
    "annotation": "\ud83e\udde0 ML Signal: Categorical values that can be used for classification tasks",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      2116,
      13,
      1462,
      62,
      907,
      3419,
      1279,
      584,
      13,
      1462,
      62,
      907,
      3419
    ],
    "start_token": 1049,
    "end_token": 1074,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      327,
      2397,
      12409,
      3815,
      326,
      460,
      307,
      973,
      329,
      17923,
      8861
    ],
    "label": "ml_signal",
    "reason": "Categorical values that can be used for classification tasks"
  },
  {
    "line": 109,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of Enum for defining a set of related constants improves code readability and maintainability",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1074,
    "end_token": 1074,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2039,
      388,
      329,
      16215,
      257,
      900,
      286,
      3519,
      38491,
      19575,
      2438,
      1100,
      1799,
      290,
      5529,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of Enum for defining a set of related constants improves code readability and maintainability"
  },
  {
    "line": 111,
    "text": "        if self.__class__ is other.__class__:",
    "annotation": "\ud83e\udde0 ML Signal: Enum members can be used to categorize or label data, useful for feature extraction",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2116,
      13,
      834,
      4871,
      834,
      318,
      584,
      13,
      834,
      4871,
      834,
      25
    ],
    "start_token": 1074,
    "end_token": 1094,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2039,
      388,
      1866,
      460,
      307,
      973,
      284,
      17851,
      1096,
      393,
      6167,
      1366,
      11,
      4465,
      329,
      3895,
      22236
    ],
    "label": "ml_signal",
    "reason": "Enum members can be used to categorize or label data, useful for feature extraction"
  },
  {
    "line": 122,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Use of Enum for Exchange ensures type safety and readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 1094,
    "end_token": 1098,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2039,
      388,
      329,
      12516,
      19047,
      2099,
      3747,
      290,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of Enum for Exchange ensures type safety and readability"
  },
  {
    "line": 140,
    "text": "    individual = \"individual\"",
    "annotation": "\ud83e\udde0 ML Signal: Mapping of tradable types to exchanges could indicate trading preferences or market focus",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1981,
      796,
      366,
      43129,
      1
    ],
    "start_token": 1098,
    "end_token": 1106,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      337,
      5912,
      286,
      2083,
      540,
      3858,
      284,
      14525,
      714,
      7603,
      7313,
      15387,
      393,
      1910,
      2962
    ],
    "label": "ml_signal",
    "reason": "Mapping of tradable types to exchanges could indicate trading preferences or market focus"
  },
  {
    "line": 140,
    "text": "    individual = \"individual\"",
    "annotation": "\u2705 Best Practice: Dictionary mapping provides clear association between TradableType and Exchange",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1981,
      796,
      366,
      43129,
      1
    ],
    "start_token": 1106,
    "end_token": 1114,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      28261,
      16855,
      3769,
      1598,
      8112,
      1022,
      11974,
      6030,
      290,
      12516
    ],
    "label": "best_practice",
    "reason": "Dictionary mapping provides clear association between TradableType and Exchange"
  },
  {
    "line": 153,
    "text": "    #: \u79c1\u52df",
    "annotation": "\ud83e\udde0 ML Signal: Function parameter type conversion pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      13328,
      100,
      223,
      47947,
      253
    ],
    "start_token": 1114,
    "end_token": 1124,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      11507,
      2099,
      11315,
      3912
    ],
    "label": "ml_signal",
    "reason": "Function parameter type conversion pattern"
  },
  {
    "line": 155,
    "text": "    #: \u516c\u53f8(\u53ef\u80fd\u5305\u62ec\u79c1\u52df)",
    "annotation": "\ud83e\udde0 ML Signal: Dictionary access pattern",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      10263,
      227,
      105,
      20998,
      116,
      7,
      20998,
      107,
      47797,
      121,
      44293,
      227,
      162,
      233,
      105,
      163,
      100,
      223,
      47947,
      253,
      8
    ],
    "start_token": 1124,
    "end_token": 1150,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28261,
      1895,
      3912
    ],
    "label": "ml_signal",
    "reason": "Dictionary access pattern"
  },
  {
    "line": 159,
    "text": "class TradableType(Enum):",
    "annotation": "\u2705 Best Practice: Avoid redundant assignments",
    "confidence": 0.5,
    "tokens": [
      4871,
      11974,
      6030,
      7,
      4834,
      388,
      2599
    ],
    "start_token": 1150,
    "end_token": 1157,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      24390,
      30806,
      25815
    ],
    "label": "best_practice",
    "reason": "Avoid redundant assignments"
  },
  {
    "line": 160,
    "text": "    #: A\u80a1(\u4e2d\u56fd)",
    "annotation": "\u2705 Best Practice: Explicitly define __all__ for module exports",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      317,
      164,
      224,
      94,
      7,
      40792,
      32368,
      121,
      8
    ],
    "start_token": 1157,
    "end_token": 1171,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      8160,
      11593,
      439,
      834,
      329,
      8265,
      15319
    ],
    "label": "best_practice",
    "reason": "Explicitly define __all__ for module exports"
  },
  {
    "line": 160,
    "text": "    #: A\u80a1(\u4e2d\u56fd)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Importing * can lead to namespace pollution",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      317,
      164,
      224,
      94,
      7,
      40792,
      32368,
      121,
      8
    ],
    "start_token": 1171,
    "end_token": 1185,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      17267,
      278,
      1635,
      460,
      1085,
      284,
      25745,
      12231
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Importing * can lead to namespace pollution"
  },
  {
    "line": 160,
    "text": "    #: A\u80a1(\u4e2d\u56fd)",
    "annotation": "\u2705 Best Practice: Use += to extend __all__ with imported module's __all__",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      317,
      164,
      224,
      94,
      7,
      40792,
      32368,
      121,
      8
    ],
    "start_token": 1185,
    "end_token": 1199,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      15853,
      284,
      9117,
      11593,
      439,
      834,
      351,
      17392,
      8265,
      338,
      11593,
      439,
      834
    ],
    "label": "best_practice",
    "reason": "Use += to extend __all__ with imported module's __all__"
  }
]