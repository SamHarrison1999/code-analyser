[
  {
    "line": 7,
    "text": "from sqlalchemy import Column, String, DateTime, Float",
    "annotation": "\u2705 Best Practice: Grouping related imports together improves readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      6738,
      44161,
      282,
      26599,
      1330,
      29201,
      11,
      10903,
      11,
      7536,
      7575,
      11,
      48436
    ],
    "start_token": 0,
    "end_token": 13,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      3519,
      17944,
      1978,
      19575,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping related imports together improves readability and maintainability."
  },
  {
    "line": 9,
    "text": "",
    "annotation": "\u2705 Best Practice: Class docstring provides a description of the class purpose",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 13,
    "end_token": 13,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      2205,
      8841,
      3769,
      257,
      6764,
      286,
      262,
      1398,
      4007
    ],
    "label": "best_practice",
    "reason": "Class docstring provides a description of the class purpose"
  },
  {
    "line": 14,
    "text": "class Mixin(object):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a string for primary_key might lead to SQL injection if not handled properly",
    "confidence": 0.5,
    "tokens": [
      4871,
      15561,
      259,
      7,
      15252,
      2599
    ],
    "start_token": 13,
    "end_token": 19,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4731,
      329,
      4165,
      62,
      2539,
      1244,
      1085,
      284,
      16363,
      16954,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a string for primary_key might lead to SQL injection if not handled properly"
  },
  {
    "line": 15,
    "text": "    \"\"\"",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using a string for entity_id might lead to SQL injection if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 19,
    "end_token": 23,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      257,
      4731,
      329,
      9312,
      62,
      312,
      1244,
      1085,
      284,
      16363,
      16954,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using a string for entity_id might lead to SQL injection if not handled properly"
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of DateTime for timestamp indicates time-based data handling",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 23,
    "end_token": 23,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7536,
      7575,
      329,
      41033,
      9217,
      640,
      12,
      3106,
      1366,
      9041
    ],
    "label": "ml_signal",
    "reason": "Usage of DateTime for timestamp indicates time-based data handling"
  },
  {
    "line": 17,
    "text": "    \"\"\"",
    "annotation": "\u2705 Best Practice: Method definitions should be placed after decorators for clarity and convention.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      37227
    ],
    "start_token": 23,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      17336,
      815,
      307,
      4624,
      706,
      11705,
      2024,
      329,
      16287,
      290,
      9831,
      13
    ],
    "label": "best_practice",
    "reason": "Method definitions should be placed after decorators for clarity and convention."
  },
  {
    "line": 18,
    "text": "",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the purpose and usage of the method.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 27,
    "end_token": 27,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      2446,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the purpose and usage of the method."
  },
  {
    "line": 21,
    "text": "    #: entity id",
    "annotation": "\ud83e\udde0 ML Signal: Usage of inspect.getsource to retrieve source code of a class.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      9312,
      4686
    ],
    "start_token": 27,
    "end_token": 34,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      10104,
      13,
      11407,
      1668,
      284,
      19818,
      2723,
      2438,
      286,
      257,
      1398,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of inspect.getsource to retrieve source code of a class."
  },
  {
    "line": 21,
    "text": "    #: entity id",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using inspect.getsource can expose sensitive code details if misused.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      9312,
      4686
    ],
    "start_token": 34,
    "end_token": 41,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      10104,
      13,
      11407,
      1668,
      460,
      15651,
      8564,
      2438,
      3307,
      611,
      2984,
      1484,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using inspect.getsource can expose sensitive code details if misused."
  },
  {
    "line": 24,
    "text": "    #: the meaning could be different for different case,most time it means 'happen time'",
    "annotation": "\u2705 Best Practice: Use of @classmethod decorator for class method definition",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      262,
      3616,
      714,
      307,
      1180,
      329,
      1180,
      1339,
      11,
      1712,
      640,
      340,
      1724,
      705,
      71,
      1324,
      268,
      640,
      6
    ],
    "start_token": 41,
    "end_token": 65,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      11705,
      1352,
      329,
      1398,
      2446,
      6770
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod decorator for class method definition"
  },
  {
    "line": 32,
    "text": "        print(inspect.getsource(cls))",
    "annotation": "\u2705 Best Practice: Check if attribute exists before accessing it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      1040,
      806,
      13,
      11407,
      1668,
      7,
      565,
      82,
      4008
    ],
    "start_token": 65,
    "end_token": 83,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      11688,
      7160,
      878,
      22534,
      340
    ],
    "label": "best_practice",
    "reason": "Check if attribute exists before accessing it"
  },
  {
    "line": 35,
    "text": "    def important_cols(cls):",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking and updating a class attribute",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      1593,
      62,
      4033,
      82,
      7,
      565,
      82,
      2599
    ],
    "start_token": 83,
    "end_token": 95,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      290,
      19698,
      257,
      1398,
      11688
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking and updating a class attribute"
  },
  {
    "line": 42,
    "text": "    @classmethod",
    "annotation": "\u2705 Best Practice: Use hasattr to check if an attribute exists before accessing it",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 95,
    "end_token": 101,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      468,
      35226,
      284,
      2198,
      611,
      281,
      11688,
      7160,
      878,
      22534,
      340
    ],
    "label": "best_practice",
    "reason": "Use hasattr to check if an attribute exists before accessing it"
  },
  {
    "line": 44,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Initialize class attributes in a consistent manner",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 101,
    "end_token": 109,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      1096,
      1398,
      12608,
      287,
      257,
      6414,
      5642
    ],
    "label": "best_practice",
    "reason": "Initialize class attributes in a consistent manner"
  },
  {
    "line": 45,
    "text": "        register the recorder for the schema",
    "annotation": "\u2705 Best Practice: Check for duplicates before appending to a list",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7881,
      262,
      38156,
      329,
      262,
      32815
    ],
    "start_token": 109,
    "end_token": 122,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      329,
      14184,
      16856,
      878,
      598,
      1571,
      284,
      257,
      1351
    ],
    "label": "best_practice",
    "reason": "Check for duplicates before appending to a list"
  },
  {
    "line": 52,
    "text": "            cls.provider_map_recorder = {}",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using assert for runtime checks can be disabled with optimization flags",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      537,
      82,
      13,
      15234,
      1304,
      62,
      8899,
      62,
      8344,
      2875,
      796,
      23884
    ],
    "start_token": 122,
    "end_token": 145,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      6818,
      329,
      19124,
      8794,
      460,
      307,
      10058,
      351,
      23989,
      9701
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using assert for runtime checks can be disabled with optimization flags"
  },
  {
    "line": 53,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Accessing class attributes",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 145,
    "end_token": 145,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      8798,
      278,
      1398,
      12608
    ],
    "label": "ml_signal",
    "reason": "Accessing class attributes"
  },
  {
    "line": 56,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over data samples to validate correctness",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 145,
    "end_token": 145,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      1366,
      8405,
      284,
      26571,
      29409
    ],
    "label": "ml_signal",
    "reason": "Iterating over data samples to validate correctness"
  },
  {
    "line": 58,
    "text": "    def register_provider(cls, provider):",
    "annotation": "\ud83e\udde0 ML Signal: Querying data with specific parameters",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      7881,
      62,
      15234,
      1304,
      7,
      565,
      82,
      11,
      10131,
      2599
    ],
    "start_token": 145,
    "end_token": 159,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2264,
      263,
      1112,
      1366,
      351,
      2176,
      10007
    ],
    "label": "ml_signal",
    "reason": "Querying data with specific parameters"
  },
  {
    "line": 60,
    "text": "        register the provider to the schema defined by cls",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Printing sensitive data to console",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7881,
      262,
      10131,
      284,
      262,
      32815,
      5447,
      416,
      537,
      82
    ],
    "start_token": 159,
    "end_token": 176,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      44118,
      8564,
      1366,
      284,
      8624
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Printing sensitive data to console"
  },
  {
    "line": 61,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over keys in data for validation",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 176,
    "end_token": 176,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      8251,
      287,
      1366,
      329,
      21201
    ],
    "label": "ml_signal",
    "reason": "Iterating over keys in data for validation"
  },
  {
    "line": 63,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Special handling for timestamp comparison",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 176,
    "end_token": 184,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6093,
      9041,
      329,
      41033,
      7208
    ],
    "label": "ml_signal",
    "reason": "Special handling for timestamp comparison"
  },
  {
    "line": 66,
    "text": "            cls.providers = []",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential timezone or format issues in timestamp comparison",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      537,
      82,
      13,
      15234,
      4157,
      796,
      17635
    ],
    "start_token": 184,
    "end_token": 202,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      640,
      11340,
      393,
      5794,
      2428,
      287,
      41033,
      7208
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential timezone or format issues in timestamp comparison"
  },
  {
    "line": 69,
    "text": "            cls.providers.append(provider)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Direct comparison without type checking",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      537,
      82,
      13,
      15234,
      4157,
      13,
      33295,
      7,
      15234,
      1304,
      8
    ],
    "start_token": 202,
    "end_token": 224,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      4128,
      7208,
      1231,
      2099,
      10627
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Direct comparison without type checking"
  },
  {
    "line": 66,
    "text": "            cls.providers = []",
    "annotation": "\u2705 Best Practice: Importing within a function scope to limit the import's scope and potentially reduce startup time.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      537,
      82,
      13,
      15234,
      4157,
      796,
      17635
    ],
    "start_token": 224,
    "end_token": 242,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      1626,
      257,
      2163,
      8354,
      284,
      4179,
      262,
      1330,
      338,
      8354,
      290,
      6196,
      4646,
      13693,
      640,
      13
    ],
    "label": "best_practice",
    "reason": "Importing within a function scope to limit the import's scope and potentially reduce startup time."
  },
  {
    "line": 69,
    "text": "            cls.providers.append(provider)",
    "annotation": "\u2705 Best Practice: Using default values and fallbacks to ensure function robustness.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      537,
      82,
      13,
      15234,
      4157,
      13,
      33295,
      7,
      15234,
      1304,
      8
    ],
    "start_token": 242,
    "end_token": 264,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      8554,
      4277,
      3815,
      290,
      2121,
      10146,
      284,
      4155,
      2163,
      12373,
      1108,
      13
    ],
    "label": "best_practice",
    "reason": "Using default values and fallbacks to ensure function robustness."
  },
  {
    "line": 71,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Usage of a method that retrieves data by ID, indicating a common pattern for data access.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 264,
    "end_token": 270,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      257,
      2446,
      326,
      13236,
      1158,
      1366,
      416,
      4522,
      11,
      12739,
      257,
      2219,
      3912,
      329,
      1366,
      1895,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of a method that retrieves data by ID, indicating a common pattern for data access."
  },
  {
    "line": 95,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides detailed parameter descriptions and return information",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 270,
    "end_token": 270,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      6496,
      11507,
      16969,
      290,
      1441,
      1321
    ],
    "label": "best_practice",
    "reason": "Docstring provides detailed parameter descriptions and return information"
  },
  {
    "line": 121,
    "text": "        index: Union[str, list] = None,",
    "annotation": "\u2705 Best Practice: Importing within function scope to limit import scope",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      6376,
      25,
      4479,
      58,
      2536,
      11,
      1351,
      60,
      796,
      6045,
      11
    ],
    "start_token": 270,
    "end_token": 288,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      1626,
      2163,
      8354,
      284,
      4179,
      1330,
      8354
    ],
    "label": "best_practice",
    "reason": "Importing within function scope to limit import scope"
  },
  {
    "line": 123,
    "text": "        time_field: str = \"timestamp\",",
    "annotation": "\u2705 Best Practice: Default provider selection logic",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      640,
      62,
      3245,
      25,
      965,
      796,
      366,
      16514,
      27823,
      1600
    ],
    "start_token": 288,
    "end_token": 305,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      15161,
      10131,
      6356,
      9156
    ],
    "label": "best_practice",
    "reason": "Default provider selection logic"
  },
  {
    "line": 147,
    "text": "        :param drop_index_col: whether drop the col if it's in index, default False",
    "annotation": "\u2705 Best Practice: Use of @classmethod decorator for class-level method",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      17143,
      4268,
      62,
      9630,
      62,
      4033,
      25,
      1771,
      4268,
      262,
      951,
      611,
      340,
      338,
      287,
      6376,
      11,
      4277,
      10352
    ],
    "start_token": 305,
    "end_token": 332,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      11705,
      1352,
      329,
      1398,
      12,
      5715,
      2446
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod decorator for class-level method"
  },
  {
    "line": 156,
    "text": "            data_schema=cls,",
    "annotation": "\u2705 Best Practice: Use of a default value for 'provider' allows for flexible function calls.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1366,
      62,
      15952,
      2611,
      28,
      565,
      82,
      11
    ],
    "start_token": 332,
    "end_token": 351,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      257,
      4277,
      1988,
      329,
      705,
      15234,
      1304,
      6,
      3578,
      329,
      12846,
      2163,
      3848,
      13
    ],
    "label": "best_practice",
    "reason": "Use of a default value for 'provider' allows for flexible function calls."
  },
  {
    "line": 157,
    "text": "            ids=ids,",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on the presence of a parameter.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2340,
      28,
      2340,
      11
    ],
    "start_token": 351,
    "end_token": 367,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      262,
      4931,
      286,
      257,
      11507,
      13
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on the presence of a parameter."
  },
  {
    "line": 162,
    "text": "            level=level,",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Dynamic import within a function can lead to potential security risks if the module name is influenced by user input.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      28,
      5715,
      11
    ],
    "start_token": 367,
    "end_token": 382,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      26977,
      1330,
      1626,
      257,
      2163,
      460,
      1085,
      284,
      2785,
      2324,
      7476,
      611,
      262,
      8265,
      1438,
      318,
      12824,
      416,
      2836,
      5128,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Dynamic import within a function can lead to potential security risks if the module name is influenced by user input."
  },
  {
    "line": 166,
    "text": "            return_type=return_type,",
    "annotation": "\ud83e\udde0 ML Signal: Appending results to a list in a loop.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      62,
      4906,
      28,
      7783,
      62,
      4906,
      11
    ],
    "start_token": 382,
    "end_token": 401,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2034,
      1571,
      2482,
      284,
      257,
      1351,
      287,
      257,
      9052,
      13
    ],
    "label": "ml_signal",
    "reason": "Appending results to a list in a loop."
  },
  {
    "line": 221,
    "text": "        record data by the arguments",
    "annotation": "\u26a0\ufe0f SAST Risk (High): Use of eval() can lead to code injection vulnerabilities.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1700,
      1366,
      416,
      262,
      7159
    ],
    "start_token": 401,
    "end_token": 413,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      11922,
      2599,
      5765,
      286,
      5418,
      3419,
      460,
      1085,
      284,
      2438,
      16954,
      23805,
      13
    ],
    "label": "sast_risk",
    "severity": "High",
    "reason": "Use of eval() can lead to code injection vulnerabilities."
  },
  {
    "line": 234,
    "text": "        :param start_timestamp:",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Catching broad exceptions can hide unexpected errors.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      17143,
      923,
      62,
      16514,
      27823,
      25
    ],
    "start_token": 413,
    "end_token": 427,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      327,
      19775,
      3154,
      13269,
      460,
      7808,
      10059,
      8563,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Catching broad exceptions can hide unexpected errors."
  },
  {
    "line": 244,
    "text": "                recorder_class = cls.provider_map_recorder[provider]",
    "annotation": "\u2705 Best Practice: Inheriting from a base class (Mixin) to promote code reuse and modularity",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      38156,
      62,
      4871,
      796,
      537,
      82,
      13,
      15234,
      1304,
      62,
      8899,
      62,
      8344,
      2875,
      58,
      15234,
      1304,
      60
    ],
    "start_token": 427,
    "end_token": 460,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      257,
      2779,
      1398,
      357,
      35608,
      259,
      8,
      284,
      7719,
      2438,
      32349,
      290,
      26507,
      414
    ],
    "label": "best_practice",
    "reason": "Inheriting from a base class (Mixin) to promote code reuse and modularity"
  },
  {
    "line": 246,
    "text": "                recorder_class = cls.provider_map_recorder[cls.providers[provider_index]]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using pd.Timestamp.now() as a default value will set the same timestamp for all instances created at the same time",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      38156,
      62,
      4871,
      796,
      537,
      82,
      13,
      15234,
      1304,
      62,
      8899,
      62,
      8344,
      2875,
      58,
      565,
      82,
      13,
      15234,
      4157,
      58,
      15234,
      1304,
      62,
      9630,
      11907
    ],
    "start_token": 460,
    "end_token": 501,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      279,
      67,
      13,
      14967,
      27823,
      13,
      2197,
      3419,
      355,
      257,
      4277,
      1988,
      481,
      900,
      262,
      976,
      41033,
      329,
      477,
      10245,
      2727,
      379,
      262,
      976,
      640
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using pd.Timestamp.now() as a default value will set the same timestamp for all instances created at the same time"
  },
  {
    "line": 248,
    "text": "            # get args for specific recorder class",
    "annotation": "\u2705 Best Practice: Including an updated_timestamp column to track modifications to the record",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      651,
      26498,
      329,
      2176,
      38156,
      1398
    ],
    "start_token": 501,
    "end_token": 519,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      41461,
      281,
      6153,
      62,
      16514,
      27823,
      5721,
      284,
      2610,
      19008,
      284,
      262,
      1700
    ],
    "label": "best_practice",
    "reason": "Including an updated_timestamp column to track modifications to the record"
  },
  {
    "line": 247,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of class inheritance, indicating a design pattern",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 519,
    "end_token": 519,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1398,
      24155,
      11,
      12739,
      257,
      1486,
      3912
    ],
    "label": "ml_signal",
    "reason": "Use of class inheritance, indicating a design pattern"
  },
  {
    "line": 249,
    "text": "            from zvt.contract.recorder import TimeSeriesDataRecorder",
    "annotation": "\ud83e\udde0 ML Signal: Use of class attributes to define schema or structure",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      422,
      1976,
      36540,
      13,
      28484,
      13,
      8344,
      2875,
      1330,
      3862,
      27996,
      6601,
      6690,
      2875
    ],
    "start_token": 519,
    "end_token": 544,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1398,
      12608,
      284,
      8160,
      32815,
      393,
      4645
    ],
    "label": "ml_signal",
    "reason": "Use of class attributes to define schema or structure"
  },
  {
    "line": 250,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 544,
    "end_token": 544,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 252,
    "text": "                args = [",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      26498,
      796,
      685
    ],
    "start_token": 544,
    "end_token": 562,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 254,
    "text": "                    for item in inspect.getfullargspec(cls.record_data).args",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      2378,
      287,
      10104,
      13,
      1136,
      12853,
      853,
      16684,
      7,
      565,
      82,
      13,
      22105,
      62,
      7890,
      737,
      22046
    ],
    "start_token": 562,
    "end_token": 599,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 255,
    "text": "                    if item not in (\"cls\", \"provider_index\", \"provider\")",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2378,
      407,
      287,
      5855,
      565,
      82,
      1600,
      366,
      15234,
      1304,
      62,
      9630,
      1600,
      366,
      15234,
      1304,
      4943
    ],
    "start_token": 599,
    "end_token": 636,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 259,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 636,
    "end_token": 636,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 260,
    "text": "            #: just fill the None arg to kw,so we could use the recorder_class default args",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive data if not handled properly",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      655,
      6070,
      262,
      6045,
      1822,
      284,
      479,
      86,
      11,
      568,
      356,
      714,
      779,
      262,
      38156,
      62,
      4871,
      4277,
      26498
    ],
    "start_token": 636,
    "end_token": 668,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      1366,
      611,
      407,
      12118,
      6105
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive data if not handled properly"
  },
  {
    "line": 255,
    "text": "                    if item not in (\"cls\", \"provider_index\", \"provider\")",
    "annotation": "\u2705 Best Practice: Use of classmethod to define a method that operates on the class itself rather than instances",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      2378,
      407,
      287,
      5855,
      565,
      82,
      1600,
      366,
      15234,
      1304,
      62,
      9630,
      1600,
      366,
      15234,
      1304,
      4943
    ],
    "start_token": 668,
    "end_token": 705,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      24396,
      284,
      8160,
      257,
      2446,
      326,
      14051,
      319,
      262,
      1398,
      2346,
      2138,
      621,
      10245
    ],
    "label": "best_practice",
    "reason": "Use of classmethod to define a method that operates on the class itself rather than instances"
  },
  {
    "line": 260,
    "text": "            #: just fill the None arg to kw,so we could use the recorder_class default args",
    "annotation": "\ud83e\udde0 ML Signal: Use of session object indicates interaction with a database",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      655,
      6070,
      262,
      6045,
      1822,
      284,
      479,
      86,
      11,
      568,
      356,
      714,
      779,
      262,
      38156,
      62,
      4871,
      4277,
      26498
    ],
    "start_token": 705,
    "end_token": 737,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6246,
      2134,
      9217,
      10375,
      351,
      257,
      6831
    ],
    "label": "ml_signal",
    "reason": "Use of session object indicates interaction with a database"
  },
  {
    "line": 260,
    "text": "            #: just fill the None arg to kw,so we could use the recorder_class default args",
    "annotation": "\u2705 Best Practice: Use of optional parameters to provide flexibility in method usage",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      655,
      6070,
      262,
      6045,
      1822,
      284,
      479,
      86,
      11,
      568,
      356,
      714,
      779,
      262,
      38156,
      62,
      4871,
      4277,
      26498
    ],
    "start_token": 737,
    "end_token": 769,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11902,
      10007,
      284,
      2148,
      13688,
      287,
      2446,
      8748
    ],
    "label": "best_practice",
    "reason": "Use of optional parameters to provide flexibility in method usage"
  },
  {
    "line": 260,
    "text": "            #: just fill the None arg to kw,so we could use the recorder_class default args",
    "annotation": "\ud83e\udde0 ML Signal: Querying a database table using SQLAlchemy",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      655,
      6070,
      262,
      6045,
      1822,
      284,
      479,
      86,
      11,
      568,
      356,
      714,
      779,
      262,
      38156,
      62,
      4871,
      4277,
      26498
    ],
    "start_token": 769,
    "end_token": 801,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2264,
      263,
      1112,
      257,
      6831,
      3084,
      1262,
      16363,
      2348,
      26599
    ],
    "label": "ml_signal",
    "reason": "Querying a database table using SQLAlchemy"
  },
  {
    "line": 266,
    "text": "",
    "annotation": "\u2705 Best Practice: Conditional logic to filter query results based on input parameters",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 801,
    "end_token": 801,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      9724,
      1859,
      9156,
      284,
      8106,
      12405,
      2482,
      1912,
      319,
      5128,
      10007
    ],
    "label": "best_practice",
    "reason": "Conditional logic to filter query results based on input parameters"
  },
  {
    "line": 266,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Returning query results, indicating data retrieval pattern",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 801,
    "end_token": 801,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      42882,
      12405,
      2482,
      11,
      12739,
      1366,
      45069,
      3912
    ],
    "label": "ml_signal",
    "reason": "Returning query results, indicating data retrieval pattern"
  },
  {
    "line": 260,
    "text": "            #: just fill the None arg to kw,so we could use the recorder_class default args",
    "annotation": "\u2705 Best Practice: Provide a default value or handle None for start_date and end_date to avoid potential errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      655,
      6070,
      262,
      6045,
      1822,
      284,
      479,
      86,
      11,
      568,
      356,
      714,
      779,
      262,
      38156,
      62,
      4871,
      4277,
      26498
    ],
    "start_token": 801,
    "end_token": 833,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      257,
      4277,
      1988,
      393,
      5412,
      6045,
      329,
      923,
      62,
      4475,
      290,
      886,
      62,
      4475,
      284,
      3368,
      2785,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Provide a default value or handle None for start_date and end_date to avoid potential errors."
  },
  {
    "line": 266,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): If start_date or end_date is None, pd.date_range may raise an error.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 833,
    "end_token": 833,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      1002,
      923,
      62,
      4475,
      393,
      886,
      62,
      4475,
      318,
      6045,
      11,
      279,
      67,
      13,
      4475,
      62,
      9521,
      743,
      5298,
      281,
      4049,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "If start_date or end_date is None, pd.date_range may raise an error."
  },
  {
    "line": 269,
    "text": "",
    "annotation": "\u2705 Best Practice: Docstring provides a clear explanation of the method's purpose and return value",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 833,
    "end_token": 833,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      257,
      1598,
      7468,
      286,
      262,
      2446,
      338,
      4007,
      290,
      1441,
      1988
    ],
    "label": "best_practice",
    "reason": "Docstring provides a clear explanation of the method's purpose and return value"
  },
  {
    "line": 274,
    "text": "                table: str = cls.__tablename__",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on a boolean parameter",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3084,
      25,
      965,
      796,
      537,
      82,
      13,
      834,
      8658,
      11925,
      480,
      834
    ],
    "start_token": 833,
    "end_token": 860,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      257,
      25131,
      11507
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on a boolean parameter"
  },
  {
    "line": 276,
    "text": "                    items = table.split(\"_\")",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded time intervals could indicate domain-specific knowledge",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3709,
      796,
      3084,
      13,
      35312,
      7203,
      62,
      4943
    ],
    "start_token": 860,
    "end_token": 887,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      640,
      20016,
      714,
      7603,
      7386,
      12,
      11423,
      3725
    ],
    "label": "ml_signal",
    "reason": "Hardcoded time intervals could indicate domain-specific knowledge"
  },
  {
    "line": 279,
    "text": "                        kw[\"adjust_type\"] = adjust_type",
    "annotation": "\ud83e\udde0 ML Signal: Hardcoded time intervals could indicate domain-specific knowledge",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      479,
      86,
      14692,
      23032,
      62,
      4906,
      8973,
      796,
      4532,
      62,
      4906
    ],
    "start_token": 887,
    "end_token": 921,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      6912,
      40976,
      640,
      20016,
      714,
      7603,
      7386,
      12,
      11423,
      3725
    ],
    "label": "ml_signal",
    "reason": "Hardcoded time intervals could indicate domain-specific knowledge"
  },
  {
    "line": 282,
    "text": "                    #: for other schema not with normal format,but need to calculate size for remaining days",
    "annotation": "\u2705 Best Practice: Use of @classmethod decorator indicates method is intended to be called on the class itself",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      329,
      584,
      32815,
      407,
      351,
      3487,
      5794,
      11,
      4360,
      761,
      284,
      15284,
      2546,
      329,
      5637,
      1528
    ],
    "start_token": 921,
    "end_token": 958,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      11705,
      1352,
      9217,
      2446,
      318,
      5292,
      284,
      307,
      1444,
      319,
      262,
      1398,
      2346
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod decorator indicates method is intended to be called on the class itself"
  },
  {
    "line": 279,
    "text": "                        kw[\"adjust_type\"] = adjust_type",
    "annotation": "\u2705 Best Practice: Use of default parameter value to handle optional argument",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      479,
      86,
      14692,
      23032,
      62,
      4906,
      8973,
      796,
      4532,
      62,
      4906
    ],
    "start_token": 958,
    "end_token": 992,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      1988,
      284,
      5412,
      11902,
      4578
    ],
    "label": "best_practice",
    "reason": "Use of default parameter value to handle optional argument"
  },
  {
    "line": 280,
    "text": "                    level = IntervalLevel(items[1])",
    "annotation": "\ud83e\udde0 ML Signal: Use of current timestamp when no timestamp is provided",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1241,
      796,
      4225,
      2100,
      4971,
      7,
      23814,
      58,
      16,
      12962
    ],
    "start_token": 992,
    "end_token": 1021,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1459,
      41033,
      618,
      645,
      41033,
      318,
      2810
    ],
    "label": "ml_signal",
    "reason": "Use of current timestamp when no timestamp is provided"
  },
  {
    "line": 284,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of input to a specific timestamp format",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1021,
    "end_token": 1021,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      5128,
      284,
      257,
      2176,
      41033,
      5794
    ],
    "label": "ml_signal",
    "reason": "Conversion of input to a specific timestamp format"
  },
  {
    "line": 286,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over trading intervals to check if a timestamp falls within them",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1021,
    "end_token": 1021,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      7313,
      20016,
      284,
      2198,
      611,
      257,
      41033,
      8953,
      1626,
      606
    ],
    "label": "ml_signal",
    "reason": "Iterating over trading intervals to check if a timestamp falls within them"
  },
  {
    "line": 287,
    "text": "                #: add other custom args",
    "annotation": "\ud83e\udde0 ML Signal: Construction of open and close times for trading intervals",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1303,
      25,
      751,
      584,
      2183,
      26498
    ],
    "start_token": 1021,
    "end_token": 1042,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      20395,
      286,
      1280,
      290,
      1969,
      1661,
      329,
      7313,
      20016
    ],
    "label": "ml_signal",
    "reason": "Construction of open and close times for trading intervals"
  },
  {
    "line": 290,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Checking if the timestamp is within a trading interval",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1042,
    "end_token": 1042,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      262,
      41033,
      318,
      1626,
      257,
      7313,
      16654
    ],
    "label": "ml_signal",
    "reason": "Checking if the timestamp is within a trading interval"
  },
  {
    "line": 293,
    "text": "            else:",
    "annotation": "\u2705 Best Practice: Use of default parameter value to handle optional argument",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1042,
    "end_token": 1055,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      4277,
      11507,
      1988,
      284,
      5412,
      11902,
      4578
    ],
    "label": "best_practice",
    "reason": "Use of default parameter value to handle optional argument"
  },
  {
    "line": 294,
    "text": "                r = recorder_class(**kw)",
    "annotation": "\u2705 Best Practice: Use of helper function to get current timestamp",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      374,
      796,
      38156,
      62,
      4871,
      7,
      1174,
      46265,
      8
    ],
    "start_token": 1055,
    "end_token": 1079,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      31904,
      2163,
      284,
      651,
      1459,
      41033
    ],
    "label": "best_practice",
    "reason": "Use of helper function to get current timestamp"
  },
  {
    "line": 297,
    "text": "            print(f\"no recorders for {cls.__name__}\")",
    "annotation": "\u2705 Best Practice: Conversion to a specific type for consistency",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3601,
      7,
      69,
      1,
      3919,
      1700,
      364,
      329,
      1391,
      565,
      82,
      13,
      834,
      3672,
      834,
      92,
      4943
    ],
    "start_token": 1079,
    "end_token": 1107,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44101,
      284,
      257,
      2176,
      2099,
      329,
      15794
    ],
    "label": "best_practice",
    "reason": "Conversion to a specific type for consistency"
  },
  {
    "line": 300,
    "text": "class NormalMixin(Mixin):",
    "annotation": "\u2705 Best Practice: Clear variable naming for readability",
    "confidence": 1.0,
    "tokens": [
      4871,
      14435,
      35608,
      259,
      7,
      35608,
      259,
      2599
    ],
    "start_token": 1107,
    "end_token": 1115,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      7885,
      19264,
      329,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear variable naming for readability"
  },
  {
    "line": 303,
    "text": "    #: the record updated time in db, some recorder would check it for whether need to refresh",
    "annotation": "\u2705 Best Practice: Clear variable naming for readability",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      262,
      1700,
      6153,
      640,
      287,
      20613,
      11,
      617,
      38156,
      561,
      2198,
      340,
      329,
      1771,
      761,
      284,
      14976
    ],
    "start_token": 1115,
    "end_token": 1137,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11459,
      7885,
      19264,
      329,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Clear variable naming for readability"
  },
  {
    "line": 307,
    "text": "class Entity(Mixin):",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of checking if a timestamp is within a range",
    "confidence": 1.0,
    "tokens": [
      4871,
      20885,
      7,
      35608,
      259,
      2599
    ],
    "start_token": 1137,
    "end_token": 1143,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      10627,
      611,
      257,
      41033,
      318,
      1626,
      257,
      2837
    ],
    "label": "ml_signal",
    "reason": "Pattern of checking if a timestamp is within a range"
  },
  {
    "line": 310,
    "text": "    #: \u6240\u5c5e\u4ea4\u6613\u6240",
    "annotation": "\u2705 Best Practice: Use of classmethod decorator for methods that operate on class variables",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      10545,
      231,
      222,
      161,
      109,
      252,
      12859,
      97,
      23626,
      241,
      33699,
      222
    ],
    "start_token": 1143,
    "end_token": 1160,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      24396,
      11705,
      1352,
      329,
      5050,
      326,
      8076,
      319,
      1398,
      9633
    ],
    "label": "best_practice",
    "reason": "Use of classmethod decorator for methods that operate on class variables"
  },
  {
    "line": 306,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Method for extracting specific time components from a string",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1160,
    "end_token": 1160,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      11789,
      329,
      37895,
      2176,
      640,
      6805,
      422,
      257,
      4731
    ],
    "label": "ml_signal",
    "reason": "Method for extracting specific time components from a string"
  },
  {
    "line": 307,
    "text": "class Entity(Mixin):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Assumes the format of the string is always \"HH:MM\"",
    "confidence": 0.5,
    "tokens": [
      4871,
      20885,
      7,
      35608,
      259,
      2599
    ],
    "start_token": 1160,
    "end_token": 1166,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      2195,
      8139,
      262,
      5794,
      286,
      262,
      4731,
      318,
      1464,
      366,
      16768,
      25,
      12038,
      1
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Assumes the format of the string is always \"HH:MM\""
  },
  {
    "line": 316,
    "text": "    #: \u4e0a\u5e02\u65e5",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over trading dates to generate timestamps",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      220,
      41468,
      30585,
      224,
      33768,
      98
    ],
    "start_token": 1166,
    "end_token": 1177,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      7313,
      9667,
      284,
      7716,
      4628,
      395,
      9430
    ],
    "label": "ml_signal",
    "reason": "Iterating over trading dates to generate timestamps"
  },
  {
    "line": 318,
    "text": "    #: \u9000\u5e02\u65e5",
    "annotation": "\ud83e\udde0 ML Signal: Conditional logic based on interval level",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      1303,
      25,
      16268,
      222,
      222,
      30585,
      224,
      33768,
      98
    ],
    "start_token": 1177,
    "end_token": 1189,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      9724,
      1859,
      9156,
      1912,
      319,
      16654,
      1241
    ],
    "label": "ml_signal",
    "reason": "Conditional logic based on interval level"
  },
  {
    "line": 321,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Checking for specific weekday (Friday)",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1189,
    "end_token": 1189,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      329,
      2176,
      28269,
      357,
      20610,
      8
    ],
    "label": "ml_signal",
    "reason": "Checking for specific weekday (Friday)"
  },
  {
    "line": 326,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Handling custom trading intervals",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1189,
    "end_token": 1189,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      49500,
      2183,
      7313,
      20016
    ],
    "label": "ml_signal",
    "reason": "Handling custom trading intervals"
  },
  {
    "line": 331,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Creating timestamps for each interval",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1189,
    "end_token": 1189,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      4628,
      395,
      9430,
      329,
      1123,
      16654
    ],
    "label": "ml_signal",
    "reason": "Creating timestamps for each interval"
  },
  {
    "line": 335,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Incrementing timestamp by interval level",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1189,
    "end_token": 1197,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      10791,
      434,
      278,
      41033,
      416,
      16654,
      1241
    ],
    "label": "ml_signal",
    "reason": "Incrementing timestamp by interval level"
  },
  {
    "line": 333,
    "text": "        :param end_date:",
    "annotation": "\u2705 Best Practice: Consider adding type hints for the method parameters and return type",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      17143,
      886,
      62,
      4475,
      25
    ],
    "start_token": 1197,
    "end_token": 1210,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      2099,
      20269,
      329,
      262,
      2446,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Consider adding type hints for the method parameters and return type"
  },
  {
    "line": 335,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Conversion to a specific type (pd.Timestamp) indicates expected input format",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1210,
    "end_token": 1218,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      284,
      257,
      2176,
      2099,
      357,
      30094,
      13,
      14967,
      27823,
      8,
      9217,
      2938,
      5128,
      5794
    ],
    "label": "ml_signal",
    "reason": "Conversion to a specific type (pd.Timestamp) indicates expected input format"
  },
  {
    "line": 335,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of helper function (is_same_time) suggests a pattern of modular code",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1218,
    "end_token": 1226,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      31904,
      2163,
      357,
      271,
      62,
      31642,
      62,
      2435,
      8,
      5644,
      257,
      3912,
      286,
      26507,
      2438
    ],
    "label": "ml_signal",
    "reason": "Use of helper function (is_same_time) suggests a pattern of modular code"
  },
  {
    "line": 340,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of class method (get_trading_intervals) indicates a pattern of accessing class-level data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1226,
    "end_token": 1234,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      1398,
      2446,
      357,
      1136,
      62,
      2213,
      4980,
      62,
      3849,
      12786,
      8,
      9217,
      257,
      3912,
      286,
      22534,
      1398,
      12,
      5715,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of class method (get_trading_intervals) indicates a pattern of accessing class-level data"
  },
  {
    "line": 342,
    "text": "",
    "annotation": "\u2705 Best Practice: Use of @classmethod decorator indicates a pattern of class-level method usage",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1234,
    "end_token": 1234,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      11705,
      1352,
      9217,
      257,
      3912,
      286,
      1398,
      12,
      5715,
      2446,
      8748
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod decorator indicates a pattern of class-level method usage"
  },
  {
    "line": 341,
    "text": "        overwrite it to get the trading intervals of the entity",
    "annotation": "\ud83e\udde0 ML Signal: Conversion of input to a specific type (pd.Timestamp) indicates expected input format",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      49312,
      340,
      284,
      651,
      262,
      7313,
      20016,
      286,
      262,
      9312
    ],
    "start_token": 1234,
    "end_token": 1251,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      44101,
      286,
      5128,
      284,
      257,
      2176,
      2099,
      357,
      30094,
      13,
      14967,
      27823,
      8,
      9217,
      2938,
      5128,
      5794
    ],
    "label": "ml_signal",
    "reason": "Conversion of input to a specific type (pd.Timestamp) indicates expected input format"
  },
  {
    "line": 342,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of helper function is_same_time suggests a pattern of time comparison",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1251,
    "end_token": 1251,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      31904,
      2163,
      318,
      62,
      31642,
      62,
      2435,
      5644,
      257,
      3912,
      286,
      640,
      7208
    ],
    "label": "ml_signal",
    "reason": "Use of helper function is_same_time suggests a pattern of time comparison"
  },
  {
    "line": 347,
    "text": "        else:",
    "annotation": "\ud83e\udde0 ML Signal: Use of cls.get_trading_intervals() indicates reliance on class-level data",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1251,
    "end_token": 1260,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      537,
      82,
      13,
      1136,
      62,
      2213,
      4980,
      62,
      3849,
      12786,
      3419,
      9217,
      24126,
      319,
      1398,
      12,
      5715,
      1366
    ],
    "label": "ml_signal",
    "reason": "Use of cls.get_trading_intervals() indicates reliance on class-level data"
  },
  {
    "line": 347,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Use of named arguments (the_date, the_time) improves readability",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1260,
    "end_token": 1269,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      3706,
      7159,
      357,
      1169,
      62,
      4475,
      11,
      262,
      62,
      2435,
      8,
      19575,
      1100,
      1799
    ],
    "label": "best_practice",
    "reason": "Use of named arguments (the_date, the_time) improves readability"
  },
  {
    "line": 348,
    "text": "            return [(\"09:30\", \"11:30\"), (\"13:00\", \"15:00\")]",
    "annotation": "\u2705 Best Practice: Use of @classmethod indicates method is intended to operate on class-level data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      685,
      7203,
      2931,
      25,
      1270,
      1600,
      366,
      1157,
      25,
      1270,
      12340,
      5855,
      1485,
      25,
      405,
      1600,
      366,
      1314,
      25,
      405,
      4943,
      60
    ],
    "start_token": 1269,
    "end_token": 1303,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      2488,
      4871,
      24396,
      9217,
      2446,
      318,
      5292,
      284,
      8076,
      319,
      1398,
      12,
      5715,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of @classmethod indicates method is intended to operate on class-level data"
  },
  {
    "line": 348,
    "text": "            return [(\"09:30\", \"11:30\"), (\"13:00\", \"15:00\")]",
    "annotation": "\u2705 Best Practice: Docstring provides clear explanation of parameters and return type",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      685,
      7203,
      2931,
      25,
      1270,
      1600,
      366,
      1157,
      25,
      1270,
      12340,
      5855,
      1485,
      25,
      405,
      1600,
      366,
      1314,
      25,
      405,
      4943,
      60
    ],
    "start_token": 1303,
    "end_token": 1337,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      3769,
      1598,
      7468,
      286,
      10007,
      290,
      1441,
      2099
    ],
    "label": "best_practice",
    "reason": "Docstring provides clear explanation of parameters and return type"
  },
  {
    "line": 357,
    "text": "            open_time = date_and_time(the_date=timestamp.date(), the_time=open_close[0])",
    "annotation": "\u2705 Best Practice: Ensures timestamp is always a pd.Timestamp object",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1280,
      62,
      2435,
      796,
      3128,
      62,
      392,
      62,
      2435,
      7,
      1169,
      62,
      4475,
      28,
      16514,
      27823,
      13,
      4475,
      22784,
      262,
      62,
      2435,
      28,
      9654,
      62,
      19836,
      58,
      15,
      12962
    ],
    "start_token": 1337,
    "end_token": 1377,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48221,
      942,
      41033,
      318,
      1464,
      257,
      279,
      67,
      13,
      14967,
      27823,
      2134
    ],
    "label": "best_practice",
    "reason": "Ensures timestamp is always a pd.Timestamp object"
  },
  {
    "line": 359,
    "text": "            if open_time <= timestamp <= close_time:",
    "annotation": "\ud83e\udde0 ML Signal: Iterating over interval timestamps to check for a match",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      1280,
      62,
      2435,
      19841,
      41033,
      19841,
      1969,
      62,
      2435,
      25
    ],
    "start_token": 1377,
    "end_token": 1399,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      40806,
      803,
      625,
      16654,
      4628,
      395,
      9430,
      284,
      2198,
      329,
      257,
      2872
    ],
    "label": "ml_signal",
    "reason": "Iterating over interval timestamps to check for a match"
  },
  {
    "line": 360,
    "text": "                return True",
    "annotation": "\ud83e\udde0 ML Signal: Checking if two timestamps are the same",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6407
    ],
    "start_token": 1399,
    "end_token": 1416,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      611,
      734,
      4628,
      395,
      9430,
      389,
      262,
      976
    ],
    "label": "ml_signal",
    "reason": "Checking if two timestamps are the same"
  },
  {
    "line": 367,
    "text": "        if not timestamp:",
    "annotation": "\u2705 Best Practice: Explicitly return a boolean value for clarity",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      407,
      41033,
      25
    ],
    "start_token": 1416,
    "end_token": 1427,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11884,
      306,
      1441,
      257,
      25131,
      1988,
      329,
      16287
    ],
    "label": "best_practice",
    "reason": "Explicitly return a boolean value for clarity"
  },
  {
    "line": 369,
    "text": "        else:",
    "annotation": "\u2705 Best Practice: Consider adding a docstring to describe the function's purpose and parameters",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 1427,
    "end_token": 1436,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      2205,
      8841,
      284,
      6901,
      262,
      2163,
      338,
      4007,
      290,
      10007
    ],
    "label": "best_practice",
    "reason": "Consider adding a docstring to describe the function's purpose and parameters"
  },
  {
    "line": 376,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Consider specifying the return type in the docstring",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1436,
    "end_token": 1444,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      31577,
      262,
      1441,
      2099,
      287,
      262,
      2205,
      8841
    ],
    "label": "best_practice",
    "reason": "Consider specifying the return type in the docstring"
  },
  {
    "line": 376,
    "text": "        )",
    "annotation": "\u2705 Best Practice: Define a class docstring to describe the purpose and usage of the class",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1444,
    "end_token": 1452,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      2896,
      500,
      257,
      1398,
      2205,
      8841,
      284,
      6901,
      262,
      4007,
      290,
      8748,
      286,
      262,
      1398
    ],
    "label": "best_practice",
    "reason": "Define a class docstring to describe the purpose and usage of the class"
  },
  {
    "line": 378,
    "text": "",
    "annotation": "\u2705 Best Practice: Use 'pass' to indicate an intentionally empty class or method",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1452,
    "end_token": 1452,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      705,
      6603,
      6,
      284,
      7603,
      281,
      16464,
      6565,
      1398,
      393,
      2446
    ],
    "label": "best_practice",
    "reason": "Use 'pass' to indicate an intentionally empty class or method"
  },
  {
    "line": 378,
    "text": "",
    "annotation": "\u2705 Best Practice: Class should inherit from object explicitly in Python 2.x for new-style classes, but in Python 3.x it's optional.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1452,
    "end_token": 1452,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5016,
      815,
      16955,
      422,
      2134,
      11777,
      287,
      11361,
      362,
      13,
      87,
      329,
      649,
      12,
      7635,
      6097,
      11,
      475,
      287,
      11361,
      513,
      13,
      87,
      340,
      338,
      11902,
      13
    ],
    "label": "best_practice",
    "reason": "Class should inherit from object explicitly in Python 2.x for new-style classes, but in Python 3.x it's optional."
  },
  {
    "line": 380,
    "text": "    def get_close_hour_and_minute(cls):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using pd.Timestamp.now() as a default value will set the same timestamp for all instances created without an explicit value.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      651,
      62,
      19836,
      62,
      9769,
      62,
      392,
      62,
      11374,
      7,
      565,
      82,
      2599
    ],
    "start_token": 1452,
    "end_token": 1469,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      279,
      67,
      13,
      14967,
      27823,
      13,
      2197,
      3419,
      355,
      257,
      4277,
      1988,
      481,
      900,
      262,
      976,
      41033,
      329,
      477,
      10245,
      2727,
      1231,
      281,
      7952,
      1988,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using pd.Timestamp.now() as a default value will set the same timestamp for all instances created without an explicit value."
  },
  {
    "line": 382,
    "text": "        return int(hour), int(minute)",
    "annotation": "\u2705 Best Practice: Consider adding a default value or a nullable constraint for updated_timestamp to avoid potential errors.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      493,
      7,
      9769,
      828,
      493,
      7,
      11374,
      8
    ],
    "start_token": 1469,
    "end_token": 1485,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      4375,
      257,
      4277,
      1988,
      393,
      257,
      9242,
      540,
      32315,
      329,
      6153,
      62,
      16514,
      27823,
      284,
      3368,
      2785,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Consider adding a default value or a nullable constraint for updated_timestamp to avoid potential errors."
  },
  {
    "line": 382,
    "text": "        return int(hour), int(minute)",
    "annotation": "\u2705 Best Practice: Use of classmethod to operate on class-level data",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      493,
      7,
      9769,
      828,
      493,
      7,
      11374,
      8
    ],
    "start_token": 1485,
    "end_token": 1501,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      1398,
      24396,
      284,
      8076,
      319,
      1398,
      12,
      5715,
      1366
    ],
    "label": "best_practice",
    "reason": "Use of classmethod to operate on class-level data"
  },
  {
    "line": 386,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Pattern of creating objects from dictionaries",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1501,
    "end_token": 1509,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      23939,
      286,
      4441,
      5563,
      422,
      48589,
      3166
    ],
    "label": "ml_signal",
    "reason": "Pattern of creating objects from dictionaries"
  },
  {
    "line": 386,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Use of dictionary unpacking for object creation",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1509,
    "end_token": 1517,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      22155,
      8593,
      5430,
      329,
      2134,
      6282
    ],
    "label": "best_practice",
    "reason": "Use of dictionary unpacking for object creation"
  },
  {
    "line": 392,
    "text": "        \"\"\"",
    "annotation": "\u2705 Best Practice: Docstring explaining the purpose of the constructor",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1517,
    "end_token": 1525,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      14432,
      8841,
      11170,
      262,
      4007,
      286,
      262,
      23772
    ],
    "label": "best_practice",
    "reason": "Docstring explaining the purpose of the constructor"
  },
  {
    "line": 394,
    "text": "        for current_date in cls.get_trading_dates(start_date=start_date, end_date=end_date):",
    "annotation": "\u2705 Best Practice: Initializing instance variables in the constructor",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      329,
      1459,
      62,
      4475,
      287,
      537,
      82,
      13,
      1136,
      62,
      2213,
      4980,
      62,
      19581,
      7,
      9688,
      62,
      4475,
      28,
      9688,
      62,
      4475,
      11,
      886,
      62,
      4475,
      28,
      437,
      62,
      4475,
      2599
    ],
    "start_token": 1525,
    "end_token": 1563,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      20768,
      2890,
      4554,
      9633,
      287,
      262,
      23772
    ],
    "label": "best_practice",
    "reason": "Initializing instance variables in the constructor"
  },
  {
    "line": 404,
    "text": "                    start = start_end[0]",
    "annotation": "\u2705 Best Practice: Method to modify internal state",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      796,
      923,
      62,
      437,
      58,
      15,
      60
    ],
    "start_token": 1563,
    "end_token": 1590,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      13096,
      5387,
      1181
    ],
    "label": "best_practice",
    "reason": "Method to modify internal state"
  },
  {
    "line": 406,
    "text": "",
    "annotation": "\u2705 Best Practice: Method to modify internal state",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1590,
    "end_token": 1590,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      13096,
      5387,
      1181
    ],
    "label": "best_practice",
    "reason": "Method to modify internal state"
  },
  {
    "line": 410,
    "text": "                    while current_timestamp <= end_timestamp:",
    "annotation": "\u2705 Best Practice: Method to calculate and return a value",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      981,
      1459,
      62,
      16514,
      27823,
      19841,
      886,
      62,
      16514,
      27823,
      25
    ],
    "start_token": 1590,
    "end_token": 1620,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      11789,
      284,
      15284,
      290,
      1441,
      257,
      1988
    ],
    "label": "best_practice",
    "reason": "Method to calculate and return a value"
  },
  {
    "line": 414,
    "text": "    @classmethod",
    "annotation": "\u2705 Best Practice: Implementing __repr__ for better debugging and logging",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 1620,
    "end_token": 1626,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      48282,
      278,
      11593,
      260,
      1050,
      834,
      329,
      1365,
      28769,
      290,
      18931
    ],
    "label": "best_practice",
    "reason": "Implementing __repr__ for better debugging and logging"
  },
  {
    "line": 404,
    "text": "                    start = start_end[0]",
    "annotation": "\u2705 Best Practice: Importing inside a function can reduce the initial loading time and memory usage if the import is only needed within this function.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      923,
      796,
      923,
      62,
      437,
      58,
      15,
      60
    ],
    "start_token": 1626,
    "end_token": 1653,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      278,
      2641,
      257,
      2163,
      460,
      4646,
      262,
      4238,
      11046,
      640,
      290,
      4088,
      8748,
      611,
      262,
      1330,
      318,
      691,
      2622,
      1626,
      428,
      2163,
      13
    ],
    "label": "best_practice",
    "reason": "Importing inside a function can reduce the initial loading time and memory usage if the import is only needed within this function."
  },
  {
    "line": 406,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of dynamic class name construction for schema retrieval.",
    "confidence": 1.0,
    "tokens": [],
    "start_token": 1653,
    "end_token": 1653,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      8925,
      1398,
      1438,
      5103,
      329,
      32815,
      45069,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of dynamic class name construction for schema retrieval."
  },
  {
    "line": 408,
    "text": "                    end_timestamp = date_and_time(the_date=current_date, the_time=end)",
    "annotation": "\ud83e\udde0 ML Signal: Querying data using dynamic parameters, indicating a pattern of flexible data retrieval.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      16514,
      27823,
      796,
      3128,
      62,
      392,
      62,
      2435,
      7,
      1169,
      62,
      4475,
      28,
      14421,
      62,
      4475,
      11,
      262,
      62,
      2435,
      28,
      437,
      8
    ],
    "start_token": 1653,
    "end_token": 1697,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      2264,
      263,
      1112,
      1366,
      1262,
      8925,
      10007,
      11,
      12739,
      257,
      3912,
      286,
      12846,
      1366,
      45069,
      13
    ],
    "label": "ml_signal",
    "reason": "Querying data using dynamic parameters, indicating a pattern of flexible data retrieval."
  },
  {
    "line": 408,
    "text": "                    end_timestamp = date_and_time(the_date=current_date, the_time=end)",
    "annotation": "\ud83e\udde0 ML Signal: Definition of a class with attributes can be used to identify patterns in data modeling",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      886,
      62,
      16514,
      27823,
      796,
      3128,
      62,
      392,
      62,
      2435,
      7,
      1169,
      62,
      4475,
      28,
      14421,
      62,
      4475,
      11,
      262,
      62,
      2435,
      28,
      437,
      8
    ],
    "start_token": 1697,
    "end_token": 1741,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30396,
      286,
      257,
      1398,
      351,
      12608,
      460,
      307,
      973,
      284,
      5911,
      7572,
      287,
      1366,
      21128
    ],
    "label": "ml_signal",
    "reason": "Definition of a class with attributes can be used to identify patterns in data modeling"
  },
  {
    "line": 409,
    "text": "",
    "annotation": "\u2705 Best Practice: Inheriting from a mixin suggests a design pattern for code reuse",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1741,
    "end_token": 1741,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      47025,
      1780,
      422,
      257,
      5022,
      259,
      5644,
      257,
      1486,
      3912,
      329,
      2438,
      32349
    ],
    "label": "best_practice",
    "reason": "Inheriting from a mixin suggests a design pattern for code reuse"
  },
  {
    "line": 411,
    "text": "                        yield current_timestamp",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      7800,
      1459,
      62,
      16514,
      27823
    ],
    "start_token": 1741,
    "end_token": 1769,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 413,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1769,
    "end_token": 1769,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 415,
    "text": "    def is_open_timestamp(cls, timestamp):",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      318,
      62,
      9654,
      62,
      16514,
      27823,
      7,
      565,
      82,
      11,
      41033,
      2599
    ],
    "start_token": 1769,
    "end_token": 1785,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 417,
    "text": "        return is_same_time(",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      318,
      62,
      31642,
      62,
      2435,
      7
    ],
    "start_token": 1785,
    "end_token": 1799,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 419,
    "text": "            date_and_time(the_date=timestamp.date(), the_time=cls.get_trading_intervals()[0][0]),",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      3128,
      62,
      392,
      62,
      2435,
      7,
      1169,
      62,
      4475,
      28,
      16514,
      27823,
      13,
      4475,
      22784,
      262,
      62,
      2435,
      28,
      565,
      82,
      13,
      1136,
      62,
      2213,
      4980,
      62,
      3849,
      12786,
      3419,
      58,
      15,
      7131,
      15,
      46570
    ],
    "start_token": 1799,
    "end_token": 1845,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 421,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 1845,
    "end_token": 1845,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 423,
    "text": "    def is_close_timestamp(cls, timestamp):",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      825,
      318,
      62,
      19836,
      62,
      16514,
      27823,
      7,
      565,
      82,
      11,
      41033,
      2599
    ],
    "start_token": 1845,
    "end_token": 1861,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 416,
    "text": "        timestamp = pd.Timestamp(timestamp)",
    "annotation": "\ud83e\udde0 ML Signal: Inheritance from PortfolioStock indicates a relationship that could be used to understand class hierarchies",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      796,
      279,
      67,
      13,
      14967,
      27823,
      7,
      16514,
      27823,
      8
    ],
    "start_token": 1861,
    "end_token": 1879,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      47025,
      42942,
      422,
      4347,
      13652,
      26207,
      9217,
      257,
      2776,
      326,
      714,
      307,
      973,
      284,
      1833,
      1398,
      28398,
      444
    ],
    "label": "ml_signal",
    "reason": "Inheritance from PortfolioStock indicates a relationship that could be used to understand class hierarchies"
  },
  {
    "line": 418,
    "text": "            timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      11
    ],
    "start_token": 1879,
    "end_token": 1892,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 420,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1892,
    "end_token": 1900,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 422,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 1900,
    "end_token": 1906,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 424,
    "text": "        timestamp = pd.Timestamp(timestamp)",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      796,
      279,
      67,
      13,
      14967,
      27823,
      7,
      16514,
      27823,
      8
    ],
    "start_token": 1906,
    "end_token": 1924,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 426,
    "text": "            timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Use of SQLAlchemy Column to define database schema",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      11
    ],
    "start_token": 1924,
    "end_token": 1937,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      16363,
      2348,
      26599,
      29201,
      284,
      8160,
      6831,
      32815
    ],
    "label": "ml_signal",
    "reason": "Use of SQLAlchemy Column to define database schema"
  },
  {
    "line": 422,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Class definition with inheritance, useful for understanding class hierarchies",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 1937,
    "end_token": 1943,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5016,
      6770,
      351,
      24155,
      11,
      4465,
      329,
      4547,
      1398,
      28398,
      444
    ],
    "label": "ml_signal",
    "reason": "Class definition with inheritance, useful for understanding class hierarchies"
  },
  {
    "line": 424,
    "text": "        timestamp = pd.Timestamp(timestamp)",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      796,
      279,
      67,
      13,
      14967,
      27823,
      7,
      16514,
      27823,
      8
    ],
    "start_token": 1943,
    "end_token": 1961,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 426,
    "text": "            timestamp,",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      41033,
      11
    ],
    "start_token": 1961,
    "end_token": 1974,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 428,
    "text": "        )",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1267
    ],
    "start_token": 1974,
    "end_token": 1982,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 430,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 1982,
    "end_token": 1988,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 432,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 1988,
    "end_token": 1996,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 434,
    "text": "        :type timestamp: pd.Timestamp",
    "annotation": "\ud83e\udde0 ML Signal: Database column definition, useful for schema inference",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      41033,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 1996,
    "end_token": 2012,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      24047,
      5721,
      6770,
      11,
      4465,
      329,
      32815,
      32278
    ],
    "label": "ml_signal",
    "reason": "Database column definition, useful for schema inference"
  },
  {
    "line": 430,
    "text": "    @classmethod",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2488,
      4871,
      24396
    ],
    "start_token": 2012,
    "end_token": 2018,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 432,
    "text": "        \"\"\"",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      37227
    ],
    "start_token": 2018,
    "end_token": 2026,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 434,
    "text": "        :type timestamp: pd.Timestamp",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      41033,
      25,
      279,
      67,
      13,
      14967,
      27823
    ],
    "start_token": 2026,
    "end_token": 2042,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 436,
    "text": "        :type level: zvt.domain.common.IntervalLevel",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      1241,
      25,
      1976,
      36540,
      13,
      27830,
      13,
      11321,
      13,
      9492,
      2100,
      4971
    ],
    "start_token": 2042,
    "end_token": 2063,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 436,
    "text": "        :type level: zvt.domain.common.IntervalLevel",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      1241,
      25,
      1976,
      36540,
      13,
      27830,
      13,
      11321,
      13,
      9492,
      2100,
      4971
    ],
    "start_token": 2063,
    "end_token": 2084,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 436,
    "text": "        :type level: zvt.domain.common.IntervalLevel",
    "annotation": "\ud83e\udde0 ML Signal: Use of ORM column definitions indicates database interaction patterns",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      1241,
      25,
      1976,
      36540,
      13,
      27830,
      13,
      11321,
      13,
      9492,
      2100,
      4971
    ],
    "start_token": 2084,
    "end_token": 2105,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      5765,
      286,
      6375,
      44,
      5721,
      17336,
      9217,
      6831,
      10375,
      7572
    ],
    "label": "ml_signal",
    "reason": "Use of ORM column definitions indicates database interaction patterns"
  },
  {
    "line": 436,
    "text": "        :type level: zvt.domain.common.IntervalLevel",
    "annotation": "\u2705 Best Practice: Use of __all__ to define public API of the module",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1058,
      4906,
      1241,
      25,
      1976,
      36540,
      13,
      27830,
      13,
      11321,
      13,
      9492,
      2100,
      4971
    ],
    "start_token": 2105,
    "end_token": 2126,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      286,
      11593,
      439,
      834,
      284,
      8160,
      1171,
      7824,
      286,
      262,
      8265
    ],
    "label": "best_practice",
    "reason": "Use of __all__ to define public API of the module"
  }
]