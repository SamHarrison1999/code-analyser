[
  {
    "line": 8,
    "text": "\"\"\"",
    "annotation": "\u2705 Best Practice: Grouping imports from the same package together improves readability.",
    "confidence": 1.0,
    "tokens": [
      37811
    ],
    "start_token": 0,
    "end_token": 1,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      422,
      262,
      976,
      5301,
      1978,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports from the same package together improves readability."
  },
  {
    "line": 10,
    "text": "import pandas as pd",
    "annotation": "\u2705 Best Practice: Grouping imports from the same package together improves readability.",
    "confidence": 1.0,
    "tokens": [
      11748,
      19798,
      292,
      355,
      279,
      67
    ],
    "start_token": 1,
    "end_token": 7,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      4912,
      278,
      17944,
      422,
      262,
      976,
      5301,
      1978,
      19575,
      1100,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Grouping imports from the same package together improves readability."
  },
  {
    "line": 12,
    "text": "from tushare.stock import cons as ct",
    "annotation": "\ud83e\udde0 ML Signal: Usage of external libraries like tushare can indicate financial data processing.",
    "confidence": 1.0,
    "tokens": [
      6738,
      256,
      1530,
      533,
      13,
      13578,
      1330,
      762,
      355,
      269,
      83
    ],
    "start_token": 7,
    "end_token": 18,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      7097,
      12782,
      588,
      256,
      1530,
      533,
      460,
      7603,
      3176,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "Usage of external libraries like tushare can indicate financial data processing."
  },
  {
    "line": 11,
    "text": "import os",
    "annotation": "\ud83e\udde0 ML Signal: Function to set and store a token, indicating token management behavior",
    "confidence": 0.5,
    "tokens": [
      11748,
      28686
    ],
    "start_token": 18,
    "end_token": 20,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      15553,
      284,
      900,
      290,
      3650,
      257,
      11241,
      11,
      12739,
      11241,
      4542,
      4069
    ],
    "label": "ml_signal",
    "reason": "Function to set and store a token, indicating token management behavior"
  },
  {
    "line": 13,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Creating a DataFrame to store a single token",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 20,
    "end_token": 20,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      30481,
      257,
      6060,
      19778,
      284,
      3650,
      257,
      2060,
      11241
    ],
    "label": "ml_signal",
    "reason": "Creating a DataFrame to store a single token"
  },
  {
    "line": 15,
    "text": "",
    "annotation": "\ud83e\udde0 ML Signal: Usage of os.path.expanduser to access user home directory",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 20,
    "end_token": 20,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      29566,
      286,
      28686,
      13,
      6978,
      13,
      11201,
      392,
      7220,
      284,
      1895,
      2836,
      1363,
      8619
    ],
    "label": "ml_signal",
    "reason": "Usage of os.path.expanduser to access user home directory"
  },
  {
    "line": 17,
    "text": "    df = pd.DataFrame([token], columns=['token'])",
    "annotation": "\ud83e\udde0 ML Signal: Constructing a file path for storing the token",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      47764,
      796,
      279,
      67,
      13,
      6601,
      19778,
      26933,
      30001,
      4357,
      15180,
      28,
      17816,
      30001,
      6,
      12962
    ],
    "start_token": 20,
    "end_token": 39,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      28407,
      278,
      257,
      2393,
      3108,
      329,
      23069,
      262,
      11241
    ],
    "label": "ml_signal",
    "reason": "Constructing a file path for storing the token"
  },
  {
    "line": 18,
    "text": "    user_home = os.path.expanduser('~')",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Potential exposure of sensitive token data if path is not secure",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2836,
      62,
      11195,
      796,
      28686,
      13,
      6978,
      13,
      11201,
      392,
      7220,
      10786,
      93,
      11537
    ],
    "start_token": 39,
    "end_token": 56,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      32480,
      7111,
      286,
      8564,
      11241,
      1366,
      611,
      3108,
      318,
      407,
      5713
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Potential exposure of sensitive token data if path is not secure"
  },
  {
    "line": 20,
    "text": "    df.to_csv(fp, index=False)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Writing sensitive data to a file without encryption",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      47764,
      13,
      1462,
      62,
      40664,
      7,
      46428,
      11,
      6376,
      28,
      25101,
      8
    ],
    "start_token": 56,
    "end_token": 71,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      22183,
      8564,
      1366,
      284,
      257,
      2393,
      1231,
      15835
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Writing sensitive data to a file without encryption"
  },
  {
    "line": 16,
    "text": "def set_token(token):",
    "annotation": "\u2705 Best Practice: Import statements should be at the top of the file for better readability and maintainability.",
    "confidence": 1.0,
    "tokens": [
      4299,
      900,
      62,
      30001,
      7,
      30001,
      2599
    ],
    "start_token": 71,
    "end_token": 78,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      17267,
      6299,
      815,
      307,
      379,
      262,
      1353,
      286,
      262,
      2393,
      329,
      1365,
      1100,
      1799,
      290,
      5529,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Import statements should be at the top of the file for better readability and maintainability."
  },
  {
    "line": 18,
    "text": "    user_home = os.path.expanduser('~')",
    "annotation": "\u2705 Best Practice: Use os.path.expanduser to handle user directory paths, improving code portability.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2836,
      62,
      11195,
      796,
      28686,
      13,
      6978,
      13,
      11201,
      392,
      7220,
      10786,
      93,
      11537
    ],
    "start_token": 78,
    "end_token": 95,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      28686,
      13,
      6978,
      13,
      11201,
      392,
      7220,
      284,
      5412,
      2836,
      8619,
      13532,
      11,
      10068,
      2438,
      2493,
      1799,
      13
    ],
    "label": "best_practice",
    "reason": "Use os.path.expanduser to handle user directory paths, improving code portability."
  },
  {
    "line": 20,
    "text": "    df.to_csv(fp, index=False)",
    "annotation": "\u2705 Best Practice: Use os.path.join to construct file paths, ensuring cross-platform compatibility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      47764,
      13,
      1462,
      62,
      40664,
      7,
      46428,
      11,
      6376,
      28,
      25101,
      8
    ],
    "start_token": 95,
    "end_token": 110,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      5765,
      28686,
      13,
      6978,
      13,
      22179,
      284,
      5678,
      2393,
      13532,
      11,
      13359,
      3272,
      12,
      24254,
      17764,
      13
    ],
    "label": "best_practice",
    "reason": "Use os.path.join to construct file paths, ensuring cross-platform compatibility."
  },
  {
    "line": 21,
    "text": "    ",
    "annotation": "\u2705 Best Practice: Check if a file exists before attempting to read it to avoid runtime errors.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220
    ],
    "start_token": 110,
    "end_token": 114,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      6822,
      611,
      257,
      2393,
      7160,
      878,
      9361,
      284,
      1100,
      340,
      284,
      3368,
      19124,
      8563,
      13
    ],
    "label": "best_practice",
    "reason": "Check if a file exists before attempting to read it to avoid runtime errors."
  },
  {
    "line": 24,
    "text": "    user_home = os.path.expanduser('~')",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Reading CSV files without specifying a safe mode can lead to security issues if the file is maliciously crafted.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      2836,
      62,
      11195,
      796,
      28686,
      13,
      6978,
      13,
      11201,
      392,
      7220,
      10786,
      93,
      11537
    ],
    "start_token": 114,
    "end_token": 131,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11725,
      44189,
      3696,
      1231,
      31577,
      257,
      3338,
      4235,
      460,
      1085,
      284,
      2324,
      2428,
      611,
      262,
      2393,
      318,
      17412,
      306,
      18025,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Reading CSV files without specifying a safe mode can lead to security issues if the file is maliciously crafted."
  },
  {
    "line": 26,
    "text": "    if os.path.exists(fp):",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using deprecated 'ix' indexer; consider using 'iloc' or 'loc' for better future compatibility.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      28686,
      13,
      6978,
      13,
      1069,
      1023,
      7,
      46428,
      2599
    ],
    "start_token": 131,
    "end_token": 144,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      39224,
      705,
      844,
      6,
      6376,
      263,
      26,
      2074,
      1262,
      705,
      346,
      420,
      6,
      393,
      705,
      17946,
      6,
      329,
      1365,
      2003,
      17764,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using deprecated 'ix' indexer; consider using 'iloc' or 'loc' for better future compatibility."
  },
  {
    "line": 29,
    "text": "    else:",
    "annotation": "\u2705 Best Practice: Provide user feedback when an expected file is not found.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      2073,
      25
    ],
    "start_token": 144,
    "end_token": 149,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      44290,
      2836,
      7538,
      618,
      281,
      2938,
      2393,
      318,
      407,
      1043,
      13
    ],
    "label": "best_practice",
    "reason": "Provide user feedback when an expected file is not found."
  },
  {
    "line": 25,
    "text": "    fp = os.path.join(user_home, ct.TOKEN_F_P)",
    "annotation": "\u2705 Best Practice: Consider using default parameter values that are more descriptive or None to indicate optional parameters.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      277,
      79,
      796,
      28686,
      13,
      6978,
      13,
      22179,
      7,
      7220,
      62,
      11195,
      11,
      269,
      83,
      13,
      10468,
      43959,
      62,
      37,
      62,
      47,
      8
    ],
    "start_token": 149,
    "end_token": 175,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      4277,
      11507,
      3815,
      326,
      389,
      517,
      35644,
      393,
      6045,
      284,
      7603,
      11902,
      10007,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using default parameter values that are more descriptive or None to indicate optional parameters."
  },
  {
    "line": 26,
    "text": "    if os.path.exists(fp):",
    "annotation": "\u26a0\ufe0f SAST Risk (Medium): Storing passwords in plain text is insecure. Consider using a secure storage mechanism.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      611,
      28686,
      13,
      6978,
      13,
      1069,
      1023,
      7,
      46428,
      2599
    ],
    "start_token": 175,
    "end_token": 188,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      31205,
      2599,
      520,
      3255,
      21442,
      287,
      8631,
      2420,
      318,
      31955,
      13,
      12642,
      1262,
      257,
      5713,
      6143,
      9030,
      13
    ],
    "label": "sast_risk",
    "severity": "Medium",
    "reason": "Storing passwords in plain text is insecure. Consider using a secure storage mechanism."
  },
  {
    "line": 31,
    "text": "        return None",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Using os.path.exists can lead to race conditions. Consider using a safer file existence check.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      1441,
      6045
    ],
    "start_token": 188,
    "end_token": 197,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      8554,
      28686,
      13,
      6978,
      13,
      1069,
      1023,
      460,
      1085,
      284,
      3234,
      3403,
      13,
      12642,
      1262,
      257,
      14178,
      2393,
      6224,
      2198,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Using os.path.exists can lead to race conditions. Consider using a safer file existence check."
  },
  {
    "line": 33,
    "text": "",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Reading from a CSV file without validation can lead to CSV injection attacks.",
    "confidence": 0.5,
    "tokens": [],
    "start_token": 197,
    "end_token": 197,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11725,
      422,
      257,
      44189,
      2393,
      1231,
      21201,
      460,
      1085,
      284,
      44189,
      16954,
      3434,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Reading from a CSV file without validation can lead to CSV injection attacks."
  },
  {
    "line": 34,
    "text": "def set_broker(broker='', user='', passwd=''):",
    "annotation": "\ud83e\udde0 ML Signal: Checking for existing entries before appending is a common pattern for deduplication.",
    "confidence": 1.0,
    "tokens": [
      4299,
      900,
      62,
      7957,
      6122,
      7,
      7957,
      6122,
      11639,
      3256,
      2836,
      11639,
      3256,
      1208,
      16993,
      28,
      7061,
      2599
    ],
    "start_token": 197,
    "end_token": 215,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      39432,
      329,
      4683,
      12784,
      878,
      598,
      1571,
      318,
      257,
      2219,
      3912,
      329,
      4648,
      84,
      489,
      3299,
      13
    ],
    "label": "ml_signal",
    "reason": "Checking for existing entries before appending is a common pattern for deduplication."
  },
  {
    "line": 38,
    "text": "    if os.path.exists(BK):",
    "annotation": "\u2705 Best Practice: Consider using pd.concat instead of append, as append is deprecated in future versions of pandas.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      611,
      28686,
      13,
      6978,
      13,
      1069,
      1023,
      7,
      33,
      42,
      2599
    ],
    "start_token": 215,
    "end_token": 229,
    "annotation_tokens": [
      26486,
      227,
      6705,
      19939,
      25,
      12642,
      1262,
      279,
      67,
      13,
      1102,
      9246,
      2427,
      286,
      24443,
      11,
      355,
      24443,
      318,
      39224,
      287,
      2003,
      6300,
      286,
      19798,
      292,
      13
    ],
    "label": "best_practice",
    "reason": "Consider using pd.concat instead of append, as append is deprecated in future versions of pandas."
  },
  {
    "line": 40,
    "text": "        if (all[all.broker == broker]['user']).any():",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Writing to a CSV file without validation can lead to CSV injection attacks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      611,
      357,
      439,
      58,
      439,
      13,
      7957,
      6122,
      6624,
      20426,
      7131,
      6,
      7220,
      20520,
      737,
      1092,
      33529
    ],
    "start_token": 229,
    "end_token": 253,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      22183,
      284,
      257,
      44189,
      2393,
      1231,
      21201,
      460,
      1085,
      284,
      44189,
      16954,
      3434,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Writing to a CSV file without validation can lead to CSV injection attacks."
  },
  {
    "line": 43,
    "text": "        all.to_csv(BK, index=False)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Writing to a CSV file without validation can lead to CSV injection attacks.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      13,
      1462,
      62,
      40664,
      7,
      33,
      42,
      11,
      6376,
      28,
      25101,
      8
    ],
    "start_token": 253,
    "end_token": 273,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      22183,
      284,
      257,
      44189,
      2393,
      1231,
      21201,
      460,
      1085,
      284,
      44189,
      16954,
      3434,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Writing to a CSV file without validation can lead to CSV injection attacks."
  },
  {
    "line": 37,
    "text": "                      dtype=object)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The function does not handle exceptions that may occur when checking if a file exists or when reading a CSV file.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      288,
      4906,
      28,
      15252,
      8
    ],
    "start_token": 273,
    "end_token": 299,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      2163,
      857,
      407,
      5412,
      13269,
      326,
      743,
      3051,
      618,
      10627,
      611,
      257,
      2393,
      7160,
      393,
      618,
      3555,
      257,
      44189,
      2393,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The function does not handle exceptions that may occur when checking if a file exists or when reading a CSV file."
  },
  {
    "line": 39,
    "text": "        all = pd.read_csv(BK, dtype=object)",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): The use of a global variable BK without validation can lead to unexpected behavior if BK is not defined.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      796,
      279,
      67,
      13,
      961,
      62,
      40664,
      7,
      33,
      42,
      11,
      288,
      4906,
      28,
      15252,
      8
    ],
    "start_token": 299,
    "end_token": 323,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      383,
      779,
      286,
      257,
      3298,
      7885,
      347,
      42,
      1231,
      21201,
      460,
      1085,
      284,
      10059,
      4069,
      611,
      347,
      42,
      318,
      407,
      5447,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "The use of a global variable BK without validation can lead to unexpected behavior if BK is not defined."
  },
  {
    "line": 41,
    "text": "            all = all[all.broker != broker]",
    "annotation": "\u26a0\ufe0f SAST Risk (Low): Reading a CSV file without specifying error handling can lead to unhandled exceptions.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      796,
      477,
      58,
      439,
      13,
      7957,
      6122,
      14512,
      20426,
      60
    ],
    "start_token": 323,
    "end_token": 345,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      20535,
      2599,
      11725,
      257,
      44189,
      2393,
      1231,
      31577,
      4049,
      9041,
      460,
      1085,
      284,
      555,
      38788,
      13269,
      13
    ],
    "label": "sast_risk",
    "severity": "Low",
    "reason": "Reading a CSV file without specifying error handling can lead to unhandled exceptions."
  },
  {
    "line": 43,
    "text": "        all.to_csv(BK, index=False)",
    "annotation": "\ud83e\udde0 ML Signal: The function checks for an empty string to determine behavior, which is a common pattern in data processing.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      477,
      13,
      1462,
      62,
      40664,
      7,
      33,
      42,
      11,
      6376,
      28,
      25101,
      8
    ],
    "start_token": 345,
    "end_token": 365,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      383,
      2163,
      8794,
      329,
      281,
      6565,
      4731,
      284,
      5004,
      4069,
      11,
      543,
      318,
      257,
      2219,
      3912,
      287,
      1366,
      7587,
      13
    ],
    "label": "ml_signal",
    "reason": "The function checks for an empty string to determine behavior, which is a common pattern in data processing."
  },
  {
    "line": 47,
    "text": "        ",
    "annotation": "\ud83e\udde0 ML Signal: Filtering a DataFrame based on a column value is a common data manipulation pattern.",
    "confidence": 0.5,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220
    ],
    "start_token": 365,
    "end_token": 373,
    "annotation_tokens": [
      8582,
      100,
      254,
      10373,
      26484,
      25,
      7066,
      20212,
      257,
      6060,
      19778,
      1912,
      319,
      257,
      5721,
      1988,
      318,
      257,
      2219,
      1366,
      17512,
      3912,
      13
    ],
    "label": "ml_signal",
    "reason": "Filtering a DataFrame based on a column value is a common data manipulation pattern."
  },
  {
    "line": 46,
    "text": "        ",
    "annotation": "\u26a0\ufe0f SAST Risk (High): Using os.remove without validation can lead to arbitrary file deletion if BK is user-controlled.",
    "confidence": 1.0,
    "tokens": [
      220,
      220,
      220,
      220,
      220,
      220,
      220,
      220
    ],
    "start_token": 373,
    "end_token": 381,
    "annotation_tokens": [
      158,
      248,
      254,
      37929,
      311,
      11262,
      19602,
      357,
      11922,
      2599,
      8554,
      28686,
      13,
      28956,
      1231,
      21201,
      460,
      1085,
      284,
      14977,
      2393,
      39948,
      611,
      347,
      42,
      318,
      2836,
      12,
      14401,
      13
    ],
    "label": "sast_risk",
    "severity": "High",
    "reason": "Using os.remove without validation can lead to arbitrary file deletion if BK is user-controlled."
  }
]